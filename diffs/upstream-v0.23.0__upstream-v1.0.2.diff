diff --git a/.changeset/nix-flake-improvements.md b/.changeset/nix-flake-improvements.md
new file mode 100644
index 0000000..0988492
--- /dev/null
+++ b/.changeset/nix-flake-improvements.md
@@ -0,0 +1,13 @@
+---
+"@fission-ai/openspec": patch
+---
+
+### Improvements
+
+- **Nix flake maintenance** â€” Version now read dynamically from package.json, reducing manual sync issues
+- **Nix build optimization** â€” Source filtering excludes node_modules and artifacts, improving build times
+- **update-flake.sh script** â€” Detects when hash is already correct, skipping unnecessary rebuilds
+
+### Other
+
+- Updated Nix CI actions to latest versions (nix-installer v21, magic-nix-cache v13)
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 2b887c7..9d435a4 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -190,10 +190,10 @@ jobs:
         uses: actions/checkout@v4
 
       - name: Install Nix
-        uses: DeterminateSystems/nix-installer-action@v13
+        uses: DeterminateSystems/nix-installer-action@v21
 
       - name: Setup Nix cache
-        uses: DeterminateSystems/magic-nix-cache-action@v8
+        uses: DeterminateSystems/magic-nix-cache-action@v13
 
       - name: Build with Nix
         run: nix build
@@ -229,7 +229,7 @@ jobs:
       - name: Check flake.nix modifications
         run: |
           if git diff --quiet flake.nix; then
-            echo "âš ï¸  Warning: flake.nix was not modified by update script"
+            echo "â„¹ï¸  flake.nix unchanged (hash already up-to-date)"
           else
             echo "âœ… flake.nix was updated by script"
             git diff flake.nix
diff --git a/.github/workflows/polish-release-notes.yml b/.github/workflows/polish-release-notes.yml
deleted file mode 100644
index a58e42b..0000000
--- a/.github/workflows/polish-release-notes.yml
+++ /dev/null
@@ -1,149 +0,0 @@
-name: Polish Release Notes
-
-# Uses Claude to transform raw changelog into polished release notes.
-# Triggered automatically by release-prepare after publishing, or manually.
-on:
-  repository_dispatch:
-    types: [polish-release-notes]
-  workflow_dispatch:
-    inputs:
-      tag_name:
-        description: 'Release tag to polish (e.g., v0.18.0)'
-        required: true
-        type: string
-
-env:
-  # repository_dispatch passes tag via client_payload, workflow_dispatch via inputs
-  TAG_NAME: ${{ github.event.client_payload.tag_name || inputs.tag_name }}
-
-permissions:
-  contents: write
-
-jobs:
-  polish:
-    # Only run on the main repo, not forks
-    if: github.repository == 'Fission-AI/OpenSpec'
-    runs-on: ubuntu-latest
-
-    steps:
-      - uses: actions/checkout@v4
-
-      - name: Get current release body
-        id: get-release
-        env:
-          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
-        run: |
-          gh release view "${{ env.TAG_NAME }}" --json body -q '.body' > current-notes.md
-          echo "Fetched release notes for ${{ env.TAG_NAME }}"
-
-      - name: Transform release notes with Claude
-        uses: anthropics/claude-code-action@v1
-        id: claude
-        with:
-          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
-          github_token: ${{ secrets.GITHUB_TOKEN }}
-          claude_args: "--allowedTools Write,Read"
-          prompt: |
-            Transform the changelog in `current-notes.md` into release notes for OpenSpec ${{ env.TAG_NAME }}.
-
-            ## Voice
-
-            OpenSpec is a developer tool. Write like you're talking to a peer:
-            - Direct and practical, not marketing copy
-            - Focus on what changed and why it matters
-            - Skip the hype, keep it real
-
-            ## Output
-
-            Create two files:
-
-            ### 1. `release-title.txt`
-
-            A short title in this format:
-            ```
-            ${{ env.TAG_NAME }} - [1-4 words describing the release]
-            ```
-
-            Examples:
-            - `v0.18.0 - OPSX Experimental Workflow`
-            - `v0.16.0 - Antigravity, iFlow Support`
-            - `v0.15.0 - Gemini CLI, RooCode`
-
-            Rules for title:
-            - Lead with the most notable addition
-            - 1-4 words after the dash, no fluff
-            - If multiple features, comma-separate the top 2
-            - For bugfix-only releases, use something like `v0.17.2 - Pre-commit Hook Fix`
-
-            ### 2. `polished-notes.md`
-
-            ```markdown
-            ## What's New in ${{ env.TAG_NAME }}
-
-            [One sentence: what's the theme of this release?]
-
-            ### New
-
-            - **Feature name** - What it does and why you'd use it
-
-            ### Improved
-
-            - **Area** - What got better
-
-            ### Fixed
-
-            - What was broken, now works
-            ```
-
-            Omit empty sections.
-
-            ## Rules
-
-            1. Write for developers using OpenSpec with AI coding assistants
-            2. Remove commit hashes (like `eb152eb:`), PR numbers, and changesets wrappers (`### Minor Changes`)
-            3. Lead with what users can do, not implementation details
-            4. One to two sentences per item, max
-            5. Use **bold** for feature/area names
-            6. Skip internal changes (CI, refactors, tests) unless they affect users
-            7. If the input is already well-formatted, just clean up structure and remove noise
-
-            ## Example
-
-            Before:
-            ```
-            ### Minor Changes
-            - 8dfd824: Add OPSX experimental workflow commands and enhanced artifact system
-              **New Commands:**
-              - `/opsx:ff` - Fast-forward through artifact creation
-            ```
-
-            After (polished-notes.md):
-            ```
-            ### New
-
-            - **Fast-forward mode** - Generate all planning artifacts at once with `/opsx:ff`. Useful when you already know what you're building.
-            ```
-
-            After (release-title.txt):
-            ```
-            v0.18.0 - OPSX Experimental Workflow
-            ```
-
-            Write both files. No other output.
-
-      - name: Update release
-        env:
-          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
-        run: |
-          TAG="${{ env.TAG_NAME }}"
-
-          if [ -f "polished-notes.md" ] && [ -f "release-title.txt" ]; then
-            TITLE=$(cat release-title.txt)
-            gh release edit "$TAG" --title "$TITLE" --notes-file polished-notes.md
-            echo "Updated: $TITLE"
-          elif [ -f "polished-notes.md" ]; then
-            gh release edit "$TAG" --notes-file polished-notes.md
-            echo "Updated notes (title unchanged)"
-          else
-            echo "No changes generated, keeping original"
-          fi
diff --git a/.github/workflows/release-prepare.yml b/.github/workflows/release-prepare.yml
index b59653e..0a58d8e 100644
--- a/.github/workflows/release-prepare.yml
+++ b/.github/workflows/release-prepare.yml
@@ -58,19 +58,3 @@ jobs:
         env:
           GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
           # npm authentication handled via OIDC trusted publishing (no token needed)
-
-      # Trigger release notes polishing after a release is published
-      # Uses repository_dispatch instead of workflow_dispatch because:
-      # - workflow_dispatch requires actions:write permission (GitHub App doesn't have it)
-      # - repository_dispatch works with contents:write (which we already have)
-      - name: Polish release notes
-        if: steps.changesets.outputs.published == 'true'
-        env:
-          GH_TOKEN: ${{ steps.app-token.outputs.token }}
-        run: |
-          # Get version from package.json (just bumped by changesets)
-          TAG="v$(jq -r .version package.json)"
-          echo "Triggering polish workflow for $TAG"
-          gh api repos/${{ github.repository }}/dispatches \
-            --method POST \
-            --input - <<< "{\"event_type\":\"polish-release-notes\",\"client_payload\":{\"tag_name\":\"$TAG\"}}"
diff --git a/AGENTS.md b/AGENTS.md
index 7f111dd..e69de29 100644
--- a/AGENTS.md
+++ b/AGENTS.md
@@ -1,18 +0,0 @@
-<!-- OPENSPEC:START -->
-# OpenSpec Instructions
-
-These instructions are for AI assistants working in this project.
-
-Always open `@/openspec/AGENTS.md` when the request:
-- Mentions planning or proposals (words like proposal, spec, change, plan)
-- Introduces new capabilities, breaking changes, architecture shifts, or big performance/security work
-- Sounds ambiguous and you need the authoritative spec before coding
-
-Use `@/openspec/AGENTS.md` to learn:
-- How to create and apply change proposals
-- Spec format and conventions
-- Project structure and guidelines
-
-Keep this managed block so 'openspec update' can refresh the instructions.
-
-<!-- OPENSPEC:END -->
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 8b25ccb..9ec8b0e 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,108 @@
 # @fission-ai/openspec
 
+## 1.0.2
+
+### Patch Changes
+
+- [#596](https://github.com/Fission-AI/OpenSpec/pull/596) [`e91568d`](https://github.com/Fission-AI/OpenSpec/commit/e91568deb948073f3e9d9bb2d2ab5bf8080d6cf4) Thanks [@TabishB](https://github.com/TabishB)! - ### Bug Fixes
+
+  - Clarified spec naming convention â€” Specs should be named after capabilities (`specs/<capability>/spec.md`), not changes
+  - Fixed task checkbox format guidance â€” Tasks now clearly require `- [ ]` checkbox format for apply phase tracking
+
+## 1.0.1
+
+### Patch Changes
+
+- [#587](https://github.com/Fission-AI/OpenSpec/pull/587) [`943e0d4`](https://github.com/Fission-AI/OpenSpec/commit/943e0d41026d034de66b9442d1276c01b293eb2b) Thanks [@TabishB](https://github.com/TabishB)! - ### Bug Fixes
+
+  - Fixed incorrect archive path in onboarding documentation â€” the template now shows the correct path `openspec/changes/archive/YYYY-MM-DD-<name>/` instead of the incorrect `openspec/archive/YYYY-MM-DD--<name>/`
+
+## 1.0.0
+
+### Major Changes
+
+- [#578](https://github.com/Fission-AI/OpenSpec/pull/578) [`0cc9d90`](https://github.com/Fission-AI/OpenSpec/commit/0cc9d9025af367faa1688a7b2606a2549053cd3f) Thanks [@TabishB](https://github.com/TabishB)! - ## OpenSpec 1.0 â€” The OPSX Release
+
+  The workflow has been rebuilt from the ground up. OPSX replaces the old phase-locked `/openspec:*` commands with an action-based system where AI understands what artifacts exist, what's ready to create, and what each action unlocks.
+
+  ### Breaking Changes
+
+  - **Old commands removed** â€” `/openspec:proposal`, `/openspec:apply`, and `/openspec:archive` no longer exist
+  - **Config files removed** â€” Tool-specific instruction files (`CLAUDE.md`, `.cursorrules`, `AGENTS.md`, `project.md`) are no longer generated
+  - **Migration** â€” Run `openspec init` to upgrade. Legacy artifacts are detected and cleaned up with confirmation.
+
+  ### From Static Prompts to Dynamic Instructions
+
+  **Before:** AI received the same static instructions every time, regardless of project state.
+
+  **Now:** Instructions are dynamically assembled from three layers:
+
+  1. **Context** â€” Project background from `config.yaml` (tech stack, conventions)
+  2. **Rules** â€” Artifact-specific constraints (e.g., "propose spike tasks for unknowns")
+  3. **Template** â€” The actual structure for the output file
+
+  AI queries the CLI for real-time state: which artifacts exist, what's ready to create, what dependencies are satisfied, and what each action unlocks.
+
+  ### From Phase-Locked to Action-Based
+
+  **Before:** Linear workflow â€” proposal â†’ apply â†’ archive. Couldn't easily go back or iterate.
+
+  **Now:** Flexible actions on a change. Edit any artifact anytime. The artifact graph tracks state automatically.
+
+  | Command              | What it does                                         |
+  | -------------------- | ---------------------------------------------------- |
+  | `/opsx:explore`      | Think through ideas before committing to a change    |
+  | `/opsx:new`          | Start a new change                                   |
+  | `/opsx:continue`     | Create one artifact at a time (step-through)         |
+  | `/opsx:ff`           | Create all planning artifacts at once (fast-forward) |
+  | `/opsx:apply`        | Implement tasks                                      |
+  | `/opsx:verify`       | Validate implementation matches artifacts            |
+  | `/opsx:sync`         | Sync delta specs to main specs                       |
+  | `/opsx:archive`      | Archive completed change                             |
+  | `/opsx:bulk-archive` | Archive multiple changes with conflict detection     |
+  | `/opsx:onboard`      | Guided 15-minute walkthrough of complete workflow    |
+
+  ### From Text Merging to Semantic Spec Syncing
+
+  **Before:** Spec updates required manual merging or wholesale file replacement.
+
+  **Now:** Delta specs use semantic markers that AI understands:
+
+  - `## ADDED Requirements` â€” New requirements to add
+  - `## MODIFIED Requirements` â€” Partial updates (add scenario without copying existing ones)
+  - `## REMOVED Requirements` â€” Delete with reason and migration notes
+  - `## RENAMED Requirements` â€” Rename preserving content
+
+  Archive parses these at the requirement level, not brittle header matching.
+
+  ### From Scattered Files to Agent Skills
+
+  **Before:** 8+ config files at project root + slash commands scattered across 21 tool-specific locations with different formats.
+
+  **Now:** Single `.claude/skills/` directory with YAML-fronted markdown files. Auto-detected by Claude Code, Cursor, Windsurf. Cross-editor compatible.
+
+  ### New Features
+
+  - **Onboarding skill** â€” `/opsx:onboard` walks new users through their first complete change with codebase-aware task suggestions and step-by-step narration (11 phases, ~15 minutes)
+
+  - **21 AI tools supported** â€” Claude Code, Cursor, Windsurf, Continue, Gemini CLI, GitHub Copilot, Amazon Q, Cline, RooCode, Kilo Code, Auggie, CodeBuddy, Qoder, Qwen, CoStrict, Crush, Factory, OpenCode, Antigravity, iFlow, and Codex
+
+  - **Interactive setup** â€” `openspec init` shows animated welcome screen and searchable multi-select for choosing tools. Pre-selects already-configured tools for easy refresh.
+
+  - **Customizable schemas** â€” Define custom artifact workflows in `openspec/schemas/` without touching package code. Teams can share workflows via version control.
+
+  ### Bug Fixes
+
+  - Fixed Claude Code YAML parsing failure when command names contained colons
+  - Fixed task file parsing to handle trailing whitespace on checkbox lines
+  - Fixed JSON instruction output to separate context/rules from template â€” AI was copying constraint blocks into artifact files
+
+  ### Documentation
+
+  - New getting-started guide, CLI reference, concepts documentation
+  - Removed misleading "edit mid-flight and continue" claims that weren't implemented
+  - Added migration guide for upgrading from pre-OPSX versions
+
 ## 0.23.0
 
 ### Minor Changes
diff --git a/README.md b/README.md
index 72bb301..c43d3e9 100644
--- a/README.md
+++ b/README.md
@@ -1,453 +1,188 @@
 <p align="center">
   <a href="https://github.com/Fission-AI/OpenSpec">
     <picture>
-      <source srcset="assets/openspec_pixel_dark.svg" media="(prefers-color-scheme: dark)">
-      <source srcset="assets/openspec_pixel_light.svg" media="(prefers-color-scheme: light)">
-      <img src="assets/openspec_pixel_light.svg" alt="OpenSpec logo" height="64">
+      <source srcset="assets/openspec_bg.png">
+      <img src="assets/openspec_bg.png" alt="OpenSpec logo">
     </picture>
   </a>
-  
 </p>
-<p align="center">Spec-driven development for AI coding assistants.</p>
+
 <p align="center">
   <a href="https://github.com/Fission-AI/OpenSpec/actions/workflows/ci.yml"><img alt="CI" src="https://github.com/Fission-AI/OpenSpec/actions/workflows/ci.yml/badge.svg" /></a>
   <a href="https://www.npmjs.com/package/@fission-ai/openspec"><img alt="npm version" src="https://img.shields.io/npm/v/@fission-ai/openspec?style=flat-square" /></a>
-  <a href="https://nodejs.org/"><img alt="node version" src="https://img.shields.io/node/v/@fission-ai/openspec?style=flat-square" /></a>
   <a href="./LICENSE"><img alt="License: MIT" src="https://img.shields.io/badge/License-MIT-blue.svg?style=flat-square" /></a>
-  <a href="https://conventionalcommits.org"><img alt="Conventional Commits" src="https://img.shields.io/badge/Conventional%20Commits-1.0.0-yellow.svg?style=flat-square" /></a>
-  <a href="https://discord.gg/YctCnvvshC"><img alt="Discord" src="https://img.shields.io/badge/Discord-Join%20the%20community-5865F2?logo=discord&logoColor=white&style=flat-square" /></a>
-</p>
-
-<p align="center">
-  <img src="assets/openspec_dashboard.png" alt="OpenSpec dashboard preview" width="90%">
-</p>
-
-<p align="center">
-  Follow <a href="https://x.com/0xTab">@0xTab on X</a> for updates Â· Join the <a href="https://discord.gg/YctCnvvshC">OpenSpec Discord</a> for help and questions.
+  <a href="https://discord.gg/YctCnvvshC"><img alt="Discord" src="https://img.shields.io/discord/1411657095639601154?style=flat-square&logo=discord&logoColor=white&label=Discord&suffix=%20online" /></a>
 </p>
 
-<p align="center">
-  <sub>ğŸ§ª <strong>New:</strong> <a href="docs/experimental-workflow.md">Experimental Workflow (OPSX)</a> â€” schema-driven, hackable, fluid. Iterate on workflows without code changes.</sub>
-</p>
+<details>
+<summary><strong>The most loved spec framework.</strong></summary>
 
-# OpenSpec
+[![Stars](https://img.shields.io/github/stars/Fission-AI/OpenSpec?style=flat-square&label=Stars)](https://github.com/Fission-AI/OpenSpec/stargazers)
+[![Downloads](https://img.shields.io/npm/dm/@fission-ai/openspec?style=flat-square&label=Downloads/mo)](https://www.npmjs.com/package/@fission-ai/openspec)
+[![Contributors](https://img.shields.io/github/contributors/Fission-AI/OpenSpec?style=flat-square&label=Contributors)](https://github.com/Fission-AI/OpenSpec/graphs/contributors)
 
-OpenSpec aligns humans and AI coding assistants with spec-driven development so you agree on what to build before any code is written. **No API keys required.**
+</details>
+<p></p>
+Our philosophy:
 
-## Why OpenSpec?
+```text
+â†’ fluid not rigid
+â†’ iterative not waterfall
+â†’ easy not complex
+â†’ built for brownfield not just greenfield
+â†’ scalable from personal projects to enterprises
+```
 
-AI coding assistants are powerful but unpredictable when requirements live in chat history. OpenSpec adds a lightweight specification workflow that locks intent before implementation, giving you deterministic, reviewable outputs.
+> [!TIP]
+> **New workflow now available!** We've rebuilt OpenSpec with a new artifact-guided workflow.
+>
+> Run `/opsx:onboard` to get started. â†’ [Learn more here](docs/opsx.md)
 
-Key outcomes:
-- Human and AI stakeholders agree on specs before work begins.
-- Structured change folders (proposals, tasks, and spec updates) keep scope explicit and auditable.
-- Shared visibility into what's proposed, active, or archived.
-- Works with the AI tools you already use: custom slash commands where supported, context rules everywhere else.
+<p align="center">
+  Follow <a href="https://x.com/0xTab">@0xTab on X</a> for updates Â· Join the <a href="https://discord.gg/YctCnvvshC">OpenSpec Discord</a> for help and questions.
+</p>
 
-## How OpenSpec compares (at a glance)
+### Teams
 
-- **Lightweight**: simple workflow, no API keys, minimal setup.
-- **Brownfield-first**: works great beyond 0â†’1. OpenSpec separates the source of truth from proposals: `openspec/specs/` (current truth) and `openspec/changes/` (proposed updates). This keeps diffs explicit and manageable across features.
-- **Change tracking**: proposals, tasks, and spec deltas live together; archiving merges the approved updates back into specs.
-- **Compared to spec-kit & Kiro**: those shine for brand-new features (0â†’1). OpenSpec also excels when modifying existing behavior (1â†’n), especially when updates span multiple specs.
+Using OpenSpec in a team? [Email here](mailto:teams@openspec.dev) for access to our Slack channel.
 
-See the full comparison in [How OpenSpec Compares](#how-openspec-compares).
+<!-- TODO: Add GIF demo of /opsx:new â†’ /opsx:archive workflow -->
 
-## How It Works
+## See it in action
 
+```text
+You: /opsx:new add-dark-mode
+AI:  Created openspec/changes/add-dark-mode/
+     Ready to create: proposal
+
+You: /opsx:ff   # "fast-forward" - generate all planning docs
+AI:  âœ“ proposal.md â€” why we're doing this, what's changing
+     âœ“ specs/       â€” requirements and scenarios
+     âœ“ design.md    â€” technical approach
+     âœ“ tasks.md     â€” implementation checklist
+     Ready for implementation!
+
+You: /opsx:apply
+AI:  Implementing tasks...
+     âœ“ 1.1 Add theme context provider
+     âœ“ 1.2 Create toggle component
+     âœ“ 2.1 Add CSS variables
+     âœ“ 2.2 Wire up localStorage
+     All tasks complete!
+
+You: /opsx:archive
+AI:  Archived to openspec/changes/archive/2025-01-23-add-dark-mode/
+     Specs updated. Ready for the next feature.
 ```
-â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-â”‚ Draft Change       â”‚
-â”‚ Proposal           â”‚
-â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-         â”‚ share intent with your AI
-         â–¼
-â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-â”‚ Review & Align     â”‚
-â”‚ (edit specs/tasks) â”‚â—€â”€â”€â”€â”€ feedback loop â”€â”€â”€â”€â”€â”€â”
-â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
-         â”‚ approved plan                        â”‚
-         â–¼                                      â”‚
-â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
-â”‚ Implement Tasks    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-â”‚ (AI writes code)   â”‚
-â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-         â”‚ ship the change
-         â–¼
-â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-â”‚ Archive & Update   â”‚
-â”‚ Specs (source)     â”‚
-â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-
-1. Draft a change proposal that captures the spec updates you want.
-2. Review the proposal with your AI assistant until everyone agrees.
-3. Implement tasks that reference the agreed specs.
-4. Archive the change to merge the approved updates back into the source-of-truth specs.
-```
-
-## Getting Started
-
-### Supported AI Tools
-
-<details>
-<summary><strong>Native Slash Commands</strong> (click to expand)</summary>
-
-These tools have built-in OpenSpec commands. Select the OpenSpec integration when prompted.
-
-| Tool | Commands |
-|------|----------|
-| **Amazon Q Developer** | `@openspec-proposal`, `@openspec-apply`, `@openspec-archive` (`.amazonq/prompts/`) |
-| **Antigravity** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.agent/workflows/`) |
-| **Auggie (Augment CLI)** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.augment/commands/`) |
-| **Claude Code** | `/openspec:proposal`, `/openspec:apply`, `/openspec:archive` |
-| **Cline** | Workflows in `.clinerules/workflows/` directory (`.clinerules/workflows/openspec-*.md`) |
-| **CodeBuddy Code (CLI)** | `/openspec:proposal`, `/openspec:apply`, `/openspec:archive` (`.codebuddy/commands/`) â€” see [docs](https://www.codebuddy.ai/cli) |
-| **Codex** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (global: `~/.codex/prompts`, auto-installed) |
-| **Continue** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.continue/prompts/`) |
-| **CoStrict** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.cospec/openspec/commands/`) â€” see [docs](https://costrict.ai)|
-| **Crush** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.crush/commands/openspec/`) |
-| **Cursor** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` |
-| **Factory Droid** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.factory/commands/`) |
-| **Gemini CLI** | `/openspec:proposal`, `/openspec:apply`, `/openspec:archive` (`.gemini/commands/openspec/`) |
-| **GitHub Copilot** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.github/prompts/`) |
-| **iFlow (iflow-cli)** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.iflow/commands/`) |
-| **Kilo Code** | `/openspec-proposal.md`, `/openspec-apply.md`, `/openspec-archive.md` (`.kilocode/workflows/`) |
-| **OpenCode** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` |
-| **Qoder** | `/openspec:proposal`, `/openspec:apply`, `/openspec:archive` (`.qoder/commands/openspec/`) â€” see [docs](https://qoder.com) |
-| **Qwen Code** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.qwen/commands/`) |
-| **RooCode** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.roo/commands/`) |
-| **Windsurf** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.windsurf/workflows/`) |
-
-Kilo Code discovers team workflows automatically. Save the generated files under `.kilocode/workflows/` and trigger them from the command palette with `/openspec-proposal.md`, `/openspec-apply.md`, or `/openspec-archive.md`.
-
-</details>
 
 <details>
-<summary><strong>AGENTS.md Compatible</strong> (click to expand)</summary>
+<summary><strong>OpenSpec Dashboard</strong></summary>
 
-These tools automatically read workflow instructions from `openspec/AGENTS.md`. Ask them to follow the OpenSpec workflow if they need a reminder. Learn more about the [AGENTS.md convention](https://agents.md/).
-
-| Tools |
-|-------|
-| Amp â€¢ Jules â€¢ Others |
+<p align="center">
+  <img src="assets/openspec_dashboard.png" alt="OpenSpec dashboard preview" width="90%">
+</p>
 
 </details>
 
-### Install & Initialize
+## Quick Start
 
-#### Prerequisites
-- **Node.js >= 20.19.0** - Check your version with `node --version`
+**Requires Node.js 20.19.0 or higher.**
 
-#### Step 1: Install the CLI globally
-
-**Option A: Using npm**
+Install OpenSpec globally:
 
 ```bash
 npm install -g @fission-ai/openspec@latest
 ```
 
-Verify installation:
-```bash
-openspec --version
-```
-
-**Option B: Using Nix (NixOS and Nix package manager)**
-
-Run OpenSpec directly without installation:
-```bash
-nix run github:Fission-AI/OpenSpec -- init
-```
-
-Or install to your profile:
-```bash
-nix profile install github:Fission-AI/OpenSpec
-```
-
-Or add to your development environment in `flake.nix`:
-```nix
-{
-  inputs = {
-    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
-    openspec.url = "github:Fission-AI/OpenSpec";
-  };
-
-  outputs = { nixpkgs, openspec, ... }: {
-    devShells.x86_64-linux.default = nixpkgs.legacyPackages.x86_64-linux.mkShell {
-      buildInputs = [ openspec.packages.x86_64-linux.default ];
-    };
-  };
-}
-```
-
-Verify installation:
-```bash
-openspec --version
-```
-
-#### Step 2: Initialize OpenSpec in your project
-
-Navigate to your project directory:
-```bash
-cd my-project
-```
+Then navigate to your project directory and initialize:
 
-Run the initialization:
 ```bash
+cd your-project
 openspec init
 ```
 
-**What happens during initialization:**
-- You'll be prompted to pick any natively supported AI tools (Claude Code, CodeBuddy, Cursor, OpenCode, Qoder,etc.); other assistants always rely on the shared `AGENTS.md` stub
-- OpenSpec automatically configures slash commands for the tools you choose and always writes a managed `AGENTS.md` hand-off at the project root
-- A new `openspec/` directory structure is created in your project
-
-**After setup:**
-- Primary AI tools can trigger `/openspec` workflows without additional configuration
-- Run `openspec list` to verify the setup and view any active changes
-- If your coding assistant doesn't surface the new slash commands right away, restart it. Slash commands are loaded at startup,
-  so a fresh launch ensures they appear
-
-### Optional: Populate Project Context
-
-After `openspec init` completes, you'll receive a suggested prompt to help populate your project context:
-
-```text
-Populate your project context:
-"Please read openspec/project.md and help me fill it out with details about my project, tech stack, and conventions"
-```
-
-Use `openspec/project.md` to define project-level conventions, standards, architectural patterns, and other guidelines that should be followed across all changes.
+Now tell your AI: `/opsx:new <what-you-want-to-build>`
 
-### Create Your First Change
+> [!NOTE]
+> Not sure if your tool is supported? [View the full list](docs/supported-tools.md) â€“ we support 20+ tools and growing.
+>
+> Also works with pnpm, yarn, bun, and nix. [See installation options](docs/installation.md).
 
-Here's a real example showing the complete OpenSpec workflow. This works with any AI tool. Those with native slash commands will recognize the shortcuts automatically.
+## Docs
 
-#### 1. Draft the Proposal
-Start by asking your AI to create a change proposal:
-
-```text
-You: Create an OpenSpec change proposal for adding profile search filters by role and team
-     (Shortcut for tools with slash commands: /openspec:proposal Add profile search filters)
-
-AI:  I'll create an OpenSpec change proposal for profile filters.
-     *Scaffolds openspec/changes/add-profile-filters/ with proposal.md, tasks.md, spec deltas.*
-```
-
-#### 2. Verify & Review
-Check that the change was created correctly and review the proposal:
-
-```bash
-$ openspec list                             # Confirm the change folder exists
-$ openspec validate add-profile-filters     # Validate spec formatting
-$ openspec show add-profile-filters         # Review proposal, tasks, and spec delta
-```
+â†’ **[Getting Started](docs/getting-started.md)**: first steps<br>
+â†’ **[Workflows](docs/workflows.md)**: combos and patterns<br>
+â†’ **[Commands](docs/commands.md)**: slash commands & skills<br>
+â†’ **[CLI](docs/cli.md)**: terminal reference<br>
+â†’ **[Supported Tools](docs/supported-tools.md)**: tool integrations & install paths<br>
+â†’ **[Concepts](docs/concepts.md)**: how it all fits<br>
+â†’ **[Multi-Language](docs/multi-language.md)**: multi-language support<br>
+â†’ **[Customization](docs/customization.md)**: make it yours
 
-#### 3. Refine the Specs
-Iterate on the specifications until they match your needs:
 
-```text
-You: Can you add acceptance criteria for the role and team filters?
+## Why OpenSpec?
 
-AI:  I'll update the spec delta with scenarios for role and team filters.
-     *Edits openspec/changes/add-profile-filters/specs/profile/spec.md and tasks.md.*
-```
+AI coding assistants are powerful but unpredictable when requirements live only in chat history. OpenSpec adds a lightweight spec layer so you agree on what to build before any code is written.
 
-#### 4. Implement the Change
-Once specs look good, start implementation:
+- **Agree before you build** â€” human and AI align on specs before code gets written
+- **Stay organized** â€” each change gets its own folder with proposal, specs, design, and tasks
+- **Work fluidly** â€” update any artifact anytime, no rigid phase gates
+- **Use your tools** â€” works with 20+ AI assistants via slash commands
 
-```text
-You: The specs look good. Let's implement this change.
-     (Shortcut for tools with slash commands: /openspec:apply add-profile-filters)
+### How we compare
 
-AI:  I'll work through the tasks in the add-profile-filters change.
-     *Implements tasks from openspec/changes/add-profile-filters/tasks.md*
-     *Marks tasks complete: Task 1.1 âœ“, Task 1.2 âœ“, Task 2.1 âœ“...*
-```
+**vs. [Spec Kit](https://github.com/github/spec-kit)** (GitHub) â€” Thorough but heavyweight. Rigid phase gates, lots of Markdown, Python setup. OpenSpec is lighter and lets you iterate freely.
 
-#### 5. Archive the Completed Change
-After implementation is complete, archive the change:
+**vs. [Kiro](https://kiro.dev)** (AWS) â€” Powerful but you're locked into their IDE and limited to Claude models. OpenSpec works with the tools you already use.
 
-```text
-AI:  All tasks are complete. The implementation is ready.
+**vs. nothing** â€” AI coding without specs means vague prompts and unpredictable results. OpenSpec brings predictability without the ceremony.
 
-You: Please archive the change
-     (Shortcut for tools with slash commands: /openspec:archive add-profile-filters)
+## Updating OpenSpec
 
-AI:  I'll archive the add-profile-filters change.
-    *Runs: openspec archive add-profile-filters --yes*
-     âœ“ Change archived successfully. Specs updated. Ready for the next feature!
-```
+**Upgrade the package**
 
-Or run the command yourself in terminal:
 ```bash
-$ openspec archive add-profile-filters --yes  # Archive the completed change without prompts
+npm install -g @fission-ai/openspec@latest
 ```
 
-**Note:** Tools with native slash commands (Claude Code, CodeBuddy, Cursor, Codex, Qoder, RooCode) can use the shortcuts shown. All other tools work with natural language requests to "create an OpenSpec proposal", "apply the OpenSpec change", or "archive the change".
+**Refresh agent instructions**
 
-## Command Reference
+Run this inside each project to regenerate AI guidance and ensure the latest slash commands are active:
 
 ```bash
-openspec list               # View active change folders
-openspec view               # Interactive dashboard of specs and changes
-openspec show <change>      # Display change details (proposal, tasks, spec updates)
-openspec validate <change>  # Check spec formatting and structure
-openspec archive <change> [--yes|-y]   # Move a completed change into archive/ (non-interactive with --yes)
-```
-
-## Example: How AI Creates OpenSpec Files
-
-When you ask your AI assistant to "add two-factor authentication", it creates:
-
-```
-openspec/
-â”œâ”€â”€ specs/
-â”‚   â””â”€â”€ auth/
-â”‚       â””â”€â”€ spec.md           # Current auth spec (if exists)
-â””â”€â”€ changes/
-    â””â”€â”€ add-2fa/              # AI creates this entire structure
-        â”œâ”€â”€ proposal.md       # Why and what changes
-        â”œâ”€â”€ tasks.md          # Implementation checklist
-        â”œâ”€â”€ design.md         # Technical decisions (optional)
-        â””â”€â”€ specs/
-            â””â”€â”€ auth/
-                â””â”€â”€ spec.md   # Delta showing additions
-```
-
-### AI-Generated Spec (created in `openspec/specs/auth/spec.md`):
-
-```markdown
-# Auth Specification
-
-## Purpose
-Authentication and session management.
-
-## Requirements
-### Requirement: User Authentication
-The system SHALL issue a JWT on successful login.
-
-#### Scenario: Valid credentials
-- WHEN a user submits valid credentials
-- THEN a JWT is returned
-```
-
-### AI-Generated Change Delta (created in `openspec/changes/add-2fa/specs/auth/spec.md`):
-
-```markdown
-# Delta for Auth
-
-## ADDED Requirements
-### Requirement: Two-Factor Authentication
-The system MUST require a second factor during login.
-
-#### Scenario: OTP required
-- WHEN a user submits valid credentials
-- THEN an OTP challenge is required
-```
-
-### AI-Generated Tasks (created in `openspec/changes/add-2fa/tasks.md`):
-
-```markdown
-## 1. Database Setup
-- [ ] 1.1 Add OTP secret column to users table
-- [ ] 1.2 Create OTP verification logs table
-
-## 2. Backend Implementation  
-- [ ] 2.1 Add OTP generation endpoint
-- [ ] 2.2 Modify login flow to require OTP
-- [ ] 2.3 Add OTP verification endpoint
-
-## 3. Frontend Updates
-- [ ] 3.1 Create OTP input component
-- [ ] 3.2 Update login flow UI
+openspec update
 ```
 
-**Important:** You don't create these files manually. Your AI assistant generates them based on your requirements and the existing codebase.
-
-## Understanding OpenSpec Files
-
-### Delta Format
+## Usage Notes
 
-Deltas are "patches" that show how specs change:
+**Model selection**: OpenSpec works best with high-reasoning models. We recommend Opus 4.5 and GPT 5.2 for both planning and implementation.
 
-- **`## ADDED Requirements`** - New capabilities
-- **`## MODIFIED Requirements`** - Changed behavior (include complete updated text)
-- **`## REMOVED Requirements`** - Deprecated features
+**Context hygiene**: OpenSpec benefits from a clean context window. Clear your context before starting implementation and maintain good context hygiene throughout your session.
 
-**Format requirements:**
-- Use `### Requirement: <name>` for headers
-- Every requirement needs at least one `#### Scenario:` block
-- Use SHALL/MUST in requirement text
-
-## How OpenSpec Compares
-
-### vs. spec-kit
-OpenSpecâ€™s two-folder model (`openspec/specs/` for the current truth, `openspec/changes/` for proposed updates) keeps state and diffs separate. This scales when you modify existing features or touch multiple specs. spec-kit is strong for greenfield/0â†’1 but provides less structure for cross-spec updates and evolving features.
-
-### vs. Kiro.dev
-OpenSpec groups every change for a feature in one folder (`openspec/changes/feature-name/`), making it easy to track related specs, tasks, and designs together. Kiro spreads updates across multiple spec folders, which can make feature tracking harder.
+## Contributing
 
-### vs. No Specs
-Without specs, AI coding assistants generate code from vague prompts, often missing requirements or adding unwanted features. OpenSpec brings predictability by agreeing on the desired behavior before any code is written.
+**Small fixes** â€” Bug fixes, typo corrections, and minor improvements can be submitted directly as PRs.
 
-## Team Adoption
+**Larger changes** â€” For new features, significant refactors, or architectural changes, please submit an OpenSpec change proposal first so we can align on intent and goals before implementation begins.
 
-1. **Initialize OpenSpec** â€“ Run `openspec init` in your repo.
-2. **Start with new features** â€“ Ask your AI to capture upcoming work as change proposals.
-3. **Grow incrementally** â€“ Each change archives into living specs that document your system.
-4. **Stay flexible** â€“ Different teammates can use Claude Code, CodeBuddy, Cursor, or any AGENTS.md-compatible tool while sharing the same specs.
+When writing proposals, keep the OpenSpec philosophy in mind: we serve a wide variety of users across different coding agents, models, and use cases. Changes should work well for everyone.
 
-Run `openspec update` whenever someone switches tools so your agents pick up the latest instructions and slash-command bindings.
+**AI-generated code is welcome** â€” as long as it's been tested and verified. PRs containing AI-generated code should mention the coding agent and model used (e.g., "Generated with Claude Code using claude-opus-4-5-20251101").
 
-## Updating OpenSpec
+### Development
 
-1. **Upgrade the package**
-   ```bash
-   npm install -g @fission-ai/openspec@latest
-   ```
-2. **Refresh agent instructions**
-   - Run `openspec update` inside each project to regenerate AI guidance and ensure the latest slash commands are active.
+- Install dependencies: `pnpm install`
+- Build: `pnpm run build`
+- Test: `pnpm test`
+- Develop CLI locally: `pnpm run dev` or `pnpm run dev:cli`
+- Conventional commits (one-line): `type(scope): subject`
 
-## Experimental Features
+## Other
 
 <details>
-<summary><strong>ğŸ§ª OPSX: Fluid, Iterative Workflow</strong> (Claude Code only)</summary>
-
-**Why this exists:**
-- Standard workflow is locked down â€” you can't tweak instructions or customize
-- When AI output is bad, you can't improve the prompts yourself
-- Same workflow for everyone, no way to match how your team works
-
-**What's different:**
-- **Hackable** â€” edit templates and schemas yourself, test immediately, no rebuild
-- **Granular** â€” each artifact has its own instructions, test and tweak individually
-- **Customizable** â€” define your own workflows, artifacts, and dependencies
-- **Fluid** â€” no phase gates, update any artifact anytime
-
-```
-You can always go back:
-
-  proposal â”€â”€â†’ specs â”€â”€â†’ design â”€â”€â†’ tasks â”€â”€â†’ implement
-     â–²           â–²          â–²                    â”‚
-     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-```
+<summary><strong>Telemetry</strong></summary>
 
-| Command | What it does |
-|---------|--------------|
-| `/opsx:new` | Start a new change |
-| `/opsx:continue` | Create the next artifact (based on what's ready) |
-| `/opsx:ff` | Fast-forward (all planning artifacts at once) |
-| `/opsx:apply` | Implement tasks, updating artifacts as needed |
-| `/opsx:archive` | Archive when done |
-
-**Setup:** `openspec artifact-experimental-setup`
-
-[Full documentation â†’](docs/experimental-workflow.md)
-
-</details>
-
-<details>
-<summary><strong>Telemetry</strong> â€“ OpenSpec collects anonymous usage stats (opt-out: <code>OPENSPEC_TELEMETRY=0</code>)</summary>
+OpenSpec collects anonymous usage stats.
 
 We collect only command names and version to understand usage patterns. No arguments, paths, content, or PII. Automatically disabled in CI.
 
@@ -455,14 +190,6 @@ We collect only command names and version to understand usage patterns. No argum
 
 </details>
 
-## Contributing
-
-- Install dependencies: `pnpm install`
-- Build: `pnpm run build`
-- Test: `pnpm test`
-- Develop CLI locally: `pnpm run dev` or `pnpm run dev:cli`
-- Conventional commits (one-line): `type(scope): subject`
-
 <details>
 <summary><strong>Maintainers & Advisors</strong></summary>
 
@@ -470,6 +197,8 @@ See [MAINTAINERS.md](MAINTAINERS.md) for the list of core maintainers and adviso
 
 </details>
 
+
+
 ## License
 
 MIT
diff --git a/README_OLD.md b/README_OLD.md
new file mode 100644
index 0000000..e0f7f39
--- /dev/null
+++ b/README_OLD.md
@@ -0,0 +1,475 @@
+<p align="center">
+  <a href="https://github.com/Fission-AI/OpenSpec">
+    <picture>
+      <source srcset="assets/openspec_pixel_dark.svg" media="(prefers-color-scheme: dark)">
+      <source srcset="assets/openspec_pixel_light.svg" media="(prefers-color-scheme: light)">
+      <img src="assets/openspec_pixel_light.svg" alt="OpenSpec logo" height="64">
+    </picture>
+  </a>
+  
+</p>
+<p align="center">Spec-driven development for AI coding assistants.</p>
+<p align="center">
+  <a href="https://github.com/Fission-AI/OpenSpec/actions/workflows/ci.yml"><img alt="CI" src="https://github.com/Fission-AI/OpenSpec/actions/workflows/ci.yml/badge.svg" /></a>
+  <a href="https://www.npmjs.com/package/@fission-ai/openspec"><img alt="npm version" src="https://img.shields.io/npm/v/@fission-ai/openspec?style=flat-square" /></a>
+  <a href="https://nodejs.org/"><img alt="node version" src="https://img.shields.io/node/v/@fission-ai/openspec?style=flat-square" /></a>
+  <a href="./LICENSE"><img alt="License: MIT" src="https://img.shields.io/badge/License-MIT-blue.svg?style=flat-square" /></a>
+  <a href="https://conventionalcommits.org"><img alt="Conventional Commits" src="https://img.shields.io/badge/Conventional%20Commits-1.0.0-yellow.svg?style=flat-square" /></a>
+  <a href="https://discord.gg/YctCnvvshC"><img alt="Discord" src="https://img.shields.io/badge/Discord-Join%20the%20community-5865F2?logo=discord&logoColor=white&style=flat-square" /></a>
+</p>
+
+<p align="center">
+  <img src="assets/openspec_dashboard.png" alt="OpenSpec dashboard preview" width="90%">
+</p>
+
+<p align="center">
+  Follow <a href="https://x.com/0xTab">@0xTab on X</a> for updates Â· Join the <a href="https://discord.gg/YctCnvvshC">OpenSpec Discord</a> for help and questions.
+</p>
+
+<p align="center">
+  <sub>ğŸ§ª <strong>New:</strong> <a href="docs/opsx.md">OPSX Workflow</a> â€” schema-driven, hackable, fluid. Iterate on workflows without code changes.</sub>
+</p>
+
+# OpenSpec
+
+OpenSpec aligns humans and AI coding assistants with spec-driven development so you agree on what to build before any code is written. **No API keys required.**
+
+## Why OpenSpec?
+
+AI coding assistants are powerful but unpredictable when requirements live in chat history. OpenSpec adds a lightweight specification workflow that locks intent before implementation, giving you deterministic, reviewable outputs.
+
+Key outcomes:
+- Human and AI stakeholders agree on specs before work begins.
+- Structured change folders (proposals, tasks, and spec updates) keep scope explicit and auditable.
+- Shared visibility into what's proposed, active, or archived.
+- Works with the AI tools you already use: custom slash commands where supported, context rules everywhere else.
+
+## How OpenSpec compares (at a glance)
+
+- **Lightweight**: simple workflow, no API keys, minimal setup.
+- **Brownfield-first**: works great beyond 0â†’1. OpenSpec separates the source of truth from proposals: `openspec/specs/` (current truth) and `openspec/changes/` (proposed updates). This keeps diffs explicit and manageable across features.
+- **Change tracking**: proposals, tasks, and spec deltas live together; archiving merges the approved updates back into specs.
+- **Compared to spec-kit & Kiro**: those shine for brand-new features (0â†’1). OpenSpec also excels when modifying existing behavior (1â†’n), especially when updates span multiple specs.
+
+See the full comparison in [How OpenSpec Compares](#how-openspec-compares).
+
+## How It Works
+
+```
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚ Draft Change       â”‚
+â”‚ Proposal           â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+         â”‚ share intent with your AI
+         â–¼
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚ Review & Align     â”‚
+â”‚ (edit specs/tasks) â”‚â—€â”€â”€â”€â”€ feedback loop â”€â”€â”€â”€â”€â”€â”
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
+         â”‚ approved plan                        â”‚
+         â–¼                                      â”‚
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
+â”‚ Implement Tasks    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+â”‚ (AI writes code)   â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+         â”‚ ship the change
+         â–¼
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚ Archive & Update   â”‚
+â”‚ Specs (source)     â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+
+1. Draft a change proposal that captures the spec updates you want.
+2. Review the proposal with your AI assistant until everyone agrees.
+3. Implement tasks that reference the agreed specs.
+4. Archive the change to merge the approved updates back into the source-of-truth specs.
+```
+
+## Getting Started
+
+### Supported AI Tools
+
+<details>
+<summary><strong>Native Slash Commands</strong> (click to expand)</summary>
+
+These tools have built-in OpenSpec commands. Select the OpenSpec integration when prompted.
+
+| Tool | Commands |
+|------|----------|
+| **Amazon Q Developer** | `@openspec-proposal`, `@openspec-apply`, `@openspec-archive` (`.amazonq/prompts/`) |
+| **Antigravity** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.agent/workflows/`) |
+| **Auggie (Augment CLI)** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.augment/commands/`) |
+| **Claude Code** | `/openspec:proposal`, `/openspec:apply`, `/openspec:archive` |
+| **Cline** | Workflows in `.clinerules/workflows/` directory (`.clinerules/workflows/openspec-*.md`) |
+| **CodeBuddy Code (CLI)** | `/openspec:proposal`, `/openspec:apply`, `/openspec:archive` (`.codebuddy/commands/`) â€” see [docs](https://www.codebuddy.ai/cli) |
+| **Codex** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (global: `~/.codex/prompts`, auto-installed) |
+| **Continue** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.continue/prompts/`) |
+| **CoStrict** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.cospec/openspec/commands/`) â€” see [docs](https://costrict.ai)|
+| **Crush** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.crush/commands/openspec/`) |
+| **Cursor** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` |
+| **Factory Droid** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.factory/commands/`) |
+| **Gemini CLI** | `/openspec:proposal`, `/openspec:apply`, `/openspec:archive` (`.gemini/commands/openspec/`) |
+| **GitHub Copilot** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.github/prompts/`) |
+| **iFlow (iflow-cli)** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.iflow/commands/`) |
+| **Kilo Code** | `/openspec-proposal.md`, `/openspec-apply.md`, `/openspec-archive.md` (`.kilocode/workflows/`) |
+| **OpenCode** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` |
+| **Qoder** | `/openspec:proposal`, `/openspec:apply`, `/openspec:archive` (`.qoder/commands/openspec/`) â€” see [docs](https://qoder.com) |
+| **Qwen Code** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.qwen/commands/`) |
+| **RooCode** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.roo/commands/`) |
+| **Windsurf** | `/openspec-proposal`, `/openspec-apply`, `/openspec-archive` (`.windsurf/workflows/`) |
+
+Kilo Code discovers team workflows automatically. Save the generated files under `.kilocode/workflows/` and trigger them from the command palette with `/openspec-proposal.md`, `/openspec-apply.md`, or `/openspec-archive.md`.
+
+</details>
+
+<details>
+<summary><strong>AGENTS.md Compatible</strong> (click to expand)</summary>
+
+These tools automatically read workflow instructions from `openspec/AGENTS.md`. Ask them to follow the OpenSpec workflow if they need a reminder. Learn more about the [AGENTS.md convention](https://agents.md/).
+
+| Tools |
+|-------|
+| Amp â€¢ Jules â€¢ Others |
+
+</details>
+
+### Install & Initialize
+
+#### Prerequisites
+- **Node.js >= 20.19.0** - Check your version with `node --version`
+
+#### Step 1: Install the CLI globally
+
+**Option A: Using npm**
+
+```bash
+npm install -g @fission-ai/openspec@latest
+```
+
+Verify installation:
+```bash
+openspec --version
+```
+
+**Option B: Using Nix (NixOS and Nix package manager)**
+
+Run OpenSpec directly without installation:
+```bash
+nix run github:Fission-AI/OpenSpec -- init
+```
+
+Or install to your profile:
+```bash
+nix profile install github:Fission-AI/OpenSpec
+```
+
+Or add to your development environment in `flake.nix`:
+```nix
+{
+  inputs = {
+    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
+    openspec.url = "github:Fission-AI/OpenSpec";
+  };
+
+  outputs = { nixpkgs, openspec, ... }: {
+    devShells.x86_64-linux.default = nixpkgs.legacyPackages.x86_64-linux.mkShell {
+      buildInputs = [ openspec.packages.x86_64-linux.default ];
+    };
+  };
+}
+```
+
+Verify installation:
+```bash
+openspec --version
+```
+
+#### Step 2: Initialize OpenSpec in your project
+
+Navigate to your project directory:
+```bash
+cd my-project
+```
+
+Run the initialization:
+```bash
+openspec init
+```
+
+**What happens during initialization:**
+- You'll be prompted to pick any natively supported AI tools (Claude Code, CodeBuddy, Cursor, OpenCode, Qoder,etc.); other assistants always rely on the shared `AGENTS.md` stub
+- OpenSpec automatically configures slash commands for the tools you choose and always writes a managed `AGENTS.md` hand-off at the project root
+- A new `openspec/` directory structure is created in your project
+
+**After setup:**
+- Primary AI tools can trigger `/openspec` workflows without additional configuration
+- Run `openspec list` to verify the setup and view any active changes
+- If your coding assistant doesn't surface the new slash commands right away, restart it. Slash commands are loaded at startup,
+  so a fresh launch ensures they appear
+
+### Optional: Populate Project Context
+
+After `openspec init` completes, you'll receive a suggested prompt to help populate your project context:
+
+```text
+Populate your project context:
+"Please read openspec/project.md and help me fill it out with details about my project, tech stack, and conventions"
+```
+
+Use `openspec/project.md` to define project-level conventions, standards, architectural patterns, and other guidelines that should be followed across all changes.
+
+### Create Your First Change
+
+Here's a real example showing the complete OpenSpec workflow. This works with any AI tool. Those with native slash commands will recognize the shortcuts automatically.
+
+#### 1. Draft the Proposal
+Start by asking your AI to create a change proposal:
+
+```text
+You: Create an OpenSpec change proposal for adding profile search filters by role and team
+     (Shortcut for tools with slash commands: /openspec:proposal Add profile search filters)
+
+AI:  I'll create an OpenSpec change proposal for profile filters.
+     *Scaffolds openspec/changes/add-profile-filters/ with proposal.md, tasks.md, spec deltas.*
+```
+
+#### 2. Verify & Review
+Check that the change was created correctly and review the proposal:
+
+```bash
+$ openspec list                             # Confirm the change folder exists
+$ openspec validate add-profile-filters     # Validate spec formatting
+$ openspec show add-profile-filters         # Review proposal, tasks, and spec delta
+```
+
+#### 3. Refine the Specs
+Iterate on the specifications until they match your needs:
+
+```text
+You: Can you add acceptance criteria for the role and team filters?
+
+AI:  I'll update the spec delta with scenarios for role and team filters.
+     *Edits openspec/changes/add-profile-filters/specs/profile/spec.md and tasks.md.*
+```
+
+#### 4. Implement the Change
+Once specs look good, start implementation:
+
+```text
+You: The specs look good. Let's implement this change.
+     (Shortcut for tools with slash commands: /openspec:apply add-profile-filters)
+
+AI:  I'll work through the tasks in the add-profile-filters change.
+     *Implements tasks from openspec/changes/add-profile-filters/tasks.md*
+     *Marks tasks complete: Task 1.1 âœ“, Task 1.2 âœ“, Task 2.1 âœ“...*
+```
+
+#### 5. Archive the Completed Change
+After implementation is complete, archive the change:
+
+```text
+AI:  All tasks are complete. The implementation is ready.
+
+You: Please archive the change
+     (Shortcut for tools with slash commands: /openspec:archive add-profile-filters)
+
+AI:  I'll archive the add-profile-filters change.
+    *Runs: openspec archive add-profile-filters --yes*
+     âœ“ Change archived successfully. Specs updated. Ready for the next feature!
+```
+
+Or run the command yourself in terminal:
+```bash
+$ openspec archive add-profile-filters --yes  # Archive the completed change without prompts
+```
+
+**Note:** Tools with native slash commands (Claude Code, CodeBuddy, Cursor, Codex, Qoder, RooCode) can use the shortcuts shown. All other tools work with natural language requests to "create an OpenSpec proposal", "apply the OpenSpec change", or "archive the change".
+
+## Command Reference
+
+```bash
+openspec list               # View active change folders
+openspec view               # Interactive dashboard of specs and changes
+openspec show <change>      # Display change details (proposal, tasks, spec updates)
+openspec validate <change>  # Check spec formatting and structure
+openspec archive <change> [--yes|-y]   # Move a completed change into archive/ (non-interactive with --yes)
+```
+
+## Example: How AI Creates OpenSpec Files
+
+When you ask your AI assistant to "add two-factor authentication", it creates:
+
+```
+openspec/
+â”œâ”€â”€ specs/
+â”‚   â””â”€â”€ auth/
+â”‚       â””â”€â”€ spec.md           # Current auth spec (if exists)
+â””â”€â”€ changes/
+    â””â”€â”€ add-2fa/              # AI creates this entire structure
+        â”œâ”€â”€ proposal.md       # Why and what changes
+        â”œâ”€â”€ tasks.md          # Implementation checklist
+        â”œâ”€â”€ design.md         # Technical decisions (optional)
+        â””â”€â”€ specs/
+            â””â”€â”€ auth/
+                â””â”€â”€ spec.md   # Delta showing additions
+```
+
+### AI-Generated Spec (created in `openspec/specs/auth/spec.md`):
+
+```markdown
+# Auth Specification
+
+## Purpose
+Authentication and session management.
+
+## Requirements
+### Requirement: User Authentication
+The system SHALL issue a JWT on successful login.
+
+#### Scenario: Valid credentials
+- WHEN a user submits valid credentials
+- THEN a JWT is returned
+```
+
+### AI-Generated Change Delta (created in `openspec/changes/add-2fa/specs/auth/spec.md`):
+
+```markdown
+# Delta for Auth
+
+## ADDED Requirements
+### Requirement: Two-Factor Authentication
+The system MUST require a second factor during login.
+
+#### Scenario: OTP required
+- WHEN a user submits valid credentials
+- THEN an OTP challenge is required
+```
+
+### AI-Generated Tasks (created in `openspec/changes/add-2fa/tasks.md`):
+
+```markdown
+## 1. Database Setup
+- [ ] 1.1 Add OTP secret column to users table
+- [ ] 1.2 Create OTP verification logs table
+
+## 2. Backend Implementation  
+- [ ] 2.1 Add OTP generation endpoint
+- [ ] 2.2 Modify login flow to require OTP
+- [ ] 2.3 Add OTP verification endpoint
+
+## 3. Frontend Updates
+- [ ] 3.1 Create OTP input component
+- [ ] 3.2 Update login flow UI
+```
+
+**Important:** You don't create these files manually. Your AI assistant generates them based on your requirements and the existing codebase.
+
+## Understanding OpenSpec Files
+
+### Delta Format
+
+Deltas are "patches" that show how specs change:
+
+- **`## ADDED Requirements`** - New capabilities
+- **`## MODIFIED Requirements`** - Changed behavior (include complete updated text)
+- **`## REMOVED Requirements`** - Deprecated features
+
+**Format requirements:**
+- Use `### Requirement: <name>` for headers
+- Every requirement needs at least one `#### Scenario:` block
+- Use SHALL/MUST in requirement text
+
+## How OpenSpec Compares
+
+### vs. spec-kit
+OpenSpecâ€™s two-folder model (`openspec/specs/` for the current truth, `openspec/changes/` for proposed updates) keeps state and diffs separate. This scales when you modify existing features or touch multiple specs. spec-kit is strong for greenfield/0â†’1 but provides less structure for cross-spec updates and evolving features.
+
+### vs. Kiro.dev
+OpenSpec groups every change for a feature in one folder (`openspec/changes/feature-name/`), making it easy to track related specs, tasks, and designs together. Kiro spreads updates across multiple spec folders, which can make feature tracking harder.
+
+### vs. No Specs
+Without specs, AI coding assistants generate code from vague prompts, often missing requirements or adding unwanted features. OpenSpec brings predictability by agreeing on the desired behavior before any code is written.
+
+## Team Adoption
+
+1. **Initialize OpenSpec** â€“ Run `openspec init` in your repo.
+2. **Start with new features** â€“ Ask your AI to capture upcoming work as change proposals.
+3. **Grow incrementally** â€“ Each change archives into living specs that document your system.
+4. **Stay flexible** â€“ Different teammates can use Claude Code, CodeBuddy, Cursor, or any AGENTS.md-compatible tool while sharing the same specs.
+
+Run `openspec update` whenever someone switches tools so your agents pick up the latest instructions and slash-command bindings.
+
+## Updating OpenSpec
+
+1. **Upgrade the package**
+   ```bash
+   npm install -g @fission-ai/openspec@latest
+   ```
+2. **Refresh agent instructions**
+   - Run `openspec update` inside each project to regenerate AI guidance and ensure the latest slash commands are active.
+
+## Experimental Features
+
+<details>
+<summary><strong>ğŸ§ª OPSX: Fluid, Iterative Workflow</strong> (Claude Code only)</summary>
+
+**Why this exists:**
+- Standard workflow is locked down â€” you can't tweak instructions or customize
+- When AI output is bad, you can't improve the prompts yourself
+- Same workflow for everyone, no way to match how your team works
+
+**What's different:**
+- **Hackable** â€” edit templates and schemas yourself, test immediately, no rebuild
+- **Granular** â€” each artifact has its own instructions, test and tweak individually
+- **Customizable** â€” define your own workflows, artifacts, and dependencies
+- **Fluid** â€” no phase gates, update any artifact anytime
+
+```
+You can always go back:
+
+  proposal â”€â”€â†’ specs â”€â”€â†’ design â”€â”€â†’ tasks â”€â”€â†’ implement
+     â–²           â–²          â–²                    â”‚
+     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+```
+
+| Command | What it does |
+|---------|--------------|
+| `/opsx:new` | Start a new change |
+| `/opsx:continue` | Create the next artifact (based on what's ready) |
+| `/opsx:ff` | Fast-forward (all planning artifacts at once) |
+| `/opsx:apply` | Implement tasks, updating artifacts as needed |
+| `/opsx:archive` | Archive when done |
+
+**Setup:** `openspec experimental`
+
+[Full documentation â†’](docs/opsx.md)
+
+</details>
+
+<details>
+<summary><strong>Telemetry</strong> â€“ OpenSpec collects anonymous usage stats (opt-out: <code>OPENSPEC_TELEMETRY=0</code>)</summary>
+
+We collect only command names and version to understand usage patterns. No arguments, paths, content, or PII. Automatically disabled in CI.
+
+**Opt-out:** `export OPENSPEC_TELEMETRY=0` or `export DO_NOT_TRACK=1`
+
+</details>
+
+## Contributing
+
+- Install dependencies: `pnpm install`
+- Build: `pnpm run build`
+- Test: `pnpm test`
+- Develop CLI locally: `pnpm run dev` or `pnpm run dev:cli`
+- Conventional commits (one-line): `type(scope): subject`
+
+<details>
+<summary><strong>Maintainers & Advisors</strong></summary>
+
+See [MAINTAINERS.md](MAINTAINERS.md) for the list of core maintainers and advisors who help guide the project.
+
+</details>
+
+## License
+
+MIT
diff --git a/assets/openspec_bg.png b/assets/openspec_bg.png
new file mode 100644
index 0000000..423c2d3
Binary files /dev/null and b/assets/openspec_bg.png differ
diff --git a/docs/artifact_poc.md b/docs/artifact_poc.md
deleted file mode 100644
index 01dd009..0000000
--- a/docs/artifact_poc.md
+++ /dev/null
@@ -1,597 +0,0 @@
-# POC-OpenSpec-Core Analysis
-
----
-
-## Design Decisions & Terminology
-
-### Philosophy: Not a Workflow System
-
-This system is **not** a workflow engine. It's an **artifact tracker with dependency awareness**.
-
-| What it's NOT | What it IS |
-|---------------|------------|
-| Linear step-by-step progression | Exploratory, iterative planning |
-| Bureaucratic checkpoints | Enablers that unlock possibilities |
-| "You must complete step 1 first" | "Here's what you could create now" |
-| Form-filling | Fluid document creation |
-
-**Key insight:** Dependencies are *enablers*, not *gates*. You can't meaningfully write a design document if there's no proposal to design from - that's not bureaucracy, it's logic.
-
-### Terminology
-
-| Term | Definition | Example |
-|------|------------|---------|
-| **Change** | A unit of work being planned (feature, refactor, migration) | `openspec/changes/add-auth/` |
-| **Schema** | An artifact graph definition (what artifacts exist, their dependencies) | `spec-driven.yaml` |
-| **Artifact** | A node in the graph (a document to create) | `proposal`, `design`, `specs` |
-| **Template** | Instructions/guidance for creating an artifact | `templates/proposal.md` |
-
-### Hierarchy
-
-```
-Schema (defines) â”€â”€â†’ Artifacts (guided by) â”€â”€â†’ Templates
-```
-
-- **Schema** = the artifact graph (what exists, dependencies)
-- **Artifact** = a document to produce
-- **Template** = instructions for creating that artifact
-
-### Schema Variations
-
-Schemas can vary across multiple dimensions:
-
-| Dimension | Examples |
-|-----------|----------|
-| Philosophy | `spec-driven`, `tdd`, `prototype-first` |
-| Version | `v1`, `v2`, `v3` |
-| Language | `en`, `zh`, `es` |
-| Custom | `team-alpha`, `experimental` |
-
-### Schema Resolution (XDG Standard)
-
-Schemas follow the XDG Base Directory Specification with a 2-level resolution:
-
-```
-1. ${XDG_DATA_HOME}/openspec/schemas/<name>/schema.yaml   # Global user override
-2. <package>/schemas/<name>/schema.yaml                    # Built-in defaults
-```
-
-**Platform-specific paths:**
-- Unix/macOS: `~/.local/share/openspec/schemas/`
-- Windows: `%LOCALAPPDATA%/openspec/schemas/`
-- All platforms: `$XDG_DATA_HOME/openspec/schemas/` (when set)
-
-**Why XDG?**
-- Schemas are workflow definitions (data), not user preferences (config)
-- Built-ins baked into package, never auto-copied
-- Users customize by creating files in global data dir
-- Consistent with modern CLI tooling standards
-
-### Template Inheritance (2 Levels Max)
-
-Templates are co-located with schemas in a `templates/` subdirectory:
-
-```
-1. ${XDG_DATA_HOME}/openspec/schemas/<schema>/templates/<artifact>.md  # User override
-2. <package>/schemas/<schema>/templates/<artifact>.md                   # Built-in
-```
-
-**Rules:**
-- User overrides take precedence over package built-ins
-- A CLI command shows resolved paths (no guessing)
-- No inheritance between schemas (copy if you need to diverge)
-- Templates are always co-located with their schema
-
-**Why this matters:**
-- Avoids "where does this come from?" debugging
-- No implicit magic that works until it doesn't
-- Schema + templates form a cohesive unit
-
----
-
-## Executive Summary
-
-This is an **artifact tracker with dependency awareness** that guides iterative development through a structured artifact pipeline. The core innovation is using the **filesystem as a database** - artifact completion is detected by file existence, making the system stateless and version-control friendly.
-
-The system answers:
-- "What artifacts exist for this change?"
-- "What could I create next?" (not "what must I create")
-- "What's blocking X?" (informational, not prescriptive)
-
----
-
-## Core Components
-
-### 1. ArtifactGraph (Slice 1 - COMPLETE)
-
-The dependency graph engine with XDG-compliant schema resolution.
-
-| Responsibility | Approach |
-|----------------|----------|
-| Model artifacts as a DAG | Artifact with `requires: string[]` |
-| Track completion state | `Set<string>` for completed artifacts |
-| Calculate build order | Kahn's algorithm (topological sort) |
-| Find ready artifacts | Check if all dependencies are in `completed` set |
-| Resolve schemas | XDG global â†’ package built-ins |
-
-**Key Data Structures (Zod-validated):**
-
-```typescript
-// Zod schemas define types + validation
-const ArtifactSchema = z.object({
-  id: z.string().min(1),
-  generates: z.string().min(1),      // e.g., "proposal.md" or "specs/*.md"
-  description: z.string(),
-  template: z.string(),              // path to template file
-  requires: z.array(z.string()).default([]),
-});
-
-const SchemaYamlSchema = z.object({
-  name: z.string().min(1),
-  version: z.number().int().positive(),
-  description: z.string().optional(),
-  artifacts: z.array(ArtifactSchema).min(1),
-});
-
-// Derived types
-type Artifact = z.infer<typeof ArtifactSchema>;
-type SchemaYaml = z.infer<typeof SchemaYamlSchema>;
-```
-
-**Key Methods:**
-- `resolveSchema(name)` - Load schema with XDG fallback
-- `ArtifactGraph.fromSchema(schema)` - Build graph from schema
-- `detectState(graph, changeDir)` - Scan filesystem for completion
-- `getNextArtifacts(graph, completed)` - Find artifacts ready to create
-- `getBuildOrder(graph)` - Topological sort of all artifacts
-- `getBlocked(graph, completed)` - Artifacts with unmet dependencies
-
----
-
-### 2. Change Utilities (Slice 2)
-
-Simple utility functions for programmatic change creation. No class, no abstraction layer.
-
-| Responsibility | Approach |
-|----------------|----------|
-| Create changes | Create dirs under `openspec/changes/<name>/` with README |
-| Name validation | Enforce kebab-case naming |
-
-**Key Paths:**
-
-```
-openspec/changes/<name>/   â†’ Change instances with artifacts (project-level)
-```
-
-**Key Functions** (`src/utils/change-utils.ts`):
-- `createChange(projectRoot, name, description?)` - Create new change directory + README
-- `validateChangeName(name)` - Validate kebab-case naming, returns `{ valid, error? }`
-
-**Note:** Existing CLI commands (`ListCommand`, `ChangeCommand`) already handle listing, path resolution, and existence checks. No need to extract that logic - it works fine as-is.
-
----
-
-### 3. InstructionLoader (Slice 3)
-
-Template resolution and instruction enrichment.
-
-| Responsibility | Approach |
-|----------------|----------|
-| Resolve templates | XDG 2-level fallback (schema-specific â†’ shared â†’ built-in) |
-| Build dynamic context | Gather dependency status, change info |
-| Enrich templates | Inject context into base templates |
-| Generate status reports | Formatted markdown with progress |
-
-**Key Class - ChangeState:**
-
-```
-ChangeState {
-  changeName: string
-  changeDir: string
-  graph: ArtifactGraph
-  completed: Set<string>
-
-  // Methods
-  getNextSteps(): string[]
-  getStatus(artifactId): ArtifactStatus
-  isComplete(): boolean
-}
-```
-
-**Key Functions:**
-- `getTemplatePath(artifactId, schemaName?)` - Resolve with 2-level fallback
-- `getEnrichedInstructions(artifactId, projectRoot, changeName?)` - Main entry point
-- `getChangeStatus(projectRoot, changeName?)` - Formatted status report
-
----
-
-### 4. CLI (Slice 4)
-
-User interface layer. **All commands are deterministic** - require explicit `--change` parameter.
-
-| Command | Function | Status |
-|---------|----------|--------|
-| `status --change <id>` | Show change progress (artifact graph) | **NEW** |
-| `next --change <id>` | Show artifacts ready to create | **NEW** |
-| `instructions <artifact> --change <id>` | Get enriched instructions for artifact | **NEW** |
-| `list` | List all changes | EXISTS (`openspec change list`) |
-| `new <name>` | Create change | **NEW** (uses `createChange()`) |
-| `init` | Initialize structure | EXISTS (`openspec init`) |
-| `templates --change <id>` | Show resolved template paths | **NEW** |
-
-**Note:** Commands that operate on a change require `--change`. Missing parameter â†’ error with list of available changes. Agent infers the change from conversation and passes it explicitly.
-
-**Existing CLI commands** (not part of this slice):
-- `openspec change list` / `openspec change show <id>` / `openspec change validate <id>`
-- `openspec list --changes` / `openspec list --specs`
-- `openspec view` (dashboard)
-- `openspec init` / `openspec archive <change>`
-
----
-
-### 5. Claude Commands
-
-Integration layer for Claude Code. **Operational commands only** - artifact creation via natural language.
-
-| Command | Purpose |
-|---------|---------|
-| `/status` | Show change progress |
-| `/next` | Show what's ready to create |
-| `/run [artifact]` | Execute a specific step (power users) |
-| `/list` | List all changes |
-| `/new <name>` | Create a new change |
-| `/init` | Initialize structure |
-
-**Artifact creation:** Users say "create the proposal" or "write the tests" in natural language. The agent:
-1. Infers change from conversation (confirms if uncertain)
-2. Infers artifact from request
-3. Calls CLI with explicit `--change` parameter
-4. Creates artifact following instructions
-
-This works for ANY artifact in ANY schema - no new slash commands needed when schemas change.
-
-**Note:** Legacy commands (`/openspec-proposal`, `/openspec-apply`, `/openspec-archive`) exist in the main project for backward compatibility but are separate from this architecture.
-
----
-
-## Component Dependency Graph
-
-```
-â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-â”‚                     PRESENTATION LAYER                       â”‚
-â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
-â”‚  â”‚     CLI      â”‚ â†â”€shell execâ”€â”€â”€â”€â”€â”€â”€â”‚ Claude Commands    â”‚ â”‚
-â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
-â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-          â”‚ imports
-          â–¼
-â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-â”‚                    ORCHESTRATION LAYER                       â”‚
-â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
-â”‚  â”‚ InstructionLoader  â”‚        â”‚  change-utils (Slice 2)  â”‚ â”‚
-â”‚  â”‚    (Slice 3)       â”‚        â”‚  createChange()          â”‚ â”‚
-â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚  validateChangeName()    â”‚ â”‚
-â”‚            â”‚                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
-â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-             â”‚ uses
-             â–¼
-â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-â”‚                      CORE LAYER                              â”‚
-â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
-â”‚  â”‚               ArtifactGraph (Slice 1)                â”‚   â”‚
-â”‚  â”‚                                                      â”‚   â”‚
-â”‚  â”‚  Schema Resolution (XDG) â”€â”€â†’ Graph â”€â”€â†’ State Detectionâ”‚   â”‚
-â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
-â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-             â–²
-             â”‚ reads from
-             â–¼
-â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-â”‚                   PERSISTENCE LAYER                          â”‚
-â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
-â”‚  â”‚  XDG Schemas     â”‚   â”‚  Project Artifacts             â”‚  â”‚
-â”‚  â”‚  ~/.local/share/ â”‚   â”‚  openspec/changes/<name>/      â”‚  â”‚
-â”‚  â”‚  openspec/       â”‚   â”‚  - proposal.md, design.md      â”‚  â”‚
-â”‚  â”‚  schemas/        â”‚   â”‚  - specs/*.md, tasks.md        â”‚  â”‚
-â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
-â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-```
-
----
-
-## Key Design Patterns
-
-### 1. Filesystem as Database
-
-No SQLite, no JSON state files. The existence of `proposal.md` means proposal is complete.
-
-```
-// State detection is just file existence checking
-if (exists(artifactPath)) {
-  completed.add(artifactId)
-}
-```
-
-### 2. Deterministic CLI, Inferring Agent
-
-**CLI layer:** Always deterministic - requires explicit `--change` parameter.
-
-```
-openspec status --change add-auth     # explicit, works
-openspec status                        # error: "No change specified"
-```
-
-**Agent layer:** Infers from conversation, confirms if uncertain, passes explicit `--change`.
-
-This separation means:
-- CLI is pure, testable, no state to corrupt
-- Agent handles all "smartness"
-- No config.yaml tracking of "active change"
-
-### 3. XDG-Compliant Schema Resolution
-
-```
-${XDG_DATA_HOME}/openspec/schemas/<name>/schema.yaml   # User override
-    â†“ (not found)
-<package>/schemas/<name>/schema.yaml                    # Built-in
-    â†“ (not found)
-Error (schema not found)
-```
-
-### 4. Two-Level Template Fallback
-
-```
-${XDG_DATA_HOME}/openspec/schemas/<schema>/templates/<artifact>.md  # User override
-    â†“ (not found)
-<package>/schemas/<schema>/templates/<artifact>.md                   # Built-in
-    â†“ (not found)
-Error (no silent fallback to avoid confusion)
-```
-
-### 5. Glob Pattern Support
-
-`specs/*.md` allows multiple files to satisfy a single artifact:
-
-```
-if (artifact.generates.includes("*")) {
-  const parentDir = changeDir / patternParts[0]
-  if (exists(parentDir) && hasFiles(parentDir)) {
-    completed.add(artifactId)
-  }
-}
-```
-
-### 6. Stateless State Detection
-
-Every command re-scans the filesystem. No cached state to corrupt.
-
----
-
-## Artifact Pipeline (Default Schema)
-
-The default `spec-driven` schema:
-
-```
-â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-â”‚ proposal â”‚  (no dependencies)
-â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
-     â”‚
-     â–¼
-â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-â”‚  specs   â”‚  (requires: proposal)
-â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
-     â”‚
-     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-     â–¼              â–¼
-â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-â”‚  design  â”‚   â”‚          â”‚
-â”‚          â”‚â—„â”€â”€â”¤ proposal â”‚
-â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-     â”‚         (requires: proposal, specs)
-     â–¼
-â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-â”‚  tasks   â”‚  (requires: design)
-â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-```
-
-Other schemas (TDD, prototype-first) would have different graphs.
-
----
-
-## Implementation Order
-
-Structured as **vertical slices** - each slice is independently testable.
-
----
-
-### Slice 1: "What's Ready?" (Core Query) âœ… COMPLETE
-
-**Delivers:** Types + Graph + State Detection + Schema Resolution
-
-**Implementation:** `src/core/artifact-graph/`
-- `types.ts` - Zod schemas and derived TypeScript types
-- `schema.ts` - YAML parsing with Zod validation
-- `graph.ts` - ArtifactGraph class with topological sort
-- `state.ts` - Filesystem-based state detection
-- `resolver.ts` - XDG-compliant schema resolution
-- `builtin-schemas.ts` - Package-bundled default schemas
-
-**Key decisions made:**
-- Zod for schema validation (consistent with project)
-- XDG for global schema overrides
-- `Set<string>` for completion state (immutable, functional)
-- `inProgress` and `failed` states deferred (require external tracking)
-
----
-
-### Slice 2: "Change Creation Utilities"
-
-**Delivers:** Utility functions for programmatic change creation
-
-**Scope:**
-- `createChange(projectRoot, name, description?)` â†’ creates directory + README
-- `validateChangeName(name)` â†’ kebab-case pattern enforcement
-
-**Not in scope (already exists in CLI commands):**
-- `listChanges()` â†’ exists in `ListCommand` and `ChangeCommand.getActiveChanges()`
-- `getChangePath()` â†’ simple `path.join()` inline
-- `changeExists()` â†’ simple `fs.access()` inline
-- `isInitialized()` â†’ simple directory check inline
-
-**Why simplified:** Extracting existing CLI logic into a class would require similar refactoring of `SpecCommand` for consistency. The existing code works fine (~15 lines each). Only truly new functionality is `createChange()` + name validation.
-
----
-
-### Slice 3: "Get Instructions" (Enrichment)
-
-**Delivers:** Template resolution + context injection
-
-**Testable behaviors:**
-- Template fallback: schema-specific â†’ shared â†’ built-in â†’ error
-- Context injection: completed deps show âœ“, missing show âœ—
-- Output path shown correctly based on change directory
-
----
-
-### Slice 4: "CLI + Integration"
-
-**Delivers:** New artifact graph commands (builds on existing CLI)
-
-**New commands:**
-- `status --change <id>` - Show artifact completion state
-- `next --change <id>` - Show ready-to-create artifacts
-- `instructions <artifact> --change <id>` - Get enriched template
-- `templates --change <id>` - Show resolved paths
-- `new <name>` - Create change (wrapper for `createChange()`)
-
-**Already exists (not in scope):**
-- `openspec change list/show/validate` - change management
-- `openspec list --changes/--specs` - listing
-- `openspec view` - dashboard
-- `openspec init` - initialization
-
-**Testable behaviors:**
-- Each new command produces expected output
-- Commands compose correctly (status â†’ next â†’ instructions flow)
-- Error handling for missing changes, invalid artifacts, etc.
-
----
-
-## Directory Structure
-
-```
-# Global (XDG paths - user overrides)
-~/.local/share/openspec/           # Unix/macOS ($XDG_DATA_HOME/openspec/)
-%LOCALAPPDATA%/openspec/           # Windows
-â””â”€â”€ schemas/                       # Schema overrides
-    â””â”€â”€ custom-workflow/           # User-defined schema directory
-        â”œâ”€â”€ schema.yaml            # Schema definition
-        â””â”€â”€ templates/             # Co-located templates
-            â””â”€â”€ proposal.md
-
-# Package (built-in defaults)
-<package>/
-â””â”€â”€ schemas/                       # Built-in schema definitions
-    â”œâ”€â”€ spec-driven/               # Default: proposal â†’ specs â†’ design â†’ tasks
-    â”‚   â”œâ”€â”€ schema.yaml
-    â”‚   â””â”€â”€ templates/
-    â”‚       â”œâ”€â”€ proposal.md
-    â”‚       â”œâ”€â”€ design.md
-    â”‚       â”œâ”€â”€ spec.md
-    â”‚       â””â”€â”€ tasks.md
-    â””â”€â”€ tdd/                       # TDD: tests â†’ implementation â†’ docs
-        â”œâ”€â”€ schema.yaml
-        â””â”€â”€ templates/
-            â”œâ”€â”€ test.md
-            â”œâ”€â”€ implementation.md
-            â”œâ”€â”€ spec.md
-            â””â”€â”€ docs.md
-
-# Project (change instances)
-openspec/
-â””â”€â”€ changes/                       # Change instances
-    â”œâ”€â”€ add-auth/
-    â”‚   â”œâ”€â”€ README.md              # Auto-generated on creation
-    â”‚   â”œâ”€â”€ proposal.md            # Created artifacts
-    â”‚   â”œâ”€â”€ design.md
-    â”‚   â””â”€â”€ specs/
-    â”‚       â””â”€â”€ *.md
-    â”œâ”€â”€ refactor-db/
-    â”‚   â””â”€â”€ ...
-    â””â”€â”€ archive/                   # Completed changes
-        â””â”€â”€ 2025-01-01-add-auth/
-
-.claude/
-â”œâ”€â”€ settings.local.json            # Permissions
-â””â”€â”€ commands/                      # Slash commands
-    â””â”€â”€ *.md
-```
-
----
-
-## Schema YAML Format
-
-```yaml
-# Built-in: <package>/schemas/spec-driven/schema.yaml
-# Or user override: ~/.local/share/openspec/schemas/spec-driven/schema.yaml
-name: spec-driven
-version: 1
-description: Specification-driven development
-
-artifacts:
-  - id: proposal
-    generates: "proposal.md"
-    description: "Create project proposal document"
-    template: "proposal.md"          # resolves from co-located templates/ directory
-    requires: []
-
-  - id: specs
-    generates: "specs/*.md"          # glob pattern
-    description: "Create technical specification documents"
-    template: "specs.md"
-    requires:
-      - proposal
-
-  - id: design
-    generates: "design.md"
-    description: "Create design document"
-    template: "design.md"
-    requires:
-      - proposal
-      - specs
-
-  - id: tasks
-    generates: "tasks.md"
-    description: "Create tasks breakdown document"
-    template: "tasks.md"
-    requires:
-      - design
-```
-
----
-
-## Summary
-
-| Layer | Component | Responsibility | Status |
-|-------|-----------|----------------|--------|
-| Core | ArtifactGraph | Pure dependency logic + XDG schema resolution | âœ… Slice 1 COMPLETE |
-| Utils | change-utils | Change creation + name validation only | Slice 2 (new functionality only) |
-| Core | InstructionLoader | Template resolution + enrichment | Slice 3 (all new) |
-| Presentation | CLI | New artifact graph commands | Slice 4 (new commands only) |
-| Integration | Claude Commands | AI assistant glue | Slice 4 |
-
-**What already exists (not in this proposal):**
-- `getActiveChangeIds()` in `src/utils/item-discovery.ts` - list changes
-- `ChangeCommand.list/show/validate()` in `src/commands/change.ts`
-- `ListCommand.execute()` in `src/core/list.ts`
-- `ViewCommand.execute()` in `src/core/view.ts` - dashboard
-- `src/core/init.ts` - initialization
-- `src/core/archive.ts` - archiving
-
-**Key Principles:**
-- **Filesystem IS the database** - stateless, version-control friendly
-- **Dependencies are enablers** - show what's possible, don't force order
-- **Deterministic CLI, inferring agent** - CLI requires explicit `--change`, agent infers from context
-- **XDG-compliant paths** - schemas and templates use standard user data directories
-- **2-level inheritance** - user override â†’ package built-in (no deeper)
-- **Schemas are versioned** - support variations by philosophy, version, language
diff --git a/docs/cli.md b/docs/cli.md
new file mode 100644
index 0000000..e064e9d
--- /dev/null
+++ b/docs/cli.md
@@ -0,0 +1,894 @@
+# CLI Reference
+
+The OpenSpec CLI (`openspec`) provides terminal commands for project setup, validation, status inspection, and management. These commands complement the AI slash commands (like `/opsx:new`) documented in [Commands](commands.md).
+
+## Summary
+
+| Category | Commands | Purpose |
+|----------|----------|---------|
+| **Setup** | `init`, `update` | Initialize and update OpenSpec in your project |
+| **Browsing** | `list`, `view`, `show` | Explore changes and specs |
+| **Validation** | `validate` | Check changes and specs for issues |
+| **Lifecycle** | `archive` | Finalize completed changes |
+| **Workflow** | `status`, `instructions`, `templates`, `schemas` | Artifact-driven workflow support |
+| **Schemas** | `schema init`, `schema fork`, `schema validate`, `schema which` | Create and manage custom workflows |
+| **Config** | `config` | View and modify settings |
+| **Utility** | `feedback`, `completion` | Feedback and shell integration |
+
+---
+
+## Human vs Agent Commands
+
+Most CLI commands are designed for **human use** in a terminal. Some commands also support **agent/script use** via JSON output.
+
+### Human-Only Commands
+
+These commands are interactive and designed for terminal use:
+
+| Command | Purpose |
+|---------|---------|
+| `openspec init` | Initialize project (interactive prompts) |
+| `openspec view` | Interactive dashboard |
+| `openspec config edit` | Open config in editor |
+| `openspec feedback` | Submit feedback via GitHub |
+| `openspec completion install` | Install shell completions |
+
+### Agent-Compatible Commands
+
+These commands support `--json` output for programmatic use by AI agents and scripts:
+
+| Command | Human Use | Agent Use |
+|---------|-----------|-----------|
+| `openspec list` | Browse changes/specs | `--json` for structured data |
+| `openspec show <item>` | Read content | `--json` for parsing |
+| `openspec validate` | Check for issues | `--all --json` for bulk validation |
+| `openspec status` | See artifact progress | `--json` for structured status |
+| `openspec instructions` | Get next steps | `--json` for agent instructions |
+| `openspec templates` | Find template paths | `--json` for path resolution |
+| `openspec schemas` | List available schemas | `--json` for schema discovery |
+
+---
+
+## Global Options
+
+These options work with all commands:
+
+| Option | Description |
+|--------|-------------|
+| `--version`, `-V` | Show version number |
+| `--no-color` | Disable color output |
+| `--help`, `-h` | Display help for command |
+
+---
+
+## Setup Commands
+
+### `openspec init`
+
+Initialize OpenSpec in your project. Creates the folder structure and configures AI tool integrations.
+
+```
+openspec init [path] [options]
+```
+
+**Arguments:**
+
+| Argument | Required | Description |
+|----------|----------|-------------|
+| `path` | No | Target directory (default: current directory) |
+
+**Options:**
+
+| Option | Description |
+|--------|-------------|
+| `--tools <list>` | Configure AI tools non-interactively. Use `all`, `none`, or comma-separated list |
+| `--force` | Auto-cleanup legacy files without prompting |
+
+**Supported tools:** `amazon-q`, `antigravity`, `auggie`, `claude`, `cline`, `codex`, `codebuddy`, `continue`, `costrict`, `crush`, `cursor`, `factory`, `gemini`, `github-copilot`, `iflow`, `kilocode`, `opencode`, `qoder`, `qwen`, `roocode`, `windsurf`
+
+**Examples:**
+
+```bash
+# Interactive initialization
+openspec init
+
+# Initialize in a specific directory
+openspec init ./my-project
+
+# Non-interactive: configure for Claude and Cursor
+openspec init --tools claude,cursor
+
+# Configure for all supported tools
+openspec init --tools all
+
+# Skip prompts and auto-cleanup legacy files
+openspec init --force
+```
+
+**What it creates:**
+
+```
+openspec/
+â”œâ”€â”€ specs/              # Your specifications (source of truth)
+â”œâ”€â”€ changes/            # Proposed changes
+â””â”€â”€ config.yaml         # Project configuration
+
+.claude/skills/         # Claude Code skill files (if claude selected)
+.cursor/rules/          # Cursor rules (if cursor selected)
+... (other tool configs)
+```
+
+---
+
+### `openspec update`
+
+Update OpenSpec instruction files after upgrading the CLI. Re-generates AI tool configuration files.
+
+```
+openspec update [path] [options]
+```
+
+**Arguments:**
+
+| Argument | Required | Description |
+|----------|----------|-------------|
+| `path` | No | Target directory (default: current directory) |
+
+**Options:**
+
+| Option | Description |
+|--------|-------------|
+| `--force` | Force update even when files are up to date |
+
+**Example:**
+
+```bash
+# Update instruction files after npm upgrade
+npm update @fission-ai/openspec
+openspec update
+```
+
+---
+
+## Browsing Commands
+
+### `openspec list`
+
+List changes or specs in your project.
+
+```
+openspec list [options]
+```
+
+**Options:**
+
+| Option | Description |
+|--------|-------------|
+| `--specs` | List specs instead of changes |
+| `--changes` | List changes (default) |
+| `--sort <order>` | Sort by `recent` (default) or `name` |
+| `--json` | Output as JSON |
+
+**Examples:**
+
+```bash
+# List all active changes
+openspec list
+
+# List all specs
+openspec list --specs
+
+# JSON output for scripts
+openspec list --json
+```
+
+**Output (text):**
+
+```
+Active changes:
+  add-dark-mode     UI theme switching support
+  fix-login-bug     Session timeout handling
+```
+
+---
+
+### `openspec view`
+
+Display an interactive dashboard for exploring specs and changes.
+
+```
+openspec view
+```
+
+Opens a terminal-based interface for navigating your project's specifications and changes.
+
+---
+
+### `openspec show`
+
+Display details of a change or spec.
+
+```
+openspec show [item-name] [options]
+```
+
+**Arguments:**
+
+| Argument | Required | Description |
+|----------|----------|-------------|
+| `item-name` | No | Name of change or spec (prompts if omitted) |
+
+**Options:**
+
+| Option | Description |
+|--------|-------------|
+| `--type <type>` | Specify type: `change` or `spec` (auto-detected if unambiguous) |
+| `--json` | Output as JSON |
+| `--no-interactive` | Disable prompts |
+
+**Change-specific options:**
+
+| Option | Description |
+|--------|-------------|
+| `--deltas-only` | Show only delta specs (JSON mode) |
+
+**Spec-specific options:**
+
+| Option | Description |
+|--------|-------------|
+| `--requirements` | Show only requirements, exclude scenarios (JSON mode) |
+| `--no-scenarios` | Exclude scenario content (JSON mode) |
+| `-r, --requirement <id>` | Show specific requirement by 1-based index (JSON mode) |
+
+**Examples:**
+
+```bash
+# Interactive selection
+openspec show
+
+# Show a specific change
+openspec show add-dark-mode
+
+# Show a specific spec
+openspec show auth --type spec
+
+# JSON output for parsing
+openspec show add-dark-mode --json
+```
+
+---
+
+## Validation Commands
+
+### `openspec validate`
+
+Validate changes and specs for structural issues.
+
+```
+openspec validate [item-name] [options]
+```
+
+**Arguments:**
+
+| Argument | Required | Description |
+|----------|----------|-------------|
+| `item-name` | No | Specific item to validate (prompts if omitted) |
+
+**Options:**
+
+| Option | Description |
+|--------|-------------|
+| `--all` | Validate all changes and specs |
+| `--changes` | Validate all changes |
+| `--specs` | Validate all specs |
+| `--type <type>` | Specify type when name is ambiguous: `change` or `spec` |
+| `--strict` | Enable strict validation mode |
+| `--json` | Output as JSON |
+| `--concurrency <n>` | Max parallel validations (default: 6, or `OPENSPEC_CONCURRENCY` env) |
+| `--no-interactive` | Disable prompts |
+
+**Examples:**
+
+```bash
+# Interactive validation
+openspec validate
+
+# Validate a specific change
+openspec validate add-dark-mode
+
+# Validate all changes
+openspec validate --changes
+
+# Validate everything with JSON output (for CI/scripts)
+openspec validate --all --json
+
+# Strict validation with increased parallelism
+openspec validate --all --strict --concurrency 12
+```
+
+**Output (text):**
+
+```
+Validating add-dark-mode...
+  âœ“ proposal.md valid
+  âœ“ specs/ui/spec.md valid
+  âš  design.md: missing "Technical Approach" section
+
+1 warning found
+```
+
+**Output (JSON):**
+
+```json
+{
+  "version": "1.0.0",
+  "results": {
+    "changes": [
+      {
+        "name": "add-dark-mode",
+        "valid": true,
+        "warnings": ["design.md: missing 'Technical Approach' section"]
+      }
+    ]
+  },
+  "summary": {
+    "total": 1,
+    "valid": 1,
+    "invalid": 0
+  }
+}
+```
+
+---
+
+## Lifecycle Commands
+
+### `openspec archive`
+
+Archive a completed change and merge delta specs into main specs.
+
+```
+openspec archive [change-name] [options]
+```
+
+**Arguments:**
+
+| Argument | Required | Description |
+|----------|----------|-------------|
+| `change-name` | No | Change to archive (prompts if omitted) |
+
+**Options:**
+
+| Option | Description |
+|--------|-------------|
+| `-y, --yes` | Skip confirmation prompts |
+| `--skip-specs` | Skip spec updates (for infrastructure/tooling/doc-only changes) |
+| `--no-validate` | Skip validation (requires confirmation) |
+
+**Examples:**
+
+```bash
+# Interactive archive
+openspec archive
+
+# Archive specific change
+openspec archive add-dark-mode
+
+# Archive without prompts (CI/scripts)
+openspec archive add-dark-mode --yes
+
+# Archive a tooling change that doesn't affect specs
+openspec archive update-ci-config --skip-specs
+```
+
+**What it does:**
+
+1. Validates the change (unless `--no-validate`)
+2. Prompts for confirmation (unless `--yes`)
+3. Merges delta specs into `openspec/specs/`
+4. Moves change folder to `openspec/changes/archive/YYYY-MM-DD-<name>/`
+
+---
+
+## Workflow Commands
+
+These commands support the artifact-driven OPSX workflow. They're useful for both humans checking progress and agents determining next steps.
+
+### `openspec status`
+
+Display artifact completion status for a change.
+
+```
+openspec status [options]
+```
+
+**Options:**
+
+| Option | Description |
+|--------|-------------|
+| `--change <id>` | Change name (prompts if omitted) |
+| `--schema <name>` | Schema override (auto-detected from change's config) |
+| `--json` | Output as JSON |
+
+**Examples:**
+
+```bash
+# Interactive status check
+openspec status
+
+# Status for specific change
+openspec status --change add-dark-mode
+
+# JSON for agent use
+openspec status --change add-dark-mode --json
+```
+
+**Output (text):**
+
+```
+Change: add-dark-mode
+Schema: spec-driven
+
+Artifacts:
+  âœ“ proposal     proposal.md exists
+  âœ“ specs        specs/ exists
+  â—† design       ready (requires: specs)
+  â—‹ tasks        blocked (requires: design)
+
+Next: Create design using /opsx:continue
+```
+
+**Output (JSON):**
+
+```json
+{
+  "change": "add-dark-mode",
+  "schema": "spec-driven",
+  "artifacts": [
+    {"id": "proposal", "status": "complete", "path": "proposal.md"},
+    {"id": "specs", "status": "complete", "path": "specs/"},
+    {"id": "design", "status": "ready", "requires": ["specs"]},
+    {"id": "tasks", "status": "blocked", "requires": ["design"]}
+  ],
+  "next": "design"
+}
+```
+
+---
+
+### `openspec instructions`
+
+Get enriched instructions for creating an artifact or applying tasks. Used by AI agents to understand what to create next.
+
+```
+openspec instructions [artifact] [options]
+```
+
+**Arguments:**
+
+| Argument | Required | Description |
+|----------|----------|-------------|
+| `artifact` | No | Artifact ID: `proposal`, `specs`, `design`, `tasks`, or `apply` |
+
+**Options:**
+
+| Option | Description |
+|--------|-------------|
+| `--change <id>` | Change name (required in non-interactive mode) |
+| `--schema <name>` | Schema override |
+| `--json` | Output as JSON |
+
+**Special case:** Use `apply` as the artifact to get task implementation instructions.
+
+**Examples:**
+
+```bash
+# Get instructions for next artifact
+openspec instructions --change add-dark-mode
+
+# Get specific artifact instructions
+openspec instructions design --change add-dark-mode
+
+# Get apply/implementation instructions
+openspec instructions apply --change add-dark-mode
+
+# JSON for agent consumption
+openspec instructions design --change add-dark-mode --json
+```
+
+**Output includes:**
+
+- Template content for the artifact
+- Project context from config
+- Content from dependency artifacts
+- Per-artifact rules from config
+
+---
+
+### `openspec templates`
+
+Show resolved template paths for all artifacts in a schema.
+
+```
+openspec templates [options]
+```
+
+**Options:**
+
+| Option | Description |
+|--------|-------------|
+| `--schema <name>` | Schema to inspect (default: `spec-driven`) |
+| `--json` | Output as JSON |
+
+**Examples:**
+
+```bash
+# Show template paths for default schema
+openspec templates
+
+# Show templates for custom schema
+openspec templates --schema my-workflow
+
+# JSON for programmatic use
+openspec templates --json
+```
+
+**Output (text):**
+
+```
+Schema: spec-driven
+
+Templates:
+  proposal  â†’ ~/.openspec/schemas/spec-driven/templates/proposal.md
+  specs     â†’ ~/.openspec/schemas/spec-driven/templates/specs.md
+  design    â†’ ~/.openspec/schemas/spec-driven/templates/design.md
+  tasks     â†’ ~/.openspec/schemas/spec-driven/templates/tasks.md
+```
+
+---
+
+### `openspec schemas`
+
+List available workflow schemas with their descriptions and artifact flows.
+
+```
+openspec schemas [options]
+```
+
+**Options:**
+
+| Option | Description |
+|--------|-------------|
+| `--json` | Output as JSON |
+
+**Example:**
+
+```bash
+openspec schemas
+```
+
+**Output:**
+
+```
+Available schemas:
+
+  spec-driven (package)
+    The default spec-driven development workflow
+    Flow: proposal â†’ specs â†’ design â†’ tasks
+
+  my-custom (project)
+    Custom workflow for this project
+    Flow: research â†’ proposal â†’ tasks
+```
+
+---
+
+## Schema Commands
+
+Commands for creating and managing custom workflow schemas.
+
+### `openspec schema init`
+
+Create a new project-local schema.
+
+```
+openspec schema init <name> [options]
+```
+
+**Arguments:**
+
+| Argument | Required | Description |
+|----------|----------|-------------|
+| `name` | Yes | Schema name (kebab-case) |
+
+**Options:**
+
+| Option | Description |
+|--------|-------------|
+| `--description <text>` | Schema description |
+| `--artifacts <list>` | Comma-separated artifact IDs (default: `proposal,specs,design,tasks`) |
+| `--default` | Set as project default schema |
+| `--no-default` | Don't prompt to set as default |
+| `--force` | Overwrite existing schema |
+| `--json` | Output as JSON |
+
+**Examples:**
+
+```bash
+# Interactive schema creation
+openspec schema init research-first
+
+# Non-interactive with specific artifacts
+openspec schema init rapid \
+  --description "Rapid iteration workflow" \
+  --artifacts "proposal,tasks" \
+  --default
+```
+
+**What it creates:**
+
+```
+openspec/schemas/<name>/
+â”œâ”€â”€ schema.yaml           # Schema definition
+â””â”€â”€ templates/
+    â”œâ”€â”€ proposal.md       # Template for each artifact
+    â”œâ”€â”€ specs.md
+    â”œâ”€â”€ design.md
+    â””â”€â”€ tasks.md
+```
+
+---
+
+### `openspec schema fork`
+
+Copy an existing schema to your project for customization.
+
+```
+openspec schema fork <source> [name] [options]
+```
+
+**Arguments:**
+
+| Argument | Required | Description |
+|----------|----------|-------------|
+| `source` | Yes | Schema to copy |
+| `name` | No | New schema name (default: `<source>-custom`) |
+
+**Options:**
+
+| Option | Description |
+|--------|-------------|
+| `--force` | Overwrite existing destination |
+| `--json` | Output as JSON |
+
+**Example:**
+
+```bash
+# Fork the built-in spec-driven schema
+openspec schema fork spec-driven my-workflow
+```
+
+---
+
+### `openspec schema validate`
+
+Validate a schema's structure and templates.
+
+```
+openspec schema validate [name] [options]
+```
+
+**Arguments:**
+
+| Argument | Required | Description |
+|----------|----------|-------------|
+| `name` | No | Schema to validate (validates all if omitted) |
+
+**Options:**
+
+| Option | Description |
+|--------|-------------|
+| `--verbose` | Show detailed validation steps |
+| `--json` | Output as JSON |
+
+**Example:**
+
+```bash
+# Validate a specific schema
+openspec schema validate my-workflow
+
+# Validate all schemas
+openspec schema validate
+```
+
+---
+
+### `openspec schema which`
+
+Show where a schema resolves from (useful for debugging precedence).
+
+```
+openspec schema which [name] [options]
+```
+
+**Arguments:**
+
+| Argument | Required | Description |
+|----------|----------|-------------|
+| `name` | No | Schema name |
+
+**Options:**
+
+| Option | Description |
+|--------|-------------|
+| `--all` | List all schemas with their sources |
+| `--json` | Output as JSON |
+
+**Example:**
+
+```bash
+# Check where a schema comes from
+openspec schema which spec-driven
+```
+
+**Output:**
+
+```
+spec-driven resolves from: package
+  Source: /usr/local/lib/node_modules/@fission-ai/openspec/schemas/spec-driven
+```
+
+**Schema precedence:**
+
+1. Project: `openspec/schemas/<name>/`
+2. User: `~/.local/share/openspec/schemas/<name>/`
+3. Package: Built-in schemas
+
+---
+
+## Configuration Commands
+
+### `openspec config`
+
+View and modify global OpenSpec configuration.
+
+```
+openspec config <subcommand> [options]
+```
+
+**Subcommands:**
+
+| Subcommand | Description |
+|------------|-------------|
+| `path` | Show config file location |
+| `list` | Show all current settings |
+| `get <key>` | Get a specific value |
+| `set <key> <value>` | Set a value |
+| `unset <key>` | Remove a key |
+| `reset` | Reset to defaults |
+| `edit` | Open in `$EDITOR` |
+
+**Examples:**
+
+```bash
+# Show config file path
+openspec config path
+
+# List all settings
+openspec config list
+
+# Get a specific value
+openspec config get telemetry.enabled
+
+# Set a value
+openspec config set telemetry.enabled false
+
+# Set a string value explicitly
+openspec config set user.name "My Name" --string
+
+# Remove a custom setting
+openspec config unset user.name
+
+# Reset all configuration
+openspec config reset --all --yes
+
+# Edit config in your editor
+openspec config edit
+```
+
+---
+
+## Utility Commands
+
+### `openspec feedback`
+
+Submit feedback about OpenSpec. Creates a GitHub issue.
+
+```
+openspec feedback <message> [options]
+```
+
+**Arguments:**
+
+| Argument | Required | Description |
+|----------|----------|-------------|
+| `message` | Yes | Feedback message |
+
+**Options:**
+
+| Option | Description |
+|--------|-------------|
+| `--body <text>` | Detailed description |
+
+**Requirements:** GitHub CLI (`gh`) must be installed and authenticated.
+
+**Example:**
+
+```bash
+openspec feedback "Add support for custom artifact types" \
+  --body "I'd like to define my own artifact types beyond the built-in ones."
+```
+
+---
+
+### `openspec completion`
+
+Manage shell completions for the OpenSpec CLI.
+
+```
+openspec completion <subcommand> [shell]
+```
+
+**Subcommands:**
+
+| Subcommand | Description |
+|------------|-------------|
+| `generate [shell]` | Output completion script to stdout |
+| `install [shell]` | Install completion for your shell |
+| `uninstall [shell]` | Remove installed completions |
+
+**Supported shells:** `bash`, `zsh`, `fish`, `powershell`
+
+**Examples:**
+
+```bash
+# Install completions (auto-detects shell)
+openspec completion install
+
+# Install for specific shell
+openspec completion install zsh
+
+# Generate script for manual installation
+openspec completion generate bash > ~/.bash_completion.d/openspec
+
+# Uninstall
+openspec completion uninstall
+```
+
+---
+
+## Exit Codes
+
+| Code | Meaning |
+|------|---------|
+| `0` | Success |
+| `1` | Error (validation failure, missing files, etc.) |
+
+---
+
+## Environment Variables
+
+| Variable | Description |
+|----------|-------------|
+| `OPENSPEC_CONCURRENCY` | Default concurrency for bulk validation (default: 6) |
+| `EDITOR` or `VISUAL` | Editor for `openspec config edit` |
+| `NO_COLOR` | Disable color output when set |
+
+---
+
+## Related Documentation
+
+- [Commands](commands.md) - AI slash commands (`/opsx:new`, `/opsx:apply`, etc.)
+- [Workflows](workflows.md) - Common patterns and when to use each command
+- [Customization](customization.md) - Create custom schemas and templates
+- [Getting Started](getting-started.md) - First-time setup guide
diff --git a/docs/commands.md b/docs/commands.md
new file mode 100644
index 0000000..6974aaa
--- /dev/null
+++ b/docs/commands.md
@@ -0,0 +1,652 @@
+# Commands
+
+This is the reference for OpenSpec's slash commands. These commands are invoked in your AI coding assistant's chat interface (e.g., Claude Code, Cursor, Windsurf).
+
+For workflow patterns and when to use each command, see [Workflows](workflows.md). For CLI commands, see [CLI](cli.md).
+
+## Quick Reference
+
+| Command | Purpose |
+|---------|---------|
+| `/opsx:explore` | Think through ideas before committing to a change |
+| `/opsx:new` | Start a new change |
+| `/opsx:continue` | Create the next artifact based on dependencies |
+| `/opsx:ff` | Fast-forward: create all planning artifacts at once |
+| `/opsx:apply` | Implement tasks from the change |
+| `/opsx:verify` | Validate implementation matches artifacts |
+| `/opsx:sync` | Merge delta specs into main specs |
+| `/opsx:archive` | Archive a completed change |
+| `/opsx:bulk-archive` | Archive multiple changes at once |
+| `/opsx:onboard` | Guided tutorial through the complete workflow |
+
+---
+
+## Command Reference
+
+### `/opsx:explore`
+
+Think through ideas, investigate problems, and clarify requirements before committing to a change.
+
+**Syntax:**
+```
+/opsx:explore [topic]
+```
+
+**Arguments:**
+| Argument | Required | Description |
+|----------|----------|-------------|
+| `topic` | No | What you want to explore or investigate |
+
+**What it does:**
+- Opens an exploratory conversation with no structure required
+- Investigates the codebase to answer questions
+- Compares options and approaches
+- Creates visual diagrams to clarify thinking
+- Can transition to `/opsx:new` when insights crystallize
+
+**Example:**
+```text
+You: /opsx:explore
+
+AI:  What would you like to explore?
+
+You: How should we handle authentication for the mobile app?
+
+AI:  Let me investigate your current auth setup...
+     [Analyzes codebase]
+
+     I see you're using session-based auth for the web app.
+     For mobile, we have three main options:
+
+     1. JWT tokens (stateless, works offline)
+     2. OAuth2 (if you need third-party login)
+     3. Extend current sessions (simpler, but requires connectivity)
+
+     Your API already has CORS configured. Which direction interests you?
+
+You: Let's go with JWT. Can we start a change for that?
+
+AI:  Ready when you are. Run /opsx:new add-jwt-auth to begin.
+```
+
+**Tips:**
+- Use when requirements are unclear or you need to investigate
+- No artifacts are created during exploration
+- Good for comparing multiple approaches before deciding
+- Can read files and search the codebase
+
+---
+
+### `/opsx:new`
+
+Start a new change. Creates the change folder structure and scaffolds it with the selected schema.
+
+**Syntax:**
+```
+/opsx:new [change-name] [--schema <schema-name>]
+```
+
+**Arguments:**
+| Argument | Required | Description |
+|----------|----------|-------------|
+| `change-name` | No | Name for the change folder (prompted if not provided) |
+| `--schema` | No | Workflow schema to use (default: from config or `spec-driven`) |
+
+**What it does:**
+- Creates `openspec/changes/<change-name>/` directory
+- Creates `.openspec.yaml` metadata file in the change folder
+- Shows the first artifact template ready for creation
+- Prompts for change name and schema if not provided
+
+**What it creates:**
+```
+openspec/changes/<change-name>/
+â””â”€â”€ .openspec.yaml    # Change metadata (schema, created date)
+```
+
+**Example:**
+```
+You: /opsx:new add-dark-mode
+
+AI:  Created openspec/changes/add-dark-mode/
+     Schema: spec-driven
+
+     Ready to create: proposal
+     Use /opsx:continue to create it, or /opsx:ff to create all artifacts.
+```
+
+**Tips:**
+- Use descriptive names: `add-feature`, `fix-bug`, `refactor-module`
+- Avoid generic names like `update`, `changes`, `wip`
+- Schema can also be set in project config (`openspec/config.yaml`)
+
+---
+
+### `/opsx:continue`
+
+Create the next artifact in the dependency chain. Creates one artifact at a time for incremental progress.
+
+**Syntax:**
+```
+/opsx:continue [change-name]
+```
+
+**Arguments:**
+| Argument | Required | Description |
+|----------|----------|-------------|
+| `change-name` | No | Which change to continue (inferred from context if not provided) |
+
+**What it does:**
+- Queries the artifact dependency graph
+- Shows which artifacts are ready vs blocked
+- Creates the first ready artifact
+- Reads dependency files for context
+- Shows what becomes available after creation
+
+**Example:**
+```
+You: /opsx:continue
+
+AI:  Change: add-dark-mode
+
+     Artifact status:
+     âœ“ proposal    (done)
+     â—† specs       (ready)
+     â—† design      (ready)
+     â—‹ tasks       (blocked - needs: specs)
+
+     Creating specs...
+
+     [Reads proposal.md, creates specs based on requirements]
+
+     âœ“ Created openspec/changes/add-dark-mode/specs/ui/spec.md
+
+     Now available: tasks
+     Run /opsx:continue to create the next artifact.
+```
+
+**Tips:**
+- Use when you want to review each artifact before proceeding
+- Good for complex changes where you want control
+- Multiple artifacts may become ready simultaneously
+- You can edit created artifacts before continuing
+
+---
+
+### `/opsx:ff`
+
+Fast-forward through artifact creation. Creates all planning artifacts at once.
+
+**Syntax:**
+```
+/opsx:ff [change-name]
+```
+
+**Arguments:**
+| Argument | Required | Description |
+|----------|----------|-------------|
+| `change-name` | No | Which change to fast-forward (inferred from context if not provided) |
+
+**What it does:**
+- Creates all artifacts in dependency order
+- Tracks progress via todo list
+- Stops when all `apply-required` artifacts are complete
+- Reads each dependency before creating the next artifact
+
+**Example:**
+```
+You: /opsx:ff add-dark-mode
+
+AI:  Fast-forwarding add-dark-mode...
+
+     âœ“ Creating proposal.md
+     âœ“ Creating specs/ui/spec.md
+     âœ“ Creating design.md
+     âœ“ Creating tasks.md
+
+     All planning artifacts complete!
+     Ready for implementation. Run /opsx:apply to begin.
+```
+
+**Tips:**
+- Use when you have a clear picture of what you're building
+- Faster than `/opsx:continue` for straightforward changes
+- You can still edit artifacts afterward
+- Good for small to medium features
+
+---
+
+### `/opsx:apply`
+
+Implement tasks from the change. Works through the task list, writing code and checking off items.
+
+**Syntax:**
+```
+/opsx:apply [change-name]
+```
+
+**Arguments:**
+| Argument | Required | Description |
+|----------|----------|-------------|
+| `change-name` | No | Which change to implement (inferred from context if not provided) |
+
+**What it does:**
+- Reads `tasks.md` and identifies incomplete tasks
+- Works through tasks one by one
+- Writes code, creates files, runs tests as needed
+- Marks tasks complete with checkboxes `[x]`
+
+**Example:**
+```
+You: /opsx:apply
+
+AI:  Implementing add-dark-mode...
+
+     Reading tasks.md:
+     - [ ] 1.1 Create ThemeContext
+     - [ ] 1.2 Add CSS custom properties
+     - [ ] 1.3 Implement localStorage persistence
+
+     Working on 1.1: Create ThemeContext...
+     [Creates src/context/ThemeContext.tsx]
+
+     âœ“ 1.1 Complete
+
+     Working on 1.2: Add CSS custom properties...
+     [Updates src/styles/globals.css]
+
+     âœ“ 1.2 Complete
+     ...
+```
+
+**Tips:**
+- Can resume where you left off if interrupted
+- Use for parallel changes by specifying the change name
+- Completion state is tracked in `tasks.md` checkboxes
+
+---
+
+### `/opsx:verify`
+
+Validate that implementation matches your change artifacts. Checks completeness, correctness, and coherence.
+
+**Syntax:**
+```
+/opsx:verify [change-name]
+```
+
+**Arguments:**
+| Argument | Required | Description |
+|----------|----------|-------------|
+| `change-name` | No | Which change to verify (inferred from context if not provided) |
+
+**What it does:**
+- Checks three dimensions of implementation quality
+- Searches codebase for implementation evidence
+- Reports issues categorized as CRITICAL, WARNING, or SUGGESTION
+- Does not block archive, but surfaces issues
+
+**Verification dimensions:**
+
+| Dimension | What it validates |
+|-----------|-------------------|
+| **Completeness** | All tasks done, all requirements implemented, scenarios covered |
+| **Correctness** | Implementation matches spec intent, edge cases handled |
+| **Coherence** | Design decisions reflected in code, patterns consistent |
+
+**Example:**
+```
+You: /opsx:verify
+
+AI:  Verifying add-dark-mode...
+
+     COMPLETENESS
+     âœ“ All 8 tasks in tasks.md are checked
+     âœ“ All requirements in specs have corresponding code
+     âš  Scenario "System preference detection" has no test coverage
+
+     CORRECTNESS
+     âœ“ Implementation matches spec intent
+     âœ“ Edge cases from scenarios are handled
+     âœ“ Error states match spec definitions
+
+     COHERENCE
+     âœ“ Design decisions reflected in code structure
+     âœ“ Naming conventions consistent with design.md
+     âš  Design mentions "CSS variables" but implementation uses Tailwind classes
+
+     SUMMARY
+     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+     Critical issues: 0
+     Warnings: 2
+     Ready to archive: Yes (with warnings)
+
+     Recommendations:
+     1. Add test for system preference detection
+     2. Update design.md to reflect Tailwind usage, or refactor to use CSS variables
+```
+
+**Tips:**
+- Run before archiving to catch mismatches early
+- Warnings don't block archive but indicate potential issues
+- Good for reviewing AI's work before committing
+- Can reveal drift between artifacts and implementation
+
+---
+
+### `/opsx:sync`
+
+**Optional command.** Merge delta specs from a change into main specs. Archive will prompt to sync if needed, so you typically don't need to run this manually.
+
+**Syntax:**
+```
+/opsx:sync [change-name]
+```
+
+**Arguments:**
+| Argument | Required | Description |
+|----------|----------|-------------|
+| `change-name` | No | Which change to sync (inferred from context if not provided) |
+
+**What it does:**
+- Reads delta specs from change folder
+- Parses ADDED/MODIFIED/REMOVED/RENAMED sections
+- Merges changes into main `openspec/specs/` directory
+- Preserves existing content not mentioned in delta
+- Does not archive the change (remains active)
+
+**Example:**
+```text
+You: /opsx:sync
+
+AI:  Syncing add-dark-mode delta specs...
+
+     Reading: openspec/changes/add-dark-mode/specs/ui/spec.md
+     Target:  openspec/specs/ui/spec.md
+
+     Changes to apply:
+     âœ“ ADDED: Theme Selection requirement (2 scenarios)
+     âœ“ ADDED: Accessibility requirement (1 scenario)
+
+     Merging...
+     âœ“ openspec/specs/ui/spec.md updated
+
+     Change remains active. Run /opsx:archive when ready to complete.
+```
+
+**When to use manually:**
+
+| Scenario | Use sync? |
+|----------|-----------|
+| Long-running change, want specs in main before archiving | Yes |
+| Multiple parallel changes need the updated base specs | Yes |
+| Want to preview/review the merge separately | Yes |
+| Quick change, going straight to archive | No (archive handles it) |
+
+**Tips:**
+- Sync is intelligent, not copy-paste
+- Can add scenarios to existing requirements without duplicating
+- Change stays active after sync (not archived)
+- Most users will never need to call this directlyâ€”archive prompts if needed
+
+---
+
+### `/opsx:archive`
+
+Archive a completed change. Finalizes the change and moves it to the archive folder.
+
+**Syntax:**
+```
+/opsx:archive [change-name]
+```
+
+**Arguments:**
+| Argument | Required | Description |
+|----------|----------|-------------|
+| `change-name` | No | Which change to archive (inferred from context if not provided) |
+
+**What it does:**
+- Checks artifact completion status
+- Checks task completion (warns if incomplete)
+- Offers to sync delta specs if not already synced
+- Moves change folder to `openspec/changes/archive/YYYY-MM-DD-<name>/`
+- Preserves all artifacts for audit trail
+
+**Example:**
+```text
+You: /opsx:archive
+
+AI:  Archiving add-dark-mode...
+
+     Artifact status:
+     âœ“ proposal.md exists
+     âœ“ specs/ exists
+     âœ“ design.md exists
+     âœ“ tasks.md exists (8/8 tasks complete)
+
+     Delta specs: Not yet synced
+     â†’ Sync now? (recommended)
+
+You: Yes
+
+AI:  âœ“ Synced specs to openspec/specs/ui/spec.md
+     âœ“ Moved to openspec/changes/archive/2025-01-24-add-dark-mode/
+
+     Change archived successfully.
+```
+
+**Tips:**
+- Archive won't block on incomplete tasks, but will warn
+- Delta specs can be synced during archive or beforehand
+- Archived changes are preserved for history
+- Use `/opsx:verify` first to catch issues
+
+---
+
+### `/opsx:bulk-archive`
+
+Archive multiple completed changes at once. Handles spec conflicts between changes.
+
+**Syntax:**
+```
+/opsx:bulk-archive [change-names...]
+```
+
+**Arguments:**
+| Argument | Required | Description |
+|----------|----------|-------------|
+| `change-names` | No | Specific changes to archive (prompts to select if not provided) |
+
+**What it does:**
+- Lists all completed changes
+- Validates each change before archiving
+- Detects spec conflicts across changes
+- Resolves conflicts by checking what's actually implemented
+- Archives in chronological order
+
+**Example:**
+```
+You: /opsx:bulk-archive
+
+AI:  Found 3 completed changes:
+     - add-dark-mode (8/8 tasks complete)
+     - fix-login-bug (3/3 tasks complete)
+     - update-footer (2/2 tasks complete)
+
+     Checking for spec conflicts...
+     âš  add-dark-mode and update-footer both touch specs/ui/
+
+     Inspecting codebase to resolve...
+     Both changes are implemented. Will merge in chronological order:
+     1. add-dark-mode (created Jan 20)
+     2. update-footer (created Jan 22)
+
+     Archive all 3 changes?
+
+You: Yes
+
+AI:  âœ“ Archived add-dark-mode
+     âœ“ Archived fix-login-bug
+     âœ“ Archived update-footer
+     Specs merged: add-dark-mode â†’ update-footer
+```
+
+**Tips:**
+- Good for parallel work streams
+- Conflict resolution is agentic (checks codebase)
+- Changes are archived in order of creation
+- Prompts before overwriting spec content
+
+---
+
+### `/opsx:onboard`
+
+Guided onboarding through the complete OpenSpec workflow. An interactive tutorial using your actual codebase.
+
+**Syntax:**
+```
+/opsx:onboard
+```
+
+**What it does:**
+- Walks through a complete workflow cycle with narration
+- Scans your codebase for real improvement opportunities
+- Creates an actual change with real artifacts
+- Implements actual work (small, safe changes)
+- Archives the completed change
+- Explains each step as it happens
+
+**Phases:**
+1. Welcome and codebase analysis
+2. Finding an improvement opportunity
+3. Creating a change (`/opsx:new`)
+4. Writing the proposal
+5. Creating specs
+6. Writing the design
+7. Creating tasks
+8. Implementing tasks (`/opsx:apply`)
+9. Verifying implementation
+10. Archiving the change
+11. Summary and next steps
+
+**Example:**
+```
+You: /opsx:onboard
+
+AI:  Welcome to OpenSpec!
+
+     I'll walk you through the complete workflow using your actual codebase.
+     We'll find something small to improve, create a proper change for it,
+     implement it, and archive it.
+
+     Let me scan your codebase for opportunities...
+
+     [Analyzes codebase]
+
+     I found a few things we could work on:
+     1. Add input validation to the contact form
+     2. Improve error messages in the auth flow
+     3. Add loading states to async buttons
+
+     Which interests you? (or suggest something else)
+```
+
+**Tips:**
+- Best for new users learning the workflow
+- Uses real code, not toy examples
+- Creates a real change you can keep or discard
+- Takes 15-30 minutes to complete
+
+---
+
+## Command Syntax by AI Tool
+
+Different AI tools use slightly different command syntax. Use the format that matches your tool:
+
+| Tool | Syntax Example |
+|------|----------------|
+| Claude Code | `/opsx:new`, `/opsx:apply` |
+| Cursor | `/opsx-new`, `/opsx-apply` |
+| Windsurf | `/opsx-new`, `/opsx-apply` |
+| Copilot | `/opsx-new`, `/opsx-apply` |
+
+The functionality is identical regardless of syntax.
+
+---
+
+## Legacy Commands
+
+These commands use the older "all-at-once" workflow. They still work but OPSX commands are recommended.
+
+| Command | What it does |
+|---------|--------------|
+| `/openspec:proposal` | Create all artifacts at once (proposal, specs, design, tasks) |
+| `/openspec:apply` | Implement the change |
+| `/openspec:archive` | Archive the change |
+
+**When to use legacy commands:**
+- Existing projects using the old workflow
+- Simple changes where you don't need incremental artifact creation
+- Preference for the all-or-nothing approach
+
+**Migrating to OPSX:**
+Legacy changes can be continued with OPSX commands. The artifact structure is compatible.
+
+---
+
+## Troubleshooting
+
+### "Change not found"
+
+The command couldn't identify which change to work on.
+
+**Solutions:**
+- Specify the change name explicitly: `/opsx:apply add-dark-mode`
+- Check that the change folder exists: `openspec list`
+- Verify you're in the right project directory
+
+### "No artifacts ready"
+
+All artifacts are either complete or blocked by missing dependencies.
+
+**Solutions:**
+- Run `openspec status --change <name>` to see what's blocking
+- Check if required artifacts exist
+- Create missing dependency artifacts first
+
+### "Schema not found"
+
+The specified schema doesn't exist.
+
+**Solutions:**
+- List available schemas: `openspec schemas`
+- Check spelling of schema name
+- Create the schema if it's custom: `openspec schema init <name>`
+
+### Commands not recognized
+
+The AI tool doesn't recognize OpenSpec commands.
+
+**Solutions:**
+- Ensure OpenSpec is initialized: `openspec init`
+- Regenerate skills: `openspec update`
+- Check that `.claude/skills/` directory exists (for Claude Code)
+- Restart your AI tool to pick up new skills
+
+### Artifacts not generating properly
+
+The AI creates incomplete or incorrect artifacts.
+
+**Solutions:**
+- Add project context in `openspec/config.yaml`
+- Add per-artifact rules for specific guidance
+- Provide more detail in your change description
+- Use `/opsx:continue` instead of `/opsx:ff` for more control
+
+---
+
+## Next Steps
+
+- [Workflows](workflows.md) - Common patterns and when to use each command
+- [CLI](cli.md) - Terminal commands for management and validation
+- [Customization](customization.md) - Create custom schemas and workflows
diff --git a/docs/concepts.md b/docs/concepts.md
new file mode 100644
index 0000000..2ec1772
--- /dev/null
+++ b/docs/concepts.md
@@ -0,0 +1,582 @@
+# Concepts
+
+This guide explains the core ideas behind OpenSpec and how they fit together. For practical usage, see [Getting Started](getting-started.md) and [Workflows](workflows.md).
+
+## Philosophy
+
+OpenSpec is built around four principles:
+
+```
+fluid not rigid       â€” no phase gates, work on what makes sense
+iterative not waterfall â€” learn as you build, refine as you go
+easy not complex      â€” lightweight setup, minimal ceremony
+brownfield-first      â€” works with existing codebases, not just greenfield
+```
+
+### Why These Principles Matter
+
+**Fluid not rigid.** Traditional spec systems lock you into phases: first you plan, then you implement, then you're done. OpenSpec is more flexible â€” you can create artifacts in any order that makes sense for your work.
+
+**Iterative not waterfall.** Requirements change. Understanding deepens. What seemed like a good approach at the start might not hold up after you see the codebase. OpenSpec embraces this reality.
+
+**Easy not complex.** Some spec frameworks require extensive setup, rigid formats, or heavyweight processes. OpenSpec stays out of your way. Initialize in seconds, start working immediately, customize only if you need to.
+
+**Brownfield-first.** Most software work isn't building from scratch â€” it's modifying existing systems. OpenSpec's delta-based approach makes it easy to specify changes to existing behavior, not just describe new systems.
+
+## The Big Picture
+
+OpenSpec organizes your work into two main areas:
+
+```
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚                        openspec/                                 â”‚
+â”‚                                                                  â”‚
+â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
+â”‚   â”‚       specs/        â”‚      â”‚         changes/              â”‚ â”‚
+â”‚   â”‚                     â”‚      â”‚                               â”‚ â”‚
+â”‚   â”‚  Source of truth    â”‚â—„â”€â”€â”€â”€â”€â”‚  Proposed modifications       â”‚ â”‚
+â”‚   â”‚  How your system    â”‚ mergeâ”‚  Each change = one folder     â”‚ â”‚
+â”‚   â”‚  currently works    â”‚      â”‚  Contains artifacts + deltas  â”‚ â”‚
+â”‚   â”‚                     â”‚      â”‚                               â”‚ â”‚
+â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
+â”‚                                                                  â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+```
+
+**Specs** are the source of truth â€” they describe how your system currently behaves.
+
+**Changes** are proposed modifications â€” they live in separate folders until you're ready to merge them.
+
+This separation is key. You can work on multiple changes in parallel without conflicts. You can review a change before it affects the main specs. And when you archive a change, its deltas merge cleanly into the source of truth.
+
+## Specs
+
+Specs describe your system's behavior using structured requirements and scenarios.
+
+### Structure
+
+```
+openspec/specs/
+â”œâ”€â”€ auth/
+â”‚   â””â”€â”€ spec.md           # Authentication behavior
+â”œâ”€â”€ payments/
+â”‚   â””â”€â”€ spec.md           # Payment processing
+â”œâ”€â”€ notifications/
+â”‚   â””â”€â”€ spec.md           # Notification system
+â””â”€â”€ ui/
+    â””â”€â”€ spec.md           # UI behavior and themes
+```
+
+Organize specs by domain â€” logical groupings that make sense for your system. Common patterns:
+
+- **By feature area**: `auth/`, `payments/`, `search/`
+- **By component**: `api/`, `frontend/`, `workers/`
+- **By bounded context**: `ordering/`, `fulfillment/`, `inventory/`
+
+### Spec Format
+
+A spec contains requirements, and each requirement has scenarios:
+
+```markdown
+# Auth Specification
+
+## Purpose
+Authentication and session management for the application.
+
+## Requirements
+
+### Requirement: User Authentication
+The system SHALL issue a JWT token upon successful login.
+
+#### Scenario: Valid credentials
+- GIVEN a user with valid credentials
+- WHEN the user submits login form
+- THEN a JWT token is returned
+- AND the user is redirected to dashboard
+
+#### Scenario: Invalid credentials
+- GIVEN invalid credentials
+- WHEN the user submits login form
+- THEN an error message is displayed
+- AND no token is issued
+
+### Requirement: Session Expiration
+The system MUST expire sessions after 30 minutes of inactivity.
+
+#### Scenario: Idle timeout
+- GIVEN an authenticated session
+- WHEN 30 minutes pass without activity
+- THEN the session is invalidated
+- AND the user must re-authenticate
+```
+
+**Key elements:**
+
+| Element | Purpose |
+|---------|---------|
+| `## Purpose` | High-level description of this spec's domain |
+| `### Requirement:` | A specific behavior the system must have |
+| `#### Scenario:` | A concrete example of the requirement in action |
+| SHALL/MUST/SHOULD | RFC 2119 keywords indicating requirement strength |
+
+### Why Structure Specs This Way
+
+**Requirements are the "what"** â€” they state what the system should do without specifying implementation.
+
+**Scenarios are the "when"** â€” they provide concrete examples that can be verified. Good scenarios:
+- Are testable (you could write an automated test for them)
+- Cover both happy path and edge cases
+- Use Given/When/Then or similar structured format
+
+**RFC 2119 keywords** (SHALL, MUST, SHOULD, MAY) communicate intent:
+- **MUST/SHALL** â€” absolute requirement
+- **SHOULD** â€” recommended, but exceptions exist
+- **MAY** â€” optional
+
+## Changes
+
+A change is a proposed modification to your system, packaged as a folder with everything needed to understand and implement it.
+
+### Change Structure
+
+```
+openspec/changes/add-dark-mode/
+â”œâ”€â”€ proposal.md           # Why and what
+â”œâ”€â”€ design.md             # How (technical approach)
+â”œâ”€â”€ tasks.md              # Implementation checklist
+â”œâ”€â”€ .openspec.yaml        # Change metadata (optional)
+â””â”€â”€ specs/                # Delta specs
+    â””â”€â”€ ui/
+        â””â”€â”€ spec.md       # What's changing in ui/spec.md
+```
+
+Each change is self-contained. It has:
+- **Artifacts** â€” documents that capture intent, design, and tasks
+- **Delta specs** â€” specifications for what's being added, modified, or removed
+- **Metadata** â€” optional configuration for this specific change
+
+### Why Changes Are Folders
+
+Packaging a change as a folder has several benefits:
+
+1. **Everything together.** Proposal, design, tasks, and specs live in one place. No hunting through different locations.
+
+2. **Parallel work.** Multiple changes can exist simultaneously without conflicting. Work on `add-dark-mode` while `fix-auth-bug` is also in progress.
+
+3. **Clean history.** When archived, changes move to `changes/archive/` with their full context preserved. You can look back and understand not just what changed, but why.
+
+4. **Review-friendly.** A change folder is easy to review â€” open it, read the proposal, check the design, see the spec deltas.
+
+## Artifacts
+
+Artifacts are the documents within a change that guide the work.
+
+### The Artifact Flow
+
+```
+proposal â”€â”€â”€â”€â”€â”€â–º specs â”€â”€â”€â”€â”€â”€â–º design â”€â”€â”€â”€â”€â”€â–º tasks â”€â”€â”€â”€â”€â”€â–º implement
+    â”‚               â”‚             â”‚              â”‚
+   why            what           how          steps
+ + scope        changes       approach      to take
+```
+
+Artifacts build on each other. Each artifact provides context for the next.
+
+### Artifact Types
+
+#### Proposal (`proposal.md`)
+
+The proposal captures **intent**, **scope**, and **approach** at a high level.
+
+```markdown
+# Proposal: Add Dark Mode
+
+## Intent
+Users have requested a dark mode option to reduce eye strain
+during nighttime usage and match system preferences.
+
+## Scope
+In scope:
+- Theme toggle in settings
+- System preference detection
+- Persist preference in localStorage
+
+Out of scope:
+- Custom color themes (future work)
+- Per-page theme overrides
+
+## Approach
+Use CSS custom properties for theming with a React context
+for state management. Detect system preference on first load,
+allow manual override.
+```
+
+**When to update the proposal:**
+- Scope changes (narrowing or expanding)
+- Intent clarifies (better understanding of the problem)
+- Approach fundamentally shifts
+
+#### Specs (delta specs in `specs/`)
+
+Delta specs describe **what's changing** relative to the current specs. See [Delta Specs](#delta-specs) below.
+
+#### Design (`design.md`)
+
+The design captures **technical approach** and **architecture decisions**.
+
+```markdown
+# Design: Add Dark Mode
+
+## Technical Approach
+Theme state managed via React Context to avoid prop drilling.
+CSS custom properties enable runtime switching without class toggling.
+
+## Architecture Decisions
+
+### Decision: Context over Redux
+Using React Context for theme state because:
+- Simple binary state (light/dark)
+- No complex state transitions
+- Avoids adding Redux dependency
+
+### Decision: CSS Custom Properties
+Using CSS variables instead of CSS-in-JS because:
+- Works with existing stylesheet
+- No runtime overhead
+- Browser-native solution
+
+## Data Flow
+```
+ThemeProvider (context)
+       â”‚
+       â–¼
+ThemeToggle â—„â”€â”€â–º localStorage
+       â”‚
+       â–¼
+CSS Variables (applied to :root)
+```
+
+## File Changes
+- `src/contexts/ThemeContext.tsx` (new)
+- `src/components/ThemeToggle.tsx` (new)
+- `src/styles/globals.css` (modified)
+```
+
+**When to update the design:**
+- Implementation reveals the approach won't work
+- Better solution discovered
+- Dependencies or constraints change
+
+#### Tasks (`tasks.md`)
+
+Tasks are the **implementation checklist** â€” concrete steps with checkboxes.
+
+```markdown
+# Tasks
+
+## 1. Theme Infrastructure
+- [ ] 1.1 Create ThemeContext with light/dark state
+- [ ] 1.2 Add CSS custom properties for colors
+- [ ] 1.3 Implement localStorage persistence
+- [ ] 1.4 Add system preference detection
+
+## 2. UI Components
+- [ ] 2.1 Create ThemeToggle component
+- [ ] 2.2 Add toggle to settings page
+- [ ] 2.3 Update Header to include quick toggle
+
+## 3. Styling
+- [ ] 3.1 Define dark theme color palette
+- [ ] 3.2 Update components to use CSS variables
+- [ ] 3.3 Test contrast ratios for accessibility
+```
+
+**Task best practices:**
+- Group related tasks under headings
+- Use hierarchical numbering (1.1, 1.2, etc.)
+- Keep tasks small enough to complete in one session
+- Check tasks off as you complete them
+
+## Delta Specs
+
+Delta specs are the key concept that makes OpenSpec work for brownfield development. They describe **what's changing** rather than restating the entire spec.
+
+### The Format
+
+```markdown
+# Delta for Auth
+
+## ADDED Requirements
+
+### Requirement: Two-Factor Authentication
+The system MUST support TOTP-based two-factor authentication.
+
+#### Scenario: 2FA enrollment
+- GIVEN a user without 2FA enabled
+- WHEN the user enables 2FA in settings
+- THEN a QR code is displayed for authenticator app setup
+- AND the user must verify with a code before activation
+
+#### Scenario: 2FA login
+- GIVEN a user with 2FA enabled
+- WHEN the user submits valid credentials
+- THEN an OTP challenge is presented
+- AND login completes only after valid OTP
+
+## MODIFIED Requirements
+
+### Requirement: Session Expiration
+The system MUST expire sessions after 15 minutes of inactivity.
+(Previously: 30 minutes)
+
+#### Scenario: Idle timeout
+- GIVEN an authenticated session
+- WHEN 15 minutes pass without activity
+- THEN the session is invalidated
+
+## REMOVED Requirements
+
+### Requirement: Remember Me
+(Deprecated in favor of 2FA. Users should re-authenticate each session.)
+```
+
+### Delta Sections
+
+| Section | Meaning | What Happens on Archive |
+|---------|---------|------------------------|
+| `## ADDED Requirements` | New behavior | Appended to main spec |
+| `## MODIFIED Requirements` | Changed behavior | Replaces existing requirement |
+| `## REMOVED Requirements` | Deprecated behavior | Deleted from main spec |
+
+### Why Deltas Instead of Full Specs
+
+**Clarity.** A delta shows exactly what's changing. Reading a full spec, you'd have to diff it mentally against the current version.
+
+**Conflict avoidance.** Two changes can touch the same spec file without conflicting, as long as they modify different requirements.
+
+**Review efficiency.** Reviewers see the change, not the unchanged context. Focus on what matters.
+
+**Brownfield fit.** Most work modifies existing behavior. Deltas make modifications first-class, not an afterthought.
+
+## Schemas
+
+Schemas define the artifact types and their dependencies for a workflow.
+
+### How Schemas Work
+
+```yaml
+# openspec/schemas/spec-driven/schema.yaml
+name: spec-driven
+artifacts:
+  - id: proposal
+    generates: proposal.md
+    requires: []              # No dependencies, can create first
+
+  - id: specs
+    generates: specs/**/*.md
+    requires: [proposal]      # Needs proposal before creating
+
+  - id: design
+    generates: design.md
+    requires: [proposal]      # Can create in parallel with specs
+
+  - id: tasks
+    generates: tasks.md
+    requires: [specs, design] # Needs both specs and design first
+```
+
+**Artifacts form a dependency graph:**
+
+```
+                    proposal
+                   (root node)
+                       â”‚
+         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+         â”‚                           â”‚
+         â–¼                           â–¼
+      specs                       design
+   (requires:                  (requires:
+    proposal)                   proposal)
+         â”‚                           â”‚
+         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+                       â”‚
+                       â–¼
+                    tasks
+                (requires:
+                specs, design)
+```
+
+**Dependencies are enablers, not gates.** They show what's possible to create, not what you must create next. You can skip design if you don't need it. You can create specs before or after design â€” both depend only on proposal.
+
+### Built-in Schemas
+
+**spec-driven** (default)
+
+The standard workflow for spec-driven development:
+
+```
+proposal â†’ specs â†’ design â†’ tasks â†’ implement
+```
+
+Best for: Most feature work where you want to agree on specs before implementation.
+
+### Custom Schemas
+
+Create custom schemas for your team's workflow:
+
+```bash
+# Create from scratch
+openspec schema init research-first
+
+# Or fork an existing one
+openspec schema fork spec-driven research-first
+```
+
+**Example custom schema:**
+
+```yaml
+# openspec/schemas/research-first/schema.yaml
+name: research-first
+artifacts:
+  - id: research
+    generates: research.md
+    requires: []           # Do research first
+
+  - id: proposal
+    generates: proposal.md
+    requires: [research]   # Proposal informed by research
+
+  - id: tasks
+    generates: tasks.md
+    requires: [proposal]   # Skip specs/design, go straight to tasks
+```
+
+See [Customization](customization.md) for full details on creating and using custom schemas.
+
+## Archive
+
+Archiving completes a change by merging its delta specs into the main specs and preserving the change for history.
+
+### What Happens When You Archive
+
+```
+Before archive:
+
+openspec/
+â”œâ”€â”€ specs/
+â”‚   â””â”€â”€ auth/
+â”‚       â””â”€â”€ spec.md â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â””â”€â”€ changes/                         â”‚
+    â””â”€â”€ add-2fa/                     â”‚
+        â”œâ”€â”€ proposal.md              â”‚
+        â”œâ”€â”€ design.md                â”‚ merge
+        â”œâ”€â”€ tasks.md                 â”‚
+        â””â”€â”€ specs/                   â”‚
+            â””â”€â”€ auth/                â”‚
+                â””â”€â”€ spec.md â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+
+
+After archive:
+
+openspec/
+â”œâ”€â”€ specs/
+â”‚   â””â”€â”€ auth/
+â”‚       â””â”€â”€ spec.md        # Now includes 2FA requirements
+â””â”€â”€ changes/
+    â””â”€â”€ archive/
+        â””â”€â”€ 2025-01-24-add-2fa/    # Preserved for history
+            â”œâ”€â”€ proposal.md
+            â”œâ”€â”€ design.md
+            â”œâ”€â”€ tasks.md
+            â””â”€â”€ specs/
+                â””â”€â”€ auth/
+                    â””â”€â”€ spec.md
+```
+
+### The Archive Process
+
+1. **Merge deltas.** Each delta spec section (ADDED/MODIFIED/REMOVED) is applied to the corresponding main spec.
+
+2. **Move to archive.** The change folder moves to `changes/archive/` with a date prefix for chronological ordering.
+
+3. **Preserve context.** All artifacts remain intact in the archive. You can always look back to understand why a change was made.
+
+### Why Archive Matters
+
+**Clean state.** Active changes (`changes/`) shows only work in progress. Completed work moves out of the way.
+
+**Audit trail.** The archive preserves the full context of every change â€” not just what changed, but the proposal explaining why, the design explaining how, and the tasks showing the work done.
+
+**Spec evolution.** Specs grow organically as changes are archived. Each archive merges its deltas, building up a comprehensive specification over time.
+
+## How It All Fits Together
+
+```
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚                              OPENSPEC FLOW                                   â”‚
+â”‚                                                                              â”‚
+â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                         â”‚
+â”‚   â”‚  1. START      â”‚  /opsx:new creates a change folder                      â”‚
+â”‚   â”‚     CHANGE     â”‚                                                         â”‚
+â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                         â”‚
+â”‚           â”‚                                                                  â”‚
+â”‚           â–¼                                                                  â”‚
+â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                         â”‚
+â”‚   â”‚  2. CREATE     â”‚  /opsx:ff or /opsx:continue                             â”‚
+â”‚   â”‚     ARTIFACTS  â”‚  Creates proposal â†’ specs â†’ design â†’ tasks              â”‚
+â”‚   â”‚                â”‚  (based on schema dependencies)                         â”‚
+â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                         â”‚
+â”‚           â”‚                                                                  â”‚
+â”‚           â–¼                                                                  â”‚
+â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                         â”‚
+â”‚   â”‚  3. IMPLEMENT  â”‚  /opsx:apply                                            â”‚
+â”‚   â”‚     TASKS      â”‚  Work through tasks, checking them off                  â”‚
+â”‚   â”‚                â”‚â—„â”€â”€â”€â”€ Update artifacts as you learn                      â”‚
+â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                         â”‚
+â”‚           â”‚                                                                  â”‚
+â”‚           â–¼                                                                  â”‚
+â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                         â”‚
+â”‚   â”‚  4. VERIFY     â”‚  /opsx:verify (optional)                                â”‚
+â”‚   â”‚     WORK       â”‚  Check implementation matches specs                     â”‚
+â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                         â”‚
+â”‚           â”‚                                                                  â”‚
+â”‚           â–¼                                                                  â”‚
+â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
+â”‚   â”‚  5. ARCHIVE    â”‚â”€â”€â”€â”€â–ºâ”‚  Delta specs merge into main specs           â”‚   â”‚
+â”‚   â”‚     CHANGE     â”‚     â”‚  Change folder moves to archive/             â”‚   â”‚
+â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚  Specs are now the updated source of truth   â”‚   â”‚
+â”‚                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
+â”‚                                                                              â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+```
+
+**The virtuous cycle:**
+
+1. Specs describe current behavior
+2. Changes propose modifications (as deltas)
+3. Implementation makes the changes real
+4. Archive merges deltas into specs
+5. Specs now describe the new behavior
+6. Next change builds on updated specs
+
+## Glossary
+
+| Term | Definition |
+|------|------------|
+| **Artifact** | A document within a change (proposal, design, tasks, or delta specs) |
+| **Archive** | The process of completing a change and merging its deltas into main specs |
+| **Change** | A proposed modification to the system, packaged as a folder with artifacts |
+| **Delta spec** | A spec that describes changes (ADDED/MODIFIED/REMOVED) relative to current specs |
+| **Domain** | A logical grouping for specs (e.g., `auth/`, `payments/`) |
+| **Requirement** | A specific behavior the system must have |
+| **Scenario** | A concrete example of a requirement, typically in Given/When/Then format |
+| **Schema** | A definition of artifact types and their dependencies |
+| **Spec** | A specification describing system behavior, containing requirements and scenarios |
+| **Source of truth** | The `openspec/specs/` directory, containing the current agreed-upon behavior |
+
+## Next Steps
+
+- [Getting Started](getting-started.md) - Practical first steps
+- [Workflows](workflows.md) - Common patterns and when to use each
+- [Commands](commands.md) - Full command reference
+- [Customization](customization.md) - Create custom schemas and configure your project
diff --git a/docs/customization.md b/docs/customization.md
new file mode 100644
index 0000000..ee4596e
--- /dev/null
+++ b/docs/customization.md
@@ -0,0 +1,342 @@
+# Customization
+
+OpenSpec provides three levels of customization:
+
+| Level | What it does | Best for |
+|-------|--------------|----------|
+| **Project Config** | Set defaults, inject context/rules | Most teams |
+| **Custom Schemas** | Define your own workflow artifacts | Teams with unique processes |
+| **Global Overrides** | Share schemas across all projects | Power users |
+
+---
+
+## Project Configuration
+
+The `openspec/config.yaml` file is the easiest way to customize OpenSpec for your team. It lets you:
+
+- **Set a default schema** - Skip `--schema` on every command
+- **Inject project context** - AI sees your tech stack, conventions, etc.
+- **Add per-artifact rules** - Custom rules for specific artifacts
+
+### Quick Setup
+
+```bash
+openspec init
+```
+
+This walks you through creating a config interactively. Or create one manually:
+
+```yaml
+# openspec/config.yaml
+schema: spec-driven
+
+context: |
+  Tech stack: TypeScript, React, Node.js, PostgreSQL
+  API style: RESTful, documented in docs/api.md
+  Testing: Jest + React Testing Library
+  We value backwards compatibility for all public APIs
+
+rules:
+  proposal:
+    - Include rollback plan
+    - Identify affected teams
+  specs:
+    - Use Given/When/Then format
+    - Reference existing patterns before inventing new ones
+```
+
+### How It Works
+
+**Default schema:**
+
+```bash
+# Without config
+openspec new change my-feature --schema spec-driven
+
+# With config - schema is automatic
+openspec new change my-feature
+```
+
+**Context and rules injection:**
+
+When generating any artifact, your context and rules are injected into the AI prompt:
+
+```xml
+<context>
+Tech stack: TypeScript, React, Node.js, PostgreSQL
+...
+</context>
+
+<rules>
+- Include rollback plan
+- Identify affected teams
+</rules>
+
+<template>
+[Schema's built-in template]
+</template>
+```
+
+- **Context** appears in ALL artifacts
+- **Rules** ONLY appear for the matching artifact
+
+### Schema Resolution Order
+
+When OpenSpec needs a schema, it checks in this order:
+
+1. CLI flag: `--schema <name>`
+2. Change metadata (`.openspec.yaml` in the change folder)
+3. Project config (`openspec/config.yaml`)
+4. Default (`spec-driven`)
+
+---
+
+## Custom Schemas
+
+When project config isn't enough, create your own schema with a completely custom workflow. Custom schemas live in your project's `openspec/schemas/` directory and are version-controlled with your code.
+
+```text
+your-project/
+â”œâ”€â”€ openspec/
+â”‚   â”œâ”€â”€ config.yaml        # Project config
+â”‚   â”œâ”€â”€ schemas/           # Custom schemas live here
+â”‚   â”‚   â””â”€â”€ my-workflow/
+â”‚   â”‚       â”œâ”€â”€ schema.yaml
+â”‚   â”‚       â””â”€â”€ templates/
+â”‚   â””â”€â”€ changes/           # Your changes
+â””â”€â”€ src/
+```
+
+### Fork an Existing Schema
+
+The fastest way to customize is to fork a built-in schema:
+
+```bash
+openspec schema fork spec-driven my-workflow
+```
+
+This copies the entire `spec-driven` schema to `openspec/schemas/my-workflow/` where you can edit it freely.
+
+**What you get:**
+
+```text
+openspec/schemas/my-workflow/
+â”œâ”€â”€ schema.yaml           # Workflow definition
+â””â”€â”€ templates/
+    â”œâ”€â”€ proposal.md       # Template for proposal artifact
+    â”œâ”€â”€ spec.md           # Template for specs
+    â”œâ”€â”€ design.md         # Template for design
+    â””â”€â”€ tasks.md          # Template for tasks
+```
+
+Now edit `schema.yaml` to change the workflow, or edit templates to change what AI generates.
+
+### Create a Schema from Scratch
+
+For a completely fresh workflow:
+
+```bash
+# Interactive
+openspec schema init research-first
+
+# Non-interactive
+openspec schema init rapid \
+  --description "Rapid iteration workflow" \
+  --artifacts "proposal,tasks" \
+  --default
+```
+
+### Schema Structure
+
+A schema defines the artifacts in your workflow and how they depend on each other:
+
+```yaml
+# openspec/schemas/my-workflow/schema.yaml
+name: my-workflow
+version: 1
+description: My team's custom workflow
+
+artifacts:
+  - id: proposal
+    generates: proposal.md
+    description: Initial proposal document
+    template: proposal.md
+    instruction: |
+      Create a proposal that explains WHY this change is needed.
+      Focus on the problem, not the solution.
+    requires: []
+
+  - id: design
+    generates: design.md
+    description: Technical design
+    template: design.md
+    instruction: |
+      Create a design document explaining HOW to implement.
+    requires:
+      - proposal    # Can't create design until proposal exists
+
+  - id: tasks
+    generates: tasks.md
+    description: Implementation checklist
+    template: tasks.md
+    requires:
+      - design
+
+apply:
+  requires: [tasks]
+  tracks: tasks.md
+```
+
+**Key fields:**
+
+| Field | Purpose |
+|-------|---------|
+| `id` | Unique identifier, used in commands and rules |
+| `generates` | Output filename (supports globs like `specs/**/*.md`) |
+| `template` | Template file in `templates/` directory |
+| `instruction` | AI instructions for creating this artifact |
+| `requires` | Dependencies - which artifacts must exist first |
+
+### Templates
+
+Templates are markdown files that guide the AI. They're injected into the prompt when creating that artifact.
+
+```markdown
+<!-- templates/proposal.md -->
+## Why
+
+<!-- Explain the motivation for this change. What problem does this solve? -->
+
+## What Changes
+
+<!-- Describe what will change. Be specific about new capabilities or modifications. -->
+
+## Impact
+
+<!-- Affected code, APIs, dependencies, systems -->
+```
+
+Templates can include:
+- Section headers the AI should fill in
+- HTML comments with guidance for the AI
+- Example formats showing expected structure
+
+### Validate Your Schema
+
+Before using a custom schema, validate it:
+
+```bash
+openspec schema validate my-workflow
+```
+
+This checks:
+- `schema.yaml` syntax is correct
+- All referenced templates exist
+- No circular dependencies
+- Artifact IDs are valid
+
+### Use Your Custom Schema
+
+Once created, use your schema with:
+
+```bash
+# Specify on command
+openspec new change feature --schema my-workflow
+
+# Or set as default in config.yaml
+schema: my-workflow
+```
+
+### Debug Schema Resolution
+
+Not sure which schema is being used? Check with:
+
+```bash
+# See where a specific schema resolves from
+openspec schema which my-workflow
+
+# List all available schemas
+openspec schema which --all
+```
+
+Output shows whether it's from your project, user directory, or the package:
+
+```text
+Schema: my-workflow
+Source: project
+Path: /path/to/project/openspec/schemas/my-workflow
+```
+
+---
+
+> **Note:** OpenSpec also supports user-level schemas at `~/.local/share/openspec/schemas/` for sharing across projects, but project-level schemas in `openspec/schemas/` are recommended since they're version-controlled with your code.
+
+---
+
+## Examples
+
+### Rapid Iteration Workflow
+
+A minimal workflow for quick iterations:
+
+```yaml
+# openspec/schemas/rapid/schema.yaml
+name: rapid
+version: 1
+description: Fast iteration with minimal overhead
+
+artifacts:
+  - id: proposal
+    generates: proposal.md
+    description: Quick proposal
+    template: proposal.md
+    instruction: |
+      Create a brief proposal for this change.
+      Focus on what and why, skip detailed specs.
+    requires: []
+
+  - id: tasks
+    generates: tasks.md
+    description: Implementation checklist
+    template: tasks.md
+    requires: [proposal]
+
+apply:
+  requires: [tasks]
+  tracks: tasks.md
+```
+
+### Adding a Review Artifact
+
+Fork the default and add a review step:
+
+```bash
+openspec schema fork spec-driven with-review
+```
+
+Then edit `schema.yaml` to add:
+
+```yaml
+  - id: review
+    generates: review.md
+    description: Pre-implementation review checklist
+    template: review.md
+    instruction: |
+      Create a review checklist based on the design.
+      Include security, performance, and testing considerations.
+    requires:
+      - design
+
+  - id: tasks
+    # ... existing tasks config ...
+    requires:
+      - specs
+      - design
+      - review    # Now tasks require review too
+```
+
+---
+
+## See Also
+
+- [CLI Reference: Schema Commands](cli.md#schema-commands) - Full command documentation
diff --git a/docs/experimental-release-plan.md b/docs/experimental-release-plan.md
deleted file mode 100644
index 387b48c..0000000
--- a/docs/experimental-release-plan.md
+++ /dev/null
@@ -1,926 +0,0 @@
-# OpenSpec Experimental Release Plan
-
-This document outlines the plan to release the experimental artifact workflow system for user testing.
-
-## Overview
-
-The goal is to allow users to test the new artifact-driven workflow system alongside the existing OpenSpec commands. This experimental system (`opsx`) provides a more granular, step-by-step approach to creating change artifacts.
-
-## Three Workflow Modes
-
-### 1. Old Workflow (Current Production)
-- **Commands**: `/openspec:proposal`, `/openspec:apply`, `/openspec:archive`
-- **Behavior**: Hardcoded slash commands that generate all artifacts in one command
-- **Status**: Production, unchanged
-
-### 2. New Artifact System - Batch Mode (Future)
-- **Commands**: Refactored `/openspec:proposal` using schemas
-- **Behavior**: Schema-driven but generates all artifacts at once (like legacy)
-- **Status**: Not in scope for this experimental release
-- **Note**: This is a future refactor to unify the old system with schemas
-
-### 3. New Artifact System - Granular Mode (Experimental)
-- **Commands**: `/opsx:new`, `/opsx:continue`
-- **Behavior**: One artifact at a time, dependency-driven, iterative
-- **Status**: Target for this experimental release
-
----
-
-## Work Items
-
-### 1. Rename AWF to OPSX
-
-**Current State:**
-- Commands: `/awf:start`, `/awf:continue`
-- Files: `.claude/commands/awf/start.md`, `.claude/commands/awf/continue.md`
-
-**Target State:**
-- Commands: `/opsx:new`, `/opsx:continue`
-- Files: `.claude/commands/opsx/new.md`, `.claude/commands/opsx/continue.md`
-
-**Tasks:**
-- [x] Create `.claude/commands/opsx/` directory
-- [x] Rename `start.md` â†’ `new.md` and update content
-- [x] Copy `continue.md` with updated references
-- [x] Update all references from "awf" to "opsx" in command content
-- [x] Update frontmatter (name, description) to use "opsx" naming
-- [x] Remove `.claude/commands/awf/` directory
-
-**CLI Commands:**
-The underlying CLI commands (`openspec status`, `openspec instructions`, etc.) remain unchanged. Only the slash command names change.
-
----
-
-### 2. Remove WF Skill Files
-
-**Current State:**
-- `.claude/commands/wf/start.md` - References non-existent `openspec wf` commands
-- `.claude/commands/wf/continue.md` - References non-existent `openspec wf` commands
-
-**Target State:**
-- Directory and files removed
-
-**Tasks:**
-- [x] Delete `.claude/commands/wf/start.md`
-- [x] Delete `.claude/commands/wf/continue.md`
-- [x] Delete `.claude/commands/wf/` directory
-
----
-
-### 3. Add Agent Skills for Experimental Workflow
-
-**Purpose:**
-Generate experimental workflow skills using the [Agent Skills](https://agentskills.io/specification) open standard.
-
-**Why Skills Instead of Slash Commands:**
-- **Cross-editor compatibility**: Skills work in Claude Code, Cursor, Windsurf, and other compatible editors automatically
-- **Simpler implementation**: Single directory (`.claude/skills/`) instead of 18+ editor-specific configurators
-- **Standard format**: Open standard with simple YAML frontmatter + markdown
-- **User invocation**: Users explicitly invoke skills when they want to use them
-
-**Behavior:**
-1. Create `.claude/skills/` directory if it doesn't exist
-2. Generate two skills using the Agent Skills specification:
-   - `openspec-new-change/SKILL.md` - Start a new change with artifact workflow
-   - `openspec-continue-change/SKILL.md` - Continue working on a change (create next artifact)
-3. Skills are added **alongside** existing `/openspec:*` commands (not replacing)
-
-**Supported Editors:**
-- Claude Code (native support)
-- Cursor (native support via Settings â†’ Rules â†’ Import Settings)
-- Windsurf (imports `.claude` configs)
-- Cline, Codex, and other Agent Skills-compatible editors
-
-**Tasks:**
-- [x] Create skill template content for `openspec-new-change` (based on current opsx:new)
-- [x] Create skill template content for `openspec-continue-change` (based on current opsx:continue)
-- [x] Add temporary `artifact-experimental-setup` command to CLI
-- [x] Implement skill file generation (YAML frontmatter + markdown body)
-- [x] Add success message with usage instructions
-
-**Note:** The `artifact-experimental-setup` command is temporary and will be merged into `openspec init` once the experimental workflow is promoted to stable.
-
-**Skill Format:**
-Each skill is a directory with a `SKILL.md` file:
-```
-.claude/skills/
-â”œâ”€â”€ openspec-new-change/
-â”‚   â””â”€â”€ SKILL.md          # name, description, instructions
-â”œâ”€â”€ openspec-continue-change/
-â”‚   â””â”€â”€ SKILL.md          # name, description, instructions
-â””â”€â”€ openspec-apply-change/
-    â””â”€â”€ SKILL.md          # name, description, instructions
-```
-
-**CLI Interface:**
-```bash
-openspec artifact-experimental-setup
-
-# Output:
-# ğŸ§ª Experimental Artifact Workflow Skills Created
-#
-#   âœ“ .claude/skills/openspec-new-change/SKILL.md
-#   âœ“ .claude/skills/openspec-continue-change/SKILL.md
-#   âœ“ .claude/skills/openspec-apply-change/SKILL.md
-#
-# ğŸ“– Usage:
-#
-#   Skills work automatically in compatible editors:
-#   â€¢ Claude Code - Auto-detected, ready to use
-#   â€¢ Cursor - Enable in Settings â†’ Rules â†’ Import Settings
-#   â€¢ Windsurf - Auto-imports from .claude directory
-#
-#   Ask Claude naturally:
-#   â€¢ "I want to start a new OpenSpec change to add <feature>"
-#   â€¢ "Continue working on this change"
-#
-#   Claude will automatically use the appropriate skill.
-#
-# ğŸ’¡ This is an experimental feature.
-#    Feedback welcome at: https://github.com/Fission-AI/OpenSpec/issues
-```
-
-**Implementation Notes:**
-- Simple file writing: Create directories and write templated `SKILL.md` files (no complex logic)
-- Use existing `FileSystemUtils.writeFile()` pattern like slash command configurators
-- Template structure: YAML frontmatter + markdown body
-- Keep existing `/opsx:*` slash commands for now (manual cleanup later)
-- Skills use invocation model (user explicitly asks Claude to use them)
-- Skill `description` field guides when Claude suggests using the skill
-- Each `SKILL.md` has required fields: `name` (matches directory) and `description`
-
----
-
-### 4. Update `/opsx:new` Command Content
-
-**Current Behavior (awf:start):**
-1. Ask user what they want to build (if no input)
-2. Create change directory
-3. Show artifact status
-4. Show what's ready
-5. Get instructions for proposal
-6. STOP and wait
-
-**New Behavior (opsx:new):**
-Same flow but with updated naming:
-- References to "awf" â†’ "opsx"
-- References to `/awf:continue` â†’ `/opsx:continue`
-- Update frontmatter name/description
-
-**Tasks:**
-- [x] Update all "awf" references to "opsx"
-- [x] Update command references in prompt text
-- [x] Verify CLI commands still work (they use `openspec`, not `awf`)
-
----
-
-### 5. Update `/opsx:continue` Command Content
-
-**Current Behavior (awf:continue):**
-1. Prompt for change selection (if not provided)
-2. Check current status
-3. Create ONE artifact based on what's ready
-4. Show progress and what's unlocked
-5. STOP
-
-**New Behavior (opsx:continue):**
-Same flow with updated naming.
-
-**Tasks:**
-- [x] Update all "awf" references to "opsx"
-- [x] Update command references in prompt text
-
----
-
-### 6. End-to-End Testing
-
-**Objective:**
-Run through a complete workflow with Claude using the new skills to create a real feature, validating the entire flow works.
-
-**Test Scenario:**
-Use a real OpenSpec feature as the test case (dog-fooding).
-
-**Test Flow:**
-1. Run `openspec artifact-experimental-setup` to create skills
-2. Verify `.claude/skills/openspec-new-change/SKILL.md` created
-3. Verify `.claude/skills/openspec-continue-change/SKILL.md` created
-4. Verify `.claude/skills/openspec-apply-change/SKILL.md` created
-5. Ask Claude: "I want to start a new OpenSpec change to add feature X"
-6. Verify Claude invokes the `openspec-new-change` skill
-7. Verify change directory created at `openspec/changes/add-feature-x/`
-8. Verify proposal template shown
-9. Ask Claude: "Continue working on this change"
-10. Verify Claude invokes the `openspec-continue-change` skill
-11. Verify `proposal.md` created with content
-12. Ask Claude: "Continue" (create specs)
-13. Verify `specs/*.md` created
-14. Ask Claude: "Continue" (create design)
-15. Verify `design.md` created
-16. Ask Claude: "Continue" (create tasks)
-17. Verify `tasks.md` created
-18. Verify status shows 4/4 complete
-19. Implement the feature based on tasks
-20. Run `/openspec:archive` to archive the change
-
-**Validation Checklist:**
-- [ ] `openspec artifact-experimental-setup` creates correct directory structure
-- [ ] Skills are auto-detected in Claude Code
-- [ ] Skill descriptions trigger appropriate invocations
-- [ ] Skills create change directory and show proposal template
-- [ ] Skills correctly identify ready artifacts
-- [ ] Skills create artifacts with meaningful content
-- [ ] Dependency detection works (specs requires proposal, etc.)
-- [ ] Progress tracking is accurate
-- [ ] Template content is useful and well-structured
-- [ ] Error handling works (invalid names, missing changes, etc.)
-- [ ] Works with different schemas (spec-driven, tdd)
-- [ ] Test in Cursor (Settings â†’ Rules â†’ Import Settings)
-
-**Document Results:**
-- Create test log documenting what worked and what didn't
-- Note any friction points or confusing UX
-- Identify bugs or improvements needed before user release
-
----
-
-### 7. Documentation for Users
-
-**Create user-facing documentation explaining:**
-
-1. **What is the experimental workflow?**
-   - A new way to create OpenSpec changes step-by-step using Agent Skills
-   - One artifact at a time with dependency tracking
-   - More interactive and iterative than the batch approach
-   - Works across Claude Code, Cursor, Windsurf, and other compatible editors
-
-2. **How to set up experimental workflow**
-   ```bash
-   openspec artifact-experimental-setup
-   ```
-
-   Note: This is a temporary command that will be integrated into `openspec init` once promoted to stable.
-
-3. **Available skills**
-   - `openspec-new-change` - Start a new change with artifact workflow
-   - `openspec-continue-change` - Continue working (create next artifact)
-
-4. **How to use**
-   - **Claude Code**: Skills are auto-detected, just ask Claude naturally
-     - "I want to start a new OpenSpec change to add X"
-     - "Continue working on this change"
-   - **Cursor**: Enable in Settings â†’ Rules â†’ Import Settings
-   - **Windsurf**: Auto-imports `.claude` directory
-
-5. **Example workflow**
-   - Step-by-step walkthrough with natural language interactions
-   - Show how Claude invokes skills based on user requests
-
-6. **Feedback mechanism**
-   - GitHub issue template for feedback
-   - What to report (bugs, UX issues, suggestions)
-
-**Tasks:**
-- [ ] Create `docs/experimental-workflow.md` user guide
-- [ ] Add GitHub issue template for experimental feedback
-- [ ] Update README with mention of experimental features
-
----
-
-## Dependency Graph
-
-```
-1. Remove WF skill files
-   â””â”€â”€ (no dependencies)
-
-2. Rename AWF to OPSX
-   â””â”€â”€ (no dependencies)
-
-3. Add Agent Skills
-   â””â”€â”€ Depends on: Rename AWF to OPSX (uses opsx content as templates)
-
-4. Update opsx:new content
-   â””â”€â”€ Depends on: Rename AWF to OPSX
-
-5. Update opsx:continue content
-   â””â”€â”€ Depends on: Rename AWF to OPSX
-
-6. E2E Testing
-   â””â”€â”€ Depends on: Add Agent Skills (tests the skills workflow)
-
-7. User Documentation
-   â””â”€â”€ Depends on: E2E Testing (need to know final behavior)
-```
-
----
-
-## Out of Scope
-
-The following are explicitly NOT part of this experimental release:
-
-1. **Batch mode refactor** - Making legacy `/openspec:proposal` use schemas
-2. **New schemas** - Only shipping with existing `spec-driven` and `tdd`
-3. **Schema customization UI** - No `openspec schema list` or similar
-4. **Multiple editor support in CLI** - Skills work cross-editor automatically via `.claude/skills/`
-5. **Replacing existing commands** - Skills are additive, not replacing `/openspec:*` or `/opsx:*`
-
----
-
-## Success Criteria
-
-The experimental release is ready when:
-
-1. `openspec-new-change`, `openspec-continue-change`, and `openspec-apply-change` skills work end-to-end
-2. `openspec artifact-experimental-setup` creates skills in `.claude/skills/`
-3. Skills work in Claude Code and are compatible with Cursor/Windsurf
-4. At least one complete workflow has been tested manually
-5. User documentation exists explaining how to generate and use skills
-6. Feedback mechanism is in place
-7. WF skill files are removed
-8. No references to "awf" remain in user-facing content
-
----
-
-## Open Questions
-
-1. **Schema selection** - Should `opsx:new` allow selecting a schema, or always use `spec-driven`?
-   - Current: Always uses `spec-driven` as default
-   - Consider: Add `--schema tdd` option or prompt
-
-2. **Namespace in CLI** - Should experimental CLI commands be namespaced?
-   - Current: `openspec status`, `openspec instructions` (no namespace)
-   - Alternative: `openspec opsx status` (explicit experimental namespace)
-   - Recommendation: Keep current, less typing for users
-
-3. **Deprecation path** - If opsx becomes the default, how do we migrate?
-   - Not needed for experimental release
-   - Document that command names may change
-
----
-
-## Estimated Work Breakdown
-
-| Item | Complexity | Notes |
-|------|------------|-------|
-| Remove WF files | Trivial | Just delete 2 files + directory |
-| Rename AWF â†’ OPSX | Low | File renames + content updates |
-| Add Agent Skills | **Low** | **Simple: 3-4 files, single output directory, standard format** |
-| Update opsx:new content | Low | Text replacements |
-| Update opsx:continue content | Low | Text replacements |
-| E2E Testing | Medium | Manual testing, documenting results |
-| User Documentation | Medium | New docs, issue template |
-
-**Key Improvement:** Switching to Agent Skills reduces complexity significantly:
-- **Before:** 20+ files (type definitions, 18+ editor configurators, editor selection UI)
-- **After:** 3-4 files (skill templates, simple CLI command)
-- **Cross-editor:** Works automatically in Claude Code, Cursor, Windsurf without extra code
-
----
-
-## User Feedback from E2E Testing
-
-### What Worked Well
-
-1. **Clear dependency graph** â­ HIGH PRIORITY - KEEP
-   - The status command showing blocked/unblocked artifacts was intuitive:
-     ```
-     [x] proposal
-     [ ] design
-     [-] tasks (blocked by: design, specs)
-     ```
-   - Users always knew what they could work on next
-   - **Relevance**: Core UX strength to preserve
-
-2. **Structured instructions output** â­ HIGH PRIORITY - KEEP
-   - `openspec instructions <artifact>` gave templates, output paths, and context in one call
-   - Very helpful for understanding what to create
-   - **Relevance**: Essential for agent-driven workflow
-
-3. **Simple scaffolding** âœ… WORKS WELL
-   - `openspec new change "name"` just worked - created directory structure without fuss
-   - **Relevance**: Good baseline, room for improvement (see pain points)
-
----
-
-### Pain Points & Confusion
-
-1. **Redundant CLI calls** âš ï¸ MEDIUM PRIORITY
-   - Users called both `status` AND `next` every time, but they overlap significantly
-   - `status` already shows what's blocked
-   - **Recommendation**: Consider merging or making `next` give actionable guidance beyond just listing names
-   - **Relevance**: Reduces friction in iterative workflow
-
-2. **Specs directory structure was ambiguous** ğŸ”¥ HIGH PRIORITY - FIX
-   - Instructions said: `Write to: .../specs/**/*.md`
-   - Users had to guess: `specs/spec.md`? `specs/game/spec.md`? `specs/tic-tac-toe/spec.md`?
-   - Users ended up doing manual `mkdir -p .../specs/tic-tac-toe` then writing `spec.md` inside
-   - **Recommendation**: CLI should scaffold this directory structure automatically
-   - **Relevance**: Critical agent UX - ambiguous paths cause workflow friction
-
-3. **Repetitive --change flag** âš ï¸ MEDIUM PRIORITY
-   - Every command needed `--change "tic-tac-toe-game"`
-   - After 10+ calls, this felt verbose
-   - **Recommendation**: `openspec use "tic-tac-toe-game"` to set context, then subsequent commands assume that change
-   - **Relevance**: Quality of life improvement for iterative sessions
-
-4. **No validation feedback** ğŸ”¥ HIGH PRIORITY - ADD
-   - After writing each artifact, users just ran `status` hoping it would show `[x]`
-   - Questions raised:
-     - How did it know the artifact was "done"? File existence?
-     - What if spec format was wrong (e.g., wrong heading levels)?
-   - **Recommendation**: Add `openspec validate --change "name"` to check content quality
-   - **Relevance**: Critical for user confidence and catching errors early
-
-5. **Query-heavy, action-light CLI** ğŸ”¥ HIGH PRIORITY - ENHANCE
-   - Most commands retrieve info. The only "action" is `new change`
-   - Artifact creation is manual Write to guessed paths
-   - **Recommendation**: `openspec create proposal --change "name"` could scaffold the file with template pre-filled, then user just edits
-   - **Relevance**: Directly impacts agent productivity - reduce manual file writing
-
-6. **Instructions output was verbose** âš ï¸ LOW PRIORITY
-   - XML-style output (`<artifact>`, `<template>`, `<instruction>`) was parseable but long
-   - Key info (output path, template) was buried in ~50 lines
-   - **Recommendation**: Add compact mode or structured JSON output for agents
-   - **Relevance**: Nice-to-have for agent parsing efficiency
-
----
-
-### Workflow Friction
-
-1. **Mandatory "STOP and wait" after showing proposal template** âš ï¸ MEDIUM PRIORITY
-   - The skill said "STOP and wait" after showing the proposal template
-   - This felt overly cautious when user had already provided enough context (e.g., "tic tac toe, single player vs AI, minimal aesthetics")
-   - **Recommendation**: Make the pause optional or conditional based on context clarity
-   - **Relevance**: Reduces unnecessary round-trips in agent conversations
-
-2. **No connection to implementation** ğŸ”¥ HIGH PRIORITY - ROADMAP ITEM
-   - After 4/4 artifacts complete, then what? The workflow ends at planning
-   - No `openspec apply` or guidance on how to execute the tasks
-   - User asked "would you like me to implement?" but that's outside OpenSpec's scope currently
-   - **Recommendation**: Add implementation bridge - either:
-     - `openspec apply` command to start execution phase
-     - Clear handoff to existing `/openspec:apply` workflow
-     - Documentation on next steps after planning completes
-   - **Relevance**: Critical missing piece - users expect end-to-end workflow
-
----
-
-### Priority Summary
-
-**MUST FIX (High Priority):**
-1. Specs directory structure ambiguity (#2)
-2. Add validation feedback (#4)
-3. Make CLI more action-oriented (#5)
-4. Bridge to implementation phase (#2 in Workflow Friction)
-5. Keep clear dependency graph (#1 in What Worked)
-6. Keep structured instructions (#2 in What Worked)
-
-**SHOULD FIX (Medium Priority):**
-1. Reduce redundant CLI calls (#1)
-2. Repetitive `--change` flag (#3)
-3. Mandatory STOP behavior (#1 in Workflow Friction)
-
-**NICE TO HAVE (Low Priority):**
-1. Compact instructions output mode (#6)
-
----
-
-## Design Decisions (from E2E Testing Feedback)
-
-Based on dev testing and analysis of agent workflow friction, we identified three blockers for experimental release and made the following decisions.
-
-### Blockers Identified
-
-From the pain points in E2E testing, three issues are blocking the experimental release:
-
-1. **Specs directory ambiguity** - Agents don't know where to write spec files or how to name capabilities
-2. **CLI is query-heavy** - Most commands retrieve info, artifact creation is manual
-3. **Apply integration missing** - After 4/4 artifacts complete, no guidance on implementation phase
-
-### Decision 1: Capability Discovery in Proposal (RESOLVED)
-
-**Problem:** The specs artifact instruction says "Create one spec file per capability in `specs/<name>/spec.md`" but:
-- Agent doesn't know what `<name>` should be
-- Capability identification requires research (existing specs, codebase)
-- Proposal template asks for "Affected specs" but doesn't structure it
-- Research happens implicitly, output isn't captured
-
-**Decision:** Enrich the proposal template to explicitly capture capability discovery.
-
-**Current proposal template:**
-```markdown
-## Why
-## What Changes
-## Impact
-- Affected specs: List capabilities...  â† vague, easy to skip
-- Affected code: ...
-```
-
-**New proposal template:**
-```markdown
-## Why
-## What Changes
-## Capabilities
-
-### New Capabilities
-<!-- Capabilities being introduced (will create new specs/<name>/spec.md) -->
-- `<name>`: <brief description of what this capability covers>
-
-### Modified Capabilities
-<!-- Existing capabilities being changed (will update existing specs) -->
-- `<existing-name>`: <what's changing>
-
-## Impact
-<!-- Affected code, APIs, dependencies, systems -->
-```
-
-**Rationale:**
-- Proposal already asks for capabilities (just poorly) - this makes it explicit
-- Captured output is reviewable (vs implicit research that can't be verified)
-- Creates clear contract between proposal and specs phases
-- Distinguishes NEW vs MODIFIED upfront (critical for specs phase)
-- Agent can't skip research - it's part of the deliverable
-
-**Implementation:**
-- Update `schemas/spec-driven/templates/proposal.md`
-- Update proposal instruction in `schemas/spec-driven/schema.yaml`
-- Update skill instructions to guide capability discovery
-
-### Decision 2: CLI Action Commands (IN PROGRESS)
-
-**Problem:** CLI is mostly query-oriented. Agents run `openspec status`, `openspec next`, `openspec instructions` but then must manually write files.
-
-#### Decision 2a: Remove `openspec next` command (RESOLVED)
-
-**Problem:** The `next` command is redundant. It only shows which artifacts are ready, but `status` already shows this information (artifacts with status "ready" vs "blocked" vs "done").
-
-**Current behavior:**
-```bash
-openspec status --change "X"  # Shows: proposal (done), specs (ready), design (blocked), tasks (blocked)
-openspec next --change "X"    # Shows: ["specs"]  â† redundant
-```
-
-**Decision:** Remove the `next` command. Agents should use `status` which provides the same info plus more context.
-
-**Implementation:**
-- Remove `next` command from CLI
-- Update skill instructions to use `status` instead of `next`
-- Update AGENTS.md references
-
-#### Decision 2b: CLI Scaffolding (RESOLVED - NO)
-
-**Problem:** After getting instructions, agents manually write files. Should CLI scaffold artifacts instead?
-
-**Options considered:**
-- Add `openspec create <artifact>` commands that scaffold files with templates
-- Keep current approach where agent writes files directly from instructions
-- Hybrid: CLI can scaffold, agent can also write directly
-
-**Decision:** Keep current flow. No scaffolding commands.
-
-**Rationale (from agent ergonomics perspective):**
-- One Write is better than multiple Edits - agent composes full content atomically
-- `instructions` already provides template in context - scaffolding just moves it to a file
-- Fewer tool calls: `instructions` + Write (2) vs `create` + `instructions` + Read + EditÃ—N (4+)
-- Scaffolding doesn't solve the real problem (not knowing WHAT to write)
-- Real problem solved by proposal template change (capability discovery)
-
-**For multi-file artifacts (specs):** Scaffolding can't help because CLI doesn't know capability names until proposal is complete. The capability discovery in proposal solves this.
-
-### Decision 3: Apply Integration (RESOLVED)
-
-**Original problem:** After planning completes (4/4 artifacts), the experimental workflow ends. No guidance on implementation.
-
-**Key insight: No phases, just actions.**
-
-Through discussion, we realized phases (planning â†’ implementation â†’ archive) are an artificial constraint. Work is fluid:
-- You might start implementing, realize the design is wrong â†’ update design.md
-- You're halfway through tasks, discover a new requirement â†’ update specs
-- You bounce between "planning" and "implementing" constantly
-
-**The better model: Actions on a Change**
-
-A change is a thing (with artifacts). Actions are verbs you perform on a change. Actions aren't phases - they're fluid operations you can perform anytime.
-
-| Action | What it does | Skill | CLI Command |
-|--------|--------------|-------|-------------|
-| `new` | Create a change (scaffold directory) | `opsx:new` | `openspec new change` |
-| `continue` | Create next artifact (dependency-aware) | `opsx:continue` | `openspec instructions` |
-| `apply` | Implement tasks (execute, check off) | `opsx:apply` (NEW) | TBD |
-| `update` | Refresh/update artifacts based on learnings | `opsx:update` (NEW) | TBD |
-| `explore` | Research, ask questions, understand | `opsx:explore` (NEW) | TBD |
-| `validate` | Check artifacts are correct/complete | TBD | `openspec validate` |
-| `archive` | Finalize and move to archive | existing | `openspec archive` |
-
-**Key principles:**
-- Actions are modeled as skills (primary interface for agents)
-- Some skills have matching CLI commands for convenience
-- Skills and CLI commands are decoupled - not everything needs both
-- Actions can be performed in any order (with soft prerequisites)
-- No linear phase gates
-
-**What the schema defines:**
-- Artifacts (what they are, where they go)
-- Dependencies (what must exist first)
-- Required vs optional
-- Templates + instructions
-
-**What the schema does NOT define:**
-- Phases
-- When you can modify things
-- Linear workflow
-
-**Progress tracking:**
-- tasks.md checkboxes = implementation progress
-- Artifact existence = planning progress
-- Archive readiness = user decides (or all tasks done)
-
-**For experimental release:**
-- Create `opsx:apply` skill (guidance for implementing tasks)
-- Document the "actions on a change" model
-- Other actions (update, explore) can come later
-
----
-
-### Design: `openspec-apply-change` Skill
-
-#### Overview
-
-The apply skill guides agents through implementing tasks from a completed (or in-progress) change. Unlike the old `/openspec:apply` command, this skill:
-- Is **fluid** - can be invoked anytime, not just after all artifacts are done
-- Allows **artifact updates** - if implementation reveals issues, update design/specs
-- Works **until done** - keeps going through tasks until complete or blocked
-- Tracks **progress via checkboxes** - tasks.md is the source of truth
-
-#### Skill Metadata
-
-```yaml
-name: openspec-apply-change
-description: Implement tasks from an OpenSpec change. Use when the user wants to start implementing, continue implementation, or work through tasks.
-```
-
-#### When to Invoke
-
-The skill should be invoked when:
-- User says "implement this change" or "start implementing"
-- User says "work on the tasks" or "do the next task"
-- User says "apply this change"
-- All artifacts are complete and user wants to proceed
-- User wants to continue implementation after a break
-
-#### Input
-
-- Optionally: change name
-- Optionally: specific task number to work on
-- If omitted: prompt for change selection (same pattern as continue-change)
-
-#### Steps
-
-```markdown
-**Steps**
-
-1. **If no change name provided, prompt for selection**
-
-   Run `openspec list --json` to get available changes. Use **AskUserQuestion** to let user select.
-
-   Show changes that have tasks.md (implementation-ready).
-   Mark changes with incomplete tasks as "(In Progress)".
-
-2. **Get apply instructions**
-
-   ```bash
-   openspec instructions apply --change "<name>" --json
-   ```
-
-   This returns:
-   - Context file paths (proposal, specs, design, tasks)
-   - Progress (total, complete, remaining)
-   - Task list with status
-   - Dynamic instruction based on current state
-
-   **Handle states:**
-   - If blocked (missing artifacts): show message, suggest `openspec-continue-change`
-   - If all done: congratulate, suggest archive
-   - Otherwise: proceed to implementation
-
-3. **Read context files**
-
-   Read the files listed in the instructions:
-   - `proposal.md` - why and what
-   - `specs/*.md` - requirements and scenarios
-   - `design.md` - technical approach (if exists)
-   - `tasks.md` - the implementation checklist
-
-4. **Show current progress**
-
-   Display:
-   - Progress: "N/M tasks complete"
-   - Remaining tasks overview
-   - Dynamic instruction from CLI
-
-5. **Implement tasks (loop until done or blocked)**
-
-   For each pending task:
-   - Show which task is being worked on
-   - Make the code changes required
-   - Keep changes minimal and focused
-   - Mark task complete in tasks.md: `- [ ]` â†’ `- [x]`
-   - Continue to next task
-
-   **Pause if:**
-   - Task is unclear â†’ ask for clarification
-   - Implementation reveals a design issue â†’ suggest updating artifacts
-   - Error or blocker encountered â†’ report and wait for guidance
-   - User interrupts
-
-6. **On completion or pause, show status**
-
-   Display:
-   - Tasks completed this session
-   - Overall progress: "N/M tasks complete"
-   - If all done: suggest archive
-   - If paused: explain why and wait for guidance
-```
-
-#### Output Format
-
-**During implementation:**
-```
-## Implementing: add-user-auth
-
-Working on task 3/7: Create UserAuth service class
-[...implementation happening...]
-âœ“ Task complete
-
-Working on task 4/7: Add login endpoint to AuthController
-[...implementation happening...]
-âœ“ Task complete
-
-Working on task 5/7: Add JWT token generation
-[...implementation happening...]
-```
-
-**On completion:**
-```
-## Implementation Complete
-
-**Change:** add-user-auth
-**Progress:** 7/7 tasks complete âœ“
-
-### Completed This Session
-- [x] Create UserAuth service class
-- [x] Add login endpoint to AuthController
-- [x] Add JWT token generation
-- [x] Add logout endpoint
-- [x] Add auth middleware
-- [x] Write unit tests
-- [x] Update API documentation
-
-All tasks complete! Ready to archive this change.
-```
-
-**On pause (issue encountered):**
-```
-## Implementation Paused
-
-**Change:** add-user-auth
-**Progress:** 4/7 tasks complete
-
-### Issue Encountered
-Task 5 "Add JWT token generation" - the design specifies using RS256 but
-the existing auth library only supports HS256.
-
-**Options:**
-1. Update design.md to use HS256 instead
-2. Add a new JWT library that supports RS256
-3. Other approach
-
-What would you like to do?
-```
-
-#### Guardrails
-
-- Keep going through tasks until done or blocked
-- Always read context before starting (specs, design)
-- If task is ambiguous, pause and ask before implementing
-- If implementation reveals issues, pause and suggest artifact updates
-- Keep code changes minimal and scoped to each task
-- Update task checkbox immediately after completing each task
-- Pause on errors, blockers, or unclear requirements - don't guess
-
-#### Fluid Workflow Integration
-
-The apply skill supports the "actions on a change" model:
-
-**Can be invoked anytime:**
-- Before all artifacts are done (if tasks.md exists)
-- After partial implementation
-- Interleaved with other actions (update, continue)
-
-**Allows artifact updates:**
-- If implementation reveals design issues â†’ suggest `opsx:update` or manual edit
-- If requirements need clarification â†’ suggest updating specs
-- Not phase-locked - work fluidly
-
-**Example fluid workflow:**
-```
-User: "Implement add-user-auth"
-â†’ openspec-apply-change: implements tasks 1, 2, 3, 4...
-â†’ Pauses at task 5: "Design says RS256 but library only supports HS256"
-
-User: "Let's use HS256 instead, update the design"
-â†’ User edits design.md (or uses opsx:update in future)
-
-User: "Continue implementing"
-â†’ openspec-apply-change: implements tasks 5, 6, 7
-â†’ "All tasks complete! Ready to archive."
-```
-
-#### CLI Commands Used
-
-```bash
-openspec list --json                        # List changes for selection
-openspec status --change "<name>"           # Check artifact completion
-openspec instructions apply --change "<name>" # Get apply instructions (NEW)
-# File reads via Read tool for proposal, specs, design, tasks
-# File edits via Edit tool for checking off tasks
-```
-
-#### New CLI Command: `openspec instructions apply`
-
-For consistency with artifact instructions.
-
-**Usage:**
-```bash
-openspec instructions apply --change "<name>" [--json]
-```
-
-**Output (Markdown format):**
-```markdown
-## Apply: add-user-auth
-
-### Context Files
-- proposal: openspec/changes/add-user-auth/proposal.md
-- specs: openspec/changes/add-user-auth/specs/**/*.md
-- design: openspec/changes/add-user-auth/design.md
-- tasks: openspec/changes/add-user-auth/tasks.md
-
-### Progress
-2/7 complete
-
-### Tasks
-- [x] Create UserAuth service class
-- [x] Add login endpoint
-- [ ] Add JWT token generation
-- [ ] Add logout endpoint
-- [ ] Add auth middleware
-- [ ] Write unit tests
-- [ ] Update API documentation
-
-### Instruction
-Read context files, work through pending tasks, mark complete as you go.
-Pause if you hit blockers or need clarification.
-```
-
-**Benefits of CLI command:**
-- **Consistency** - same pattern as `openspec instructions <artifact>`
-- **Structured output** - progress, tasks, context paths in one call
-- **Clean format** - markdown is readable and compact (vs verbose XML)
-- **Extensibility** - can add more sections later if needed
-- **JSON option** - `--json` flag available for programmatic use
-
-#### Differences from Old `/openspec:apply`
-
-| Aspect | Old `/openspec:apply` | New `openspec-apply-change` |
-|--------|----------------------|----------------------------|
-| Invocation | After all artifacts done | Anytime (if tasks.md exists) |
-| Granularity | All tasks at once | All tasks, but pauses on issues |
-| Artifact updates | Not mentioned | Encouraged when needed |
-| Progress tracking | Update all at end | Update after each task |
-| Flow control | Push through everything | Pause on blockers, resume after |
-| Context loading | Read once at start | Read context, reference as needed |
-| Issue handling | Not specified | Pause, present options, wait for guidance |
-
-#### Implementation Notes
-
-1. **Add CLI command**: Add `openspec instructions apply` to artifact-workflow.ts
-   - Parse tasks.md for progress (count done/pending)
-   - Return context paths, progress, task list, simple instruction
-2. **Add to skill-templates.ts**: Create `getApplyChangeSkillTemplate()` function
-3. **Update artifact-experimental-setup**: Generate this skill alongside new/continue
-4. **Update skills list**: Add to `.claude/skills/` directory
-5. **Test the flow**: Verify it works with existing changes that have tasks.md
-
----
-
-## Next Steps
-
-1. ~~Review this plan and confirm scope~~ (Done - blockers identified)
-2. ~~Design decisions~~ (Done - all 3 blockers resolved)
-3. ~~Design apply skill~~ (Done - documented above)
-4. ~~Implement proposal template change (Decision 1 - capability discovery)~~ (Done)
-5. ~~Remove `openspec next` command (Decision 2a)~~ (Done)
-6. ~~Add `openspec instructions apply` CLI command~~ (Done)
-7. ~~Create `openspec-apply-change` skill~~ (Done)
-8. Conduct E2E testing with updated workflow
-9. Write user docs (document "actions on a change" model)
-10. Release to test users
diff --git a/docs/getting-started.md b/docs/getting-started.md
new file mode 100644
index 0000000..e391272
--- /dev/null
+++ b/docs/getting-started.md
@@ -0,0 +1,273 @@
+# Getting Started
+
+This guide explains how OpenSpec works after you've installed and initialized it. For installation instructions, see the [main README](../README.md#quick-start).
+
+## How It Works
+
+OpenSpec helps you and your AI coding assistant agree on what to build before any code is written. The workflow follows a simple pattern:
+
+```
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚ Start a Change     â”‚  /opsx:new
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+         â”‚
+         â–¼
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚ Create Artifacts   â”‚  /opsx:ff or /opsx:continue
+â”‚ (proposal, specs,  â”‚
+â”‚  design, tasks)    â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+         â”‚
+         â–¼
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚ Implement Tasks    â”‚  /opsx:apply
+â”‚ (AI writes code)   â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+         â”‚
+         â–¼
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚ Archive & Merge    â”‚  /opsx:archive
+â”‚ Specs              â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+```
+
+## What OpenSpec Creates
+
+After running `openspec init`, your project has this structure:
+
+```
+openspec/
+â”œâ”€â”€ specs/              # Source of truth (your system's behavior)
+â”‚   â””â”€â”€ <domain>/
+â”‚       â””â”€â”€ spec.md
+â”œâ”€â”€ changes/            # Proposed updates (one folder per change)
+â”‚   â””â”€â”€ <change-name>/
+â”‚       â”œâ”€â”€ proposal.md
+â”‚       â”œâ”€â”€ design.md
+â”‚       â”œâ”€â”€ tasks.md
+â”‚       â””â”€â”€ specs/      # Delta specs (what's changing)
+â”‚           â””â”€â”€ <domain>/
+â”‚               â””â”€â”€ spec.md
+â””â”€â”€ config.yaml         # Project configuration (optional)
+```
+
+**Two key directories:**
+
+- **`specs/`** - The source of truth. These specs describe how your system currently behaves. Organized by domain (e.g., `specs/auth/`, `specs/payments/`).
+
+- **`changes/`** - Proposed modifications. Each change gets its own folder with all related artifacts. When a change is complete, its specs merge into the main `specs/` directory.
+
+## Understanding Artifacts
+
+Each change folder contains artifacts that guide the work:
+
+| Artifact | Purpose |
+|----------|---------|
+| `proposal.md` | The "why" and "what" - captures intent, scope, and approach |
+| `specs/` | Delta specs showing ADDED/MODIFIED/REMOVED requirements |
+| `design.md` | The "how" - technical approach and architecture decisions |
+| `tasks.md` | Implementation checklist with checkboxes |
+
+**Artifacts build on each other:**
+
+```
+proposal â”€â”€â–º specs â”€â”€â–º design â”€â”€â–º tasks â”€â”€â–º implement
+   â–²           â–²          â–²                    â”‚
+   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+            update as you learn
+```
+
+You can always go back and refine earlier artifacts as you learn more during implementation.
+
+## How Delta Specs Work
+
+Delta specs are the key concept in OpenSpec. They show what's changing relative to your current specs.
+
+### The Format
+
+Delta specs use sections to indicate the type of change:
+
+```markdown
+# Delta for Auth
+
+## ADDED Requirements
+
+### Requirement: Two-Factor Authentication
+The system MUST require a second factor during login.
+
+#### Scenario: OTP required
+- GIVEN a user with 2FA enabled
+- WHEN the user submits valid credentials
+- THEN an OTP challenge is presented
+
+## MODIFIED Requirements
+
+### Requirement: Session Timeout
+The system SHALL expire sessions after 30 minutes of inactivity.
+(Previously: 60 minutes)
+
+#### Scenario: Idle timeout
+- GIVEN an authenticated session
+- WHEN 30 minutes pass without activity
+- THEN the session is invalidated
+
+## REMOVED Requirements
+
+### Requirement: Remember Me
+(Deprecated in favor of 2FA)
+```
+
+### What Happens on Archive
+
+When you archive a change:
+
+1. **ADDED** requirements are appended to the main spec
+2. **MODIFIED** requirements replace the existing version
+3. **REMOVED** requirements are deleted from the main spec
+
+The change folder moves to `openspec/changes/archive/` for audit history.
+
+## Example: Your First Change
+
+Let's walk through adding dark mode to an application.
+
+### 1. Start the Change
+
+```
+You: /opsx:new add-dark-mode
+
+AI:  Created openspec/changes/add-dark-mode/
+     Ready to create: proposal
+```
+
+### 2. Create Artifacts
+
+Use `/opsx:ff` (fast-forward) to create all planning artifacts at once:
+
+```
+You: /opsx:ff
+
+AI:  Creating artifacts for add-dark-mode...
+     âœ“ proposal.md â€” why we're doing this, what's changing
+     âœ“ specs/       â€” requirements and scenarios
+     âœ“ design.md    â€” technical approach
+     âœ“ tasks.md     â€” implementation checklist
+     Ready for implementation!
+```
+
+### 3. What Gets Created
+
+**proposal.md** - Captures the intent:
+
+```markdown
+# Proposal: Add Dark Mode
+
+## Intent
+Users have requested a dark mode option to reduce eye strain
+during nighttime usage.
+
+## Scope
+- Add theme toggle in settings
+- Support system preference detection
+- Persist preference in localStorage
+
+## Approach
+Use CSS custom properties for theming with a React context
+for state management.
+```
+
+**specs/ui/spec.md** - Delta showing new requirements:
+
+```markdown
+# Delta for UI
+
+## ADDED Requirements
+
+### Requirement: Theme Selection
+The system SHALL allow users to choose between light and dark themes.
+
+#### Scenario: Manual toggle
+- GIVEN a user on any page
+- WHEN the user clicks the theme toggle
+- THEN the theme switches immediately
+- AND the preference persists across sessions
+
+#### Scenario: System preference
+- GIVEN a user with no saved preference
+- WHEN the application loads
+- THEN the system's preferred color scheme is used
+```
+
+**tasks.md** - Implementation checklist:
+
+```markdown
+# Tasks
+
+## 1. Theme Infrastructure
+- [ ] 1.1 Create ThemeContext with light/dark state
+- [ ] 1.2 Add CSS custom properties for colors
+- [ ] 1.3 Implement localStorage persistence
+
+## 2. UI Components
+- [ ] 2.1 Create ThemeToggle component
+- [ ] 2.2 Add toggle to settings page
+- [ ] 2.3 Update Header to include quick toggle
+
+## 3. Styling
+- [ ] 3.1 Define dark theme color palette
+- [ ] 3.2 Update components to use CSS variables
+```
+
+### 4. Implement
+
+```
+You: /opsx:apply
+
+AI:  Working through tasks...
+     âœ“ 1.1 Created ThemeContext with light/dark state
+     âœ“ 1.2 Added CSS custom properties to globals.css
+     âœ“ 1.3 Implemented localStorage persistence
+     âœ“ 2.1 Created ThemeToggle component
+     ...
+     All tasks complete!
+```
+
+During implementation, if you discover the design needs adjustment, just update the artifact and continue.
+
+### 5. Archive
+
+```
+You: /opsx:archive
+
+AI:  Archiving add-dark-mode...
+     âœ“ Merged specs into openspec/specs/ui/spec.md
+     âœ“ Moved to openspec/changes/archive/2025-01-24-add-dark-mode/
+     Done! Ready for the next feature.
+```
+
+Your delta specs are now part of the main specs, documenting how your system works.
+
+## Verifying and Reviewing
+
+Use the CLI to check on your changes:
+
+```bash
+# List active changes
+openspec list
+
+# View change details
+openspec show add-dark-mode
+
+# Validate spec formatting
+openspec validate add-dark-mode
+
+# Interactive dashboard
+openspec view
+```
+
+## Next Steps
+
+- [Workflows](workflows.md) - Common patterns and when to use each command
+- [Commands](commands.md) - Full reference for all slash commands
+- [Concepts](concepts.md) - Deeper understanding of specs, changes, and schemas
+- [Customization](customization.md) - Make OpenSpec work your way
diff --git a/docs/installation.md b/docs/installation.md
new file mode 100644
index 0000000..7891051
--- /dev/null
+++ b/docs/installation.md
@@ -0,0 +1,79 @@
+# Installation
+
+## Prerequisites
+
+- **Node.js 20.19.0 or higher** â€” Check your version: `node --version`
+
+## Package Managers
+
+### npm
+
+```bash
+npm install -g @fission-ai/openspec@latest
+```
+
+### pnpm
+
+```bash
+pnpm add -g @fission-ai/openspec@latest
+```
+
+### yarn
+
+```bash
+yarn global add @fission-ai/openspec@latest
+```
+
+### bun
+
+```bash
+bun add -g @fission-ai/openspec@latest
+```
+
+## Nix
+
+Run OpenSpec directly without installation:
+
+```bash
+nix run github:Fission-AI/OpenSpec -- init
+```
+
+Or install to your profile:
+
+```bash
+nix profile install github:Fission-AI/OpenSpec
+```
+
+Or add to your development environment in `flake.nix`:
+
+```nix
+{
+  inputs = {
+    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
+    openspec.url = "github:Fission-AI/OpenSpec";
+  };
+
+  outputs = { nixpkgs, openspec, ... }: {
+    devShells.x86_64-linux.default = nixpkgs.legacyPackages.x86_64-linux.mkShell {
+      buildInputs = [ openspec.packages.x86_64-linux.default ];
+    };
+  };
+}
+```
+
+## Verify Installation
+
+```bash
+openspec --version
+```
+
+## Next Steps
+
+After installing, initialize OpenSpec in your project:
+
+```bash
+cd your-project
+openspec init
+```
+
+See [Getting Started](getting-started.md) for a full walkthrough.
diff --git a/docs/migration-guide.md b/docs/migration-guide.md
new file mode 100644
index 0000000..5281904
--- /dev/null
+++ b/docs/migration-guide.md
@@ -0,0 +1,575 @@
+# Migrating to OPSX
+
+This guide helps you transition from the legacy OpenSpec workflow to OPSX. The migration is designed to be smoothâ€”your existing work is preserved, and the new system offers more flexibility.
+
+## What's Changing?
+
+OPSX replaces the old phase-locked workflow with a fluid, action-based approach. Here's the key shift:
+
+| Aspect | Legacy | OPSX |
+|--------|--------|------|
+| **Commands** | `/openspec:proposal`, `/openspec:apply`, `/openspec:archive` | `/opsx:new`, `/opsx:continue`, `/opsx:apply`, and more |
+| **Workflow** | Create all artifacts at once | Create incrementally or all at onceâ€”your choice |
+| **Going back** | Awkward phase gates | Naturalâ€”update any artifact anytime |
+| **Customization** | Fixed structure | Schema-driven, fully hackable |
+| **Configuration** | `CLAUDE.md` with markers + `project.md` | Clean config in `openspec/config.yaml` |
+
+**The philosophy change:** Work isn't linear. OPSX stops pretending it is.
+
+---
+
+## Before You Begin
+
+### Your Existing Work Is Safe
+
+The migration process is designed with preservation in mind:
+
+- **Active changes in `openspec/changes/`** â€” Completely preserved. You can continue them with OPSX commands.
+- **Archived changes** â€” Untouched. Your history remains intact.
+- **Main specs in `openspec/specs/`** â€” Untouched. These are your source of truth.
+- **Your content in CLAUDE.md, AGENTS.md, etc.** â€” Preserved. Only the OpenSpec marker blocks are removed; everything you wrote stays.
+
+### What Gets Removed
+
+Only OpenSpec-managed files that are being replaced:
+
+| What | Why |
+|------|-----|
+| Legacy slash command directories/files | Replaced by the new skills system |
+| `openspec/AGENTS.md` | Obsolete workflow trigger |
+| OpenSpec markers in `CLAUDE.md`, `AGENTS.md`, etc. | No longer needed |
+
+**Legacy command locations by tool** (examplesâ€”your tool may vary):
+
+- Claude Code: `.claude/commands/openspec/`
+- Cursor: `.cursor/commands/openspec-*.md`
+- Windsurf: `.windsurf/workflows/openspec-*.md`
+- Cline: `.clinerules/workflows/openspec-*.md`
+- Roo: `.roo/commands/openspec-*.md`
+- GitHub Copilot: `.github/prompts/openspec-*.prompt.md`
+- And others (Augment, Continue, Amazon Q, etc.)
+
+The migration detects whichever tools you have configured and cleans up their legacy files.
+
+The removal list may seem long, but these are all files that OpenSpec originally created. Your own content is never deleted.
+
+### What Needs Your Attention
+
+One file requires manual migration:
+
+**`openspec/project.md`** â€” This file isn't deleted automatically because it may contain project context you've written. You'll need to:
+
+1. Review its contents
+2. Move useful context to `openspec/config.yaml` (see guidance below)
+3. Delete the file when ready
+
+**Why we made this change:**
+
+The old `project.md` was passiveâ€”agents might read it, might not, might forget what they read. We found reliability was inconsistent.
+
+The new `config.yaml` context is **actively injected into every OpenSpec planning request**. This means your project conventions, tech stack, and rules are always present when the AI is creating artifacts. Higher reliability.
+
+**The tradeoff:**
+
+Because context is injected into every request, you'll want to be concise. Focus on what really matters:
+- Tech stack and key conventions
+- Non-obvious constraints the AI needs to know
+- Rules that frequently got ignored before
+
+Don't worry about getting it perfect. We're still learning what works best here, and we'll be improving how context injection works as we experiment.
+
+---
+
+## Running the Migration
+
+Both `openspec init` and `openspec update` detect legacy files and guide you through the same cleanup process. Use whichever fits your situation:
+
+### Using `openspec init`
+
+Run this if you want to add new tools or reconfigure which tools are set up:
+
+```bash
+openspec init
+```
+
+The init command detects legacy files and guides you through cleanup:
+
+```
+Upgrading to the new OpenSpec
+
+OpenSpec now uses agent skills, the emerging standard across coding
+agents. This simplifies your setup while keeping everything working
+as before.
+
+Files to remove
+No user content to preserve:
+  â€¢ .claude/commands/openspec/
+  â€¢ openspec/AGENTS.md
+
+Files to update
+OpenSpec markers will be removed, your content preserved:
+  â€¢ CLAUDE.md
+  â€¢ AGENTS.md
+
+Needs your attention
+  â€¢ openspec/project.md
+    We won't delete this file. It may contain useful project context.
+
+    The new openspec/config.yaml has a "context:" section for planning
+    context. This is included in every OpenSpec request and works more
+    reliably than the old project.md approach.
+
+    Review project.md, move any useful content to config.yaml's context
+    section, then delete the file when ready.
+
+? Upgrade and clean up legacy files? (Y/n)
+```
+
+**What happens when you say yes:**
+
+1. Legacy slash command directories are removed
+2. OpenSpec markers are stripped from `CLAUDE.md`, `AGENTS.md`, etc. (your content stays)
+3. `openspec/AGENTS.md` is deleted
+4. New skills are installed in `.claude/skills/`
+5. `openspec/config.yaml` is created with a default schema
+
+### Using `openspec update`
+
+Run this if you just want to migrate and refresh your existing tools to the latest version:
+
+```bash
+openspec update
+```
+
+The update command also detects and cleans up legacy artifacts, then refreshes your skills to the latest version.
+
+### Non-Interactive / CI Environments
+
+For scripted migrations:
+
+```bash
+openspec init --force --tools claude
+```
+
+The `--force` flag skips prompts and auto-accepts cleanup.
+
+---
+
+## Migrating project.md to config.yaml
+
+The old `openspec/project.md` was a freeform markdown file for project context. The new `openspec/config.yaml` is structured andâ€”criticallyâ€”**injected into every planning request** so your conventions are always present when the AI works.
+
+### Before (project.md)
+
+```markdown
+# Project Context
+
+This is a TypeScript monorepo using React and Node.js.
+We use Jest for testing and follow strict ESLint rules.
+Our API is RESTful and documented in docs/api.md.
+
+## Conventions
+
+- All public APIs must maintain backwards compatibility
+- New features should include tests
+- Use Given/When/Then format for specifications
+```
+
+### After (config.yaml)
+
+```yaml
+schema: spec-driven
+
+context: |
+  Tech stack: TypeScript, React, Node.js
+  Testing: Jest with React Testing Library
+  API: RESTful, documented in docs/api.md
+  We maintain backwards compatibility for all public APIs
+
+rules:
+  proposal:
+    - Include rollback plan for risky changes
+  specs:
+    - Use Given/When/Then format for scenarios
+    - Reference existing patterns before inventing new ones
+  design:
+    - Include sequence diagrams for complex flows
+```
+
+### Key Differences
+
+| project.md | config.yaml |
+|------------|-------------|
+| Freeform markdown | Structured YAML |
+| One blob of text | Separate context and per-artifact rules |
+| Unclear when it's used | Context appears in ALL artifacts; rules appear in matching artifacts only |
+| No schema selection | Explicit `schema:` field sets default workflow |
+
+### What to Keep, What to Drop
+
+When migrating, be selective. Ask yourself: "Does the AI need this for *every* planning request?"
+
+**Good candidates for `context:`**
+- Tech stack (languages, frameworks, databases)
+- Key architectural patterns (monorepo, microservices, etc.)
+- Non-obvious constraints ("we can't use library X because...")
+- Critical conventions that often get ignored
+
+**Move to `rules:` instead**
+- Artifact-specific formatting ("use Given/When/Then in specs")
+- Review criteria ("proposals must include rollback plans")
+- These only appear for the matching artifact, keeping other requests lighter
+
+**Leave out entirely**
+- General best practices the AI already knows
+- Verbose explanations that could be summarized
+- Historical context that doesn't affect current work
+
+### Migration Steps
+
+1. **Create config.yaml** (if not already created by init):
+   ```yaml
+   schema: spec-driven
+   ```
+
+2. **Add your context** (be conciseâ€”this goes into every request):
+   ```yaml
+   context: |
+     Your project background goes here.
+     Focus on what the AI genuinely needs to know.
+   ```
+
+3. **Add per-artifact rules** (optional):
+   ```yaml
+   rules:
+     proposal:
+       - Your proposal-specific guidance
+     specs:
+       - Your spec-writing rules
+   ```
+
+4. **Delete project.md** once you've moved everything useful.
+
+**Don't overthink it.** Start with the essentials and iterate. If you notice the AI missing something important, add it. If context feels bloated, trim it. This is a living document.
+
+### Need Help? Use This Prompt
+
+If you're unsure how to distill your project.md, ask your AI assistant:
+
+```
+I'm migrating from OpenSpec's old project.md to the new config.yaml format.
+
+Here's my current project.md:
+[paste your project.md content]
+
+Please help me create a config.yaml with:
+1. A concise `context:` section (this gets injected into every planning request, so keep it tightâ€”focus on tech stack, key constraints, and conventions that often get ignored)
+2. `rules:` for specific artifacts if any content is artifact-specific (e.g., "use Given/When/Then" belongs in specs rules, not global context)
+
+Leave out anything generic that AI models already know. Be ruthless about brevity.
+```
+
+The AI will help you identify what's essential vs. what can be trimmed.
+
+---
+
+## The New Commands
+
+After migration, you have 9 OPSX commands instead of 3:
+
+| Command | Purpose |
+|---------|---------|
+| `/opsx:explore` | Think through ideas with no structure |
+| `/opsx:new` | Start a new change |
+| `/opsx:continue` | Create the next artifact (one at a time) |
+| `/opsx:ff` | Fast-forwardâ€”create all planning artifacts at once |
+| `/opsx:apply` | Implement tasks from tasks.md |
+| `/opsx:verify` | Validate implementation matches specs |
+| `/opsx:sync` | Preview spec merge (optionalâ€”archive prompts if needed) |
+| `/opsx:archive` | Finalize and archive the change |
+| `/opsx:bulk-archive` | Archive multiple changes at once |
+
+### Command Mapping from Legacy
+
+| Legacy | OPSX Equivalent |
+|--------|-----------------|
+| `/openspec:proposal` | `/opsx:new` then `/opsx:ff` |
+| `/openspec:apply` | `/opsx:apply` |
+| `/openspec:archive` | `/opsx:archive` |
+
+### New Capabilities
+
+**Granular artifact creation:**
+```
+/opsx:continue
+```
+Creates one artifact at a time based on dependencies. Use this when you want to review each step.
+
+**Exploration mode:**
+```
+/opsx:explore
+```
+Think through ideas with a partner before committing to a change.
+
+---
+
+## Understanding the New Architecture
+
+### From Phase-Locked to Fluid
+
+The legacy workflow forced linear progression:
+
+```
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚   PLANNING   â”‚ â”€â”€â”€â–º â”‚ IMPLEMENTING â”‚ â”€â”€â”€â–º â”‚   ARCHIVING  â”‚
+â”‚    PHASE     â”‚      â”‚    PHASE     â”‚      â”‚    PHASE     â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+
+If you're in implementation and realize the design is wrong?
+Too bad. Phase gates don't let you go back easily.
+```
+
+OPSX uses actions, not phases:
+
+```
+         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+         â”‚           ACTIONS (not phases)         â”‚
+         â”‚                                        â”‚
+         â”‚     new â—„â”€â”€â–º continue â—„â”€â”€â–º apply â—„â”€â”€â–º archive â”‚
+         â”‚      â”‚          â”‚           â”‚           â”‚   â”‚
+         â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
+         â”‚              any order                     â”‚
+         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+```
+
+### Dependency Graph
+
+Artifacts form a directed graph. Dependencies are enablers, not gates:
+
+```
+                        proposal
+                       (root node)
+                            â”‚
+              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+              â”‚                           â”‚
+              â–¼                           â–¼
+           specs                       design
+        (requires:                  (requires:
+         proposal)                   proposal)
+              â”‚                           â”‚
+              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+                            â”‚
+                            â–¼
+                         tasks
+                     (requires:
+                     specs, design)
+```
+
+When you run `/opsx:continue`, it checks what's ready and offers the next artifact. You can also create multiple ready artifacts in any order.
+
+### Skills vs Commands
+
+The legacy system used tool-specific command files:
+
+```
+.claude/commands/openspec/
+â”œâ”€â”€ proposal.md
+â”œâ”€â”€ apply.md
+â””â”€â”€ archive.md
+```
+
+OPSX uses the emerging **skills** standard:
+
+```
+.claude/skills/
+â”œâ”€â”€ openspec-explore/SKILL.md
+â”œâ”€â”€ openspec-new-change/SKILL.md
+â”œâ”€â”€ openspec-continue-change/SKILL.md
+â”œâ”€â”€ openspec-apply-change/SKILL.md
+â””â”€â”€ ...
+```
+
+Skills are recognized across multiple AI coding tools and provide richer metadata.
+
+---
+
+## Continuing Existing Changes
+
+Your in-progress changes work seamlessly with OPSX commands.
+
+**Have an active change from the legacy workflow?**
+
+```
+/opsx:apply add-my-feature
+```
+
+OPSX reads the existing artifacts and continues from where you left off.
+
+**Want to add more artifacts to an existing change?**
+
+```
+/opsx:continue add-my-feature
+```
+
+Shows what's ready to create based on what already exists.
+
+**Need to see status?**
+
+```bash
+openspec status --change add-my-feature
+```
+
+---
+
+## The New Config System
+
+### config.yaml Structure
+
+```yaml
+# Required: Default schema for new changes
+schema: spec-driven
+
+# Optional: Project context (max 50KB)
+# Injected into ALL artifact instructions
+context: |
+  Your project background, tech stack,
+  conventions, and constraints.
+
+# Optional: Per-artifact rules
+# Only injected into matching artifacts
+rules:
+  proposal:
+    - Include rollback plan
+  specs:
+    - Use Given/When/Then format
+  design:
+    - Document fallback strategies
+  tasks:
+    - Break into 2-hour maximum chunks
+```
+
+### Schema Resolution
+
+When determining which schema to use, OPSX checks in order:
+
+1. **CLI flag**: `--schema <name>` (highest priority)
+2. **Change metadata**: `.openspec.yaml` in the change directory
+3. **Project config**: `openspec/config.yaml`
+4. **Default**: `spec-driven`
+
+### Available Schemas
+
+| Schema | Artifacts | Best For |
+|--------|-----------|----------|
+| `spec-driven` | proposal â†’ specs â†’ design â†’ tasks | Most projects |
+
+List all available schemas:
+
+```bash
+openspec schemas
+```
+
+### Custom Schemas
+
+Create your own workflow:
+
+```bash
+openspec schema init my-workflow
+```
+
+Or fork an existing one:
+
+```bash
+openspec schema fork spec-driven my-workflow
+```
+
+See [Customization](customization.md) for details.
+
+---
+
+## Troubleshooting
+
+### "Legacy files detected in non-interactive mode"
+
+You're running in a CI or non-interactive environment. Use:
+
+```bash
+openspec init --force
+```
+
+### Commands not appearing after migration
+
+Restart your IDE. Skills are detected at startup.
+
+### "Unknown artifact ID in rules"
+
+Check that your `rules:` keys match your schema's artifact IDs:
+
+- **spec-driven**: `proposal`, `specs`, `design`, `tasks`
+
+Run this to see valid artifact IDs:
+
+```bash
+openspec schemas --json
+```
+
+### Config not being applied
+
+1. Ensure the file is at `openspec/config.yaml` (not `.yml`)
+2. Validate YAML syntax
+3. Config changes take effect immediatelyâ€”no restart needed
+
+### project.md not migrated
+
+The system intentionally preserves `project.md` because it may contain your custom content. Review it manually, move useful parts to `config.yaml`, then delete it.
+
+### Want to see what would be cleaned up?
+
+Run init and decline the cleanup promptâ€”you'll see the full detection summary without any changes being made.
+
+---
+
+## Quick Reference
+
+### Files After Migration
+
+```
+project/
+â”œâ”€â”€ openspec/
+â”‚   â”œâ”€â”€ specs/                    # Unchanged
+â”‚   â”œâ”€â”€ changes/                  # Unchanged
+â”‚   â”‚   â””â”€â”€ archive/              # Unchanged
+â”‚   â””â”€â”€ config.yaml               # NEW: Project configuration
+â”œâ”€â”€ .claude/
+â”‚   â””â”€â”€ skills/                   # NEW: OPSX skills
+â”‚       â”œâ”€â”€ openspec-explore/
+â”‚       â”œâ”€â”€ openspec-new-change/
+â”‚       â””â”€â”€ ...
+â”œâ”€â”€ CLAUDE.md                     # OpenSpec markers removed, your content preserved
+â””â”€â”€ AGENTS.md                     # OpenSpec markers removed, your content preserved
+```
+
+### What's Gone
+
+- `.claude/commands/openspec/` â€” replaced by `.claude/skills/`
+- `openspec/AGENTS.md` â€” obsolete
+- `openspec/project.md` â€” migrate to `config.yaml`, then delete
+- OpenSpec marker blocks in `CLAUDE.md`, `AGENTS.md`, etc.
+
+### Command Cheatsheet
+
+```
+/opsx:new          Start a change
+/opsx:continue     Create next artifact
+/opsx:ff           Create all planning artifacts
+/opsx:apply        Implement tasks
+/opsx:archive      Finish and archive
+```
+
+---
+
+## Getting Help
+
+- **Discord**: [discord.gg/YctCnvvshC](https://discord.gg/YctCnvvshC)
+- **GitHub Issues**: [github.com/Fission-AI/OpenSpec/issues](https://github.com/Fission-AI/OpenSpec/issues)
+- **Documentation**: [docs/opsx.md](opsx.md) for the full OPSX reference
diff --git a/docs/multi-language.md b/docs/multi-language.md
new file mode 100644
index 0000000..0dfb91a
--- /dev/null
+++ b/docs/multi-language.md
@@ -0,0 +1,115 @@
+# Multi-Language Guide
+
+Configure OpenSpec to generate artifacts in languages other than English.
+
+## Quick Setup
+
+Add a language instruction to your `openspec/config.yaml`:
+
+```yaml
+schema: spec-driven
+
+context: |
+  Language: Portuguese (pt-BR)
+  All artifacts must be written in Brazilian Portuguese.
+
+  # Your other project context below...
+  Tech stack: TypeScript, React, Node.js
+```
+
+That's it. All generated artifacts will now be in Portuguese.
+
+## Language Examples
+
+### Portuguese (Brazil)
+
+```yaml
+context: |
+  Language: Portuguese (pt-BR)
+  All artifacts must be written in Brazilian Portuguese.
+```
+
+### Spanish
+
+```yaml
+context: |
+  Idioma: EspaÃ±ol
+  Todos los artefactos deben escribirse en espaÃ±ol.
+```
+
+### Chinese (Simplified)
+
+```yaml
+context: |
+  è¯­è¨€ï¼šä¸­æ–‡ï¼ˆç®€ä½“ï¼‰
+  æ‰€æœ‰äº§å‡ºç‰©å¿…é¡»ç”¨ç®€ä½“ä¸­æ–‡æ’°å†™ã€‚
+```
+
+### Japanese
+
+```yaml
+context: |
+  è¨€èªï¼šæ—¥æœ¬èª
+  ã™ã¹ã¦ã®æˆæœç‰©ã¯æ—¥æœ¬èªã§ä½œæˆã—ã¦ãã ã•ã„ã€‚
+```
+
+### French
+
+```yaml
+context: |
+  Langue : FranÃ§ais
+  Tous les artefacts doivent Ãªtre rÃ©digÃ©s en franÃ§ais.
+```
+
+### German
+
+```yaml
+context: |
+  Sprache: Deutsch
+  Alle Artefakte mÃ¼ssen auf Deutsch verfasst werden.
+```
+
+## Tips
+
+### Handle Technical Terms
+
+Decide how to handle technical terminology:
+
+```yaml
+context: |
+  Language: Japanese
+  Write in Japanese, but:
+  - Keep technical terms like "API", "REST", "GraphQL" in English
+  - Code examples and file paths remain in English
+```
+
+### Combine with Other Context
+
+Language settings work alongside your other project context:
+
+```yaml
+schema: spec-driven
+
+context: |
+  Language: Portuguese (pt-BR)
+  All artifacts must be written in Brazilian Portuguese.
+
+  Tech stack: TypeScript, React 18, Node.js 20
+  Database: PostgreSQL with Prisma ORM
+```
+
+## Verification
+
+To verify your language config is working:
+
+```bash
+# Check the instructions - should show your language context
+openspec instructions proposal --change my-change
+
+# Output will include your language context
+```
+
+## Related Documentation
+
+- [Customization Guide](./customization.md) - Project configuration options
+- [Workflows Guide](./workflows.md) - Full workflow documentation
diff --git a/docs/experimental-workflow.md b/docs/opsx.md
similarity index 94%
rename from docs/experimental-workflow.md
rename to docs/opsx.md
index 3bb9875..39fd0fc 100644
--- a/docs/experimental-workflow.md
+++ b/docs/opsx.md
@@ -1,8 +1,6 @@
-# Experimental Workflow (OPSX)
+# OPSX Workflow
 
-> **Status:** Experimental. Things might break. Feedback welcome on [Discord](https://discord.gg/YctCnvvshC).
->
-> **Compatibility:** Claude Code only (for now)
+> **Compatibility:** Claude Code only (for now). Feedback welcome on [Discord](https://discord.gg/YctCnvvshC).
 
 ## What Is It?
 
@@ -51,19 +49,9 @@ You're "in planning phase", then "in implementation phase", then "done". But rea
 **OPSX approach:**
 - **Actions, not phases** â€” create, implement, update, archive â€” do any of them anytime
 - **Dependencies are enablers** â€” they show what's possible, not what's required next
-- **Update as you learn** â€” halfway through implementation? Go back and fix the design. That's normal.
 
 ```
-You can always go back:
-
-     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-     â”‚                                    â”‚
-     â–¼                                    â”‚
   proposal â”€â”€â†’ specs â”€â”€â†’ design â”€â”€â†’ tasks â”€â”€â†’ implement
-     â–²           â–²          â–²               â”‚
-     â”‚           â”‚          â”‚               â”‚
-     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-              update as you learn
 ```
 
 ## Setup
@@ -73,7 +61,7 @@ You can always go back:
 openspec init
 
 # 2. Generate the experimental skills
-openspec artifact-experimental-setup
+openspec experimental
 ```
 
 This creates skills in `.claude/skills/` that Claude Code auto-detects.
@@ -86,7 +74,7 @@ Project config lets you set defaults and inject project-specific context into al
 
 ### Creating Config
 
-Config is created during `artifact-experimental-setup`, or manually:
+Config is created during `experimental`, or manually:
 
 ```yaml
 # openspec/config.yaml
@@ -112,14 +100,14 @@ rules:
 
 | Field | Type | Description |
 |-------|------|-------------|
-| `schema` | string | Default schema for new changes (e.g., `spec-driven`, `tdd`) |
+| `schema` | string | Default schema for new changes (e.g., `spec-driven`) |
 | `context` | string | Project context injected into all artifact instructions |
 | `rules` | object | Per-artifact rules, keyed by artifact ID |
 
 ### How It Works
 
 **Schema precedence** (highest to lowest):
-1. CLI flag (`--schema tdd`)
+1. CLI flag (`--schema <name>`)
 2. Change metadata (`.openspec.yaml` in change directory)
 3. Project config (`openspec/config.yaml`)
 4. Default (`spec-driven`)
@@ -142,12 +130,6 @@ rules:
 - `design` â€” Technical design
 - `tasks` â€” Implementation tasks
 
-**tdd**:
-- `spec` â€” Feature specification
-- `tests` â€” Test file
-- `implementation` â€” Implementation code
-- `docs` â€” Documentation
-
 ### Config Validation
 
 - Unknown artifact IDs in `rules` generate warnings
@@ -179,7 +161,7 @@ rules:
 | `/opsx:continue` | Create the next artifact (based on what's ready) |
 | `/opsx:ff` | Fast-forward â€” create all planning artifacts at once |
 | `/opsx:apply` | Implement tasks, updating artifacts as needed |
-| `/opsx:sync` | Sync delta specs to main specs |
+| `/opsx:sync` | Sync delta specs to main (optionalâ€”archive prompts if needed) |
 | `/opsx:archive` | Archive when done |
 
 ## Usage
@@ -211,17 +193,16 @@ Creates all planning artifacts at once. Use when you have a clear picture of wha
 ```
 /opsx:apply
 ```
-Works through tasks, checking them off as you go. **Key difference:** if you discover issues during implementation, you can update your specs, design, or tasks â€” then continue. No phase gates. If you're juggling multiple changes, you can run `/opsx:apply <name>`; otherwise it should infer from the conversation and prompt you to choose if it canâ€™t tell.
+Works through tasks, checking them off as you go. If you're juggling multiple changes, you can run `/opsx:apply <name>`; otherwise it should infer from the conversation and prompt you to choose if it can't tell.
 
 ### Finish up
 ```
-/opsx:sync      # Update main specs with your delta specs
-/opsx:archive   # Move to archive when done
+/opsx:archive   # Move to archive when done (prompts to sync specs if needed)
 ```
 
 ## When to Update vs. Start Fresh
 
-OPSX lets you update artifacts anytime. But when does "update as you learn" become "this is different work"?
+You can always edit your proposal or specs before implementation. But when does refining become "this is different work"?
 
 ### What a Proposal Captures
 
@@ -351,9 +332,9 @@ This section explains how OPSX works under the hood and how it compares to the s
 â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
 â”‚              â”‚           ACTIONS (not phases)             â”‚                 â”‚
 â”‚              â”‚                                            â”‚                 â”‚
-â”‚              â”‚   new â—„â”€â”€â–º continue â—„â”€â”€â–º apply â—„â”€â”€â–º sync   â”‚                 â”‚
-â”‚              â”‚    â”‚          â”‚           â”‚          â”‚     â”‚                 â”‚
-â”‚              â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚                 â”‚
+â”‚              â”‚   new â—„â”€â”€â–º continue â—„â”€â”€â–º apply â—„â”€â”€â–º archive â”‚                 â”‚
+â”‚              â”‚    â”‚          â”‚           â”‚           â”‚    â”‚                 â”‚
+â”‚              â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚                 â”‚
 â”‚              â”‚              any order                     â”‚                 â”‚
 â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
 â”‚                                                                             â”‚
@@ -476,7 +457,7 @@ Artifacts form a directed acyclic graph (DAG). Dependencies are **enablers**, no
   â”‚  â€¢ Create proposal.md                   â”‚
   â”‚  â€¢ Create tasks.md                      â”‚
   â”‚  â€¢ Create design.md                     â”‚
-  â”‚  â€¢ Create specs/*.md                    â”‚
+  â”‚  â€¢ Create specs/<capability>/spec.md    â”‚
   â”‚                                         â”‚
   â”‚  No awareness of what exists or         â”‚
   â”‚  dependencies between artifacts         â”‚
@@ -631,7 +612,6 @@ artifacts:
 Schemas define what artifacts exist and their dependencies. Currently available:
 
 - **spec-driven** (default): proposal â†’ specs â†’ design â†’ tasks
-- **tdd**: tests â†’ implementation â†’ docs
 
 ```bash
 # List available schemas
diff --git a/docs/project-config-demo.md b/docs/project-config-demo.md
deleted file mode 100644
index 7a37cd4..0000000
--- a/docs/project-config-demo.md
+++ /dev/null
@@ -1,205 +0,0 @@
-# Project Config Demo Guide
-
-A quick-reference guide for demonstrating the `openspec/config.yaml` feature.
-
-## Summary: What Project Config Does
-
-The feature adds `openspec/config.yaml` as a lightweight customization layer that lets teams:
-
-- **Set a default schema** - New changes automatically use this schema instead of having to specify `--schema` every time
-- **Inject project context** - Shared context (tech stack, conventions) shown to AI when creating any artifact
-- **Add per-artifact rules** - Custom rules that only apply to specific artifacts (e.g., proposal, specs)
-
-## Demo Walkthrough
-
-### Demo 1: Interactive Setup (Recommended Entry Point)
-
-The easiest way to demo is through the experimental setup command:
-
-```bash
-openspec artifact-experimental-setup
-```
-
-After creating skills/commands, it will prompt:
-
-```
-â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
-
-ğŸ“‹ Project Configuration (Optional)
-
-Configure project defaults for OpenSpec workflows.
-
-? Create openspec/config.yaml? (Y/n)
-```
-
-Walk through:
-
-1. **Select schema** - Shows available schemas with their artifact flows
-2. **Add context** - Opens editor for multi-line project context (tech stack, conventions)
-3. **Add rules** - Checkbox to select artifacts, then line-by-line rule entry
-
-This creates `openspec/config.yaml` with the user's choices.
-
-### Demo 2: Manual Config Creation
-
-Show that users can create the config directly:
-
-```bash
-cat > openspec/config.yaml << 'EOF'
-schema: spec-driven
-
-context: |
-  Tech stack: TypeScript, React, Node.js, PostgreSQL
-  API style: RESTful, documented in docs/api.md
-  Testing: Jest + React Testing Library
-  We value backwards compatibility for all public APIs
-
-rules:
-  proposal:
-    - Include rollback plan
-    - Identify affected teams and notify in #platform-changes
-  specs:
-    - Use Given/When/Then format
-    - Reference existing patterns before inventing new ones
-EOF
-```
-
-### Demo 3: Effect on New Changes
-
-Show that creating a new change now uses the default schema:
-
-```bash
-# Before config: had to specify schema
-openspec new change my-feature --schema spec-driven
-
-# After config: schema is automatic
-openspec new change my-feature
-# Automatically uses spec-driven from config
-```
-
-### Demo 4: Context and Rules Injection
-
-The key demo moment - show how instructions are enriched:
-
-```bash
-# Get instructions for an artifact
-openspec instructions proposal --change my-feature
-```
-
-Output shows the XML structure:
-
-```xml
-<context>
-Tech stack: TypeScript, React, Node.js, PostgreSQL
-API style: RESTful, documented in docs/api.md
-...
-</context>
-
-<rules>
-- Include rollback plan
-- Identify affected teams and notify in #platform-changes
-</rules>
-
-<template>
-[Schema's built-in proposal template]
-</template>
-```
-
-Key points to highlight:
-
-- **Context** appears in ALL artifacts (proposal, specs, design, tasks)
-- **Rules** ONLY appear for the matching artifact (proposal rules only in proposal instructions)
-
-### Demo 5: Precedence Override
-
-Show the schema resolution order:
-
-```bash
-# Config sets schema: spec-driven
-
-# 1. CLI flag wins
-openspec new change feature-a --schema tdd  # Uses tdd
-
-# 2. Change metadata wins over config
-# (if .openspec.yaml in change directory specifies schema)
-
-# 3. Config is used as default
-openspec new change feature-b  # Uses spec-driven from config
-
-# 4. Hardcoded default (no config)
-# Would fall back to spec-driven anyway
-```
-
-### Demo 6: Validation and Error Handling
-
-Show graceful error handling:
-
-```bash
-# Create config with typo
-echo "schema: spec-drivne" > openspec/config.yaml
-
-# Try to use it - shows fuzzy matching suggestions
-openspec new change test
-# Schema 'spec-drivne' not found
-# Did you mean: spec-driven (built-in)
-```
-
-```bash
-# Unknown artifact ID in rules - warns but doesn't halt
-cat > openspec/config.yaml << 'EOF'
-schema: spec-driven
-rules:
-  testplan:  # Schema doesn't have this
-    - Some rule
-EOF
-
-openspec instructions proposal --change test
-# âš ï¸ Unknown artifact ID in rules: "testplan". Valid IDs for schema "spec-driven": ...
-# (continues working)
-```
-
-## Quick Demo Script
-
-Here's a quick all-in-one demo:
-
-```bash
-# 1. Show there's no config initially
-cat openspec/config.yaml 2>/dev/null || echo "No config exists"
-
-# 2. Create a simple config
-cat > openspec/config.yaml << 'EOF'
-schema: spec-driven
-context: |
-  This is a demo project using React and TypeScript.
-  We follow semantic versioning.
-rules:
-  proposal:
-    - Include migration steps if breaking change
-EOF
-
-# 3. Show the config
-cat openspec/config.yaml
-
-# 4. Create a change (uses default schema from config)
-openspec new change demo-feature
-
-# 5. Show instructions with injected context/rules
-openspec instructions proposal --change demo-feature | head -30
-
-# 6. Show that specs don't have proposal rules
-openspec instructions specs --change demo-feature | head -30
-```
-
-## What to Emphasize in Demo
-
-- **Low friction** - Teams can customize without forking schemas
-- **Shared context** - Everyone on the team gets the same project knowledge
-- **Per-artifact rules** - Targeted guidance where it matters
-- **Graceful failures** - Typos warn, don't break workflow
-- **Team sharing** - Just commit `openspec/config.yaml` and everyone benefits
-
-## Related Documentation
-
-- [Experimental Workflow Guide](./experimental-workflow.md) - Full user guide with config section
-- [Project Config Proposal](../openspec/changes/project-config/proposal.md) - Original design proposal
-- [Project Config Design](../openspec/changes/project-config/design.md) - Technical implementation details
diff --git a/docs/schema-customization.md b/docs/schema-customization.md
deleted file mode 100644
index d4cc3f2..0000000
--- a/docs/schema-customization.md
+++ /dev/null
@@ -1,211 +0,0 @@
-# Schema Customization
-
-This document describes how users can customize OpenSpec schemas and templates, the current manual process, and the gap that needs to be addressed.
-
----
-
-## Overview
-
-OpenSpec uses a 2-level schema resolution system following the XDG Base Directory Specification:
-
-1. **User override**: `${XDG_DATA_HOME}/openspec/schemas/<name>/`
-2. **Package built-in**: `<npm-package>/schemas/<name>/`
-
-When a schema is requested (e.g., `spec-driven`), the resolver checks the user directory first. If found, that entire schema directory is used. Otherwise, it falls back to the package's built-in schema.
-
----
-
-## Current Manual Process
-
-To override the default `spec-driven` schema, a user must:
-
-### 1. Determine the correct directory path
-
-| Platform | Path |
-|----------|------|
-| macOS/Linux | `~/.local/share/openspec/schemas/` |
-| Windows | `%LOCALAPPDATA%\openspec\schemas\` |
-| All (if set) | `$XDG_DATA_HOME/openspec/schemas/` |
-
-### 2. Create the directory structure
-
-```bash
-# macOS/Linux example
-mkdir -p ~/.local/share/openspec/schemas/spec-driven/templates
-```
-
-### 3. Find and copy the default schema files
-
-The user must locate the installed npm package to copy the defaults:
-
-```bash
-# Find the package location (varies by install method)
-npm list -g openspec --parseable
-# or
-which openspec && readlink -f $(which openspec)
-
-# Copy files from the package's schemas/ directory
-cp <package-path>/schemas/spec-driven/schema.yaml ~/.local/share/openspec/schemas/spec-driven/
-cp <package-path>/schemas/spec-driven/templates/*.md ~/.local/share/openspec/schemas/spec-driven/templates/
-```
-
-### 4. Modify the copied files
-
-Edit `schema.yaml` to change the workflow structure:
-
-```yaml
-name: spec-driven
-version: 1
-description: My custom workflow
-artifacts:
-  - id: proposal
-    generates: proposal.md
-    description: Initial proposal
-    template: proposal.md
-    requires: []
-  # Add, remove, or modify artifacts...
-```
-
-Edit templates in `templates/` to customize the content guidance.
-
-### 5. Verify the override is active
-
-Currently there's no command to verify which schema is being used. Users must trust that the file exists in the right location.
-
----
-
-## Gap Analysis
-
-The current process has several friction points:
-
-| Issue | Impact |
-|-------|--------|
-| **Path discovery** | Users must know XDG conventions and platform-specific paths |
-| **Package location** | Finding the npm package path varies by install method (global, local, pnpm, yarn, volta, etc.) |
-| **No scaffolding** | Users must manually create directories and copy files |
-| **No verification** | No way to confirm which schema is actually being resolved |
-| **No diffing** | When upgrading openspec, users can't see what changed in built-in templates |
-| **Full copy required** | Must copy entire schema even to change one template |
-
-### User Stories Not Currently Supported
-
-1. *"I want to add a `research` artifact before `proposal`"* â€” requires manual copy and edit
-2. *"I want to customize just the proposal template"* â€” must copy entire schema
-3. *"I want to see what the default schema looks like"* â€” must find package path
-4. *"I want to revert to defaults"* â€” must delete files and hope paths are correct
-5. *"I upgraded openspec, did the templates change?"* â€” no way to diff
-
----
-
-## Proposed Solution: Schema Configurator
-
-A CLI command (or set of commands) that handles path resolution and file operations for users.
-
-### Option A: Single `openspec schema` command
-
-```bash
-# List available schemas (built-in and user overrides)
-openspec schema list
-
-# Show where a schema resolves from
-openspec schema which spec-driven
-# Output: /Users/me/.local/share/openspec/schemas/spec-driven/ (user override)
-# Output: /usr/local/lib/node_modules/openspec/schemas/spec-driven/ (built-in)
-
-# Copy a built-in schema to user directory for customization
-openspec schema copy spec-driven
-# Creates ~/.local/share/openspec/schemas/spec-driven/ with all files
-
-# Show diff between user override and built-in
-openspec schema diff spec-driven
-
-# Remove user override (revert to built-in)
-openspec schema reset spec-driven
-
-# Validate a schema
-openspec schema validate spec-driven
-```
-
-### Option B: Dedicated `openspec customize` command
-
-```bash
-# Interactive schema customization
-openspec customize
-# Prompts: Which schema? What do you want to change? etc.
-
-# Copy and open for editing
-openspec customize spec-driven
-# Copies to user dir, prints path, optionally opens in $EDITOR
-```
-
-### Option C: Init-time schema selection
-
-```bash
-# During project init, offer schema customization
-openspec init
-# ? Select a workflow schema:
-#   > spec-driven (default)
-#     tdd
-#     minimal
-#     custom (copy and edit)
-```
-
-### Recommended Approach
-
-**Option A** provides the most flexibility and follows Unix conventions (subcommands for discrete operations). Key commands in priority order:
-
-1. `openspec schema list` â€” see what's available
-2. `openspec schema which <name>` â€” debug resolution
-3. `openspec schema copy <name>` â€” scaffold customization
-4. `openspec schema diff <name>` â€” compare with built-in
-5. `openspec schema reset <name>` â€” revert to defaults
-
----
-
-## Implementation Considerations
-
-### Path Resolution
-
-The resolver already exists in `src/core/artifact-graph/resolver.ts`:
-
-```typescript
-export function getPackageSchemasDir(): string { ... }
-export function getUserSchemasDir(): string { ... }
-export function getSchemaDir(name: string): string | null { ... }
-export function listSchemas(): string[] { ... }
-```
-
-New commands would leverage these existing functions.
-
-### File Operations
-
-- Copy should preserve file permissions
-- Copy should not overwrite existing user files without `--force`
-- Reset should prompt for confirmation
-
-### Template-Only Overrides
-
-A future enhancement could support overriding individual templates without copying the entire schema. This would require changes to the resolution logic:
-
-```
-Current: schema dir (user) OR schema dir (built-in)
-Future:  schema.yaml from user OR built-in
-         + each template from user OR built-in (independent fallback)
-```
-
-This adds complexity but enables the "I just want to change one template" use case.
-
----
-
-## Related Documents
-
-- [Schema Workflow Gaps](./schema-workflow-gaps.md) â€” End-to-end workflow analysis and phased implementation plan
-
-## Related Files
-
-| File | Purpose |
-|------|---------|
-| `src/core/artifact-graph/resolver.ts` | Schema resolution logic |
-| `src/core/artifact-graph/instruction-loader.ts` | Template loading |
-| `src/core/global-config.ts` | XDG path helpers |
-| `schemas/spec-driven/` | Default schema and templates |
diff --git a/docs/schema-workflow-gaps.md b/docs/schema-workflow-gaps.md
deleted file mode 100644
index 27d76b1..0000000
--- a/docs/schema-workflow-gaps.md
+++ /dev/null
@@ -1,379 +0,0 @@
-# Schema Workflow: End-to-End Analysis
-
-This document analyzes the complete user journey for working with schemas in OpenSpec, identifies gaps, and proposes a phased solution.
-
----
-
-## Current State
-
-### What Exists
-
-| Component | Status |
-|-----------|--------|
-| Schema resolution | 3-level: project â†’ user â†’ package (PR #522) |
-| Built-in schemas | `spec-driven`, `tdd` |
-| Artifact workflow commands | `status`, `next`, `instructions`, `templates` with `--schema` flag |
-| Change creation | `openspec new change <name>` â€” no schema binding |
-| Project-local schemas | âœ… Supported via `openspec/schemas/` (PR #522) |
-| Schema management CLI | âœ… `schema which`, `validate`, `fork`, `init` (PR #525) |
-
-### What's Missing
-
-| Component | Status |
-|-----------|--------|
-| Schema bound to change | Not stored â€” must pass `--schema` every time |
-| Project default schema | None â€” hardcoded to `spec-driven` |
-
----
-
-## User Journey Analysis
-
-### Scenario 1: Using a Non-Default Schema
-
-**Goal:** User wants to use TDD workflow for a new feature.
-
-**Today's experience:**
-```bash
-openspec new change add-auth
-# Creates directory, no schema info stored
-
-openspec status --change add-auth
-# Shows spec-driven artifacts (WRONG - user wanted TDD)
-
-# User realizes mistake...
-openspec status --change add-auth --schema tdd
-# Correct, but must remember --schema every time
-
-# 6 months later...
-openspec status --change add-auth
-# Wrong again - nobody remembers this was TDD
-```
-
-**Problems:**
-- Schema is a runtime argument, not persisted
-- Easy to forget `--schema` and get wrong results
-- No record of intended schema for future reference
-
----
-
-### Scenario 2: Customizing a Schema
-
-**Goal:** User wants to add a "research" artifact before "proposal".
-
-**Today's experience:**
-```bash
-# Step 1: Figure out where to put overrides
-# Must know XDG conventions:
-#   macOS/Linux: ~/.local/share/openspec/schemas/
-#   Windows: %LOCALAPPDATA%\openspec\schemas/
-
-# Step 2: Create directory structure
-mkdir -p ~/.local/share/openspec/schemas/my-workflow/templates
-
-# Step 3: Find the npm package to copy defaults
-npm list -g openspec --parseable
-# Output varies by package manager:
-#   npm: /usr/local/lib/node_modules/openspec
-#   pnpm: ~/.local/share/pnpm/global/5/node_modules/openspec
-#   volta: ~/.volta/tools/image/packages/openspec/...
-#   yarn: ~/.config/yarn/global/node_modules/openspec
-
-# Step 4: Copy files
-cp -r <package-path>/schemas/spec-driven/* \
-      ~/.local/share/openspec/schemas/my-workflow/
-
-# Step 5: Edit schema.yaml and templates
-# No way to verify override is active
-# No way to diff against original
-```
-
-**Problems:**
-- Must know XDG path conventions
-- Finding npm package path varies by install method
-- No tooling to scaffold or verify
-- No diff capability when upgrading openspec
-
----
-
-### Scenario 3: Team Sharing Custom Workflow
-
-**Goal:** Team wants everyone to use the same custom schema.
-
-**Today's options:**
-1. Everyone manually sets up XDG override â€” error-prone, drift risk
-2. Document setup in README â€” still manual, easy to miss
-3. Publish separate npm package â€” overkill for most teams
-4. Check schema into repo â€” **not supported** (no project-local resolution)
-
-**Problems:**
-- No project-local schema resolution
-- Can't version control custom schemas with the codebase
-- No single source of truth for team workflow
-
----
-
-## Gap Summary
-
-| Gap | Impact | Status |
-|-----|--------|--------|
-| Schema not bound to change | Wrong results, forgotten context | â³ Pending (Phase 1) |
-| No project-local schemas | Can't share via repo | âœ… Fixed (PR #522) |
-| No schema management CLI | Manual path hunting | âœ… Fixed (PR #525) |
-| No project default schema | Must specify every time | â³ Pending (Phase 4) |
-| No init-time schema selection | Missed setup opportunity | â³ Pending (Phase 4) |
-
----
-
-## Proposed Architecture
-
-### New File Structure
-
-```
-openspec/
-â”œâ”€â”€ config.yaml                 # Project config (NEW)
-â”œâ”€â”€ schemas/                    # Project-local schemas (NEW)
-â”‚   â””â”€â”€ my-workflow/
-â”‚       â”œâ”€â”€ schema.yaml
-â”‚       â””â”€â”€ templates/
-â”‚           â”œâ”€â”€ research.md
-â”‚           â”œâ”€â”€ proposal.md
-â”‚           â””â”€â”€ ...
-â””â”€â”€ changes/
-    â””â”€â”€ add-auth/
-        â”œâ”€â”€ change.yaml         # Change metadata (NEW)
-        â”œâ”€â”€ proposal.md
-        â””â”€â”€ ...
-```
-
-### config.yaml (Project Config)
-
-```yaml
-# openspec/config.yaml
-defaultSchema: spec-driven
-```
-
-Sets the project-wide default schema. Used when:
-- Creating new changes without `--schema`
-- Running commands on changes without `change.yaml`
-
-### change.yaml (Change Metadata)
-
-```yaml
-# openspec/changes/add-auth/change.yaml
-schema: tdd
-created: 2025-01-15T10:30:00Z
-description: Add user authentication system
-```
-
-Binds a specific schema to a change. Created automatically by `openspec new change`.
-
-### Schema Resolution Order
-
-```
-1. ./openspec/schemas/<name>/                    # Project-local
-2. ~/.local/share/openspec/schemas/<name>/       # User global (XDG)
-3. <npm-package>/schemas/<name>/                 # Built-in
-```
-
-Project-local takes priority, enabling version-controlled custom schemas.
-
-### Schema Selection Order (Per Command)
-
-```
-1. --schema CLI flag                    # Explicit override
-2. change.yaml in change directory      # Change-specific binding
-3. openspec/config.yaml defaultSchema   # Project default
-4. "spec-driven"                        # Hardcoded fallback
-```
-
----
-
-## Ideal User Experience
-
-### Creating a Change
-
-```bash
-# Uses project default (from config.yaml, or spec-driven)
-openspec new change add-auth
-# Creates openspec/changes/add-auth/change.yaml:
-#   schema: spec-driven
-#   created: 2025-01-15T10:30:00Z
-
-# Explicit schema for this change
-openspec new change add-auth --schema tdd
-# Creates change.yaml with schema: tdd
-```
-
-### Working with Changes
-
-```bash
-# Auto-reads schema from change.yaml â€” no --schema needed
-openspec status --change add-auth
-# Output: "Change: add-auth (schema: tdd)"
-# Shows which artifacts are ready/blocked/done
-
-# Explicit override still works (with informational message)
-openspec status --change add-auth --schema spec-driven
-# "Note: change.yaml specifies 'tdd', using 'spec-driven' per --schema flag"
-```
-
-### Customizing Schemas
-
-```bash
-# See what's available
-openspec schema list
-# Built-in:
-#   spec-driven    proposal â†’ specs â†’ design â†’ tasks
-#   tdd            spec â†’ tests â†’ implementation â†’ docs
-# Project: (none)
-# User: (none)
-
-# Copy to project for customization
-openspec schema copy spec-driven my-workflow
-# Created ./openspec/schemas/my-workflow/
-# Edit schema.yaml and templates/ to customize
-
-# Copy to global (user-level override)
-openspec schema copy spec-driven --global
-# Created ~/.local/share/openspec/schemas/spec-driven/
-
-# See where a schema resolves from
-openspec schema which spec-driven
-# ./openspec/schemas/spec-driven/ (project)
-# or: ~/.local/share/openspec/schemas/spec-driven/ (user)
-# or: /usr/local/lib/node_modules/openspec/schemas/spec-driven/ (built-in)
-
-# Compare override with built-in
-openspec schema diff spec-driven
-# Shows diff between user/project version and package built-in
-
-# Remove override, revert to built-in
-openspec schema reset spec-driven
-# Removes ./openspec/schemas/spec-driven/ (or --global for user dir)
-```
-
-### Project Setup
-
-```bash
-openspec init
-# ? Select default workflow schema:
-#   > spec-driven (proposal â†’ specs â†’ design â†’ tasks)
-#     tdd (spec â†’ tests â†’ implementation â†’ docs)
-#     (custom schemas if detected)
-#
-# Writes to openspec/config.yaml:
-#   defaultSchema: spec-driven
-```
-
----
-
-## Implementation Phases
-
-### Phase 1: Change Metadata (change.yaml)
-
-**Priority:** High
-**Solves:** "Forgot --schema", lost context, wrong results
-
-**Scope:**
-- Create `change.yaml` when running `openspec new change`
-- Store `schema`, `created` timestamp
-- Modify workflow commands to read schema from `change.yaml`
-- `--schema` flag overrides (with informational message)
-- Backwards compatible: missing `change.yaml` â†’ use default
-
-**change.yaml format:**
-```yaml
-schema: tdd
-created: 2025-01-15T10:30:00Z
-```
-
-**Migration:**
-- Existing changes without `change.yaml` continue to work
-- Default to `spec-driven` (current behavior)
-- Optional: `openspec migrate` to add `change.yaml` to existing changes
-
----
-
-### Phase 2: Project-Local Schemas
-
-**Status:** âœ… Complete (PR #522)
-**Solves:** Team sharing, version control, no XDG knowledge needed
-
-**Implemented:**
-- `./openspec/schemas/` added to resolution order (first priority)
-- `openspec schema fork <name> [new-name]` creates in project by default
-- Teams can commit `openspec/schemas/` to repo
-
-**Resolution order:**
-```
-1. ./openspec/schemas/<name>/           # Project-local
-2. ~/.local/share/openspec/schemas/<name>/  # User global
-3. <npm-package>/schemas/<name>/        # Built-in
-```
-
----
-
-### Phase 3: Schema Management CLI
-
-**Status:** âœ… Complete (PR #525)
-**Solves:** Path discovery, scaffolding, debugging
-
-**Implemented Commands:**
-```bash
-openspec schema which [name]          # Show resolution path, --all for all schemas
-openspec schema validate [name]       # Validate schema structure and templates
-openspec schema fork <source> [name]  # Copy existing schema for customization
-openspec schema init <name>           # Create new project-local schema (interactive)
-```
-
-**Not implemented (may add later):**
-- `schema diff` â€” Compare override with built-in
-- `schema reset` â€” Remove override, revert to built-in
-
----
-
-### Phase 4: Project Config + Init Enhancement
-
-**Priority:** Low
-**Solves:** Project-wide defaults, streamlined setup
-
-**Scope:**
-- Add `openspec/config.yaml` with `defaultSchema` field
-- `openspec init` prompts for schema selection
-- Store selection in `config.yaml`
-- Commands use as fallback when no `change.yaml` exists
-
-**config.yaml format:**
-```yaml
-defaultSchema: spec-driven
-```
-
----
-
-## Backwards Compatibility
-
-| Scenario | Behavior |
-|----------|----------|
-| Existing change without `change.yaml` | Uses `--schema` flag or project default or `spec-driven` |
-| Existing project without `config.yaml` | Falls back to `spec-driven` |
-| `--schema` flag provided | Overrides `change.yaml` (with info message) |
-| No project-local schemas dir | Skipped in resolution, checks user/built-in |
-
-All existing functionality continues to work. New features are additive.
-
----
-
-## Related Documents
-
-- [Schema Customization](./schema-customization.md) â€” Details on manual override process and CLI gaps
-- [Artifact POC](./artifact_poc.md) â€” Core artifact graph architecture
-
-## Related Code
-
-| File | Purpose |
-|------|---------|
-| `src/core/artifact-graph/resolver.ts` | Schema resolution logic |
-| `src/core/artifact-graph/instruction-loader.ts` | Template loading |
-| `src/core/global-config.ts` | XDG path helpers |
-| `src/commands/artifact-workflow.ts` | CLI commands |
-| `src/utils/change-utils.ts` | Change creation utilities |
diff --git a/docs/supported-tools.md b/docs/supported-tools.md
new file mode 100644
index 0000000..df178c5
--- /dev/null
+++ b/docs/supported-tools.md
@@ -0,0 +1,84 @@
+# Supported Tools
+
+OpenSpec works with 20+ AI coding assistants. When you run `openspec init`, you'll be prompted to select which tools you use, and OpenSpec will configure the appropriate integrations.
+
+## How It Works
+
+For each tool you select, OpenSpec installs:
+
+1. **Skills** â€” Reusable instruction files that power the `/opsx:*` workflow commands
+2. **Commands** â€” Tool-specific slash command bindings
+
+## Tool Directory Reference
+
+| Tool | Skills Location | Commands Location |
+|------|-----------------|-------------------|
+| Amazon Q Developer | `.amazonq/skills/` | `.amazonq/prompts/` |
+| Antigravity | `.agent/skills/` | `.agent/workflows/` |
+| Auggie (Augment CLI) | `.augment/skills/` | `.augment/commands/` |
+| Claude Code | `.claude/skills/` | `.claude/commands/opsx/` |
+| Cline | `.cline/skills/` | `.clinerules/workflows/` |
+| CodeBuddy | `.codebuddy/skills/` | `.codebuddy/commands/opsx/` |
+| Codex | `.codex/skills/` | `.codex/prompts/` |
+| Continue | `.continue/skills/` | `.continue/prompts/` |
+| CoStrict | `.cospec/skills/` | `.cospec/openspec/commands/` |
+| Crush | `.crush/skills/` | `.crush/commands/opsx/` |
+| Cursor | `.cursor/skills/` | `.cursor/commands/` |
+| Factory Droid | `.factory/skills/` | `.factory/commands/` |
+| Gemini CLI | `.gemini/skills/` | `.gemini/commands/opsx/` |
+| GitHub Copilot | `.github/skills/` | `.github/prompts/` |
+| iFlow | `.iflow/skills/` | `.iflow/commands/` |
+| Kilo Code | `.kilocode/skills/` | `.kilocode/workflows/` |
+| OpenCode | `.opencode/skills/` | `.opencode/command/` |
+| Qoder | `.qoder/skills/` | `.qoder/commands/opsx/` |
+| Qwen Code | `.qwen/skills/` | `.qwen/commands/` |
+| RooCode | `.roo/skills/` | `.roo/commands/` |
+| Windsurf | `.windsurf/skills/` | `.windsurf/commands/opsx/` |
+
+## Non-Interactive Setup
+
+For CI/CD or scripted setup, use the `--tools` flag:
+
+```bash
+# Configure specific tools
+openspec init --tools claude,cursor
+
+# Configure all supported tools
+openspec init --tools all
+
+# Skip tool configuration
+openspec init --tools none
+```
+
+**Available tool IDs:** `amazon-q`, `antigravity`, `auggie`, `claude`, `cline`, `codebuddy`, `codex`, `continue`, `costrict`, `crush`, `cursor`, `factory`, `gemini`, `github-copilot`, `iflow`, `kilocode`, `opencode`, `qoder`, `qwen`, `roocode`, `windsurf`
+
+## What Gets Installed
+
+For each tool, OpenSpec generates 10 skill files that power the OPSX workflow:
+
+| Skill | Purpose |
+|-------|---------|
+| `openspec-explore` | Thinking partner for exploring ideas |
+| `openspec-new-change` | Start a new change |
+| `openspec-continue-change` | Create the next artifact |
+| `openspec-ff-change` | Fast-forward through all planning artifacts |
+| `openspec-apply-change` | Implement tasks |
+| `openspec-verify-change` | Verify implementation completeness |
+| `openspec-sync-specs` | Sync delta specs to main (optionalâ€”archive prompts if needed) |
+| `openspec-archive-change` | Archive a completed change |
+| `openspec-bulk-archive-change` | Archive multiple changes at once |
+| `openspec-onboard` | Guided onboarding through a complete workflow cycle |
+
+These skills are invoked via slash commands like `/opsx:new`, `/opsx:apply`, etc. See [Commands](commands.md) for the full list.
+
+## Adding a New Tool
+
+Want to add support for another AI coding assistant? Check out the [command adapter pattern](../CONTRIBUTING.md) or open an issue on GitHub.
+
+---
+
+## Related
+
+- [CLI Reference](cli.md) â€” Terminal commands
+- [Commands](commands.md) â€” Slash commands and skills
+- [Getting Started](getting-started.md) â€” First-time setup
diff --git a/docs/workflows.md b/docs/workflows.md
new file mode 100644
index 0000000..8aac9df
--- /dev/null
+++ b/docs/workflows.md
@@ -0,0 +1,425 @@
+# Workflows
+
+This guide covers common workflow patterns for OpenSpec and when to use each one. For basic setup, see [Getting Started](getting-started.md). For command reference, see [Commands](commands.md).
+
+## Philosophy: Actions, Not Phases
+
+Traditional workflows force you through phases: planning, then implementation, then done. But real work doesn't fit neatly into boxes.
+
+OPSX takes a different approach:
+
+```text
+Traditional (phase-locked):
+
+  PLANNING â”€â”€â”€â”€â”€â”€â”€â”€â–º IMPLEMENTING â”€â”€â”€â”€â”€â”€â”€â”€â–º DONE
+      â”‚                    â”‚
+      â”‚   "Can't go back"  â”‚
+      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+
+OPSX (fluid actions):
+
+  proposal â”€â”€â–º specs â”€â”€â–º design â”€â”€â–º tasks â”€â”€â–º implement
+```
+
+**Key principles:**
+
+- **Actions, not phases** - Commands are things you can do, not stages you're stuck in
+- **Dependencies are enablers** - They show what's possible, not what's required next
+
+> **Customization:** OPSX workflows are driven by schemas that define artifact sequences. See [Customization](customization.md) for details on creating custom schemas.
+
+## Workflow Patterns
+
+### Quick Feature
+
+When you know what you want to build and just need to execute:
+
+```text
+/opsx:new â”€â”€â–º /opsx:ff â”€â”€â–º /opsx:apply â”€â”€â–º /opsx:verify â”€â”€â–º /opsx:archive
+```
+
+**Example conversation:**
+
+```text
+You: /opsx:new add-logout-button
+
+AI:  Created openspec/changes/add-logout-button/
+     Ready to create: proposal
+
+You: /opsx:ff
+
+AI:  Creating all planning artifacts...
+     âœ“ proposal.md
+     âœ“ specs/
+     âœ“ design.md
+     âœ“ tasks.md
+     Ready for implementation!
+
+You: /opsx:apply
+
+AI:  Working through tasks...
+     âœ“ Added logout button to header
+     âœ“ Implemented session clearing
+     âœ“ Added confirmation dialog
+     All tasks complete!
+
+You: /opsx:archive
+
+AI:  âœ“ Merged specs
+     âœ“ Archived change
+```
+
+**Best for:** Small to medium features, bug fixes, straightforward changes.
+
+### Exploratory
+
+When requirements are unclear or you need to investigate first:
+
+```text
+/opsx:explore â”€â”€â–º /opsx:new â”€â”€â–º /opsx:continue â”€â”€â–º ... â”€â”€â–º /opsx:apply
+```
+
+**Example conversation:**
+
+```text
+You: /opsx:explore
+
+AI:  What would you like to explore?
+
+You: I want to improve page load performance but I'm not sure
+     where the bottlenecks are.
+
+AI:  Let me help investigate...
+     [Analyzes bundle sizes, identifies slow queries, reviews
+     component render patterns]
+
+     I found three main bottlenecks:
+     1. Large unoptimized images
+     2. Synchronous data fetching in ProductList
+     3. Re-renders from context changes
+
+     Which would you like to address first?
+
+You: Let's tackle the data fetching issue.
+
+You: /opsx:new optimize-product-list-fetching
+
+AI:  Created change. Ready to create: proposal
+
+You: /opsx:continue
+
+AI:  Creating proposal based on our exploration...
+     [Writes proposal incorporating investigation insights]
+
+     Ready to create: specs, design
+     Which would you like next?
+
+You: /opsx:continue
+
+AI:  Creating specs...
+```
+
+**Best for:** Performance optimization, debugging, architectural decisions, unclear requirements.
+
+### Parallel Changes
+
+Work on multiple changes at once:
+
+```text
+Change A: /opsx:new â”€â”€â–º /opsx:ff â”€â”€â–º /opsx:apply (in progress)
+                                         â”‚
+                                    context switch
+                                         â”‚
+Change B: /opsx:new â”€â”€â–º /opsx:ff â”€â”€â”€â”€â”€â”€â–º /opsx:apply
+```
+
+**Example conversation:**
+
+```text
+You: I'm working on add-dark-mode but got pulled into a bug fix
+
+You: /opsx:new fix-login-redirect
+
+AI:  Created openspec/changes/fix-login-redirect/
+
+You: /opsx:ff
+
+AI:  âœ“ Created planning artifacts
+
+You: /opsx:apply
+
+AI:  Working on fix-login-redirect...
+     [Implements the fix]
+     All tasks complete!
+
+You: /opsx:archive
+
+AI:  âœ“ Archived fix-login-redirect
+
+You: Let's get back to dark mode
+
+You: /opsx:apply add-dark-mode
+
+AI:  Resuming add-dark-mode...
+     Picking up at task 2.3: Update Header...
+```
+
+**Best for:** Parallel work streams, urgent interrupts, team collaboration.
+
+When you have multiple completed changes, use `/opsx:bulk-archive`:
+
+```text
+You: /opsx:bulk-archive
+
+AI:  Found 3 completed changes:
+     - add-dark-mode (all tasks done)
+     - fix-login-redirect (all tasks done)
+     - update-footer (all tasks done)
+
+     Checking for spec conflicts...
+     âš  add-dark-mode and update-footer both touch specs/ui/
+
+     Inspecting codebase to resolve...
+     Both changes are implemented. Will apply in chronological order.
+
+     Archive all 3 changes?
+
+You: Yes
+
+AI:  âœ“ Archived add-dark-mode
+     âœ“ Archived fix-login-redirect
+     âœ“ Archived update-footer
+     Specs merged in order: add-dark-mode â†’ update-footer
+```
+
+Bulk archive detects when multiple changes touch the same specs and resolves conflicts by checking what's actually implemented.
+
+### Completing a Change
+
+The recommended completion flow:
+
+```text
+/opsx:apply â”€â”€â–º /opsx:verify â”€â”€â–º /opsx:archive
+                    â”‚                 â”‚
+              validates          prompts to sync
+              implementation     if needed
+```
+
+#### Verify: Check Your Work
+
+`/opsx:verify` validates implementation against your artifacts across three dimensions:
+
+```text
+You: /opsx:verify
+
+AI:  Verifying add-auth...
+
+     COMPLETENESS
+     âœ“ All 12 tasks in tasks.md are checked
+     âœ“ All requirements in specs have corresponding code
+     âš  Scenario "Session timeout after inactivity" not tested
+
+     CORRECTNESS
+     âœ“ Implementation matches spec intent
+     âœ“ Edge cases from scenarios are handled
+     âœ“ Error states match spec definitions
+
+     COHERENCE
+     âœ“ Design decisions reflected in code structure
+     âœ“ Naming conventions consistent with design.md
+     âš  Design mentions "event-driven" but implementation uses polling
+
+     SUMMARY
+     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+     Critical issues: 0
+     Warnings: 2
+     Ready to archive: Yes (with warnings)
+
+     Recommendations:
+     1. Add test for session timeout scenario
+     2. Consider refactoring to event-driven as designed, or update design.md
+```
+
+**What verify checks:**
+
+| Dimension | What it validates |
+|-----------|------------------|
+| Completeness | All tasks done, all requirements implemented, scenarios covered |
+| Correctness | Implementation matches spec intent, edge cases handled |
+| Coherence | Design decisions reflected in code, patterns consistent |
+
+Verify won't block archive, but it surfaces issues you might want to address first.
+
+#### Archive: Finalize the Change
+
+`/opsx:archive` completes the change and moves it to the archive:
+
+```text
+You: /opsx:archive
+
+AI:  Archiving add-auth...
+
+     Artifact status:
+     âœ“ proposal.md exists
+     âœ“ specs/ exists
+     âœ“ design.md exists
+     âœ“ tasks.md exists (12/12 tasks complete)
+
+     Delta specs: Not yet synced to main
+     â†’ Would you like to sync now?
+
+You: Yes
+
+AI:  âœ“ Synced specs to openspec/specs/auth/spec.md
+     âœ“ Moved to openspec/changes/archive/2025-01-24-add-auth/
+
+     Change archived successfully.
+```
+
+Archive will prompt if specs aren't synced. It won't block on incomplete tasks, but it will warn you.
+
+## When to Use What
+
+### `/opsx:ff` vs `/opsx:continue`
+
+| Situation | Use |
+|-----------|-----|
+| Clear requirements, ready to build | `/opsx:ff` |
+| Exploring, want to review each step | `/opsx:continue` |
+| Want to iterate on proposal before specs | `/opsx:continue` |
+| Time pressure, need to move fast | `/opsx:ff` |
+| Complex change, want control | `/opsx:continue` |
+
+**Rule of thumb:** If you can describe the full scope upfront, use `/opsx:ff`. If you're figuring it out as you go, use `/opsx:continue`.
+
+### When to Update vs Start Fresh
+
+A common question: when is updating an existing change okay, and when should you start a new one?
+
+**Update the existing change when:**
+
+- Same intent, refined execution
+- Scope narrows (MVP first, rest later)
+- Learning-driven corrections (codebase isn't what you expected)
+- Design tweaks based on implementation discoveries
+
+**Start a new change when:**
+
+- Intent fundamentally changed
+- Scope exploded to different work entirely
+- Original change can be marked "done" standalone
+- Patches would confuse more than clarify
+
+```text
+                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+                     â”‚     Is this the same work?          â”‚
+                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+                                    â”‚
+                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+                 â”‚                  â”‚                  â”‚
+                 â–¼                  â–¼                  â–¼
+          Same intent?      >50% overlap?      Can original
+          Same problem?     Same scope?        be "done" without
+                 â”‚                  â”‚          these changes?
+                 â”‚                  â”‚                  â”‚
+       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
+       â”‚                 â”‚  â”‚             â”‚   â”‚               â”‚
+      YES               NO YES           NO  NO              YES
+       â”‚                 â”‚  â”‚             â”‚   â”‚               â”‚
+       â–¼                 â–¼  â–¼             â–¼   â–¼               â–¼
+    UPDATE            NEW  UPDATE       NEW  UPDATE          NEW
+```
+
+**Example: "Add dark mode"**
+
+- "Need to also support custom themes" â†’ New change (scope exploded)
+- "System preference detection is harder than expected" â†’ Update (same intent)
+- "Let's ship toggle first, add preferences later" â†’ Update then archive, then new change
+
+## Best Practices
+
+### Keep Changes Focused
+
+One logical unit of work per change. If you're doing "add feature X and also refactor Y", consider two separate changes.
+
+**Why it matters:**
+- Easier to review and understand
+- Cleaner archive history
+- Can ship independently
+- Simpler rollback if needed
+
+### Use `/opsx:explore` for Unclear Requirements
+
+Before committing to a change, explore the problem space:
+
+```text
+You: /opsx:explore
+
+AI:  What would you like to explore?
+
+You: How should we handle rate limiting for our API?
+
+AI:  Let me investigate your current setup and options...
+     [Researches codebase, considers patterns]
+
+     I see three approaches we could take:
+     1. Middleware-based (simple, per-endpoint)
+     2. Redis-backed (scalable, shared state)
+     3. Token bucket per user (fair, complex)
+
+     Your current stack suggests #1 or #2. What's your scale?
+```
+
+Exploration clarifies thinking before you create artifacts.
+
+### Verify Before Archiving
+
+Use `/opsx:verify` to check implementation matches artifacts:
+
+```text
+You: /opsx:verify
+
+AI:  Verifying add-dark-mode...
+
+     âœ“ All tasks in tasks.md are checked
+     âœ“ Requirements in specs have corresponding code
+     âœ“ Design decisions are reflected in implementation
+
+     Ready to archive!
+```
+
+Catches mismatches before you close out the change.
+
+### Name Changes Clearly
+
+Good names make `openspec list` useful:
+
+```text
+Good:                          Avoid:
+add-dark-mode                  feature-1
+fix-login-redirect             update
+optimize-product-query         changes
+implement-2fa                  wip
+```
+
+## Command Quick Reference
+
+For full command details and options, see [Commands](commands.md).
+
+| Command | Purpose | When to Use |
+|---------|---------|-------------|
+| `/opsx:explore` | Think through ideas | Unclear requirements, investigation |
+| `/opsx:new` | Start a change | Beginning any new work |
+| `/opsx:continue` | Create next artifact | Step-by-step artifact creation |
+| `/opsx:ff` | Create all planning artifacts | Clear scope, ready to build |
+| `/opsx:apply` | Implement tasks | Ready to write code |
+| `/opsx:verify` | Validate implementation | Before archiving, catch mismatches |
+| `/opsx:sync` | Merge delta specs | Optionalâ€”archive prompts if needed |
+| `/opsx:archive` | Complete the change | All work finished |
+| `/opsx:bulk-archive` | Archive multiple changes | Parallel work, batch completion |
+
+## Next Steps
+
+- [Commands](commands.md) - Full command reference with options
+- [Concepts](concepts.md) - Deep dive into specs, artifacts, and schemas
+- [Customization](customization.md) - Create custom workflows
diff --git a/flake.nix b/flake.nix
index cb10878..90ba68a 100644
--- a/flake.nix
+++ b/flake.nix
@@ -5,29 +5,53 @@
     nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
   };
 
-  outputs = { self, nixpkgs }:
+  outputs =
+    { self, nixpkgs }:
     let
-      supportedSystems = [ "x86_64-linux" "aarch64-linux" "x86_64-darwin" "aarch64-darwin" ];
+      supportedSystems = [
+        "x86_64-linux"
+        "aarch64-linux"
+        "x86_64-darwin"
+        "aarch64-darwin"
+      ];
 
       forAllSystems = f: nixpkgs.lib.genAttrs supportedSystems (system: f system);
     in
     {
-      packages = forAllSystems (system:
+      packages = forAllSystems (
+        system:
         let
           pkgs = nixpkgs.legacyPackages.${system};
+          inherit (pkgs) lib;
         in
         {
           default = pkgs.stdenv.mkDerivation (finalAttrs: {
             pname = "openspec";
-            version = "0.20.0";
+            version = (builtins.fromJSON (builtins.readFile ./package.json)).version;
 
-            src = ./.;
+            src = lib.fileset.toSource {
+              root = ./.;
+              fileset = lib.fileset.unions [
+                ./src
+                ./bin
+                ./schemas
+                ./scripts
+                ./test
+                ./package.json
+                ./pnpm-lock.yaml
+                ./tsconfig.json
+                ./build.js
+                ./vitest.config.ts
+                ./vitest.setup.ts
+                ./eslint.config.js
+              ];
+            };
 
             pnpmDeps = pkgs.fetchPnpmDeps {
               inherit (finalAttrs) pname version src;
               pnpm = pkgs.pnpm_9;
               fetcherVersion = 3;
-              hash = "sha256-m/7IdY1ou9ljjYAcx3W8AyEJvIZfCBWIWxproQ/INPA=";
+              hash = "sha256-9s2kdvd7svK4hofnD66HkDc86WTQeayfF5y7L2dmjNg=";
             };
 
             nativeBuildInputs = with pkgs; [
@@ -55,7 +79,8 @@
               mainProgram = "openspec";
             };
           });
-        });
+        }
+      );
 
       apps = forAllSystems (system: {
         default = {
@@ -64,7 +89,8 @@
         };
       });
 
-      devShells = forAllSystems (system:
+      devShells = forAllSystems (
+        system:
         let
           pkgs = nixpkgs.legacyPackages.${system};
         in
@@ -82,6 +108,7 @@
               echo "Run 'pnpm install' to install dependencies"
             '';
           };
-        });
+        }
+      );
     };
 }
diff --git a/openspec/AGENTS.md b/openspec/AGENTS.md
deleted file mode 100644
index fb307c7..0000000
--- a/openspec/AGENTS.md
+++ /dev/null
@@ -1,456 +0,0 @@
-# OpenSpec Instructions
-
-Instructions for AI coding assistants using OpenSpec for spec-driven development.
-
-## TL;DR Quick Checklist
-
-- Search existing work: `openspec spec list --long`, `openspec list` (use `rg` only for full-text search)
-- Decide scope: new capability vs modify existing capability
-- Pick a unique `change-id`: kebab-case, verb-led (`add-`, `update-`, `remove-`, `refactor-`)
-- Scaffold: `proposal.md`, `tasks.md`, `design.md` (only if needed), and delta specs per affected capability
-- Write deltas: use `## ADDED|MODIFIED|REMOVED|RENAMED Requirements`; include at least one `#### Scenario:` per requirement
-- Validate: `openspec validate [change-id] --strict --no-interactive` and fix issues
-- Request approval: Do not start implementation until proposal is approved
-
-## Three-Stage Workflow
-
-### Stage 1: Creating Changes
-Create proposal when you need to:
-- Add features or functionality
-- Make breaking changes (API, schema)
-- Change architecture or patterns
-- Optimize performance (changes behavior)
-- Update security patterns
-
-Triggers (examples):
-- "Help me create a change proposal"
-- "Help me plan a change"
-- "Help me create a proposal"
-- "I want to create a spec proposal"
-- "I want to create a spec"
-
-Loose matching guidance:
-- Contains one of: `proposal`, `change`, `spec`
-- With one of: `create`, `plan`, `make`, `start`, `help`
-
-Skip proposal for:
-- Bug fixes (restore intended behavior)
-- Typos, formatting, comments
-- Dependency updates (non-breaking)
-- Configuration changes
-- Tests for existing behavior
-
-**Workflow**
-1. Review `openspec/project.md`, `openspec list`, and `openspec list --specs` to understand current context.
-2. Choose a unique verb-led `change-id` and scaffold `proposal.md`, `tasks.md`, optional `design.md`, and spec deltas under `openspec/changes/<id>/`.
-3. Draft spec deltas using `## ADDED|MODIFIED|REMOVED Requirements` with at least one `#### Scenario:` per requirement.
-4. Run `openspec validate <id> --strict --no-interactive` and resolve any issues before sharing the proposal.
-
-### Stage 2: Implementing Changes
-Track these steps as TODOs and complete them one by one.
-1. **Read proposal.md** - Understand what's being built
-2. **Read design.md** (if exists) - Review technical decisions
-3. **Read tasks.md** - Get implementation checklist
-4. **Implement tasks sequentially** - Complete in order
-5. **Confirm completion** - Ensure every item in `tasks.md` is finished before updating statuses
-6. **Update checklist** - After all work is done, set every task to `- [x]` so the list reflects reality
-7. **Approval gate** - Do not start implementation until the proposal is reviewed and approved
-
-### Stage 3: Archiving Changes
-After deployment, create separate PR to:
-- Move `changes/[name]/` â†’ `changes/archive/YYYY-MM-DD-[name]/`
-- Update `specs/` if capabilities changed
-- Use `openspec archive <change-id> --skip-specs --yes` for tooling-only changes (always pass the change ID explicitly)
-- Run `openspec validate --strict --no-interactive` to confirm the archived change passes checks
-
-## Before Any Task
-
-**Context Checklist:**
-- [ ] Read relevant specs in `specs/[capability]/spec.md`
-- [ ] Check pending changes in `changes/` for conflicts
-- [ ] Read `openspec/project.md` for conventions
-- [ ] Run `openspec list` to see active changes
-- [ ] Run `openspec list --specs` to see existing capabilities
-
-**Before Creating Specs:**
-- Always check if capability already exists
-- Prefer modifying existing specs over creating duplicates
-- Use `openspec show [spec]` to review current state
-- If request is ambiguous, ask 1â€“2 clarifying questions before scaffolding
-
-### Search Guidance
-- Enumerate specs: `openspec spec list --long` (or `--json` for scripts)
-- Enumerate changes: `openspec list` (or `openspec change list --json` - deprecated but available)
-- Show details:
-  - Spec: `openspec show <spec-id> --type spec` (use `--json` for filters)
-  - Change: `openspec show <change-id> --json --deltas-only`
-- Full-text search (use ripgrep): `rg -n "Requirement:|Scenario:" openspec/specs`
-
-## Quick Start
-
-### CLI Commands
-
-```bash
-# Essential commands
-openspec list                  # List active changes
-openspec list --specs          # List specifications
-openspec show [item]           # Display change or spec
-openspec validate [item]       # Validate changes or specs
-openspec archive <change-id> [--yes|-y]   # Archive after deployment (add --yes for non-interactive runs)
-
-# Project management
-openspec init [path]           # Initialize OpenSpec
-openspec update [path]         # Update instruction files
-
-# Interactive mode
-openspec show                  # Prompts for selection
-openspec validate              # Bulk validation mode
-
-# Debugging
-openspec show [change] --json --deltas-only
-openspec validate [change] --strict --no-interactive
-```
-
-### Command Flags
-
-- `--json` - Machine-readable output
-- `--type change|spec` - Disambiguate items
-- `--strict` - Comprehensive validation
-- `--no-interactive` - Disable prompts
-- `--skip-specs` - Archive without spec updates
-- `--yes`/`-y` - Skip confirmation prompts (non-interactive archive)
-
-## Directory Structure
-
-```
-openspec/
-â”œâ”€â”€ project.md              # Project conventions
-â”œâ”€â”€ specs/                  # Current truth - what IS built
-â”‚   â””â”€â”€ [capability]/       # Single focused capability
-â”‚       â”œâ”€â”€ spec.md         # Requirements and scenarios
-â”‚       â””â”€â”€ design.md       # Technical patterns
-â”œâ”€â”€ changes/                # Proposals - what SHOULD change
-â”‚   â”œâ”€â”€ [change-name]/
-â”‚   â”‚   â”œâ”€â”€ proposal.md     # Why, what, impact
-â”‚   â”‚   â”œâ”€â”€ tasks.md        # Implementation checklist
-â”‚   â”‚   â”œâ”€â”€ design.md       # Technical decisions (optional; see criteria)
-â”‚   â”‚   â””â”€â”€ specs/          # Delta changes
-â”‚   â”‚       â””â”€â”€ [capability]/
-â”‚   â”‚           â””â”€â”€ spec.md # ADDED/MODIFIED/REMOVED
-â”‚   â””â”€â”€ archive/            # Completed changes
-```
-
-## Creating Change Proposals
-
-### Decision Tree
-
-```
-New request?
-â”œâ”€ Bug fix restoring spec behavior? â†’ Fix directly
-â”œâ”€ Typo/format/comment? â†’ Fix directly
-â”œâ”€ New feature/capability? â†’ Create proposal
-â”œâ”€ Breaking change? â†’ Create proposal
-â”œâ”€ Architecture change? â†’ Create proposal
-â””â”€ Unclear? â†’ Create proposal (safer)
-```
-
-### Proposal Structure
-
-1. **Create directory:** `changes/[change-id]/` (kebab-case, verb-led, unique)
-
-2. **Write proposal.md:**
-```markdown
-# Change: [Brief description of change]
-
-## Why
-[1-2 sentences on problem/opportunity]
-
-## What Changes
-- [Bullet list of changes]
-- [Mark breaking changes with **BREAKING**]
-
-## Impact
-- Affected specs: [list capabilities]
-- Affected code: [key files/systems]
-```
-
-3. **Create spec deltas:** `specs/[capability]/spec.md`
-```markdown
-## ADDED Requirements
-### Requirement: New Feature
-The system SHALL provide...
-
-#### Scenario: Success case
-- **WHEN** user performs action
-- **THEN** expected result
-
-## MODIFIED Requirements
-### Requirement: Existing Feature
-[Complete modified requirement]
-
-## REMOVED Requirements
-### Requirement: Old Feature
-**Reason**: [Why removing]
-**Migration**: [How to handle]
-```
-If multiple capabilities are affected, create multiple delta files under `changes/[change-id]/specs/<capability>/spec.md`â€”one per capability.
-
-4. **Create tasks.md:**
-```markdown
-## 1. Implementation
-- [ ] 1.1 Create database schema
-- [ ] 1.2 Implement API endpoint
-- [ ] 1.3 Add frontend component
-- [ ] 1.4 Write tests
-```
-
-5. **Create design.md when needed:**
-Create `design.md` if any of the following apply; otherwise omit it:
-- Cross-cutting change (multiple services/modules) or a new architectural pattern
-- New external dependency or significant data model changes
-- Security, performance, or migration complexity
-- Ambiguity that benefits from technical decisions before coding
-
-Minimal `design.md` skeleton:
-```markdown
-## Context
-[Background, constraints, stakeholders]
-
-## Goals / Non-Goals
-- Goals: [...]
-- Non-Goals: [...]
-
-## Decisions
-- Decision: [What and why]
-- Alternatives considered: [Options + rationale]
-
-## Risks / Trade-offs
-- [Risk] â†’ Mitigation
-
-## Migration Plan
-[Steps, rollback]
-
-## Open Questions
-- [...]
-```
-
-## Spec File Format
-
-### Critical: Scenario Formatting
-
-**CORRECT** (use #### headers):
-```markdown
-#### Scenario: User login success
-- **WHEN** valid credentials provided
-- **THEN** return JWT token
-```
-
-**WRONG** (don't use bullets or bold):
-```markdown
-- **Scenario: User login**  âŒ
-**Scenario**: User login     âŒ
-### Scenario: User login      âŒ
-```
-
-Every requirement MUST have at least one scenario.
-
-### Requirement Wording
-- Use SHALL/MUST for normative requirements (avoid should/may unless intentionally non-normative)
-
-### Delta Operations
-
-- `## ADDED Requirements` - New capabilities
-- `## MODIFIED Requirements` - Changed behavior
-- `## REMOVED Requirements` - Deprecated features
-- `## RENAMED Requirements` - Name changes
-
-Headers matched with `trim(header)` - whitespace ignored.
-
-#### When to use ADDED vs MODIFIED
-- ADDED: Introduces a new capability or sub-capability that can stand alone as a requirement. Prefer ADDED when the change is orthogonal (e.g., adding "Slash Command Configuration") rather than altering the semantics of an existing requirement.
-- MODIFIED: Changes the behavior, scope, or acceptance criteria of an existing requirement. Always paste the full, updated requirement content (header + all scenarios). The archiver will replace the entire requirement with what you provide here; partial deltas will drop previous details.
-- RENAMED: Use when only the name changes. If you also change behavior, use RENAMED (name) plus MODIFIED (content) referencing the new name.
-
-Common pitfall: Using MODIFIED to add a new concern without including the previous text. This causes loss of detail at archive time. If you arenâ€™t explicitly changing the existing requirement, add a new requirement under ADDED instead.
-
-Authoring a MODIFIED requirement correctly:
-1) Locate the existing requirement in `openspec/specs/<capability>/spec.md`.
-2) Copy the entire requirement block (from `### Requirement: ...` through its scenarios).
-3) Paste it under `## MODIFIED Requirements` and edit to reflect the new behavior.
-4) Ensure the header text matches exactly (whitespace-insensitive) and keep at least one `#### Scenario:`.
-
-Example for RENAMED:
-```markdown
-## RENAMED Requirements
-- FROM: `### Requirement: Login`
-- TO: `### Requirement: User Authentication`
-```
-
-## Troubleshooting
-
-### Common Errors
-
-**"Change must have at least one delta"**
-- Check `changes/[name]/specs/` exists with .md files
-- Verify files have operation prefixes (## ADDED Requirements)
-
-**"Requirement must have at least one scenario"**
-- Check scenarios use `#### Scenario:` format (4 hashtags)
-- Don't use bullet points or bold for scenario headers
-
-**Silent scenario parsing failures**
-- Exact format required: `#### Scenario: Name`
-- Debug with: `openspec show [change] --json --deltas-only`
-
-### Validation Tips
-
-```bash
-# Always use strict mode for comprehensive checks
-openspec validate [change] --strict --no-interactive
-
-# Debug delta parsing
-openspec show [change] --json | jq '.deltas'
-
-# Check specific requirement
-openspec show [spec] --json -r 1
-```
-
-## Happy Path Script
-
-```bash
-# 1) Explore current state
-openspec spec list --long
-openspec list
-# Optional full-text search:
-# rg -n "Requirement:|Scenario:" openspec/specs
-# rg -n "^#|Requirement:" openspec/changes
-
-# 2) Choose change id and scaffold
-CHANGE=add-two-factor-auth
-mkdir -p openspec/changes/$CHANGE/{specs/auth}
-printf "## Why\n...\n\n## What Changes\n- ...\n\n## Impact\n- ...\n" > openspec/changes/$CHANGE/proposal.md
-printf "## 1. Implementation\n- [ ] 1.1 ...\n" > openspec/changes/$CHANGE/tasks.md
-
-# 3) Add deltas (example)
-cat > openspec/changes/$CHANGE/specs/auth/spec.md << 'EOF'
-## ADDED Requirements
-### Requirement: Two-Factor Authentication
-Users MUST provide a second factor during login.
-
-#### Scenario: OTP required
-- **WHEN** valid credentials are provided
-- **THEN** an OTP challenge is required
-EOF
-
-# 4) Validate
-openspec validate $CHANGE --strict --no-interactive
-```
-
-## Multi-Capability Example
-
-```
-openspec/changes/add-2fa-notify/
-â”œâ”€â”€ proposal.md
-â”œâ”€â”€ tasks.md
-â””â”€â”€ specs/
-    â”œâ”€â”€ auth/
-    â”‚   â””â”€â”€ spec.md   # ADDED: Two-Factor Authentication
-    â””â”€â”€ notifications/
-        â””â”€â”€ spec.md   # ADDED: OTP email notification
-```
-
-auth/spec.md
-```markdown
-## ADDED Requirements
-### Requirement: Two-Factor Authentication
-...
-```
-
-notifications/spec.md
-```markdown
-## ADDED Requirements
-### Requirement: OTP Email Notification
-...
-```
-
-## Best Practices
-
-### Simplicity First
-- Default to <100 lines of new code
-- Single-file implementations until proven insufficient
-- Avoid frameworks without clear justification
-- Choose boring, proven patterns
-
-### Complexity Triggers
-Only add complexity with:
-- Performance data showing current solution too slow
-- Concrete scale requirements (>1000 users, >100MB data)
-- Multiple proven use cases requiring abstraction
-
-### Clear References
-- Use `file.ts:42` format for code locations
-- Reference specs as `specs/auth/spec.md`
-- Link related changes and PRs
-
-### Capability Naming
-- Use verb-noun: `user-auth`, `payment-capture`
-- Single purpose per capability
-- 10-minute understandability rule
-- Split if description needs "AND"
-
-### Change ID Naming
-- Use kebab-case, short and descriptive: `add-two-factor-auth`
-- Prefer verb-led prefixes: `add-`, `update-`, `remove-`, `refactor-`
-- Ensure uniqueness; if taken, append `-2`, `-3`, etc.
-
-## Tool Selection Guide
-
-| Task | Tool | Why |
-|------|------|-----|
-| Find files by pattern | Glob | Fast pattern matching |
-| Search code content | Grep | Optimized regex search |
-| Read specific files | Read | Direct file access |
-| Explore unknown scope | Task | Multi-step investigation |
-
-## Error Recovery
-
-### Change Conflicts
-1. Run `openspec list` to see active changes
-2. Check for overlapping specs
-3. Coordinate with change owners
-4. Consider combining proposals
-
-### Validation Failures
-1. Run with `--strict` flag
-2. Check JSON output for details
-3. Verify spec file format
-4. Ensure scenarios properly formatted
-
-### Missing Context
-1. Read project.md first
-2. Check related specs
-3. Review recent archives
-4. Ask for clarification
-
-## Quick Reference
-
-### Stage Indicators
-- `changes/` - Proposed, not yet built
-- `specs/` - Built and deployed
-- `archive/` - Completed changes
-
-### File Purposes
-- `proposal.md` - Why and what
-- `tasks.md` - Implementation steps
-- `design.md` - Technical decisions
-- `spec.md` - Requirements and behavior
-
-### CLI Essentials
-```bash
-openspec list              # What's in progress?
-openspec show [item]       # View details
-openspec validate --strict --no-interactive  # Is it correct?
-openspec archive <change-id> [--yes|-y]  # Mark complete (add --yes for automation)
-```
-
-Remember: Specs are truth. Changes are proposals. Keep them in sync.
diff --git a/openspec/changes/add-artifact-regeneration-support/proposal.md b/openspec/changes/add-artifact-regeneration-support/proposal.md
new file mode 100644
index 0000000..d855cdc
--- /dev/null
+++ b/openspec/changes/add-artifact-regeneration-support/proposal.md
@@ -0,0 +1,136 @@
+# Add Artifact Regeneration Support
+
+## Problem
+
+Currently, there is **no way to regenerate artifacts** in the OPSX workflow:
+
+- `/opsx:apply` just reads whatever's on disk
+- `/opsx:continue` only creates the NEXT artifact - won't touch existing ones
+
+If you edit `design.md` after `tasks.md` exists, your only options are:
+1. Delete tasks.md manually, then run `/opsx:continue`
+2. Edit tasks.md manually
+
+The documentation claims you can "update artifacts mid-flight and continue" but there's no mechanism that actually supports this.
+
+## Proposed Solution
+
+Two parts:
+
+### Part 1: Staleness Detection
+Add artifact staleness detection to `/opsx:apply`:
+
+1. **Track modification times**: When generating an artifact, record the mtime of its dependencies
+2. **Detect staleness**: When `/opsx:apply` runs, check if upstream artifacts (design.md, specs) have been modified since tasks.md was generated
+3. **Prompt user**: If stale, ask: "Design was modified after tasks were generated. Would you like to regenerate tasks with `/opsx:continue`?"
+
+## User Experience
+
+### Vision: Seamless Mid-Flight Correction
+
+This is the workflow we want to enable (currently documented but not supported):
+
+```
+You: /opsx:apply
+
+AI:  Working through tasks...
+     âœ“ Task 1.1: Created caching layer
+     âœ“ Task 1.2: Added cache invalidation
+
+     Working on 1.3: Implement TTL...
+     I noticed the design assumes Redis, but your project uses
+     in-memory caching. Should I update the design?
+
+You: Yes, update it to use the existing cache module.
+
+AI:  Updated design.md to use CacheManager from src/cache/
+     Updated tasks.md with revised implementation steps
+     Continuing implementation...
+     âœ“ Task 1.3: Implemented TTL using CacheManager
+     ...
+```
+
+**No restart needed.** Just update the artifact and continue.
+
+### Staleness Warning UX
+
+When user manually edits an upstream artifact:
+
+```
+$ /opsx:apply
+
+âš ï¸  Detected changes to upstream artifacts:
+    - design.md modified 5 minutes ago (after tasks.md was generated)
+
+Options:
+1. Regenerate tasks (recommended)
+2. Continue anyway with current tasks
+3. Cancel
+
+>
+```
+
+### Part 2: Regeneration Capability
+
+Add a way to regenerate specific artifacts:
+
+```bash
+# Option A: Flag on continue
+/opsx:continue --regenerate tasks
+
+# Option B: Separate command
+/opsx:regenerate tasks
+
+# Option C: Interactive prompt when staleness detected
+/opsx:apply
+# "Design changed. Regenerate tasks? [y/N]"
+```
+
+## Technical Approach
+
+### Option A: Metadata File
+Store `.openspec-meta.json` in change directory:
+```json
+{
+  "tasks.md": {
+    "generated_at": "2025-01-24T10:00:00Z",
+    "dependencies": {
+      "design.md": "2025-01-24T09:55:00Z",
+      "specs/feature/spec.md": "2025-01-24T09:50:00Z"
+    }
+  }
+}
+```
+
+### Option B: Frontmatter
+Add YAML frontmatter to generated artifacts:
+```markdown
+---
+generated_at: 2025-01-24T10:00:00Z
+depends_on:
+  - design.md@2025-01-24T09:55:00Z
+---
+# Tasks
+...
+```
+
+### Option C: Git-based
+Use git to detect if upstream files changed since downstream was last modified. No extra metadata needed but requires git.
+
+## Non-Goals
+
+- Automatic regeneration (user should always choose)
+- Blocking apply entirely (just warn)
+- Tracking code file changes (only artifact dependencies)
+
+## Dependencies
+
+- Should be implemented after `fix-midflight-update-docs` so docs are accurate first
+- Could be combined with that change if desired
+
+## Success Criteria
+
+- User is warned when applying with stale artifacts
+- Clear path to regenerate if needed
+- No false positives (only warn when genuinely stale)
+- Documentation claims become actually true
diff --git a/openspec/changes/add-opsx-onboard-skill/.openspec.yaml b/openspec/changes/add-opsx-onboard-skill/.openspec.yaml
new file mode 100644
index 0000000..a5a6fec
--- /dev/null
+++ b/openspec/changes/add-opsx-onboard-skill/.openspec.yaml
@@ -0,0 +1,2 @@
+schema: spec-driven
+created: 2026-01-24
diff --git a/openspec/changes/add-opsx-onboard-skill/design.md b/openspec/changes/add-opsx-onboard-skill/design.md
new file mode 100644
index 0000000..505f94e
--- /dev/null
+++ b/openspec/changes/add-opsx-onboard-skill/design.md
@@ -0,0 +1,115 @@
+## Context
+
+OpenSpec has a complete skill and slash command generation system. Skills are defined in `src/core/templates/skill-templates.ts` as functions that return `SkillTemplate` objects (for Agent Skills) and `CommandTemplate` objects (for slash commands). These are registered in `src/core/shared/skill-generation.ts` and generated during `openspec init` and `openspec update`.
+
+Existing skills follow a consistent pattern:
+- `getXxxSkillTemplate()` returns the skill with name, description, instructions
+- `getOpsxXxxCommandTemplate()` returns the slash command with name, description, category, tags, content
+- Both are registered in their respective arrays in `skill-generation.ts`
+
+## Goals / Non-Goals
+
+**Goals:**
+- Add `/opsx:onboard` skill that teaches the OpenSpec workflow through guided practice
+- Follow existing patterns for skill/command template generation
+- Provide comprehensive narration that explains each step
+- Include codebase analysis to suggest real, appropriately-scoped tasks
+
+**Non-Goals:**
+- Creating a separate "demo mode" or simulated workflow (we do real work)
+- Adding new CLI commands (this is purely agent instructions)
+- Modifying the init/update flow (just adding to the template arrays)
+
+## Decisions
+
+### Decision 1: Single Monolithic Skill
+
+The onboard skill will be a single comprehensive instruction set rather than composing existing skills with flags.
+
+**Rationale:**
+- Slash commands don't support flags (they're just prompts)
+- A monolithic skill gives complete control over narration and pacing
+- Easier to maintain a single cohesive experience
+- Users learn the real commands by seeing them mentioned in narration
+
+### Decision 2: Codebase Analysis Patterns
+
+The skill instructions will direct the agent to look for specific patterns when suggesting starter tasks:
+
+1. TODO/FIXME comments in code
+2. Missing error handling (`catch` blocks that swallow errors, no try-catch around risky operations)
+3. Functions without tests (cross-reference src/ with test files)
+4. Type: `any` in TypeScript files
+5. Console.log statements in non-debug code
+6. Missing input validation on user-facing inputs
+7. Recent git commits (for context on what user is working on)
+
+**Rationale:** These are universally applicable, easy to detect, and produce well-scoped tasks.
+
+### Decision 3: Narration Integration Style
+
+Each phase will follow a pattern:
+1. **EXPLAIN** what we're about to do and why (1-2 sentences)
+2. **DO** the action (run command, create artifact)
+3. **SHOW** what happened
+4. **PAUSE** at key transitions (not every step)
+
+Pauses occur at:
+- After task selection (before creating change)
+- After drafting proposal (before saving)
+- After tasks are generated (before implementation)
+- After archive (final recap)
+
+**Rationale:** Too many pauses becomes tedious. Too few loses the teaching opportunity. These are the natural "chapter breaks."
+
+### Decision 4: Scope Guardrail Approach
+
+When user selects a task that's too large, the skill will:
+1. Acknowledge the task is valuable
+2. Explain why smaller is better for first time
+3. Suggest a smaller slice or alternative
+4. Let user override if they insist
+
+**Rationale:** Soft guardrails teach without frustrating. Users learn scope calibration as part of the experience.
+
+### Decision 5: Template Structure
+
+The skill template will be ~400-600 lines of instruction text, structured as:
+
+```
+- Preflight checks (init status)
+- Phase 1: Welcome & Setup
+- Phase 2: Task Selection (with codebase analysis instructions)
+- Phase 3: Explore Demo (brief)
+- Phase 4: Change Creation
+- Phase 5: Proposal
+- Phase 6: Specs
+- Phase 7: Design
+- Phase 8: Tasks
+- Phase 9: Apply (Implementation)
+- Phase 10: Archive
+- Phase 11: Recap & Next Steps
+- Edge cases & graceful exits
+```
+
+The command template will be identical to the skill template (same content, different wrapper).
+
+**Rationale:** Following the established pattern where skill and command share the same core instructions.
+
+## Risks / Trade-offs
+
+**Risk: Instruction length**
+The skill will be significantly longer than existing skills (~500 lines vs ~100-200).
+â†’ Mitigation: This is acceptable since onboarding is inherently comprehensive. Token cost is one-time per session.
+
+**Risk: Codebase analysis may find nothing**
+Some codebases (new projects, very clean code) may not have obvious improvement opportunities.
+â†’ Mitigation: Fall back to asking user what they want to build. Include "add a new feature" as an option.
+
+**Risk: Task suggestions may be inappropriate**
+Agent might suggest tasks that touch sensitive code or have hidden complexity.
+â†’ Mitigation: User always chooses; agent just suggests. Scope estimates help set expectations.
+
+**Risk: User abandons mid-way**
+Onboarding takes ~15 minutes; users may not complete it.
+â†’ Mitigation: Graceful exit handling - note the change is saved, explain how to continue later.
diff --git a/openspec/changes/add-opsx-onboard-skill/proposal.md b/openspec/changes/add-opsx-onboard-skill/proposal.md
new file mode 100644
index 0000000..b280cc2
--- /dev/null
+++ b/openspec/changes/add-opsx-onboard-skill/proposal.md
@@ -0,0 +1,27 @@
+## Why
+
+Users who run `openspec init` are left with files but no clear path to actually using the system. There's a gap between "I have OpenSpec set up" and "I understand the workflow." An onboarding skill would guide users through their first complete change cycle on a real task in their codebase, teaching the workflow by doing it.
+
+## What Changes
+
+- Add new `/opsx:onboard` skill that guides users through their first OpenSpec change
+- Add corresponding slash command template for editor integrations
+- The skill will:
+  - Analyze the user's codebase to suggest appropriately-scoped starter tasks
+  - Walk through the full workflow (explore â†’ new â†’ proposal â†’ specs â†’ design â†’ tasks â†’ apply â†’ archive)
+  - Provide narration explaining each step as it happens
+  - Result in a real, implemented change in the user's codebase
+
+## Capabilities
+
+### New Capabilities
+- `opsx-onboard-skill`: The onboarding skill that guides users through their first complete OpenSpec workflow cycle with narration and codebase-aware task suggestions
+
+### Modified Capabilities
+<!-- No existing specs are being modified - this is purely additive -->
+
+## Impact
+
+- `src/core/templates/skill-templates.ts`: Add `getOnboardSkillTemplate()` and `getOpsxOnboardCommandTemplate()` functions
+- `src/core/shared/skill-generation.ts`: Register the new skill and command templates in `getSkillTemplates()` and `getCommandTemplates()`
+- Users running `openspec init` or `openspec update` will get the new skill/command files generated
diff --git a/openspec/changes/add-opsx-onboard-skill/specs/opsx-onboard-skill/spec.md b/openspec/changes/add-opsx-onboard-skill/specs/opsx-onboard-skill/spec.md
new file mode 100644
index 0000000..ffb4474
--- /dev/null
+++ b/openspec/changes/add-opsx-onboard-skill/specs/opsx-onboard-skill/spec.md
@@ -0,0 +1,162 @@
+## ADDED Requirements
+
+### Requirement: OPSX Onboard Skill
+
+The system SHALL provide an `/opsx:onboard` skill that guides users through their first complete OpenSpec workflow cycle with narration and real codebase work.
+
+#### Scenario: Skill invocation
+
+- **WHEN** user invokes `/opsx:onboard`
+- **THEN** agent checks if OpenSpec is initialized
+- **AND** if not initialized, prompts user to run `openspec init` first
+- **AND** if initialized, proceeds with onboarding flow
+
+#### Scenario: Welcome and expectations
+
+- **WHEN** onboarding begins
+- **THEN** agent displays welcome message explaining what will happen
+- **AND** sets expectation of ~15 minute duration
+- **AND** explains the workflow phases: explore â†’ new â†’ artifacts â†’ apply â†’ archive
+
+### Requirement: Codebase Analysis for Task Suggestions
+
+The skill SHALL analyze the user's codebase to suggest appropriately-scoped starter tasks.
+
+#### Scenario: Codebase scanning
+
+- **WHEN** onboarding reaches task selection phase
+- **THEN** agent scans codebase for small improvement opportunities
+- **AND** looks for: TODO/FIXME comments, missing error handling, functions without tests, outdated dependencies, type: any in TypeScript, console.log in production code, missing input validation
+- **AND** checks recent git commits for context on current work
+
+#### Scenario: Task suggestion presentation
+
+- **WHEN** agent has analyzed codebase
+- **THEN** agent presents 3-4 specific task suggestions with scope estimates
+- **AND** each suggestion includes: task description, estimated scope (files/lines), why it's a good starter
+- **AND** offers option for user to specify their own task
+
+#### Scenario: Scope guardrail
+
+- **WHEN** user selects or describes a task that is too large
+- **THEN** agent gently redirects toward smaller scope
+- **AND** suggests breaking down or deferring the large task
+- **AND** offers appropriately-sized alternatives
+
+### Requirement: Explore Phase Demo
+
+The skill SHALL briefly demonstrate explore mode before creating a change.
+
+#### Scenario: Brief explore demonstration
+
+- **WHEN** task is selected
+- **THEN** agent briefly demonstrates `/opsx:explore` by investigating relevant code
+- **AND** explains explore mode is for thinking before doing
+- **AND** keeps this phase short (not a full exploration session)
+- **AND** transitions to change creation
+
+### Requirement: Guided Artifact Creation
+
+The skill SHALL guide users through each artifact with narration explaining the purpose.
+
+#### Scenario: Change creation with narration
+
+- **WHEN** creating the change directory
+- **THEN** agent runs `openspec new change "<name>"` with derived kebab-case name
+- **AND** explains what a "change" is (container for thinking and planning)
+- **AND** shows the folder structure that was created
+- **AND** pauses for user acknowledgment before proceeding
+
+#### Scenario: Proposal creation with narration
+
+- **WHEN** creating proposal.md
+- **THEN** agent explains proposals capture WHY we're making this change
+- **AND** drafts proposal based on selected task
+- **AND** shows draft to user for approval before saving
+- **AND** explains the sections (Why, What Changes, Capabilities, Impact)
+
+#### Scenario: Specs creation with narration
+
+- **WHEN** creating spec files
+- **THEN** agent explains specs define WHAT we're building in detail
+- **AND** explains the requirement/scenario format
+- **AND** creates spec file(s) based on proposal capabilities
+- **AND** notes that specs become documentation that stays in sync
+
+#### Scenario: Design creation with narration
+
+- **WHEN** creating design.md
+- **THEN** agent explains design captures HOW we'll build it
+- **AND** notes this is where technical decisions and tradeoffs live
+- **AND** for small changes, acknowledges design may be brief
+- **AND** creates design based on proposal and specs
+
+#### Scenario: Tasks creation with narration
+
+- **WHEN** creating tasks.md
+- **THEN** agent explains tasks break work into checkboxes
+- **AND** explains these drive the apply phase
+- **AND** generates task list from design and specs
+- **AND** shows tasks and asks if ready to implement
+
+### Requirement: Guided Implementation
+
+The skill SHALL implement tasks with narration connecting back to artifacts.
+
+#### Scenario: Implementation with narration
+
+- **WHEN** implementing tasks
+- **THEN** agent announces each task before working on it
+- **AND** implements the change in the codebase
+- **AND** occasionally references how specs/design informed decisions
+- **AND** marks each task complete as it finishes
+- **AND** keeps narration light (not over-explaining)
+
+#### Scenario: Implementation completion
+
+- **WHEN** all tasks are complete
+- **THEN** agent announces completion
+- **AND** summarizes what was done
+- **AND** transitions to archive phase
+
+### Requirement: Archive with Explanation
+
+The skill SHALL archive the completed change and explain what happened.
+
+#### Scenario: Archive with narration
+
+- **WHEN** archiving the change
+- **THEN** agent explains archive moves change to dated folder
+- **AND** runs archive process
+- **AND** shows where archived change lives
+- **AND** explains the long-term value (finding decisions later)
+
+### Requirement: Recap and Next Steps
+
+The skill SHALL conclude with a recap and command reference.
+
+#### Scenario: Final recap
+
+- **WHEN** onboarding is complete
+- **THEN** agent summarizes the workflow phases completed
+- **AND** emphasizes this rhythm works for any size change
+- **AND** provides command reference table (/opsx:explore, /opsx:new, /opsx:ff, /opsx:continue, /opsx:apply, /opsx:verify, /opsx:archive)
+- **AND** suggests next actions (try /opsx:new or /opsx:ff on something)
+
+### Requirement: Graceful Exit Handling
+
+The skill SHALL handle users who want to stop mid-way.
+
+#### Scenario: User wants to stop
+
+- **WHEN** user indicates they want to stop during onboarding
+- **THEN** agent acknowledges gracefully
+- **AND** notes that the in-progress change is saved
+- **AND** explains how to continue later with `/opsx:continue <name>`
+- **AND** exits without pressure
+
+#### Scenario: User wants quick reference only
+
+- **WHEN** user says they just want to see the commands
+- **THEN** agent provides command cheat sheet
+- **AND** exits gracefully with encouragement to try `/opsx:new`
diff --git a/openspec/changes/add-opsx-onboard-skill/tasks.md b/openspec/changes/add-opsx-onboard-skill/tasks.md
new file mode 100644
index 0000000..7671b32
--- /dev/null
+++ b/openspec/changes/add-opsx-onboard-skill/tasks.md
@@ -0,0 +1,21 @@
+## 1. Add Skill Template
+
+- [x] 1.1 Add `getOnboardSkillTemplate()` function to `src/core/templates/skill-templates.ts` with full onboarding instruction text covering all phases (preflight, welcome, task selection, explore demo, change creation, proposal, specs, design, tasks, apply, archive, recap)
+- [x] 1.2 Include codebase analysis instructions for suggesting starter tasks (TODO/FIXME, missing error handling, missing tests, type:any, console.log, missing validation)
+- [x] 1.3 Include narration pattern instructions (EXPLAIN â†’ DO â†’ SHOW â†’ PAUSE at key transitions)
+- [x] 1.4 Include scope guardrail instructions for redirecting users away from overly large tasks
+- [x] 1.5 Include graceful exit handling instructions (user stops mid-way, user just wants command reference)
+
+## 2. Add Command Template
+
+- [x] 2.1 Add `getOpsxOnboardCommandTemplate()` function to `src/core/templates/skill-templates.ts` returning CommandTemplate with same instruction content as skill
+
+## 3. Register Templates
+
+- [x] 3.1 Add onboard skill to `getSkillTemplates()` array in `src/core/shared/skill-generation.ts` with dirName `openspec-onboard`
+- [x] 3.2 Add onboard command to `getCommandTemplates()` array in `src/core/shared/skill-generation.ts` with id `onboard`
+
+## 4. Verify
+
+- [x] 4.1 Run `pnpm run build` to ensure TypeScript compiles
+- [x] 4.2 Test skill generation by running `openspec init` in a test directory and verifying onboard skill/command files are created
diff --git a/openspec/changes/archive/2026-01-09-add-flake-update-script/specs/flake-update-script/spec.md b/openspec/changes/archive/2026-01-09-add-flake-update-script/specs/flake-update-script/spec.md
index 476bb4a..891869e 100644
--- a/openspec/changes/archive/2026-01-09-add-flake-update-script/specs/flake-update-script/spec.md
+++ b/openspec/changes/archive/2026-01-09-add-flake-update-script/specs/flake-update-script/spec.md
@@ -1,17 +1,18 @@
 ## ADDED Requirements
 
-### Requirement: Automatic Version Update
-The script SHALL automatically update the version in flake.nix to match package.json.
+### Requirement: Dynamic Version Support
+The script SHALL support flake.nix configurations that read version dynamically from package.json.
 
-#### Scenario: Version extraction from package.json
+#### Scenario: Version validation
 - **WHEN** script runs
 - **THEN** version is read from package.json using Node.js
-- **AND** version field in flake.nix is updated to match
+- **AND** script verifies flake.nix uses dynamic version pattern
+- **AND** warns if hardcoded version is detected
 
-#### Scenario: Version already up-to-date
-- **WHEN** script runs and flake.nix version already matches package.json
-- **THEN** script reports version is up-to-date
-- **AND** continues to hash update
+#### Scenario: Version display
+- **WHEN** script runs
+- **THEN** script displays current package version
+- **AND** indicates version is read dynamically by flake.nix
 
 ### Requirement: Automatic Hash Determination
 The script SHALL automatically determine and update the correct pnpm dependency hash.
@@ -29,7 +30,8 @@ The script SHALL automatically determine and update the correct pnpm dependency
 
 #### Scenario: Hash update failure
 - **WHEN** script cannot extract hash from build output
-- **THEN** script exits with error
+- **THEN** script restores original hash to flake.nix
+- **AND** exits with error code 1
 - **AND** displays build output for debugging
 
 ### Requirement: Build Verification
@@ -55,8 +57,13 @@ The script SHALL provide clear progress information and next steps.
 
 #### Scenario: Success summary
 - **WHEN** script completes successfully
-- **THEN** summary shows updated version and hash
-- **AND** next steps are displayed (test, commit, etc.)
+- **THEN** summary shows version and hash changes
+- **AND** next steps are displayed (test, verify, commit)
+
+#### Scenario: No changes needed
+- **WHEN** hash is already up-to-date
+- **THEN** script reports no changes needed
+- **AND** exits with success code 0
 
 ### Requirement: Script Safety
 The script SHALL fail fast on errors and use safe defaults.
diff --git a/openspec/changes/merge-init-experimental/.openspec.yaml b/openspec/changes/merge-init-experimental/.openspec.yaml
new file mode 100644
index 0000000..7df1534
--- /dev/null
+++ b/openspec/changes/merge-init-experimental/.openspec.yaml
@@ -0,0 +1,2 @@
+schema: spec-driven
+created: 2026-01-23
diff --git a/openspec/changes/merge-init-experimental/design.md b/openspec/changes/merge-init-experimental/design.md
new file mode 100644
index 0000000..3701e3c
--- /dev/null
+++ b/openspec/changes/merge-init-experimental/design.md
@@ -0,0 +1,193 @@
+## Context
+
+Currently `openspec init` and `openspec experimental` are separate commands with distinct purposes:
+
+- **init**: Creates `openspec/` directory, generates `AGENTS.md`/`project.md`, configures tool config files (`CLAUDE.md`, etc.), generates old slash commands (`/openspec:proposal`, etc.)
+- **experimental**: Generates skills (9 per tool), generates opsx slash commands (`/opsx:new`, etc.), creates `config.yaml`
+
+The skill-based workflow (experimental) is the direction we're going, so we're making it the default by merging into `init`.
+
+## Goals / Non-Goals
+
+**Goals:**
+- Single `openspec init` command that sets up the complete skill-based workflow
+- Clean migration path for existing users with legacy artifacts
+- Remove all code related to config files and old slash commands
+- Keep the polished UX from experimental (animated welcome, searchable multi-select)
+
+**Non-Goals:**
+- Supporting both workflows simultaneously
+- Providing options to use the old workflow
+- Backward compatibility for `/openspec:*` commands (breaking change)
+
+## Decisions
+
+### Decision 1: Merge into init, not into experimental
+
+**Choice**: Rewrite `init` to do what `experimental` does, then delete `experimental`.
+
+**Rationale**: `init` is the canonical setup command. Users expect `init` to set up their project. `experimental` was always meant to be temporary.
+
+**Alternatives considered**:
+- Keep `experimental` as the main command â†’ confusing name for default behavior
+- Create new command â†’ unnecessary, `init` already exists
+
+### Decision 2: Legacy cleanup with Y/N prompt
+
+**Choice**: Detect legacy artifacts, show what was found, prompt `"Legacy files detected. Upgrade and clean up? [Y/n]"`, then remove if confirmed.
+
+**Rationale**: Users should know what's being removed. A single Y/N is simple and decisive. No need for multiple options.
+
+**Alternatives considered**:
+- Multiple options (keep/remove/cancel) â†’ overcomplicated
+- Silent removal â†’ users might be surprised
+- Just warn without removing â†’ leaves cruft
+
+### Decision 3: Surgical removal of legacy content
+
+**Choice**: For files with mixed content (OpenSpec markers + user content), only remove the OpenSpec marker block. For files that are 100% OpenSpec content, delete the entire file.
+
+**Rationale**: Respects user customizations. CLAUDE.md might have other instructions beyond OpenSpec.
+
+**Edge cases**:
+- **Config files with mixed content**: Remove only `<!-- OPENSPEC:START -->` to `<!-- OPENSPEC:END -->` block
+- **Config files that are 100% OpenSpec**: Delete file entirely (check if content outside markers is empty/whitespace)
+- **Old slash command directories** (`.claude/commands/openspec/`): Delete entire directory (ours)
+- **`openspec/AGENTS.md`**: Delete (ours)
+- **Root `AGENTS.md`**: Only remove OpenSpec marker block, preserve rest
+
+### Decision 6: Preserve project.md with migration hint
+
+**Choice**: Do NOT auto-delete `openspec/project.md`. Preserve it and show a message directing users to manually migrate content to `config.yaml`'s `context:` field.
+
+**Rationale**:
+- `project.md` may contain valuable user-written project documentation
+- The new workflow uses `config.yaml.context` for the same purpose (auto-injected into artifacts)
+- Auto-deleting would lose user content; auto-migrating is complex (needs LLM to compress)
+- Users can migrate manually or use `/opsx:explore` to get AI assistance
+
+**Migration path**:
+1. During legacy cleanup, detect `openspec/project.md` but do not delete
+2. Show in output: "openspec/project.md still exists - migrate content to config.yaml's context: field, then delete"
+3. User migrates manually or asks Claude in explore mode: "help me migrate project.md to config.yaml"
+4. User deletes project.md when ready
+
+**Why not auto-migrate?**
+- `project.md` is verbose (sections, headers, placeholders)
+- `config.yaml.context` should be concise and dense
+- LLM compression would be ideal but adds complexity and non-determinism to init
+- Manual migration lets users decide what's actually important
+
+### Decision 4: Hidden alias for experimental
+
+**Choice**: Keep `openspec experimental` as a hidden command that delegates to `init`.
+
+**Rationale**: Users who learned `experimental` can still use it during transition. Hidden means it won't show in help.
+
+### Decision 5: Reuse existing infrastructure
+
+**Choice**: Reuse skill templates, command adapters, welcome screen, and multi-select from experimental.
+
+**Rationale**: Already built and working. Just needs to be called from init instead of experimental.
+
+## Risks / Trade-offs
+
+| Risk | Mitigation |
+|------|------------|
+| Users with custom `/openspec:*` commands lose them | Document in release notes; old commands are in git history |
+| Mixed-content detection might be imperfect | Conservative approach: if unsure, preserve the file and warn |
+| Users confused by missing config files | Clear messaging in init output about what changed |
+| `openspec update` might break | Review and update `update` command to work with new structure |
+
+## Architecture
+
+### What init creates (after merge)
+
+```
+openspec/
+  â”œâ”€â”€ config.yaml           # Schema settings (from experimental)
+  â”œâ”€â”€ specs/                # Empty, for user's specs
+  â””â”€â”€ changes/              # Empty, for user's changes
+      â””â”€â”€ archive/
+
+.<tool>/skills/             # 9 skills per selected tool
+  â”œâ”€â”€ openspec-explore/SKILL.md
+  â”œâ”€â”€ openspec-new-change/SKILL.md
+  â”œâ”€â”€ openspec-continue-change/SKILL.md
+  â”œâ”€â”€ openspec-apply-change/SKILL.md
+  â”œâ”€â”€ openspec-ff-change/SKILL.md
+  â”œâ”€â”€ openspec-verify-change/SKILL.md
+  â”œâ”€â”€ openspec-sync-specs/SKILL.md
+  â”œâ”€â”€ openspec-archive-change/SKILL.md
+  â””â”€â”€ openspec-bulk-archive-change/SKILL.md
+
+.<tool>/commands/opsx/      # 9 slash commands per selected tool
+  â”œâ”€â”€ explore.md
+  â”œâ”€â”€ new.md
+  â”œâ”€â”€ continue.md
+  â”œâ”€â”€ apply.md
+  â”œâ”€â”€ ff.md
+  â”œâ”€â”€ verify.md
+  â”œâ”€â”€ sync.md
+  â”œâ”€â”€ archive.md
+  â””â”€â”€ bulk-archive.md
+```
+
+### What init no longer creates
+
+- `CLAUDE.md`, `.cursorrules`, `.windsurfrules`, etc. (config files)
+- `openspec/AGENTS.md`
+- `openspec/project.md`
+- Root `AGENTS.md` stub
+- `.claude/commands/openspec/` (old slash commands)
+
+### Legacy detection targets
+
+| Artifact Type | Detection Method | Removal Method |
+|--------------|------------------|----------------|
+| Config files (CLAUDE.md, etc.) | File exists AND contains OpenSpec markers | Remove marker block; delete file if empty after |
+| Old slash command dirs | Directory exists at `.<tool>/commands/openspec/` | Delete entire directory |
+| openspec/AGENTS.md | File exists at `openspec/AGENTS.md` | Delete file |
+| openspec/project.md | File exists at `openspec/project.md` | **Preserve** - show migration hint only |
+| Root AGENTS.md | File exists at `AGENTS.md` AND contains OpenSpec markers | Remove marker block; delete file if empty after |
+
+### Code to remove
+
+- `src/core/configurators/` - entire directory (ToolRegistry, all config generators)
+- `src/core/configurators/slash/` - entire directory (SlashCommandRegistry, old command generators)
+- `src/core/templates/slash-command-templates.ts` - old `/openspec:*` content
+- `src/core/templates/claude-template.ts`
+- `src/core/templates/cline-template.ts`
+- `src/core/templates/costrict-template.ts`
+- `src/core/templates/agents-template.ts`
+- `src/core/templates/agents-root-stub.ts`
+- `src/core/templates/project-template.ts`
+- `src/commands/experimental/` - entire directory (merged into init)
+- Related test files
+
+### Code to migrate into init
+
+- Animated welcome screen (`src/ui/welcome-screen.ts`) - keep, call from init
+- Searchable multi-select (`src/prompts/searchable-multi-select.ts`) - keep, call from init
+- Skill templates (`src/core/templates/skill-templates.ts`) - keep
+- Command generation (`src/core/command-generation/`) - keep
+- Tool states detection (from `experimental/setup.ts`) - move to init
+
+## Open Questions
+
+1. **What happens to `openspec update`?** - RESOLVED
+
+   **Current behavior**: Updates `openspec/AGENTS.md`, config files (`CLAUDE.md`, etc.) via `ToolRegistry`, and old slash commands (`/openspec:*`) via `SlashCommandRegistry`.
+
+   **New behavior**: Rewrite to refresh skills and opsx commands instead:
+   - Detect which tools have skills installed (check for `.claude/skills/openspec-*/`, etc.)
+   - Refresh all 9 skill files per installed tool using `skill-templates.ts`
+   - Refresh all 9 opsx command files per installed tool using `command-generation/` adapters
+   - Remove imports of `ToolRegistry`, `SlashCommandRegistry`, `agentsTemplate`
+   - Update output messaging to reflect skills/commands instead of config files
+
+   **Key principle**: Same as current update - only refresh existing tools, don't add new ones.
+
+2. **Should we keep `openspec schemas` and other experimental subcommands?** - RESOLVED
+
+   **Decision**: Yes, keep them. Remove "[Experimental]" label from all subcommands (status, instructions, schemas, etc.). See task 4.3.
diff --git a/openspec/changes/merge-init-experimental/proposal.md b/openspec/changes/merge-init-experimental/proposal.md
new file mode 100644
index 0000000..c7d25da
--- /dev/null
+++ b/openspec/changes/merge-init-experimental/proposal.md
@@ -0,0 +1,32 @@
+## Why
+
+The current setup has two separate commands (`openspec init` and `openspec experimental`) that configure different parts of the OpenSpec workflow. This creates confusion about which command to run, results in partial setups, and maintains two parallel systems (config files + old slash commands vs skills + opsx commands). Making the skill-based workflow the default simplifies onboarding and establishes a single, consistent way to use OpenSpec.
+
+## What Changes
+
+- **BREAKING**: `openspec init` now generates skills and `/opsx:*` commands instead of config files and `/openspec:*` commands
+- **BREAKING**: Config files (`CLAUDE.md`, `.cursorrules`, etc.) are no longer generated
+- **BREAKING**: Old slash commands (`/openspec:proposal`, `/openspec:apply`, `/openspec:archive`) are no longer generated
+- **BREAKING**: `openspec/AGENTS.md` and `openspec/project.md` are no longer generated
+- Merge `experimental` command functionality into `init`
+- Add legacy detection and auto-cleanup with Y/N confirmation
+- Keep `openspec experimental` as hidden alias for backward compatibility
+- Use the animated welcome screen from experimental for the unified init
+
+## Capabilities
+
+### New Capabilities
+
+- `legacy-cleanup`: Detect and remove legacy OpenSpec artifacts (config files, old slash commands, AGENTS.md) during init
+
+### Modified Capabilities
+
+- `cli-init`: Complete rewrite - generates skills and opsx commands instead of config files and old slash commands; removes AGENTS.md/project.md generation; adds legacy cleanup; uses experimental's animated welcome screen
+
+## Impact
+
+- **Code removal**: `ToolRegistry`, `SlashCommandRegistry`, config file generators, old slash command templates, AGENTS.md/project.md templates
+- **Code migration**: Move skill generation and command adapter logic from `experimental/setup.ts` into `init.ts`
+- **Commands affected**: `init` (rewritten), `experimental` (becomes hidden alias), `update` (may need adjustment)
+- **User migration**: Existing users running `init` will be prompted to clean up legacy files
+- **Breaking for**: Users relying on config files for passive triggering, users using `/openspec:*` commands
diff --git a/openspec/changes/merge-init-experimental/specs/cli-init/spec.md b/openspec/changes/merge-init-experimental/specs/cli-init/spec.md
new file mode 100644
index 0000000..db26a35
--- /dev/null
+++ b/openspec/changes/merge-init-experimental/specs/cli-init/spec.md
@@ -0,0 +1,176 @@
+## MODIFIED Requirements
+
+### Requirement: Directory Creation
+
+The command SHALL create the OpenSpec directory structure with config file.
+
+#### Scenario: Creating OpenSpec structure
+
+- **WHEN** `openspec init` is executed
+- **THEN** create the following directory structure:
+```
+openspec/
+â”œâ”€â”€ config.yaml
+â”œâ”€â”€ specs/
+â””â”€â”€ changes/
+    â””â”€â”€ archive/
+```
+
+### Requirement: AI Tool Configuration
+
+The command SHALL configure AI coding assistants with skills and slash commands using a searchable multi-select experience.
+
+#### Scenario: Prompting for AI tool selection
+
+- **WHEN** run interactively
+- **THEN** display animated welcome screen with OpenSpec logo
+- **AND** present a searchable multi-select that shows all available tools
+- **AND** mark already configured tools with "(configured âœ“)" indicator
+- **AND** pre-select configured tools for easy refresh
+- **AND** sort configured tools to appear first in the list
+- **AND** allow filtering by typing to search
+
+#### Scenario: Selecting tools to configure
+
+- **WHEN** user selects tools and confirms
+- **THEN** generate skills in `.<tool>/skills/` directory for each selected tool
+- **AND** generate slash commands in `.<tool>/commands/opsx/` directory for each selected tool
+- **AND** create `openspec/config.yaml` with default schema setting
+
+### Requirement: Skill Generation
+
+The command SHALL generate Agent Skills for selected AI tools.
+
+#### Scenario: Generating skills for a tool
+
+- **WHEN** a tool is selected during initialization
+- **THEN** create 9 skill directories under `.<tool>/skills/`:
+  - `openspec-explore/SKILL.md`
+  - `openspec-new-change/SKILL.md`
+  - `openspec-continue-change/SKILL.md`
+  - `openspec-apply-change/SKILL.md`
+  - `openspec-ff-change/SKILL.md`
+  - `openspec-verify-change/SKILL.md`
+  - `openspec-sync-specs/SKILL.md`
+  - `openspec-archive-change/SKILL.md`
+  - `openspec-bulk-archive-change/SKILL.md`
+- **AND** each SKILL.md SHALL contain YAML frontmatter with name and description
+- **AND** each SKILL.md SHALL contain the skill instructions
+
+### Requirement: Slash Command Generation
+
+The command SHALL generate opsx slash commands for selected AI tools.
+
+#### Scenario: Generating slash commands for a tool
+
+- **WHEN** a tool is selected during initialization
+- **THEN** create 9 slash command files using the tool's command adapter:
+  - `/opsx:explore`
+  - `/opsx:new`
+  - `/opsx:continue`
+  - `/opsx:apply`
+  - `/opsx:ff`
+  - `/opsx:verify`
+  - `/opsx:sync`
+  - `/opsx:archive`
+  - `/opsx:bulk-archive`
+- **AND** use tool-specific path conventions (e.g., `.claude/commands/opsx/` for Claude)
+- **AND** include tool-specific frontmatter format
+
+### Requirement: Success Output
+
+The command SHALL provide clear, actionable next steps upon successful initialization.
+
+#### Scenario: Displaying success message
+
+- **WHEN** initialization completes successfully
+- **THEN** display categorized summary:
+  - "Created: <tools>" for newly configured tools
+  - "Refreshed: <tools>" for already-configured tools that were updated
+  - Count of skills and commands generated
+- **AND** display getting started section with:
+  - `/opsx:new` - Start a new change
+  - `/opsx:continue` - Create the next artifact
+  - `/opsx:apply` - Implement tasks
+- **AND** display links to documentation and feedback
+
+#### Scenario: Displaying restart instruction
+
+- **WHEN** initialization completes successfully and tools were created or refreshed
+- **THEN** display instruction to restart IDE for slash commands to take effect
+
+### Requirement: Config File Generation
+
+The command SHALL create an OpenSpec config file with schema settings.
+
+#### Scenario: Creating config.yaml
+
+- **WHEN** initialization completes
+- **AND** config.yaml does not exist
+- **THEN** create `openspec/config.yaml` with default schema setting
+- **AND** display config location in output
+
+#### Scenario: Preserving existing config.yaml
+
+- **WHEN** initialization runs in extend mode
+- **AND** `openspec/config.yaml` already exists
+- **THEN** preserve the existing config file
+- **AND** display "(exists)" indicator in output
+
+### Requirement: Non-Interactive Mode
+
+The command SHALL support non-interactive operation through command-line options.
+
+#### Scenario: Select all tools non-interactively
+
+- **WHEN** run with `--tools all`
+- **THEN** automatically select every available AI tool without prompting
+- **AND** proceed with skill and command generation
+
+#### Scenario: Select specific tools non-interactively
+
+- **WHEN** run with `--tools claude,cursor`
+- **THEN** parse the comma-separated tool IDs
+- **AND** generate skills and commands for specified tools only
+
+#### Scenario: Skip tool configuration non-interactively
+
+- **WHEN** run with `--tools none`
+- **THEN** create only the openspec directory structure and config.yaml
+- **AND** skip skill and command generation
+
+### Requirement: Experimental Command Alias
+
+The command SHALL maintain backward compatibility with the experimental command.
+
+#### Scenario: Running openspec experimental
+
+- **WHEN** user runs `openspec experimental`
+- **THEN** delegate to `openspec init`
+- **AND** the command SHALL be hidden from help output
+
+## REMOVED Requirements
+
+### Requirement: File Generation
+
+**Reason**: AGENTS.md and project.md are no longer generated. Skills contain all necessary instructions.
+
+**Migration**: Skills in `.<tool>/skills/` provide all OpenSpec workflow instructions. No manual file needed.
+
+### Requirement: AI Tool Configuration Details
+
+**Reason**: Config files (CLAUDE.md, .cursorrules, etc.) are replaced by skills.
+
+**Migration**: Use skills in `.<tool>/skills/` instead of config files. Skills provide richer, tool-specific instructions.
+
+### Requirement: Slash Command Configuration
+
+**Reason**: Old `/openspec:*` slash commands are replaced by `/opsx:*` commands with richer functionality.
+
+**Migration**: Use `/opsx:new`, `/opsx:continue`, `/opsx:apply` instead of `/openspec:proposal`, `/openspec:apply`, `/openspec:archive`.
+
+### Requirement: Root instruction stub
+
+**Reason**: Root AGENTS.md stub is no longer needed. Skills provide tool-specific instructions.
+
+**Migration**: Skills are loaded automatically by supporting tools. No root stub needed.
diff --git a/openspec/changes/merge-init-experimental/specs/legacy-cleanup/spec.md b/openspec/changes/merge-init-experimental/specs/legacy-cleanup/spec.md
new file mode 100644
index 0000000..97eff6f
--- /dev/null
+++ b/openspec/changes/merge-init-experimental/specs/legacy-cleanup/spec.md
@@ -0,0 +1,158 @@
+## ADDED Requirements
+
+### Requirement: Legacy artifact detection
+
+The system SHALL detect legacy OpenSpec artifacts from previous init versions.
+
+#### Scenario: Detecting legacy config files
+
+- **WHEN** running `openspec init` on an existing project
+- **THEN** the system SHALL check for config files with OpenSpec markers:
+  - `CLAUDE.md`
+  - `.cursorrules`
+  - `.windsurfrules`
+  - `.clinerules`
+  - `.kilocode_rules`
+  - `.github/copilot-instructions.md`
+  - `.amazonq/instructions.md`
+  - `CODEBUDDY.md`
+  - `IFLOW.md`
+  - And all other tool config files from the legacy ToolRegistry
+
+#### Scenario: Detecting legacy slash command directories
+
+- **WHEN** running `openspec init` on an existing project
+- **THEN** the system SHALL check for old slash command directories:
+  - `.claude/commands/openspec/`
+  - `.cursor/commands/openspec/` (note: old format used `openspec-*.md` in commands root)
+  - `.windsurf/workflows/openspec-*.md`
+  - And equivalent directories for all tools in the legacy SlashCommandRegistry
+
+#### Scenario: Detecting legacy OpenSpec structure files
+
+- **WHEN** running `openspec init` on an existing project
+- **THEN** the system SHALL check for:
+  - `openspec/AGENTS.md`
+  - `openspec/project.md` (for migration messaging only, not deleted)
+  - Root `AGENTS.md` with OpenSpec markers
+
+### Requirement: Legacy cleanup confirmation
+
+The system SHALL prompt for confirmation before removing legacy artifacts.
+
+#### Scenario: Prompting for cleanup when legacy detected
+
+- **WHEN** legacy artifacts are detected
+- **THEN** the system SHALL display what was found
+- **AND** prompt: "Legacy files detected. Upgrade and clean up? [Y/n]"
+- **AND** default to Yes if user presses Enter
+
+#### Scenario: User confirms cleanup
+
+- **WHEN** user responds Y or presses Enter
+- **THEN** the system SHALL remove legacy artifacts
+- **AND** proceed with skill-based setup
+
+#### Scenario: User declines cleanup
+
+- **WHEN** user responds N
+- **THEN** the system SHALL abort initialization
+- **AND** display message suggesting manual cleanup or using `--force` flag
+
+#### Scenario: Non-interactive mode
+
+- **WHEN** running with `--no-interactive` or in CI environment
+- **AND** legacy artifacts are detected
+- **THEN** the system SHALL abort with exit code 1
+- **AND** display detected legacy artifacts
+- **AND** suggest running interactively or using `--force` flag
+
+### Requirement: Surgical removal of config file content
+
+The system SHALL preserve user content when removing OpenSpec markers from config files.
+
+#### Scenario: Config file with only OpenSpec content
+
+- **WHEN** a config file contains only OpenSpec marker block (whitespace outside is acceptable)
+- **THEN** the system SHALL remove the OpenSpec marker block
+- **AND** preserve the file (even if empty or whitespace-only)
+- **AND** NOT delete the file (config files belong to the user's project root)
+
+#### Scenario: Config file with mixed content
+
+- **WHEN** a config file contains content outside OpenSpec markers
+- **THEN** the system SHALL remove only the `<!-- OPENSPEC:START -->` to `<!-- OPENSPEC:END -->` block
+- **AND** preserve all content before and after the markers
+- **AND** clean up any resulting double blank lines
+
+#### Scenario: Root AGENTS.md with mixed content
+
+- **WHEN** root `AGENTS.md` contains OpenSpec markers AND other content
+- **THEN** the system SHALL remove only the OpenSpec marker block
+- **AND** preserve the rest of the file
+
+### Requirement: Legacy directory removal
+
+The system SHALL remove legacy slash command directories entirely.
+
+#### Scenario: Removing old slash command directory
+
+- **WHEN** a legacy slash command directory exists (e.g., `.claude/commands/openspec/`)
+- **THEN** the system SHALL delete the entire directory and its contents
+- **AND** NOT delete the parent directory (e.g., `.claude/commands/` remains)
+
+#### Scenario: Removing legacy AGENTS.md
+
+- **WHEN** `openspec/AGENTS.md` exists
+- **THEN** the system SHALL delete the file
+- **AND** NOT delete the `openspec/` directory itself
+
+### Requirement: project.md migration hint
+
+The system SHALL preserve project.md and display a migration hint instead of deleting it.
+
+#### Scenario: project.md exists during upgrade
+
+- **WHEN** `openspec/project.md` exists during legacy cleanup
+- **THEN** the system SHALL NOT delete the file
+- **AND** the system SHALL display a migration hint in the output:
+  ```
+  Manual migration needed:
+    â†’ openspec/project.md still exists
+      Move useful content to config.yaml's "context:" field, then delete
+  ```
+
+#### Scenario: project.md migration rationale
+
+- **GIVEN** project.md may contain user-written project documentation
+- **AND** config.yaml's context field serves the same purpose (auto-injected into artifacts)
+- **WHEN** displaying the migration hint
+- **THEN** users can migrate manually or use `/opsx:explore` to get AI assistance
+
+### Requirement: Cleanup reporting
+
+The system SHALL report what was cleaned up.
+
+#### Scenario: Displaying cleanup summary
+
+- **WHEN** legacy cleanup completes
+- **THEN** the system SHALL display a summary section:
+  ```
+  Cleaned up legacy files:
+    âœ“ Removed OpenSpec markers from CLAUDE.md
+    âœ“ Removed .claude/commands/openspec/ (replaced by /opsx:*)
+    âœ“ Removed openspec/AGENTS.md (no longer needed)
+  ```
+- **AND IF** `openspec/project.md` exists
+- **THEN** the system SHALL display a separate migration section:
+  ```
+  Manual migration needed:
+    â†’ openspec/project.md still exists
+      Move useful content to config.yaml's "context:" field, then delete
+  ```
+
+#### Scenario: No legacy detected
+
+- **WHEN** no legacy artifacts are found
+- **THEN** the system SHALL NOT display the cleanup section
+- **AND** proceed directly with skill setup
diff --git a/openspec/changes/merge-init-experimental/tasks.md b/openspec/changes/merge-init-experimental/tasks.md
new file mode 100644
index 0000000..c79e25d
--- /dev/null
+++ b/openspec/changes/merge-init-experimental/tasks.md
@@ -0,0 +1,67 @@
+## 1. Legacy Detection & Cleanup Module
+
+- [x] 1.1 Create `src/core/legacy-cleanup.ts` with detection functions for all legacy artifact types
+- [x] 1.2 Implement `detectLegacyConfigFiles()` - check for config files with OpenSpec markers
+- [x] 1.3 Implement `detectLegacySlashCommands()` - check for old `/openspec:*` command directories
+- [x] 1.4 Implement `detectLegacyStructureFiles()` - check for AGENTS.md (project.md detected separately for messaging)
+- [x] 1.5 Implement `removeMarkerBlock()` - surgically remove OpenSpec marker blocks from files
+- [x] 1.6 Implement `cleanupLegacyArtifacts()` - orchestrate removal with proper edge case handling (preserves project.md)
+- [x] 1.7 Implement migration hint output for project.md - show message directing users to migrate to config.yaml
+- [x] 1.8 Add unit tests for legacy detection and cleanup functions
+
+## 2. Rewrite Init Command
+
+- [x] 2.1 Replace `src/core/init.ts` with new implementation using experimental's approach
+- [x] 2.2 Import and use animated welcome screen from `src/ui/welcome-screen.ts`
+- [x] 2.3 Import and use searchable multi-select from `src/prompts/searchable-multi-select.ts`
+- [x] 2.4 Integrate legacy detection at start of init flow
+- [x] 2.5 Add Y/N prompt for legacy cleanup confirmation
+- [x] 2.6 Generate skills using existing `skill-templates.ts`
+- [x] 2.7 Generate slash commands using existing `command-generation/` adapters
+- [x] 2.8 Create `openspec/config.yaml` with default schema
+- [x] 2.9 Update success output to match new workflow (skills, /opsx:* commands)
+- [x] 2.10 Add `--force` flag to skip legacy cleanup prompt in non-interactive mode
+
+## 3. Remove Legacy Code
+
+- [x] 3.1 Delete `src/core/configurators/` directory (ToolRegistry, all config generators)
+- [x] 3.2 Delete `src/core/templates/slash-command-templates.ts`
+- [x] 3.3 Delete `src/core/templates/claude-template.ts`
+- [x] 3.4 Delete `src/core/templates/cline-template.ts`
+- [x] 3.5 Delete `src/core/templates/costrict-template.ts`
+- [x] 3.6 Delete `src/core/templates/agents-template.ts`
+- [x] 3.7 Delete `src/core/templates/agents-root-stub.ts`
+- [x] 3.8 Delete `src/core/templates/project-template.ts`
+- [x] 3.9 Delete `src/commands/experimental/` directory
+- [x] 3.10 Update `src/core/templates/index.ts` to remove deleted exports
+- [x] 3.11 Delete related test files for removed modules (wizard.ts)
+
+## 4. Update CLI Registration
+
+- [x] 4.1 Update `src/cli/index.ts` to remove `registerArtifactWorkflowCommands()` call
+- [x] 4.2 Keep experimental subcommands (status, instructions, schemas, etc.) but register directly
+- [x] 4.3 Remove "[Experimental]" labels from kept subcommands
+- [x] 4.4 Add hidden `experimental` command as alias to `init`
+
+## 5. Update Related Commands
+
+- [x] 5.1 Update `openspec update` command to refresh skills/commands instead of config files
+- [x] 5.2 Remove config file refresh logic from update
+- [x] 5.3 Add skill refresh logic to update
+
+## 6. Testing & Verification
+
+- [x] 6.1 Add integration tests for new init flow (fresh install)
+- [x] 6.2 Add integration tests for legacy detection and cleanup
+- [x] 6.3 Add integration tests for extend mode (re-running init)
+- [x] 6.4 Test non-interactive mode with `--tools` flag
+- [x] 6.5 Test `--force` flag for CI environments
+- [x] 6.6 Verify cross-platform path handling (use path.join throughout)
+- [x] 6.7 Run full test suite and fix any broken tests
+
+## 7. Documentation & Cleanup
+
+- [x] 7.1 Update README with new init behavior (skill-based workflow is self-documenting)
+- [x] 7.2 Document breaking changes for release notes (in tasks file)
+- [x] 7.3 Remove any orphaned imports/references to deleted modules (verified none exist)
+- [x] 7.4 Run linter and fix any issues (passed)
diff --git a/openspec/changes/multi-provider-skill-generation/.openspec.yaml b/openspec/changes/multi-provider-skill-generation/.openspec.yaml
new file mode 100644
index 0000000..ec9a990
--- /dev/null
+++ b/openspec/changes/multi-provider-skill-generation/.openspec.yaml
@@ -0,0 +1,2 @@
+schema: spec-driven
+created: 2026-01-22
diff --git a/openspec/changes/multi-provider-skill-generation/design.md b/openspec/changes/multi-provider-skill-generation/design.md
new file mode 100644
index 0000000..bdf8718
--- /dev/null
+++ b/openspec/changes/multi-provider-skill-generation/design.md
@@ -0,0 +1,144 @@
+## Context
+
+The `artifact-experimental-setup` command generates skill files and opsx slash commands for AI coding assistants. Currently it hardcodes paths to `.claude/skills` and `.claude/commands/opsx`.
+
+The existing `AI_TOOLS` array in `config.ts` lists 22 AI tools but lacks path information. There's also an existing `SlashCommandConfigurator` system for the old workflow commands, but it's tightly coupled to the old 3 commands (proposal, apply, archive) and can't be easily extended for the 9 opsx commands.
+
+Each AI tool has:
+- Different skill directory conventions (`.claude/skills/`, `.cursor/skills/`, etc.)
+- Different command file paths (`.claude/commands/opsx/`, `.cursor/commands/`, etc.)
+- Different frontmatter formats (YAML keys, structure varies by tool)
+
+## Goals / Non-Goals
+
+**Goals:**
+- Support skill generation for any AI tool following the Agent Skills spec
+- Support command generation with tool-specific formatting via adapters
+- Require explicit tool selection (no defaults)
+- Create a generic, extensible command generation system
+
+**Non-Goals:**
+- Global path installation (deferred to future work)
+- Multi-tool generation in single command (future enhancement)
+- Unifying with existing SlashCommandConfigurator (separate systems for now)
+
+## Decisions
+
+### 1. Add `skillsDir` to `AIToolOption` interface
+
+**Decision**: Add single `skillsDir` field to existing interface. No `commandsDir` or `globalSkillsDir`.
+
+```typescript
+interface AIToolOption {
+  name: string;
+  value: string;
+  available: boolean;
+  successLabel?: string;
+  skillsDir?: string;  // e.g., '.claude' - /skills suffix per Agent Skills spec
+}
+```
+
+**Rationale**:
+- Skills follow Agent Skills spec: `<toolDir>/skills/` - suffix is standard
+- Commands need per-tool formatting, handled by adapters (not a simple path)
+- Global paths deferred - can extend interface later
+
+### 2. Strategy/Adapter pattern for command generation
+
+**Decision**: Create generic command generation with tool-specific adapters.
+
+```text
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚                      CommandContent                              â”‚
+â”‚  (tool-agnostic: id, name, description, category, tags, body)   â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+                              â”‚
+                              â–¼
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚                   generateCommand(content, adapter)              â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+                              â”‚
+              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+              â–¼               â–¼               â–¼
+        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+        â”‚  Claude  â”‚   â”‚  Cursor  â”‚   â”‚ Windsurf â”‚
+        â”‚ Adapter  â”‚   â”‚ Adapter  â”‚   â”‚ Adapter  â”‚
+        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+```
+
+**Interfaces:**
+
+```typescript
+// Tool-agnostic command data
+interface CommandContent {
+  id: string;           // e.g., 'explore', 'new', 'apply'
+  name: string;         // e.g., 'OpenSpec Explore'
+  description: string;  // e.g., 'Enter explore mode...'
+  category: string;     // e.g., 'OpenSpec'
+  tags: string[];       // e.g., ['openspec', 'explore']
+  body: string;         // The command instructions
+}
+
+// Per-tool formatting strategy
+interface ToolCommandAdapter {
+  toolId: string;
+  getFilePath(commandId: string): string;
+  formatFile(content: CommandContent): string;
+}
+```
+
+**Rationale**:
+- Separates "what to generate" from "how to format it"
+- Each tool's frontmatter quirks encapsulated in its adapter
+- Easy to add new tools by implementing adapter interface
+- Body content shared across all tools
+
+**Alternative considered**: Extend existing SlashCommandConfigurator
+- Rejected: Tightly coupled to old 3 commands, significant refactor needed
+
+### 3. Adapter registry pattern
+
+**Decision**: Create `CommandAdapterRegistry` similar to existing `SlashCommandRegistry`.
+
+```typescript
+class CommandAdapterRegistry {
+  private static adapters: Map<string, ToolCommandAdapter> = new Map();
+
+  static get(toolId: string): ToolCommandAdapter | undefined;
+  static getAll(): ToolCommandAdapter[];
+}
+```
+
+**Rationale**:
+- Consistent with existing codebase patterns
+- Easy lookup by tool ID
+- Centralized registration
+
+### 4. Required tool flag
+
+**Decision**: Require `--tool` flag - error if omitted.
+
+**Rationale**:
+- Explicit tool selection avoids assumptions
+- Consistent with project convention of not providing defaults
+- Users must consciously choose their target tool
+
+## Risks / Trade-offs
+
+**[Risk] Adapter maintenance burden** â†’ Each new tool needs an adapter. Mitigated by simple interface - most adapters are ~20 lines.
+
+**[Risk] Frontmatter format drift** â†’ Tools may change their formats. Mitigated by encapsulating format in adapter - single place to update.
+
+**[Trade-off] Two command systems** â†’ Old SlashCommandConfigurator and new CommandAdapterRegistry coexist. Acceptable for now - can unify later if needed.
+
+**[Trade-off] skillsDir optional** â†’ Tools without skillsDir configured will error. Acceptable - we add paths as tools are tested.
+
+## Implementation Approach
+
+1. Add `skillsDir` to `AIToolOption` and populate for known tools
+2. Create `CommandContent` and `ToolCommandAdapter` interfaces
+3. Implement adapters for Claude, Cursor, Windsurf (start with 3)
+4. Create `CommandAdapterRegistry`
+5. Create `generateCommand()` function
+6. Update `artifact-experimental-setup` to use new system
+7. Add `--tool` flag with validation
diff --git a/openspec/changes/multi-provider-skill-generation/proposal.md b/openspec/changes/multi-provider-skill-generation/proposal.md
new file mode 100644
index 0000000..930c948
--- /dev/null
+++ b/openspec/changes/multi-provider-skill-generation/proposal.md
@@ -0,0 +1,36 @@
+## Why
+
+The `artifact-experimental-setup` command currently hardcodes skill output paths to `.claude/skills` and `.claude/commands/opsx`. This prevents users of other AI coding tools (Cursor, Windsurf, Codex, etc.) from using OpenSpec's skill generation. We need to support the diverse ecosystem of AI coding assistants, each with their own conventions for skill/instruction file locations and command frontmatter formats.
+
+## What Changes
+
+- Add `skillsDir` path configuration to the existing `AIToolOption` interface in `config.ts`
+- Add required `--tool <tool-id>` flag to the `artifact-experimental-setup` command
+- Create a generic command generation system using Strategy/Adapter pattern:
+  - `CommandContent`: tool-agnostic command data (id, name, description, body)
+  - `ToolCommandAdapter`: per-tool formatting (file paths, frontmatter format)
+  - `CommandGenerator`: orchestrates generation using content + adapter
+- Require explicit tool selection (no default) for clarity
+
+## Capabilities
+
+### New Capabilities
+
+- `ai-tool-paths`: Configuration mapping AI tool IDs to their project-local skill directory paths
+- `command-generation`: Generic command generation system with tool adapters for formatting differences
+
+### Modified Capabilities
+
+- `cli-artifact-workflow`: Adding `--tool` flag to setup command for provider selection
+
+## Impact
+
+- **Files Modified**:
+  - `src/core/config.ts` - Extend `AIToolOption` interface with `skillsDir` field
+  - `src/commands/artifact-workflow.ts` - Add `--tool` flag, use provider paths and adapters
+- **New Files**:
+  - `src/core/command-generation/types.ts` - CommandContent, ToolCommandAdapter interfaces
+  - `src/core/command-generation/generator.ts` - Generic command generator
+  - `src/core/command-generation/adapters/*.ts` - Per-tool adapters
+- **Backward Compatibility**: Existing workflows unaffected - this is a new command setup feature
+- **User-Facing**: Required `--tool` flag on `artifact-experimental-setup` command for explicit tool selection
diff --git a/openspec/changes/multi-provider-skill-generation/specs/ai-tool-paths/spec.md b/openspec/changes/multi-provider-skill-generation/specs/ai-tool-paths/spec.md
new file mode 100644
index 0000000..7a0ded8
--- /dev/null
+++ b/openspec/changes/multi-provider-skill-generation/specs/ai-tool-paths/spec.md
@@ -0,0 +1,63 @@
+# ai-tool-paths Specification
+
+## Purpose
+
+Define the path configuration for AI coding tool skill directories, enabling skill generation to target different tools following the Agent Skills spec.
+
+## Requirements
+
+## ADDED Requirements
+
+### Requirement: AIToolOption skillsDir field
+
+The `AIToolOption` interface SHALL include an optional `skillsDir` field for skill generation path configuration.
+
+#### Scenario: Interface includes skillsDir field
+
+- **WHEN** a tool entry is defined in `AI_TOOLS` that supports skill generation
+- **THEN** it SHALL include a `skillsDir` field specifying the project-local base directory (e.g., `.claude`)
+
+#### Scenario: Skills path follows Agent Skills spec
+
+- **WHEN** generating skills for a tool with `skillsDir: '.claude'`
+- **THEN** skills SHALL be written to `<projectRoot>/<skillsDir>/skills/`
+- **AND** the `/skills` suffix is appended per Agent Skills specification
+
+### Requirement: Path configuration for supported tools
+
+The `AI_TOOLS` array SHALL include `skillsDir` for tools that support the Agent Skills specification.
+
+#### Scenario: Claude Code paths defined
+
+- **WHEN** looking up the `claude` tool
+- **THEN** `skillsDir` SHALL be `.claude`
+
+#### Scenario: Cursor paths defined
+
+- **WHEN** looking up the `cursor` tool
+- **THEN** `skillsDir` SHALL be `.cursor`
+
+#### Scenario: Windsurf paths defined
+
+- **WHEN** looking up the `windsurf` tool
+- **THEN** `skillsDir` SHALL be `.windsurf`
+
+#### Scenario: Tools without skillsDir
+
+- **WHEN** a tool has no `skillsDir` defined
+- **THEN** skill generation SHALL error with message indicating the tool is not supported
+
+### Requirement: Cross-platform path handling
+
+The system SHALL handle paths correctly across operating systems.
+
+#### Scenario: Path construction on Windows
+
+- **WHEN** constructing skill paths on Windows
+- **THEN** the system SHALL use `path.join()` for all path construction
+- **AND** SHALL NOT hardcode forward slashes
+
+#### Scenario: Path construction on Unix
+
+- **WHEN** constructing skill paths on macOS or Linux
+- **THEN** the system SHALL use `path.join()` for consistency
diff --git a/openspec/changes/multi-provider-skill-generation/specs/cli-artifact-workflow/spec.md b/openspec/changes/multi-provider-skill-generation/specs/cli-artifact-workflow/spec.md
new file mode 100644
index 0000000..45d4850
--- /dev/null
+++ b/openspec/changes/multi-provider-skill-generation/specs/cli-artifact-workflow/spec.md
@@ -0,0 +1,60 @@
+# cli-artifact-workflow Delta Specification
+
+## Purpose
+
+Add `--tool` flag to the `artifact-experimental-setup` command for multi-provider support.
+
+## ADDED Requirements
+
+### Requirement: Tool selection flag
+
+The `artifact-experimental-setup` command SHALL accept a `--tool <tool-id>` flag to specify the target AI tool.
+
+#### Scenario: Specify tool via flag
+
+- **WHEN** user runs `openspec artifact-experimental-setup --tool cursor`
+- **THEN** skill files are generated in `.cursor/skills/`
+- **AND** command files are generated using Cursor's frontmatter format
+
+#### Scenario: Missing tool flag
+
+- **WHEN** user runs `openspec artifact-experimental-setup` without `--tool`
+- **THEN** the system displays an error requiring the `--tool` flag
+- **AND** lists valid tool IDs in the error message
+
+#### Scenario: Unknown tool ID
+
+- **WHEN** user runs `openspec artifact-experimental-setup --tool unknown-tool`
+- **AND** the tool ID is not in `AI_TOOLS`
+- **THEN** the system displays an error listing valid tool IDs
+
+#### Scenario: Tool without skillsDir
+
+- **WHEN** user specifies a tool that has no `skillsDir` configured
+- **THEN** the system displays an error indicating skill generation is not supported for that tool
+
+#### Scenario: Tool without command adapter
+
+- **WHEN** user specifies a tool that has `skillsDir` but no command adapter registered
+- **THEN** skill files are generated successfully
+- **AND** command generation is skipped with informational message
+
+### Requirement: Output messaging
+
+The setup command SHALL display clear output about what was generated.
+
+#### Scenario: Show target tool in output
+
+- **WHEN** setup command runs successfully
+- **THEN** output includes the target tool name (e.g., "Setting up for Cursor...")
+
+#### Scenario: Show generated paths
+
+- **WHEN** setup command completes
+- **THEN** output lists all generated skill file paths
+- **AND** lists all generated command file paths (if applicable)
+
+#### Scenario: Show skipped commands message
+
+- **WHEN** command generation is skipped due to missing adapter
+- **THEN** output includes message: "Command generation skipped - no adapter for <tool>"
diff --git a/openspec/changes/multi-provider-skill-generation/specs/command-generation/spec.md b/openspec/changes/multi-provider-skill-generation/specs/command-generation/spec.md
new file mode 100644
index 0000000..7374b20
--- /dev/null
+++ b/openspec/changes/multi-provider-skill-generation/specs/command-generation/spec.md
@@ -0,0 +1,98 @@
+# command-generation Specification
+
+## Purpose
+
+Define a generic command generation system that supports multiple AI tools through a Strategy/Adapter pattern, separating command content from tool-specific formatting.
+
+## ADDED Requirements
+
+### Requirement: CommandContent interface
+
+The system SHALL define a tool-agnostic `CommandContent` interface for command data.
+
+#### Scenario: CommandContent structure
+
+- **WHEN** defining a command to generate
+- **THEN** `CommandContent` SHALL include:
+  - `id`: string identifier (e.g., 'explore', 'apply')
+  - `name`: human-readable name (e.g., 'OpenSpec Explore')
+  - `description`: brief description of command purpose
+  - `category`: grouping category (e.g., 'OpenSpec')
+  - `tags`: array of tag strings
+  - `body`: the command instruction content
+
+### Requirement: ToolCommandAdapter interface
+
+The system SHALL define a `ToolCommandAdapter` interface for per-tool formatting.
+
+#### Scenario: Adapter interface structure
+
+- **WHEN** implementing a tool adapter
+- **THEN** `ToolCommandAdapter` SHALL require:
+  - `toolId`: string identifier matching `AIToolOption.value`
+  - `getFilePath(commandId: string)`: returns relative file path for command
+  - `formatFile(content: CommandContent)`: returns complete file content with frontmatter
+
+#### Scenario: Claude adapter formatting
+
+- **WHEN** formatting a command for Claude Code
+- **THEN** the adapter SHALL output YAML frontmatter with `name`, `description`, `category`, `tags` fields
+- **AND** file path SHALL follow pattern `.claude/commands/opsx/<id>.md`
+
+#### Scenario: Cursor adapter formatting
+
+- **WHEN** formatting a command for Cursor
+- **THEN** the adapter SHALL output YAML frontmatter with `name` as `/opsx-<id>`, `id`, `category`, `description` fields
+- **AND** file path SHALL follow pattern `.cursor/commands/opsx-<id>.md`
+
+#### Scenario: Windsurf adapter formatting
+
+- **WHEN** formatting a command for Windsurf
+- **THEN** the adapter SHALL output YAML frontmatter with `name`, `description`, `category`, `tags` fields
+- **AND** file path SHALL follow pattern `.windsurf/commands/opsx/<id>.md`
+
+### Requirement: Command generator function
+
+The system SHALL provide a `generateCommand` function that combines content with adapter.
+
+#### Scenario: Generate command file
+
+- **WHEN** calling `generateCommand(content, adapter)`
+- **THEN** it SHALL return an object with:
+  - `path`: the file path from `adapter.getFilePath(content.id)`
+  - `fileContent`: the formatted content from `adapter.formatFile(content)`
+
+#### Scenario: Generate multiple commands
+
+- **WHEN** generating all opsx commands for a tool
+- **THEN** the system SHALL iterate over command contents and generate each using the tool's adapter
+
+### Requirement: CommandAdapterRegistry
+
+The system SHALL provide a registry for looking up tool adapters.
+
+#### Scenario: Get adapter by tool ID
+
+- **WHEN** calling `CommandAdapterRegistry.get('cursor')`
+- **THEN** it SHALL return the Cursor adapter or undefined if not registered
+
+#### Scenario: Get all adapters
+
+- **WHEN** calling `CommandAdapterRegistry.getAll()`
+- **THEN** it SHALL return array of all registered adapters
+
+#### Scenario: Adapter not found
+
+- **WHEN** looking up an adapter for unregistered tool
+- **THEN** `CommandAdapterRegistry.get()` SHALL return undefined
+- **AND** caller SHALL handle missing adapter appropriately
+
+### Requirement: Shared command body content
+
+The body content of commands SHALL be shared across all tools.
+
+#### Scenario: Same instructions across tools
+
+- **WHEN** generating the 'explore' command for Claude and Cursor
+- **THEN** both SHALL use the same `body` content
+- **AND** only the frontmatter and file path SHALL differ
diff --git a/openspec/changes/multi-provider-skill-generation/tasks.md b/openspec/changes/multi-provider-skill-generation/tasks.md
new file mode 100644
index 0000000..3732f15
--- /dev/null
+++ b/openspec/changes/multi-provider-skill-generation/tasks.md
@@ -0,0 +1,55 @@
+## 1. Extend AIToolOption Interface
+
+- [x] 1.1 Add `skillsDir?: string` field to `AIToolOption` interface in `src/core/config.ts`
+
+## 2. Add skillsDir to AI_TOOLS
+
+- [x] 2.1 Add `skillsDir: '.claude'` to Claude Code tool entry
+- [x] 2.2 Add `skillsDir: '.cursor'` to Cursor tool entry
+- [x] 2.3 Add `skillsDir: '.windsurf'` to Windsurf tool entry
+- [x] 2.4 Add skillsDir for other tools with known Agent Skills spec support (codex, opencode, roocode, kilocode, gemini, factory, github-copilot)
+
+## 3. Create Command Generation Types
+
+- [x] 3.1 Create `src/core/command-generation/types.ts` with `CommandContent` interface
+- [x] 3.2 Add `ToolCommandAdapter` interface to types.ts
+- [x] 3.3 Export types from module index
+
+## 4. Implement Tool Command Adapters
+
+- [x] 4.1 Create `src/core/command-generation/adapters/claude.ts` with Claude frontmatter format
+- [x] 4.2 Create `src/core/command-generation/adapters/cursor.ts` with Cursor frontmatter format
+- [x] 4.3 Create `src/core/command-generation/adapters/windsurf.ts` with Windsurf frontmatter format
+- [x] 4.4 Create base adapter or utility for shared YAML formatting logic (if applicable)
+
+## 5. Create Command Adapter Registry
+
+- [x] 5.1 Create `src/core/command-generation/registry.ts` with `CommandAdapterRegistry` class
+- [x] 5.2 Register Claude, Cursor, Windsurf adapters in static initializer
+- [x] 5.3 Add `get(toolId)` and `getAll()` methods
+
+## 6. Create Command Generator
+
+- [x] 6.1 Create `src/core/command-generation/generator.ts` with `generateCommand()` function
+- [x] 6.2 Add `generateCommands()` function for batch generation
+- [x] 6.3 Create module index `src/core/command-generation/index.ts` exporting public API
+
+## 7. Update artifact-experimental-setup Command
+
+- [x] 7.1 Add `--tool <tool-id>` option (required) to command in `src/commands/artifact-workflow.ts`
+- [x] 7.2 Add validation: `--tool` flag is required (error if missing with list of valid tools)
+- [x] 7.3 Add validation: tool exists in AI_TOOLS
+- [x] 7.4 Add validation: tool has skillsDir configured
+- [x] 7.5 Replace hardcoded `.claude` skill paths with `tool.skillsDir`
+- [x] 7.6 Replace hardcoded command generation with `CommandAdapterRegistry.get()` + `generateCommands()`
+- [x] 7.7 Handle missing adapter gracefully (skip commands with message)
+- [x] 7.8 Update output messages to show target tool name and paths
+
+## 8. Testing
+
+- [x] 8.1 Add unit tests for `CommandContent` and `ToolCommandAdapter` contracts
+- [x] 8.2 Add unit tests for Claude adapter (path + frontmatter format)
+- [x] 8.3 Add unit tests for Cursor adapter (path + frontmatter format)
+- [x] 8.4 Add unit tests for `CommandAdapterRegistry.get()` and missing adapter case
+- [x] 8.5 Add integration test for `--tool` flag validation
+- [x] 8.6 Verify cross-platform path handling uses `path.join()` throughout
diff --git a/openspec/specs/ci-nix-validation/spec.md b/openspec/specs/ci-nix-validation/spec.md
index b7d9b6e..f9029b4 100644
--- a/openspec/specs/ci-nix-validation/spec.md
+++ b/openspec/specs/ci-nix-validation/spec.md
@@ -33,8 +33,8 @@ The CI system SHALL validate that the update-flake.sh script executes successful
 
 - **WHEN** the CI runs the update script validation
 - **THEN** the script SHALL execute without errors
-- **AND** the script SHALL correctly extract the version from package.json
-- **AND** the script SHALL update flake.nix with the correct version
+- **AND** the script SHALL correctly read the version from package.json
+- **AND** the script SHALL validate that flake.nix uses dynamic version from package.json
 
 #### Scenario: Update script with mock hash
 
diff --git a/package.json b/package.json
index 41369f8..c4bdaa0 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "@fission-ai/openspec",
-  "version": "0.23.0",
+  "version": "1.0.2",
   "description": "AI-native system for spec-driven development",
   "keywords": [
     "openspec",
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 92da325..a632f81 100644
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -463,8 +463,8 @@ packages:
       '@types/node':
         optional: true
 
-  '@inquirer/type@3.0.8':
-    resolution: {integrity: sha512-lg9Whz8onIHRthWaN1Q9EGLa/0LFJjyM8mEUbL1eTi6yMGvBf8gvyDLtxSXztQsxMvhxxNpJYrwa1YHdq+w4Jw==}
+  '@inquirer/type@3.0.10':
+    resolution: {integrity: sha512-BvziSRxfz5Ov8ch0z/n3oijRSEcEsHnhggm4xFZe93DHcUCTlutlq9Ox4SVENAfcRD22UQq7T/atg9Wr3k09eA==}
     engines: {node: '>=18'}
     peerDependencies:
       '@types/node': '>=18'
@@ -1946,7 +1946,7 @@ snapshots:
     dependencies:
       '@inquirer/core': 10.2.2(@types/node@24.2.0)
       '@inquirer/figures': 1.0.13
-      '@inquirer/type': 3.0.8(@types/node@24.2.0)
+      '@inquirer/type': 3.0.10(@types/node@24.2.0)
       ansi-escapes: 4.3.2
       yoctocolors-cjs: 2.1.2
     optionalDependencies:
@@ -1955,7 +1955,7 @@ snapshots:
   '@inquirer/confirm@5.1.14(@types/node@24.2.0)':
     dependencies:
       '@inquirer/core': 10.2.2(@types/node@24.2.0)
-      '@inquirer/type': 3.0.8(@types/node@24.2.0)
+      '@inquirer/type': 3.0.10(@types/node@24.2.0)
     optionalDependencies:
       '@types/node': 24.2.0
 
@@ -1963,7 +1963,7 @@ snapshots:
     dependencies:
       '@inquirer/ansi': 1.0.0
       '@inquirer/figures': 1.0.13
-      '@inquirer/type': 3.0.8(@types/node@24.2.0)
+      '@inquirer/type': 3.0.10(@types/node@24.2.0)
       cli-width: 4.1.0
       mute-stream: 2.0.0
       signal-exit: 4.1.0
@@ -1975,7 +1975,7 @@ snapshots:
   '@inquirer/editor@4.2.15(@types/node@24.2.0)':
     dependencies:
       '@inquirer/core': 10.2.2(@types/node@24.2.0)
-      '@inquirer/type': 3.0.8(@types/node@24.2.0)
+      '@inquirer/type': 3.0.10(@types/node@24.2.0)
       external-editor: 3.1.0
     optionalDependencies:
       '@types/node': 24.2.0
@@ -1983,7 +1983,7 @@ snapshots:
   '@inquirer/expand@4.0.17(@types/node@24.2.0)':
     dependencies:
       '@inquirer/core': 10.2.2(@types/node@24.2.0)
-      '@inquirer/type': 3.0.8(@types/node@24.2.0)
+      '@inquirer/type': 3.0.10(@types/node@24.2.0)
       yoctocolors-cjs: 2.1.2
     optionalDependencies:
       '@types/node': 24.2.0
@@ -2000,21 +2000,21 @@ snapshots:
   '@inquirer/input@4.2.1(@types/node@24.2.0)':
     dependencies:
       '@inquirer/core': 10.2.2(@types/node@24.2.0)
-      '@inquirer/type': 3.0.8(@types/node@24.2.0)
+      '@inquirer/type': 3.0.10(@types/node@24.2.0)
     optionalDependencies:
       '@types/node': 24.2.0
 
   '@inquirer/number@3.0.17(@types/node@24.2.0)':
     dependencies:
       '@inquirer/core': 10.2.2(@types/node@24.2.0)
-      '@inquirer/type': 3.0.8(@types/node@24.2.0)
+      '@inquirer/type': 3.0.10(@types/node@24.2.0)
     optionalDependencies:
       '@types/node': 24.2.0
 
   '@inquirer/password@4.0.17(@types/node@24.2.0)':
     dependencies:
       '@inquirer/core': 10.2.2(@types/node@24.2.0)
-      '@inquirer/type': 3.0.8(@types/node@24.2.0)
+      '@inquirer/type': 3.0.10(@types/node@24.2.0)
       ansi-escapes: 4.3.2
     optionalDependencies:
       '@types/node': 24.2.0
@@ -2037,7 +2037,7 @@ snapshots:
   '@inquirer/rawlist@4.1.5(@types/node@24.2.0)':
     dependencies:
       '@inquirer/core': 10.2.2(@types/node@24.2.0)
-      '@inquirer/type': 3.0.8(@types/node@24.2.0)
+      '@inquirer/type': 3.0.10(@types/node@24.2.0)
       yoctocolors-cjs: 2.1.2
     optionalDependencies:
       '@types/node': 24.2.0
@@ -2046,7 +2046,7 @@ snapshots:
     dependencies:
       '@inquirer/core': 10.2.2(@types/node@24.2.0)
       '@inquirer/figures': 1.0.13
-      '@inquirer/type': 3.0.8(@types/node@24.2.0)
+      '@inquirer/type': 3.0.10(@types/node@24.2.0)
       yoctocolors-cjs: 2.1.2
     optionalDependencies:
       '@types/node': 24.2.0
@@ -2055,13 +2055,13 @@ snapshots:
     dependencies:
       '@inquirer/core': 10.2.2(@types/node@24.2.0)
       '@inquirer/figures': 1.0.13
-      '@inquirer/type': 3.0.8(@types/node@24.2.0)
+      '@inquirer/type': 3.0.10(@types/node@24.2.0)
       ansi-escapes: 4.3.2
       yoctocolors-cjs: 2.1.2
     optionalDependencies:
       '@types/node': 24.2.0
 
-  '@inquirer/type@3.0.8(@types/node@24.2.0)':
+  '@inquirer/type@3.0.10(@types/node@24.2.0)':
     optionalDependencies:
       '@types/node': 24.2.0
 
diff --git a/schemas/spec-driven/schema.yaml b/schemas/spec-driven/schema.yaml
index d4a6813..45f61e2 100644
--- a/schemas/spec-driven/schema.yaml
+++ b/schemas/spec-driven/schema.yaml
@@ -34,7 +34,9 @@ artifacts:
     instruction: |
       Create specification files that define WHAT the system should do.
 
-      Create one spec file per capability/feature area in specs/<name>/spec.md.
+      Create one spec file per capability listed in the proposal's Capabilities section.
+      - New capabilities: use the exact kebab-case name from the proposal (specs/<capability>/spec.md).
+      - Modified capabilities: use the existing spec folder name from openspec/specs/<capability>/ when creating the delta spec at specs/<capability>/spec.md.
 
       Delta operations (use ## headers):
       - **ADDED Requirements**: New capabilities
@@ -110,14 +112,17 @@ artifacts:
 
   - id: tasks
     generates: tasks.md
-    description: Implementation tasks derived from specs and design
+    description: Implementation checklist with trackable tasks
     template: tasks.md
     instruction: |
       Create the task list that breaks down the implementation work.
 
+      **IMPORTANT: Follow the template below exactly.** The apply phase parses
+      checkbox format to track progress. Tasks not using `- [ ]` won't be tracked.
+
       Guidelines:
       - Group related tasks under ## numbered headings
-      - Each task is a checkbox: - [ ] X.Y Task description
+      - Each task MUST be a checkbox: `- [ ] X.Y Task description`
       - Tasks should be small enough to complete in one session
       - Order tasks by dependency (what must be done first?)
 
diff --git a/schemas/tdd/schema.yaml b/schemas/tdd/schema.yaml
deleted file mode 100644
index dd9b21d..0000000
--- a/schemas/tdd/schema.yaml
+++ /dev/null
@@ -1,213 +0,0 @@
-name: tdd
-version: 1
-description: Test-driven development workflow - tests â†’ implementation â†’ docs
-artifacts:
-  - id: spec
-    generates: spec.md
-    description: Feature specification defining requirements
-    template: spec.md
-    instruction: |
-      Create the feature specification that defines WHAT to build.
-
-      Sections:
-      - **Feature**: Name and high-level description of the feature's purpose and user value
-      - **Requirements**: List of specific requirements. Use SHALL/MUST for normative language.
-      - **Acceptance Criteria**: Testable criteria in WHEN/THEN format
-
-      Format requirements:
-      - Each requirement should be specific and testable
-      - Use `#### Scenario: <name>` with WHEN/THEN format for acceptance criteria
-      - Define edge cases and error scenarios explicitly
-      - Every requirement MUST have at least one scenario
-
-      Example:
-      ```
-      ## Feature: User Authentication
-
-      Users can securely log into the application.
-
-      ## Requirements
-
-      ### Requirement: Password validation
-      The system SHALL validate passwords meet minimum security requirements.
-
-      #### Scenario: Valid password accepted
-      - **WHEN** password has 8+ chars, uppercase, lowercase, and number
-      - **THEN** password is accepted
-
-      #### Scenario: Weak password rejected
-      - **WHEN** password is less than 8 characters
-      - **THEN** system displays "Password too short" error
-      ```
-
-      This spec drives test creation - each scenario becomes a test case.
-    requires: []
-
-  - id: tests
-    generates: "tests/*.test.ts"
-    description: Test files written before implementation
-    template: test.md
-    instruction: |
-      Write tests BEFORE implementation (TDD red phase).
-
-      File naming:
-      - Create test files as `tests/<feature>.test.ts`
-      - One test file per feature/capability
-      - Use descriptive names matching the spec
-
-      Test structure:
-      - Use Given/When/Then format matching spec scenarios
-      - Group related tests with `describe()` blocks
-      - Each scenario from spec becomes at least one `it()` test
-
-      Coverage requirements:
-      - Cover each requirement from the spec
-      - Include happy path (success cases)
-      - Include edge cases (boundary conditions)
-      - Include error scenarios (invalid input, failures)
-      - Tests should fail initially (no implementation yet)
-
-      Example:
-      ```typescript
-      describe('Password validation', () => {
-        it('accepts valid password with all requirements', () => {
-          // GIVEN a password meeting all requirements
-          const password = 'SecurePass1';
-          // WHEN validating
-          const result = validatePassword(password);
-          // THEN it should be accepted
-          expect(result.valid).toBe(true);
-        });
-
-        it('rejects password shorter than 8 characters', () => {
-          // GIVEN a short password
-          const password = 'Short1';
-          // WHEN validating
-          const result = validatePassword(password);
-          // THEN it should be rejected with message
-          expect(result.valid).toBe(false);
-          expect(result.error).toBe('Password too short');
-        });
-      });
-      ```
-
-      Follow the spec requirements exactly - tests verify the spec.
-    requires:
-      - spec
-
-  - id: implementation
-    generates: "src/*.ts"
-    description: Implementation code to pass the tests
-    template: implementation.md
-    instruction: |
-      Implement the feature to make tests pass (TDD green phase).
-
-      TDD workflow:
-      1. Run tests - confirm they fail (red)
-      2. Write minimal code to pass ONE test
-      3. Run tests - confirm that test passes (green)
-      4. Refactor if needed while keeping tests green
-      5. Repeat for next failing test
-
-      Implementation guidelines:
-      - Write minimal code to pass each test - no more, no less
-      - Run tests frequently to verify progress
-      - Keep functions small and focused
-      - Use clear, descriptive names
-
-      Code organization:
-      - Create source files in `src/<feature>.ts`
-      - Export public API clearly
-      - Keep implementation details private
-      - Add JSDoc comments for public functions
-
-      Example structure:
-      ```typescript
-      /**
-       * Validates a password meets security requirements.
-       * @param password - The password to validate
-       * @returns Validation result with valid flag and optional error
-       */
-      export function validatePassword(password: string): ValidationResult {
-        if (password.length < 8) {
-          return { valid: false, error: 'Password too short' };
-        }
-        // ... additional checks
-        return { valid: true };
-      }
-      ```
-
-      Don't over-engineer - implement only what tests require.
-    requires:
-      - tests
-
-  - id: docs
-    generates: "docs/*.md"
-    description: Documentation for the implemented feature
-    template: docs.md
-    instruction: |
-      Document the implemented feature.
-
-      Sections:
-      - **Overview**: What the feature does and why it exists (1-2 paragraphs)
-      - **Getting Started**: Quick start guide to use the feature immediately
-      - **Examples**: Code examples showing common use cases
-      - **Reference**: Detailed API documentation, configuration options
-
-      Guidelines:
-      - Write for the user, not the developer
-      - Start with the most common use case
-      - Include copy-pasteable code examples
-      - Document all configuration options with defaults
-      - Note any limitations, edge cases, or gotchas
-      - Link to related features or specs
-
-      Example structure:
-      ```markdown
-      ## Overview
-
-      Password validation ensures user passwords meet security requirements
-      before account creation or password changes.
-
-      ## Getting Started
-
-      Import and use the validation function:
-
-      ```typescript
-      import { validatePassword } from './password';
-
-      const result = validatePassword('MySecurePass1');
-      if (!result.valid) {
-        console.error(result.error);
-      }
-      ```
-
-      ## Examples
-
-      ### Basic validation
-      ...
-
-      ### Custom error handling
-      ...
-
-      ## Reference
-
-      ### validatePassword(password)
-
-      | Parameter | Type | Description |
-      |-----------|------|-------------|
-      | password | string | The password to validate |
-
-      **Returns**: `{ valid: boolean, error?: string }`
-      ```
-
-      Reference the spec for requirements, implementation for details.
-    requires:
-      - implementation
-
-apply:
-  requires: [tests]
-  tracks: null
-  instruction: |
-    Run tests to see failures. Implement minimal code to pass each test.
-    Refactor while keeping tests green.
diff --git a/schemas/tdd/templates/docs.md b/schemas/tdd/templates/docs.md
deleted file mode 100644
index fae40a6..0000000
--- a/schemas/tdd/templates/docs.md
+++ /dev/null
@@ -1,15 +0,0 @@
-## Overview
-
-<!-- Feature overview -->
-
-## Getting Started
-
-<!-- Quick start guide -->
-
-## Examples
-
-<!-- Code examples -->
-
-## Reference
-
-<!-- API reference or additional details -->
diff --git a/schemas/tdd/templates/implementation.md b/schemas/tdd/templates/implementation.md
deleted file mode 100644
index fac9db9..0000000
--- a/schemas/tdd/templates/implementation.md
+++ /dev/null
@@ -1,11 +0,0 @@
-## Implementation Notes
-
-<!-- Technical implementation details -->
-
-## API
-
-<!-- Public API documentation -->
-
-## Usage
-
-<!-- Usage examples -->
diff --git a/schemas/tdd/templates/spec.md b/schemas/tdd/templates/spec.md
deleted file mode 100644
index 232e783..0000000
--- a/schemas/tdd/templates/spec.md
+++ /dev/null
@@ -1,11 +0,0 @@
-## Feature: <!-- feature name -->
-
-<!-- Feature description -->
-
-## Requirements
-
-<!-- List of requirements -->
-
-## Acceptance Criteria
-
-<!-- List of acceptance criteria -->
diff --git a/schemas/tdd/templates/test.md b/schemas/tdd/templates/test.md
deleted file mode 100644
index cfa1a11..0000000
--- a/schemas/tdd/templates/test.md
+++ /dev/null
@@ -1,11 +0,0 @@
-## Test Plan
-
-<!-- Describe the testing strategy -->
-
-## Test Cases
-
-### <!-- Test case name -->
-
-- **Given:** <!-- preconditions -->
-- **When:** <!-- action -->
-- **Then:** <!-- expected result -->
diff --git a/scripts/README.md b/scripts/README.md
index 32779c5..dcdc6e7 100644
--- a/scripts/README.md
+++ b/scripts/README.md
@@ -4,9 +4,9 @@ Utility scripts for OpenSpec maintenance and development.
 
 ## update-flake.sh
 
-Updates `flake.nix` version and dependency hash automatically.
+Updates `flake.nix` pnpm dependency hash automatically.
 
-**When to use**: After updating dependencies or releasing a new version.
+**When to use**: After updating dependencies (`pnpm install`, `pnpm update`).
 
 **Usage**:
 ```bash
@@ -14,19 +14,18 @@ Updates `flake.nix` version and dependency hash automatically.
 ```
 
 **What it does**:
-1. Extracts version from `package.json`
-2. Updates version in `flake.nix`
-3. Automatically determines the correct pnpm dependency hash
-4. Updates the hash in `flake.nix`
-5. Verifies the build succeeds
+1. Reads version from `package.json` (dynamically used by `flake.nix`)
+2. Automatically determines the correct pnpm dependency hash
+3. Updates the hash in `flake.nix`
+4. Verifies the build succeeds
 
 **Example workflow**:
 ```bash
-# After version bump and dependency updates
+# After dependency updates
 pnpm install
 ./scripts/update-flake.sh
 git add flake.nix
-git commit -m "chore: update flake.nix for v0.18.0"
+git commit -m "chore: update flake.nix dependency hash"
 ```
 
 ## postinstall.js
diff --git a/scripts/update-flake.sh b/scripts/update-flake.sh
index 022c971..a7cb682 100755
--- a/scripts/update-flake.sh
+++ b/scripts/update-flake.sh
@@ -1,14 +1,22 @@
 #!/usr/bin/env bash
 set -euo pipefail
 
-# Script to update flake.nix version and dependency hash
-# Run this after updating package.json version
+# Updates pnpm dependency hash in flake.nix after pnpm-lock.yaml changes.
+# Version is read dynamically from package.json.
+# Usage: ./scripts/update-flake.sh
 
 SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
 PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
 FLAKE_FILE="$PROJECT_ROOT/flake.nix"
 PACKAGE_JSON="$PROJECT_ROOT/package.json"
 
+# Colors for output
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[1;33m'
+BLUE='\033[0;34m'
+NC='\033[0m' # No Color
+
 # Detect OS and set sed in-place flag
 if [[ "$OSTYPE" == "darwin"* ]]; then
   # macOS (BSD sed) requires empty string argument for -i
@@ -18,58 +26,103 @@ else
   SED_INPLACE=(-i)
 fi
 
-echo "==> Updating flake.nix..."
+echo -e "${BLUE}==> Updating flake.nix pnpm dependency hash...${NC}"
+echo ""
 
 # Extract version from package.json
 VERSION=$(node -p "require('$PACKAGE_JSON').version")
-echo "    Detected version: $VERSION"
+echo -e "${BLUE}ğŸ“¦ Detected package version:${NC} $VERSION"
 
-# Update version in flake.nix
-if ! grep -q "version = \"$VERSION\"" "$FLAKE_FILE"; then
-  echo "    Updating version in flake.nix..."
-  sed "${SED_INPLACE[@]}" "s|version = \"[^\"]*\"|version = \"$VERSION\"|" "$FLAKE_FILE"
-else
-  echo "    Version already up-to-date in flake.nix"
+# Verify flake.nix uses dynamic version
+if ! grep -q "(builtins.fromJSON (builtins.readFile ./package.json)).version" "$FLAKE_FILE"; then
+  echo -e "${YELLOW}âš ï¸  Warning: flake.nix doesn't use dynamic version from package.json${NC}"
+  echo -e "   Expected pattern: version = (builtins.fromJSON (builtins.readFile ./package.json)).version;"
+  echo ""
+fi
+
+# Check if pnpm-lock.yaml exists
+if [ ! -f "$PROJECT_ROOT/pnpm-lock.yaml" ]; then
+  echo -e "${RED}âŒ Error: pnpm-lock.yaml not found${NC}"
+  exit 1
 fi
 
+echo -e "${BLUE}ğŸ”§ Current pnpm-lock.yaml:${NC} $(stat -c%y "$PROJECT_ROOT/pnpm-lock.yaml" 2>/dev/null || stat -f%Sm "$PROJECT_ROOT/pnpm-lock.yaml")"
+echo ""
+
+# Get current hash from flake.nix
+CURRENT_HASH=$(sed -nE 's/.*hash = "(sha256-[^"]+)".*/\1/p' "$FLAKE_FILE" | head -1)
+echo -e "${BLUE}ğŸ“Œ Current hash:${NC} $CURRENT_HASH"
+echo ""
+
 # Set placeholder hash to trigger error
-echo "    Setting placeholder hash..."
+echo -e "${YELLOW}â³ Setting placeholder hash to calculate correct value...${NC}"
 PLACEHOLDER="sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
 sed "${SED_INPLACE[@]}" "s|hash = \"sha256-[^\"]*\"|hash = \"$PLACEHOLDER\"|" "$FLAKE_FILE"
 
 # Try to build and capture the correct hash
-echo "    Building to get correct hash (this will fail)..."
-BUILD_OUTPUT=$(nix build 2>&1 || true)
+echo -e "${BLUE}ğŸ”¨ Building to determine correct hash (expected to fail)...${NC}"
+BUILD_OUTPUT=$(nix build --no-link 2>&1 || true)
 
 # Extract the correct hash from error output
-CORRECT_HASH=$(echo "$BUILD_OUTPUT" | grep -oP 'got:\s+\Ksha256-[A-Za-z0-9+/=]+' | head -1)
+# Try multiple patterns for compatibility with different Nix versions
+CORRECT_HASH=$(echo "$BUILD_OUTPUT" | sed -nE 's/.*got:[[:space:]]*(sha256-[A-Za-z0-9+/=]+).*/\1/p' | head -1)
+if [ -z "$CORRECT_HASH" ]; then
+  CORRECT_HASH=$(echo "$BUILD_OUTPUT" | sed -nE 's/.*got:.*(sha256-[A-Za-z0-9+/=]+).*/\1/p' | head -1)
+fi
 
 if [ -z "$CORRECT_HASH" ]; then
-  echo "âŒ Error: Could not extract hash from build output"
-  echo "Build output:"
+  echo -e "${RED}âŒ Error: Could not extract hash from build output${NC}"
+  echo ""
+  echo -e "${YELLOW}Build output:${NC}"
   echo "$BUILD_OUTPUT"
+  echo ""
+  echo -e "${YELLOW}Restoring original hash...${NC}"
+  sed "${SED_INPLACE[@]}" "s|hash = \"$PLACEHOLDER\"|hash = \"$CURRENT_HASH\"|" "$FLAKE_FILE"
   exit 1
 fi
 
-echo "    Detected hash: $CORRECT_HASH"
+echo -e "${GREEN}âœ“ Calculated hash:${NC} $CORRECT_HASH"
+echo ""
+
+# Check if hash changed
+if [ "$CURRENT_HASH" = "$CORRECT_HASH" ]; then
+  echo -e "${GREEN}âœ“ Hash is already up-to-date!${NC}"
+  sed "${SED_INPLACE[@]}" "s|hash = \"$PLACEHOLDER\"|hash = \"$CORRECT_HASH\"|" "$FLAKE_FILE"
+  echo ""
+  echo -e "${BLUE}â„¹ï¸  No changes needed. Your flake is in sync with pnpm-lock.yaml${NC}"
+  exit 0
+fi
 
-# Update flake.nix with correct hash
+echo -e "${YELLOW}ğŸ”„ Updating hash in flake.nix...${NC}"
 sed "${SED_INPLACE[@]}" "s|hash = \"$PLACEHOLDER\"|hash = \"$CORRECT_HASH\"|" "$FLAKE_FILE"
 
 # Verify the build works
-echo "    Verifying build..."
-if nix build 2>&1 | grep -q "warning: Git tree.*is dirty"; then
-  echo "âš ï¸  Warning: Git tree is dirty, but build succeeded"
+echo -e "${BLUE}ğŸ” Verifying build with new hash...${NC}"
+BUILD_OUTPUT=$(nix build --no-link 2>&1) && BUILD_SUCCESS=true || BUILD_SUCCESS=false
+if [ "$BUILD_SUCCESS" = false ]; then
+  echo -e "${RED}âŒ Build verification failed!${NC}"
+  echo ""
+  echo "$BUILD_OUTPUT"
+  exit 1
+fi
+if echo "$BUILD_OUTPUT" | grep -q "warning: Git tree.*is dirty"; then
+  echo -e "${YELLOW}âš ï¸  Git tree is dirty, but build succeeded${NC}"
 else
-  echo "âœ… Build successful"
+  echo -e "${GREEN}âœ“ Build verification successful${NC}"
 fi
+echo ""
 
+echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
+echo -e "${GREEN}âœ… flake.nix updated successfully!${NC}"
+echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
+echo ""
+echo -e "${BLUE}ğŸ“‹ Summary:${NC}"
+echo -e "   Version:    $VERSION ${YELLOW}(read dynamically from package.json)${NC}"
+echo -e "   Old hash:   $CURRENT_HASH"
+echo -e "   New hash:   $CORRECT_HASH"
 echo ""
-echo "âœ… flake.nix updated successfully!"
-echo "   Version: $VERSION"
-echo "   Hash: $CORRECT_HASH"
+echo -e "${BLUE}ğŸ“ Next steps:${NC}"
+echo -e "   1. Test:   ${GREEN}nix run . -- --version${NC}"
+echo -e "   2. Verify: ${GREEN}nix flake check${NC}"
+echo -e "   3. Commit: ${GREEN}git add flake.nix${NC}"
 echo ""
-echo "Next steps:"
-echo "  1. Test: nix run . -- --version"
-echo "  2. Commit: git add flake.nix"
-echo "  3. Include in version bump commit"
diff --git a/src/cli/index.ts b/src/cli/index.ts
index 4dc22ee..006f21c 100644
--- a/src/cli/index.ts
+++ b/src/cli/index.ts
@@ -15,8 +15,21 @@ import { ShowCommand } from '../commands/show.js';
 import { CompletionCommand } from '../commands/completion.js';
 import { FeedbackCommand } from '../commands/feedback.js';
 import { registerConfigCommand } from '../commands/config.js';
-import { registerArtifactWorkflowCommands } from '../commands/artifact-workflow.js';
 import { registerSchemaCommand } from '../commands/schema.js';
+import {
+  statusCommand,
+  instructionsCommand,
+  applyInstructionsCommand,
+  templatesCommand,
+  schemasCommand,
+  newChangeCommand,
+  DEFAULT_SCHEMA,
+  type StatusOptions,
+  type InstructionsOptions,
+  type TemplatesOptions,
+  type SchemasOptions,
+  type NewChangeOptions,
+} from '../commands/workflow/index.js';
 import { maybeShowTelemetryNotice, trackCommand, shutdown } from '../telemetry/index.js';
 
 const program = new Command();
@@ -74,18 +87,19 @@ program.hook('postAction', async () => {
   await shutdown();
 });
 
-const availableToolIds = AI_TOOLS.filter((tool) => tool.available).map((tool) => tool.value);
+const availableToolIds = AI_TOOLS.filter((tool) => tool.skillsDir).map((tool) => tool.value);
 const toolsOptionDescription = `Configure AI tools non-interactively. Use "all", "none", or a comma-separated list of: ${availableToolIds.join(', ')}`;
 
 program
   .command('init [path]')
   .description('Initialize OpenSpec in your project')
   .option('--tools <tools>', toolsOptionDescription)
-  .action(async (targetPath = '.', options?: { tools?: string }) => {
+  .option('--force', 'Auto-cleanup legacy files without prompting')
+  .action(async (targetPath = '.', options?: { tools?: string; force?: boolean }) => {
     try {
       // Validate that the path is a valid directory
       const resolvedPath = path.resolve(targetPath);
-      
+
       try {
         const stats = await fs.stat(resolvedPath);
         if (!stats.isDirectory()) {
@@ -101,10 +115,11 @@ program
           throw new Error(`Cannot access path "${targetPath}": ${error.message}`);
         }
       }
-      
+
       const { InitCommand } = await import('../core/init.js');
       const initCommand = new InitCommand({
         tools: options?.tools,
+        force: options?.force,
       });
       await initCommand.execute(targetPath);
     } catch (error) {
@@ -114,13 +129,36 @@ program
     }
   });
 
+// Hidden alias: 'experimental' -> 'init' for backwards compatibility
+program
+  .command('experimental', { hidden: true })
+  .description('Alias for init (deprecated)')
+  .option('--tool <tool-id>', 'Target AI tool (maps to --tools)')
+  .option('--no-interactive', 'Disable interactive prompts')
+  .action(async (options?: { tool?: string; noInteractive?: boolean }) => {
+    try {
+      console.log('Note: "openspec experimental" is deprecated. Use "openspec init" instead.');
+      const { InitCommand } = await import('../core/init.js');
+      const initCommand = new InitCommand({
+        tools: options?.tool,
+        interactive: options?.noInteractive === true ? false : undefined,
+      });
+      await initCommand.execute('.');
+    } catch (error) {
+      console.log();
+      ora().fail(`Error: ${(error as Error).message}`);
+      process.exit(1);
+    }
+  });
+
 program
   .command('update [path]')
   .description('Update OpenSpec instruction files')
-  .action(async (targetPath = '.') => {
+  .option('--force', 'Force update even when tools are up to date')
+  .action(async (targetPath = '.', options?: { force?: boolean }) => {
     try {
       const resolvedPath = path.resolve(targetPath);
-      const updateCommand = new UpdateCommand();
+      const updateCommand = new UpdateCommand({ force: options?.force });
       await updateCommand.execute(resolvedPath);
     } catch (error) {
       console.log(); // Empty line for spacing
@@ -375,7 +413,96 @@ program
     }
   });
 
-// Register artifact workflow commands (experimental)
-registerArtifactWorkflowCommands(program);
+// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+// Workflow Commands (formerly experimental)
+// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+
+// Status command
+program
+  .command('status')
+  .description('Display artifact completion status for a change')
+  .option('--change <id>', 'Change name to show status for')
+  .option('--schema <name>', 'Schema override (auto-detected from config.yaml)')
+  .option('--json', 'Output as JSON')
+  .action(async (options: StatusOptions) => {
+    try {
+      await statusCommand(options);
+    } catch (error) {
+      console.log();
+      ora().fail(`Error: ${(error as Error).message}`);
+      process.exit(1);
+    }
+  });
+
+// Instructions command
+program
+  .command('instructions [artifact]')
+  .description('Output enriched instructions for creating an artifact or applying tasks')
+  .option('--change <id>', 'Change name')
+  .option('--schema <name>', 'Schema override (auto-detected from config.yaml)')
+  .option('--json', 'Output as JSON')
+  .action(async (artifactId: string | undefined, options: InstructionsOptions) => {
+    try {
+      // Special case: "apply" is not an artifact, but a command to get apply instructions
+      if (artifactId === 'apply') {
+        await applyInstructionsCommand(options);
+      } else {
+        await instructionsCommand(artifactId, options);
+      }
+    } catch (error) {
+      console.log();
+      ora().fail(`Error: ${(error as Error).message}`);
+      process.exit(1);
+    }
+  });
+
+// Templates command
+program
+  .command('templates')
+  .description('Show resolved template paths for all artifacts in a schema')
+  .option('--schema <name>', `Schema to use (default: ${DEFAULT_SCHEMA})`)
+  .option('--json', 'Output as JSON mapping artifact IDs to template paths')
+  .action(async (options: TemplatesOptions) => {
+    try {
+      await templatesCommand(options);
+    } catch (error) {
+      console.log();
+      ora().fail(`Error: ${(error as Error).message}`);
+      process.exit(1);
+    }
+  });
+
+// Schemas command
+program
+  .command('schemas')
+  .description('List available workflow schemas with descriptions')
+  .option('--json', 'Output as JSON (for agent use)')
+  .action(async (options: SchemasOptions) => {
+    try {
+      await schemasCommand(options);
+    } catch (error) {
+      console.log();
+      ora().fail(`Error: ${(error as Error).message}`);
+      process.exit(1);
+    }
+  });
+
+// New command group with change subcommand
+const newCmd = program.command('new').description('Create new items');
+
+newCmd
+  .command('change <name>')
+  .description('Create a new change directory')
+  .option('--description <text>', 'Description to add to README.md')
+  .option('--schema <name>', `Workflow schema to use (default: ${DEFAULT_SCHEMA})`)
+  .action(async (name: string, options: NewChangeOptions) => {
+    try {
+      await newChangeCommand(name, options);
+    } catch (error) {
+      console.log();
+      ora().fail(`Error: ${(error as Error).message}`);
+      process.exit(1);
+    }
+  });
 
 program.parse();
diff --git a/src/commands/artifact-workflow.ts b/src/commands/artifact-workflow.ts
deleted file mode 100644
index 73dc576..0000000
--- a/src/commands/artifact-workflow.ts
+++ /dev/null
@@ -1,1183 +0,0 @@
-/**
- * Artifact Workflow CLI Commands (Experimental)
- *
- * This file contains all artifact workflow commands in isolation for easy removal.
- * Commands expose the ArtifactGraph and InstructionLoader APIs to users and agents.
- *
- * To remove this feature:
- * 1. Delete this file
- * 2. Remove the registerArtifactWorkflowCommands() call from src/cli/index.ts
- */
-
-import type { Command } from 'commander';
-import ora from 'ora';
-import chalk from 'chalk';
-import path from 'path';
-import * as fs from 'fs';
-import {
-  loadChangeContext,
-  formatChangeStatus,
-  generateInstructions,
-  listSchemas,
-  listSchemasWithInfo,
-  getSchemaDir,
-  resolveSchema,
-  ArtifactGraph,
-  type ChangeStatus,
-  type ArtifactInstructions,
-  type SchemaInfo,
-} from '../core/artifact-graph/index.js';
-import { createChange, validateChangeName } from '../utils/change-utils.js';
-import { getExploreSkillTemplate, getNewChangeSkillTemplate, getContinueChangeSkillTemplate, getApplyChangeSkillTemplate, getFfChangeSkillTemplate, getSyncSpecsSkillTemplate, getArchiveChangeSkillTemplate, getBulkArchiveChangeSkillTemplate, getVerifyChangeSkillTemplate, getOpsxExploreCommandTemplate, getOpsxNewCommandTemplate, getOpsxContinueCommandTemplate, getOpsxApplyCommandTemplate, getOpsxFfCommandTemplate, getOpsxSyncCommandTemplate, getOpsxArchiveCommandTemplate, getOpsxBulkArchiveCommandTemplate, getOpsxVerifyCommandTemplate } from '../core/templates/skill-templates.js';
-import { FileSystemUtils } from '../utils/file-system.js';
-import { serializeConfig } from '../core/config-prompts.js';
-import { readProjectConfig } from '../core/project-config.js';
-
-// -----------------------------------------------------------------------------
-// Types for Apply Instructions
-// -----------------------------------------------------------------------------
-
-interface TaskItem {
-  id: string;
-  description: string;
-  done: boolean;
-}
-
-interface ApplyInstructions {
-  changeName: string;
-  changeDir: string;
-  schemaName: string;
-  contextFiles: Record<string, string>;
-  progress: {
-    total: number;
-    complete: number;
-    remaining: number;
-  };
-  tasks: TaskItem[];
-  state: 'blocked' | 'all_done' | 'ready';
-  missingArtifacts?: string[];
-  instruction: string;
-}
-
-const DEFAULT_SCHEMA = 'spec-driven';
-
-/**
- * Checks if color output is disabled via NO_COLOR env or --no-color flag.
- */
-function isColorDisabled(): boolean {
-  return process.env.NO_COLOR === '1' || process.env.NO_COLOR === 'true';
-}
-
-/**
- * Gets the color function based on status.
- */
-function getStatusColor(status: 'done' | 'ready' | 'blocked'): (text: string) => string {
-  if (isColorDisabled()) {
-    return (text: string) => text;
-  }
-  switch (status) {
-    case 'done':
-      return chalk.green;
-    case 'ready':
-      return chalk.yellow;
-    case 'blocked':
-      return chalk.red;
-  }
-}
-
-/**
- * Gets the status indicator for an artifact.
- */
-function getStatusIndicator(status: 'done' | 'ready' | 'blocked'): string {
-  const color = getStatusColor(status);
-  switch (status) {
-    case 'done':
-      return color('[x]');
-    case 'ready':
-      return color('[ ]');
-    case 'blocked':
-      return color('[-]');
-  }
-}
-
-/**
- * Validates that a change exists and returns available changes if not.
- * Checks directory existence directly to support scaffolded changes (without proposal.md).
- */
-async function validateChangeExists(
-  changeName: string | undefined,
-  projectRoot: string
-): Promise<string> {
-  const changesPath = path.join(projectRoot, 'openspec', 'changes');
-
-  // Get all change directories (not just those with proposal.md)
-  const getAvailableChanges = async (): Promise<string[]> => {
-    try {
-      const entries = await fs.promises.readdir(changesPath, { withFileTypes: true });
-      return entries
-        .filter((e) => e.isDirectory() && e.name !== 'archive' && !e.name.startsWith('.'))
-        .map((e) => e.name);
-    } catch {
-      return [];
-    }
-  };
-
-  if (!changeName) {
-    const available = await getAvailableChanges();
-    if (available.length === 0) {
-      throw new Error('No changes found. Create one with: openspec new change <name>');
-    }
-    throw new Error(
-      `Missing required option --change. Available changes:\n  ${available.join('\n  ')}`
-    );
-  }
-
-  // Validate change name format to prevent path traversal
-  const nameValidation = validateChangeName(changeName);
-  if (!nameValidation.valid) {
-    throw new Error(`Invalid change name '${changeName}': ${nameValidation.error}`);
-  }
-
-  // Check directory existence directly
-  const changePath = path.join(changesPath, changeName);
-  const exists = fs.existsSync(changePath) && fs.statSync(changePath).isDirectory();
-
-  if (!exists) {
-    const available = await getAvailableChanges();
-    if (available.length === 0) {
-      throw new Error(
-        `Change '${changeName}' not found. No changes exist. Create one with: openspec new change <name>`
-      );
-    }
-    throw new Error(
-      `Change '${changeName}' not found. Available changes:\n  ${available.join('\n  ')}`
-    );
-  }
-
-  return changeName;
-}
-
-/**
- * Validates that a schema exists and returns available schemas if not.
- *
- * @param schemaName - The schema name to validate
- * @param projectRoot - Optional project root for project-local schema resolution
- */
-function validateSchemaExists(schemaName: string, projectRoot?: string): string {
-  const schemaDir = getSchemaDir(schemaName, projectRoot);
-  if (!schemaDir) {
-    const availableSchemas = listSchemas(projectRoot);
-    throw new Error(
-      `Schema '${schemaName}' not found. Available schemas:\n  ${availableSchemas.join('\n  ')}`
-    );
-  }
-  return schemaName;
-}
-
-// -----------------------------------------------------------------------------
-// Status Command
-// -----------------------------------------------------------------------------
-
-interface StatusOptions {
-  change?: string;
-  schema?: string;
-  json?: boolean;
-}
-
-async function statusCommand(options: StatusOptions): Promise<void> {
-  const spinner = ora('Loading change status...').start();
-
-  try {
-    const projectRoot = process.cwd();
-    const changeName = await validateChangeExists(options.change, projectRoot);
-
-    // Validate schema if explicitly provided
-    if (options.schema) {
-      validateSchemaExists(options.schema, projectRoot);
-    }
-
-    // loadChangeContext will auto-detect schema from metadata if not provided
-    const context = loadChangeContext(projectRoot, changeName, options.schema);
-    const status = formatChangeStatus(context);
-
-    spinner.stop();
-
-    if (options.json) {
-      console.log(JSON.stringify(status, null, 2));
-      return;
-    }
-
-    printStatusText(status);
-  } catch (error) {
-    spinner.stop();
-    throw error;
-  }
-}
-
-function printStatusText(status: ChangeStatus): void {
-  const doneCount = status.artifacts.filter((a) => a.status === 'done').length;
-  const total = status.artifacts.length;
-
-  console.log(`Change: ${status.changeName}`);
-  console.log(`Schema: ${status.schemaName}`);
-  console.log(`Progress: ${doneCount}/${total} artifacts complete`);
-  console.log();
-
-  for (const artifact of status.artifacts) {
-    const indicator = getStatusIndicator(artifact.status);
-    const color = getStatusColor(artifact.status);
-    let line = `${indicator} ${artifact.id}`;
-
-    if (artifact.status === 'blocked' && artifact.missingDeps && artifact.missingDeps.length > 0) {
-      line += color(` (blocked by: ${artifact.missingDeps.join(', ')})`);
-    }
-
-    console.log(line);
-  }
-
-  if (status.isComplete) {
-    console.log();
-    console.log(chalk.green('All artifacts complete!'));
-  }
-}
-
-// -----------------------------------------------------------------------------
-// Instructions Command
-// -----------------------------------------------------------------------------
-
-interface InstructionsOptions {
-  change?: string;
-  schema?: string;
-  json?: boolean;
-}
-
-async function instructionsCommand(
-  artifactId: string | undefined,
-  options: InstructionsOptions
-): Promise<void> {
-  const spinner = ora('Generating instructions...').start();
-
-  try {
-    const projectRoot = process.cwd();
-    const changeName = await validateChangeExists(options.change, projectRoot);
-
-    // Validate schema if explicitly provided
-    if (options.schema) {
-      validateSchemaExists(options.schema, projectRoot);
-    }
-
-    // loadChangeContext will auto-detect schema from metadata if not provided
-    const context = loadChangeContext(projectRoot, changeName, options.schema);
-
-    if (!artifactId) {
-      spinner.stop();
-      const validIds = context.graph.getAllArtifacts().map((a) => a.id);
-      throw new Error(
-        `Missing required argument <artifact>. Valid artifacts:\n  ${validIds.join('\n  ')}`
-      );
-    }
-
-    const artifact = context.graph.getArtifact(artifactId);
-
-    if (!artifact) {
-      spinner.stop();
-      const validIds = context.graph.getAllArtifacts().map((a) => a.id);
-      throw new Error(
-        `Artifact '${artifactId}' not found in schema '${context.schemaName}'. Valid artifacts:\n  ${validIds.join('\n  ')}`
-      );
-    }
-
-    const instructions = generateInstructions(context, artifactId, projectRoot);
-    const isBlocked = instructions.dependencies.some((d) => !d.done);
-
-    spinner.stop();
-
-    if (options.json) {
-      console.log(JSON.stringify(instructions, null, 2));
-      return;
-    }
-
-    printInstructionsText(instructions, isBlocked);
-  } catch (error) {
-    spinner.stop();
-    throw error;
-  }
-}
-
-function printInstructionsText(instructions: ArtifactInstructions, isBlocked: boolean): void {
-  const {
-    artifactId,
-    changeName,
-    schemaName,
-    changeDir,
-    outputPath,
-    description,
-    instruction,
-    context,
-    rules,
-    template,
-    dependencies,
-    unlocks,
-  } = instructions;
-
-  // Opening tag
-  console.log(`<artifact id="${artifactId}" change="${changeName}" schema="${schemaName}">`);
-  console.log();
-
-  // Warning for blocked artifacts
-  if (isBlocked) {
-    const missing = dependencies.filter((d) => !d.done).map((d) => d.id);
-    console.log('<warning>');
-    console.log('This artifact has unmet dependencies. Complete them first or proceed with caution.');
-    console.log(`Missing: ${missing.join(', ')}`);
-    console.log('</warning>');
-    console.log();
-  }
-
-  // Task directive
-  console.log('<task>');
-  console.log(`Create the ${artifactId} artifact for change "${changeName}".`);
-  console.log(description);
-  console.log('</task>');
-  console.log();
-
-  // Project context (AI constraint - do not include in output)
-  if (context) {
-    console.log('<project_context>');
-    console.log('<!-- This is background information for you. Do NOT include this in your output. -->');
-    console.log(context);
-    console.log('</project_context>');
-    console.log();
-  }
-
-  // Rules (AI constraint - do not include in output)
-  if (rules && rules.length > 0) {
-    console.log('<rules>');
-    console.log('<!-- These are constraints for you to follow. Do NOT include this in your output. -->');
-    for (const rule of rules) {
-      console.log(`- ${rule}`);
-    }
-    console.log('</rules>');
-    console.log();
-  }
-
-  // Dependencies (files to read for context)
-  if (dependencies.length > 0) {
-    console.log('<dependencies>');
-    console.log('Read these files for context before creating this artifact:');
-    console.log();
-    for (const dep of dependencies) {
-      const status = dep.done ? 'done' : 'missing';
-      const fullPath = path.join(changeDir, dep.path);
-      console.log(`<dependency id="${dep.id}" status="${status}">`);
-      console.log(`  <path>${fullPath}</path>`);
-      console.log(`  <description>${dep.description}</description>`);
-      console.log('</dependency>');
-    }
-    console.log('</dependencies>');
-    console.log();
-  }
-
-  // Output location
-  console.log('<output>');
-  console.log(`Write to: ${path.join(changeDir, outputPath)}`);
-  console.log('</output>');
-  console.log();
-
-  // Instruction (guidance)
-  if (instruction) {
-    console.log('<instruction>');
-    console.log(instruction.trim());
-    console.log('</instruction>');
-    console.log();
-  }
-
-  // Template
-  console.log('<template>');
-  console.log('<!-- Use this as the structure for your output file. Fill in the sections. -->');
-  console.log(template.trim());
-  console.log('</template>');
-  console.log();
-
-  // Success criteria placeholder
-  console.log('<success_criteria>');
-  console.log('<!-- To be defined in schema validation rules -->');
-  console.log('</success_criteria>');
-  console.log();
-
-  // Unlocks
-  if (unlocks.length > 0) {
-    console.log('<unlocks>');
-    console.log(`Completing this artifact enables: ${unlocks.join(', ')}`);
-    console.log('</unlocks>');
-    console.log();
-  }
-
-  // Closing tag
-  console.log('</artifact>');
-}
-
-// -----------------------------------------------------------------------------
-// Apply Instructions Command
-// -----------------------------------------------------------------------------
-
-interface ApplyInstructionsOptions {
-  change?: string;
-  schema?: string;
-  json?: boolean;
-}
-
-/**
- * Parses tasks.md content and extracts task items with their completion status.
- */
-function parseTasksFile(content: string): TaskItem[] {
-  const tasks: TaskItem[] = [];
-  const lines = content.split('\n');
-  let taskIndex = 0;
-
-  for (const line of lines) {
-    // Match checkbox patterns: - [ ] or - [x] or - [X]
-    const checkboxMatch = line.match(/^[-*]\s*\[([ xX])\]\s*(.+)$/);
-    if (checkboxMatch) {
-      taskIndex++;
-      const done = checkboxMatch[1].toLowerCase() === 'x';
-      const description = checkboxMatch[2].trim();
-      tasks.push({
-        id: `${taskIndex}`,
-        description,
-        done,
-      });
-    }
-  }
-
-  return tasks;
-}
-
-/**
- * Checks if an artifact output exists in the change directory.
- * Supports glob patterns (e.g., "specs/*.md") by verifying at least one matching file exists.
- */
-function artifactOutputExists(changeDir: string, generates: string): boolean {
-  // Normalize the generates path to use platform-specific separators
-  const normalizedGenerates = generates.split('/').join(path.sep);
-  const fullPath = path.join(changeDir, normalizedGenerates);
-
-  // If it's a glob pattern (contains ** or *), check for matching files
-  if (generates.includes('*')) {
-    // Extract the directory part before the glob pattern
-    const parts = normalizedGenerates.split(path.sep);
-    const dirParts: string[] = [];
-    let patternPart = '';
-    for (const part of parts) {
-      if (part.includes('*')) {
-        patternPart = part;
-        break;
-      }
-      dirParts.push(part);
-    }
-    const dirPath = path.join(changeDir, ...dirParts);
-
-    // Check if directory exists
-    if (!fs.existsSync(dirPath) || !fs.statSync(dirPath).isDirectory()) {
-      return false;
-    }
-
-    // Extract expected extension from pattern (e.g., "*.md" -> ".md")
-    const extMatch = patternPart.match(/\*(\.[a-zA-Z0-9]+)$/);
-    const expectedExt = extMatch ? extMatch[1] : null;
-
-    // Recursively check for matching files
-    const hasMatchingFiles = (dir: string): boolean => {
-      try {
-        const entries = fs.readdirSync(dir, { withFileTypes: true });
-        for (const entry of entries) {
-          if (entry.isDirectory()) {
-            // For ** patterns, recurse into subdirectories
-            if (generates.includes('**') && hasMatchingFiles(path.join(dir, entry.name))) {
-              return true;
-            }
-          } else if (entry.isFile()) {
-            // Check if file matches expected extension (or any file if no extension specified)
-            if (!expectedExt || entry.name.endsWith(expectedExt)) {
-              return true;
-            }
-          }
-        }
-      } catch {
-        return false;
-      }
-      return false;
-    };
-
-    return hasMatchingFiles(dirPath);
-  }
-
-  return fs.existsSync(fullPath);
-}
-
-/**
- * Generates apply instructions for implementing tasks from a change.
- * Schema-aware: reads apply phase configuration from schema to determine
- * required artifacts, tracking file, and instruction.
- */
-async function generateApplyInstructions(
-  projectRoot: string,
-  changeName: string,
-  schemaName?: string
-): Promise<ApplyInstructions> {
-  // loadChangeContext will auto-detect schema from metadata if not provided
-  const context = loadChangeContext(projectRoot, changeName, schemaName);
-  const changeDir = path.join(projectRoot, 'openspec', 'changes', changeName);
-
-  // Get the full schema to access the apply phase configuration
-  const schema = resolveSchema(context.schemaName);
-  const applyConfig = schema.apply;
-
-  // Determine required artifacts and tracking file from schema
-  // Fallback: if no apply block, require all artifacts
-  const requiredArtifactIds = applyConfig?.requires ?? schema.artifacts.map((a) => a.id);
-  const tracksFile = applyConfig?.tracks ?? null;
-  const schemaInstruction = applyConfig?.instruction ?? null;
-
-  // Check which required artifacts are missing
-  const missingArtifacts: string[] = [];
-  for (const artifactId of requiredArtifactIds) {
-    const artifact = schema.artifacts.find((a) => a.id === artifactId);
-    if (artifact && !artifactOutputExists(changeDir, artifact.generates)) {
-      missingArtifacts.push(artifactId);
-    }
-  }
-
-  // Build context files from all existing artifacts in schema
-  const contextFiles: Record<string, string> = {};
-  for (const artifact of schema.artifacts) {
-    if (artifactOutputExists(changeDir, artifact.generates)) {
-      contextFiles[artifact.id] = path.join(changeDir, artifact.generates);
-    }
-  }
-
-  // Parse tasks if tracking file exists
-  let tasks: TaskItem[] = [];
-  let tracksFileExists = false;
-  if (tracksFile) {
-    const tracksPath = path.join(changeDir, tracksFile);
-    tracksFileExists = fs.existsSync(tracksPath);
-    if (tracksFileExists) {
-      const tasksContent = await fs.promises.readFile(tracksPath, 'utf-8');
-      tasks = parseTasksFile(tasksContent);
-    }
-  }
-
-  // Calculate progress
-  const total = tasks.length;
-  const complete = tasks.filter((t) => t.done).length;
-  const remaining = total - complete;
-
-  // Determine state and instruction
-  let state: ApplyInstructions['state'];
-  let instruction: string;
-
-  if (missingArtifacts.length > 0) {
-    state = 'blocked';
-    instruction = `Cannot apply this change yet. Missing artifacts: ${missingArtifacts.join(', ')}.\nUse the openspec-continue-change skill to create the missing artifacts first.`;
-  } else if (tracksFile && !tracksFileExists) {
-    // Tracking file configured but doesn't exist yet
-    const tracksFilename = path.basename(tracksFile);
-    state = 'blocked';
-    instruction = `The ${tracksFilename} file is missing and must be created.\nUse openspec-continue-change to generate the tracking file.`;
-  } else if (tracksFile && tracksFileExists && total === 0) {
-    // Tracking file exists but contains no tasks
-    const tracksFilename = path.basename(tracksFile);
-    state = 'blocked';
-    instruction = `The ${tracksFilename} file exists but contains no tasks.\nAdd tasks to ${tracksFilename} or regenerate it with openspec-continue-change.`;
-  } else if (tracksFile && remaining === 0 && total > 0) {
-    state = 'all_done';
-    instruction = 'All tasks are complete! This change is ready to be archived.\nConsider running tests and reviewing the changes before archiving.';
-  } else if (!tracksFile) {
-    // No tracking file (e.g., TDD schema) - ready to apply
-    state = 'ready';
-    instruction = schemaInstruction?.trim() ?? 'All required artifacts complete. Proceed with implementation.';
-  } else {
-    state = 'ready';
-    instruction = schemaInstruction?.trim() ?? 'Read context files, work through pending tasks, mark complete as you go.\nPause if you hit blockers or need clarification.';
-  }
-
-  return {
-    changeName,
-    changeDir,
-    schemaName: context.schemaName,
-    contextFiles,
-    progress: { total, complete, remaining },
-    tasks,
-    state,
-    missingArtifacts: missingArtifacts.length > 0 ? missingArtifacts : undefined,
-    instruction,
-  };
-}
-
-async function applyInstructionsCommand(options: ApplyInstructionsOptions): Promise<void> {
-  const spinner = ora('Generating apply instructions...').start();
-
-  try {
-    const projectRoot = process.cwd();
-    const changeName = await validateChangeExists(options.change, projectRoot);
-
-    // Validate schema if explicitly provided
-    if (options.schema) {
-      validateSchemaExists(options.schema, projectRoot);
-    }
-
-    // generateApplyInstructions uses loadChangeContext which auto-detects schema
-    const instructions = await generateApplyInstructions(projectRoot, changeName, options.schema);
-
-    spinner.stop();
-
-    if (options.json) {
-      console.log(JSON.stringify(instructions, null, 2));
-      return;
-    }
-
-    printApplyInstructionsText(instructions);
-  } catch (error) {
-    spinner.stop();
-    throw error;
-  }
-}
-
-function printApplyInstructionsText(instructions: ApplyInstructions): void {
-  const { changeName, schemaName, contextFiles, progress, tasks, state, missingArtifacts, instruction } = instructions;
-
-  console.log(`## Apply: ${changeName}`);
-  console.log(`Schema: ${schemaName}`);
-  console.log();
-
-  // Warning for blocked state
-  if (state === 'blocked' && missingArtifacts) {
-    console.log('### âš ï¸ Blocked');
-    console.log();
-    console.log(`Missing artifacts: ${missingArtifacts.join(', ')}`);
-    console.log('Use the openspec-continue-change skill to create these first.');
-    console.log();
-  }
-
-  // Context files (dynamically from schema)
-  const contextFileEntries = Object.entries(contextFiles);
-  if (contextFileEntries.length > 0) {
-    console.log('### Context Files');
-    for (const [artifactId, filePath] of contextFileEntries) {
-      console.log(`- ${artifactId}: ${filePath}`);
-    }
-    console.log();
-  }
-
-  // Progress (only show if we have tracking)
-  if (progress.total > 0 || tasks.length > 0) {
-    console.log('### Progress');
-    if (state === 'all_done') {
-      console.log(`${progress.complete}/${progress.total} complete âœ“`);
-    } else {
-      console.log(`${progress.complete}/${progress.total} complete`);
-    }
-    console.log();
-  }
-
-  // Tasks
-  if (tasks.length > 0) {
-    console.log('### Tasks');
-    for (const task of tasks) {
-      const checkbox = task.done ? '[x]' : '[ ]';
-      console.log(`- ${checkbox} ${task.description}`);
-    }
-    console.log();
-  }
-
-  // Instruction
-  console.log('### Instruction');
-  console.log(instruction);
-}
-
-// -----------------------------------------------------------------------------
-// Templates Command
-// -----------------------------------------------------------------------------
-
-interface TemplatesOptions {
-  schema?: string;
-  json?: boolean;
-}
-
-interface TemplateInfo {
-  artifactId: string;
-  templatePath: string;
-  source: 'project' | 'user' | 'package';
-}
-
-async function templatesCommand(options: TemplatesOptions): Promise<void> {
-  const spinner = ora('Loading templates...').start();
-
-  try {
-    const projectRoot = process.cwd();
-    const schemaName = validateSchemaExists(options.schema ?? DEFAULT_SCHEMA, projectRoot);
-    const schema = resolveSchema(schemaName, projectRoot);
-    const graph = ArtifactGraph.fromSchema(schema);
-    const schemaDir = getSchemaDir(schemaName, projectRoot)!;
-
-    // Determine the source (project, user, or package)
-    const {
-      getUserSchemasDir,
-      getProjectSchemasDir,
-    } = await import('../core/artifact-graph/resolver.js');
-    const projectSchemasDir = getProjectSchemasDir(projectRoot);
-    const userSchemasDir = getUserSchemasDir();
-
-    let source: 'project' | 'user' | 'package';
-    if (schemaDir.startsWith(projectSchemasDir)) {
-      source = 'project';
-    } else if (schemaDir.startsWith(userSchemasDir)) {
-      source = 'user';
-    } else {
-      source = 'package';
-    }
-
-    const templates: TemplateInfo[] = graph.getAllArtifacts().map((artifact) => ({
-      artifactId: artifact.id,
-      templatePath: path.join(schemaDir, 'templates', artifact.template),
-      source,
-    }));
-
-    spinner.stop();
-
-    if (options.json) {
-      const output: Record<string, { path: string; source: string }> = {};
-      for (const t of templates) {
-        output[t.artifactId] = { path: t.templatePath, source: t.source };
-      }
-      console.log(JSON.stringify(output, null, 2));
-      return;
-    }
-
-    console.log(`Schema: ${schemaName}`);
-    console.log(`Source: ${source}`);
-    console.log();
-
-    for (const t of templates) {
-      console.log(`${t.artifactId}:`);
-      console.log(`  ${t.templatePath}`);
-    }
-  } catch (error) {
-    spinner.stop();
-    throw error;
-  }
-}
-
-// -----------------------------------------------------------------------------
-// New Change Command
-// -----------------------------------------------------------------------------
-
-interface NewChangeOptions {
-  description?: string;
-  schema?: string;
-}
-
-async function newChangeCommand(name: string | undefined, options: NewChangeOptions): Promise<void> {
-  if (!name) {
-    throw new Error('Missing required argument <name>');
-  }
-
-  const validation = validateChangeName(name);
-  if (!validation.valid) {
-    throw new Error(validation.error);
-  }
-
-  const projectRoot = process.cwd();
-
-  // Validate schema if provided
-  if (options.schema) {
-    validateSchemaExists(options.schema, projectRoot);
-  }
-
-  const schemaDisplay = options.schema ? ` with schema '${options.schema}'` : '';
-  const spinner = ora(`Creating change '${name}'${schemaDisplay}...`).start();
-
-  try {
-    const result = await createChange(projectRoot, name, { schema: options.schema });
-
-    // If description provided, create README.md with description
-    if (options.description) {
-      const { promises: fs } = await import('fs');
-      const changeDir = path.join(projectRoot, 'openspec', 'changes', name);
-      const readmePath = path.join(changeDir, 'README.md');
-      await fs.writeFile(readmePath, `# ${name}\n\n${options.description}\n`, 'utf-8');
-    }
-
-    spinner.succeed(`Created change '${name}' at openspec/changes/${name}/ (schema: ${result.schema})`);
-  } catch (error) {
-    spinner.fail(`Failed to create change '${name}'`);
-    throw error;
-  }
-}
-
-// -----------------------------------------------------------------------------
-// Artifact Experimental Setup Command
-// -----------------------------------------------------------------------------
-
-/**
- * Generates Agent Skills and slash commands for the experimental artifact workflow.
- * Creates .claude/skills/ directory with SKILL.md files following Agent Skills spec.
- * Creates .claude/commands/opsx/ directory with slash command files.
- */
-async function artifactExperimentalSetupCommand(): Promise<void> {
-  const spinner = ora('Setting up experimental artifact workflow...').start();
-
-  try {
-    const projectRoot = process.cwd();
-    const skillsDir = path.join(projectRoot, '.claude', 'skills');
-    const commandsDir = path.join(projectRoot, '.claude', 'commands', 'opsx');
-
-    // Get skill templates
-    const exploreSkill = getExploreSkillTemplate();
-    const newChangeSkill = getNewChangeSkillTemplate();
-    const continueChangeSkill = getContinueChangeSkillTemplate();
-    const applyChangeSkill = getApplyChangeSkillTemplate();
-    const ffChangeSkill = getFfChangeSkillTemplate();
-    const syncSpecsSkill = getSyncSpecsSkillTemplate();
-    const archiveChangeSkill = getArchiveChangeSkillTemplate();
-    const bulkArchiveChangeSkill = getBulkArchiveChangeSkillTemplate();
-    const verifyChangeSkill = getVerifyChangeSkillTemplate();
-
-    // Get command templates
-    const exploreCommand = getOpsxExploreCommandTemplate();
-    const newCommand = getOpsxNewCommandTemplate();
-    const continueCommand = getOpsxContinueCommandTemplate();
-    const applyCommand = getOpsxApplyCommandTemplate();
-    const ffCommand = getOpsxFfCommandTemplate();
-    const syncCommand = getOpsxSyncCommandTemplate();
-    const archiveCommand = getOpsxArchiveCommandTemplate();
-    const bulkArchiveCommand = getOpsxBulkArchiveCommandTemplate();
-    const verifyCommand = getOpsxVerifyCommandTemplate();
-
-    // Create skill directories and SKILL.md files
-    const skills = [
-      { template: exploreSkill, dirName: 'openspec-explore' },
-      { template: newChangeSkill, dirName: 'openspec-new-change' },
-      { template: continueChangeSkill, dirName: 'openspec-continue-change' },
-      { template: applyChangeSkill, dirName: 'openspec-apply-change' },
-      { template: ffChangeSkill, dirName: 'openspec-ff-change' },
-      { template: syncSpecsSkill, dirName: 'openspec-sync-specs' },
-      { template: archiveChangeSkill, dirName: 'openspec-archive-change' },
-      { template: bulkArchiveChangeSkill, dirName: 'openspec-bulk-archive-change' },
-      { template: verifyChangeSkill, dirName: 'openspec-verify-change' },
-    ];
-
-    const createdSkillFiles: string[] = [];
-
-    for (const { template, dirName } of skills) {
-      const skillDir = path.join(skillsDir, dirName);
-      const skillFile = path.join(skillDir, 'SKILL.md');
-
-      // Generate SKILL.md content with YAML frontmatter
-      const skillContent = `---
-name: ${template.name}
-description: ${template.description}
----
-
-${template.instructions}
-`;
-
-      // Write the skill file
-      await FileSystemUtils.writeFile(skillFile, skillContent);
-      createdSkillFiles.push(path.relative(projectRoot, skillFile));
-    }
-
-    // Create slash command files
-    const commands = [
-      { template: exploreCommand, fileName: 'explore.md' },
-      { template: newCommand, fileName: 'new.md' },
-      { template: continueCommand, fileName: 'continue.md' },
-      { template: applyCommand, fileName: 'apply.md' },
-      { template: ffCommand, fileName: 'ff.md' },
-      { template: syncCommand, fileName: 'sync.md' },
-      { template: archiveCommand, fileName: 'archive.md' },
-      { template: bulkArchiveCommand, fileName: 'bulk-archive.md' },
-      { template: verifyCommand, fileName: 'verify.md' },
-    ];
-
-    const createdCommandFiles: string[] = [];
-
-    for (const { template, fileName } of commands) {
-      const commandFile = path.join(commandsDir, fileName);
-
-      // Generate command content with YAML frontmatter
-      const commandContent = `---
-name: ${template.name}
-description: ${template.description}
-category: ${template.category}
-tags: [${template.tags.join(', ')}]
----
-
-${template.content}
-`;
-
-      // Write the command file
-      await FileSystemUtils.writeFile(commandFile, commandContent);
-      createdCommandFiles.push(path.relative(projectRoot, commandFile));
-    }
-
-    spinner.succeed('Experimental artifact workflow setup complete!');
-
-    // Print success message
-    console.log();
-    console.log(chalk.bold('ğŸ§ª Experimental Artifact Workflow Setup Complete'));
-    console.log();
-    console.log(chalk.bold('Skills Created:'));
-    for (const file of createdSkillFiles) {
-      console.log(chalk.green('  âœ“ ' + file));
-    }
-    console.log();
-    console.log(chalk.bold('Slash Commands Created:'));
-    for (const file of createdCommandFiles) {
-      console.log(chalk.green('  âœ“ ' + file));
-    }
-    console.log();
-
-    // Config creation section
-    console.log('â”'.repeat(70));
-    console.log();
-    console.log(chalk.bold('ğŸ“‹ Project Configuration (Optional)'));
-    console.log();
-    console.log('Configure project defaults for OpenSpec workflows.');
-    console.log();
-
-    // Check if config already exists
-    const configPath = path.join(projectRoot, 'openspec', 'config.yaml');
-    const configYmlPath = path.join(projectRoot, 'openspec', 'config.yml');
-    const configExists = fs.existsSync(configPath) || fs.existsSync(configYmlPath);
-
-    if (configExists) {
-      // Config already exists, skip creation
-      console.log(chalk.blue('â„¹ï¸  openspec/config.yaml already exists. Skipping config creation.'));
-      console.log();
-      console.log('   To update config, edit openspec/config.yaml manually or:');
-      console.log('   1. Delete openspec/config.yaml');
-      console.log('   2. Run openspec artifact-experimental-setup again');
-      console.log();
-    } else if (!process.stdin.isTTY) {
-      // Non-interactive mode (CI, automation, piped input)
-      console.log(chalk.blue('â„¹ï¸  Skipping config prompts (non-interactive mode)'));
-      console.log();
-      console.log('   To create config manually, add openspec/config.yaml with:');
-      console.log(chalk.dim('   schema: spec-driven'));
-      console.log();
-    } else {
-      // Create config with default schema
-      const yamlContent = serializeConfig({ schema: DEFAULT_SCHEMA });
-
-      try {
-        await FileSystemUtils.writeFile(configPath, yamlContent);
-
-        console.log();
-        console.log(chalk.green('âœ“ Created openspec/config.yaml'));
-        console.log();
-        console.log(`   Default schema: ${chalk.cyan(DEFAULT_SCHEMA)}`);
-        console.log();
-        console.log(chalk.dim('   Edit the file to add project context and per-artifact rules.'));
-        console.log();
-
-        // Git commit suggestion
-        console.log(chalk.bold('To share with team:'));
-        console.log(chalk.dim('  git add openspec/config.yaml .claude/'));
-        console.log(chalk.dim('  git commit -m "Setup OpenSpec experimental workflow"'));
-        console.log();
-      } catch (writeError) {
-        // Handle file write errors
-        console.error();
-        console.error(chalk.red('âœ— Failed to write openspec/config.yaml'));
-        console.error(chalk.dim(`  ${(writeError as Error).message}`));
-        console.error();
-        console.error('Fallback: Create config manually:');
-        console.error(chalk.dim('  1. Create openspec/config.yaml'));
-        console.error(chalk.dim('  2. Copy the following content:'));
-        console.error();
-        console.error(chalk.dim(yamlContent));
-        console.error();
-      }
-    }
-
-    console.log('â”'.repeat(70));
-    console.log();
-    console.log(chalk.bold('ğŸ“– Usage:'));
-    console.log();
-    console.log('  ' + chalk.cyan('Skills') + ' work automatically in compatible editors:');
-    console.log('  â€¢ Claude Code - Auto-detected, ready to use');
-    console.log('  â€¢ Cursor - Enable in Settings â†’ Rules â†’ Import Settings');
-    console.log('  â€¢ Windsurf - Auto-imports from .claude directory');
-    console.log();
-    console.log('  Ask Claude naturally:');
-    console.log('  â€¢ "I want to start a new OpenSpec change to add <feature>"');
-    console.log('  â€¢ "Continue working on this change"');
-    console.log('  â€¢ "Implement the tasks for this change"');
-    console.log();
-    console.log('  ' + chalk.cyan('Slash Commands') + ' for explicit invocation:');
-    console.log('  â€¢ /opsx:explore - Think through ideas, investigate problems');
-    console.log('  â€¢ /opsx:new - Start a new change');
-    console.log('  â€¢ /opsx:continue - Create the next artifact');
-    console.log('  â€¢ /opsx:apply - Implement tasks');
-    console.log('  â€¢ /opsx:ff - Fast-forward: create all artifacts at once');
-    console.log('  â€¢ /opsx:sync - Sync delta specs to main specs');
-    console.log('  â€¢ /opsx:verify - Verify implementation matches artifacts');
-    console.log('  â€¢ /opsx:archive - Archive a completed change');
-    console.log('  â€¢ /opsx:bulk-archive - Archive multiple completed changes');
-    console.log();
-    console.log(chalk.yellow('ğŸ’¡ This is an experimental feature.'));
-    console.log('   Feedback welcome at: https://github.com/Fission-AI/OpenSpec/issues');
-    console.log();
-  } catch (error) {
-    spinner.fail('Failed to setup experimental artifact workflow');
-    throw error;
-  }
-}
-
-// -----------------------------------------------------------------------------
-// Schemas Command
-// -----------------------------------------------------------------------------
-
-interface SchemasOptions {
-  json?: boolean;
-}
-
-async function schemasCommand(options: SchemasOptions): Promise<void> {
-  const projectRoot = process.cwd();
-  const schemas = listSchemasWithInfo(projectRoot);
-
-  if (options.json) {
-    console.log(JSON.stringify(schemas, null, 2));
-    return;
-  }
-
-  console.log('Available schemas:');
-  console.log();
-
-  for (const schema of schemas) {
-    let sourceLabel = '';
-    if (schema.source === 'project') {
-      sourceLabel = chalk.cyan(' (project)');
-    } else if (schema.source === 'user') {
-      sourceLabel = chalk.dim(' (user override)');
-    }
-    console.log(`  ${chalk.bold(schema.name)}${sourceLabel}`);
-    console.log(`    ${schema.description}`);
-    console.log(`    Artifacts: ${schema.artifacts.join(' â†’ ')}`);
-    console.log();
-  }
-}
-
-// -----------------------------------------------------------------------------
-// Command Registration
-// -----------------------------------------------------------------------------
-
-/**
- * Registers all artifact workflow commands on the given program.
- * All commands are marked as experimental in their help text.
- */
-export function registerArtifactWorkflowCommands(program: Command): void {
-  // Status command
-  program
-    .command('status')
-    .description('[Experimental] Display artifact completion status for a change')
-    .option('--change <id>', 'Change name to show status for')
-    .option('--schema <name>', 'Schema override (auto-detected from .openspec.yaml)')
-    .option('--json', 'Output as JSON')
-    .action(async (options: StatusOptions) => {
-      try {
-        await statusCommand(options);
-      } catch (error) {
-        console.log();
-        ora().fail(`Error: ${(error as Error).message}`);
-        process.exit(1);
-      }
-    });
-
-  // Instructions command
-  program
-    .command('instructions [artifact]')
-    .description('[Experimental] Output enriched instructions for creating an artifact or applying tasks')
-    .option('--change <id>', 'Change name')
-    .option('--schema <name>', 'Schema override (auto-detected from .openspec.yaml)')
-    .option('--json', 'Output as JSON')
-    .action(async (artifactId: string | undefined, options: InstructionsOptions) => {
-      try {
-        // Special case: "apply" is not an artifact, but a command to get apply instructions
-        if (artifactId === 'apply') {
-          await applyInstructionsCommand(options);
-        } else {
-          await instructionsCommand(artifactId, options);
-        }
-      } catch (error) {
-        console.log();
-        ora().fail(`Error: ${(error as Error).message}`);
-        process.exit(1);
-      }
-    });
-
-  // Templates command
-  program
-    .command('templates')
-    .description('[Experimental] Show resolved template paths for all artifacts in a schema')
-    .option('--schema <name>', `Schema to use (default: ${DEFAULT_SCHEMA})`)
-    .option('--json', 'Output as JSON mapping artifact IDs to template paths')
-    .action(async (options: TemplatesOptions) => {
-      try {
-        await templatesCommand(options);
-      } catch (error) {
-        console.log();
-        ora().fail(`Error: ${(error as Error).message}`);
-        process.exit(1);
-      }
-    });
-
-  // Schemas command
-  program
-    .command('schemas')
-    .description('[Experimental] List available workflow schemas with descriptions')
-    .option('--json', 'Output as JSON (for agent use)')
-    .action(async (options: SchemasOptions) => {
-      try {
-        await schemasCommand(options);
-      } catch (error) {
-        console.log();
-        ora().fail(`Error: ${(error as Error).message}`);
-        process.exit(1);
-      }
-    });
-
-  // New command group with change subcommand
-  const newCmd = program.command('new').description('[Experimental] Create new items');
-
-  newCmd
-    .command('change <name>')
-    .description('[Experimental] Create a new change directory')
-    .option('--description <text>', 'Description to add to README.md')
-    .option('--schema <name>', `Workflow schema to use (default: ${DEFAULT_SCHEMA})`)
-    .action(async (name: string, options: NewChangeOptions) => {
-      try {
-        await newChangeCommand(name, options);
-      } catch (error) {
-        console.log();
-        ora().fail(`Error: ${(error as Error).message}`);
-        process.exit(1);
-      }
-    });
-
-  // Artifact experimental setup command
-  program
-    .command('artifact-experimental-setup')
-    .description('[Experimental] Setup Agent Skills for the experimental artifact workflow')
-    .action(async () => {
-      try {
-        await artifactExperimentalSetupCommand();
-      } catch (error) {
-        console.log();
-        ora().fail(`Error: ${(error as Error).message}`);
-        process.exit(1);
-      }
-    });
-}
diff --git a/src/commands/workflow/index.ts b/src/commands/workflow/index.ts
new file mode 100644
index 0000000..232b2db
--- /dev/null
+++ b/src/commands/workflow/index.ts
@@ -0,0 +1,22 @@
+/**
+ * Workflow CLI Commands
+ *
+ * Commands for the artifact-driven workflow: status, instructions, templates, schemas, new change.
+ */
+
+export { statusCommand } from './status.js';
+export type { StatusOptions } from './status.js';
+
+export { instructionsCommand, applyInstructionsCommand } from './instructions.js';
+export type { InstructionsOptions } from './instructions.js';
+
+export { templatesCommand } from './templates.js';
+export type { TemplatesOptions } from './templates.js';
+
+export { schemasCommand } from './schemas.js';
+export type { SchemasOptions } from './schemas.js';
+
+export { newChangeCommand } from './new-change.js';
+export type { NewChangeOptions } from './new-change.js';
+
+export { DEFAULT_SCHEMA } from './shared.js';
diff --git a/src/commands/workflow/instructions.ts b/src/commands/workflow/instructions.ts
new file mode 100644
index 0000000..0d501af
--- /dev/null
+++ b/src/commands/workflow/instructions.ts
@@ -0,0 +1,481 @@
+/**
+ * Instructions Command
+ *
+ * Generates enriched instructions for creating artifacts or applying tasks.
+ * Includes both artifact instructions and apply instructions.
+ */
+
+import ora from 'ora';
+import path from 'path';
+import * as fs from 'fs';
+import {
+  loadChangeContext,
+  generateInstructions,
+  resolveSchema,
+  type ArtifactInstructions,
+} from '../../core/artifact-graph/index.js';
+import {
+  validateChangeExists,
+  validateSchemaExists,
+  type TaskItem,
+  type ApplyInstructions,
+} from './shared.js';
+
+// -----------------------------------------------------------------------------
+// Types
+// -----------------------------------------------------------------------------
+
+export interface InstructionsOptions {
+  change?: string;
+  schema?: string;
+  json?: boolean;
+}
+
+export interface ApplyInstructionsOptions {
+  change?: string;
+  schema?: string;
+  json?: boolean;
+}
+
+// -----------------------------------------------------------------------------
+// Artifact Instructions Command
+// -----------------------------------------------------------------------------
+
+export async function instructionsCommand(
+  artifactId: string | undefined,
+  options: InstructionsOptions
+): Promise<void> {
+  const spinner = ora('Generating instructions...').start();
+
+  try {
+    const projectRoot = process.cwd();
+    const changeName = await validateChangeExists(options.change, projectRoot);
+
+    // Validate schema if explicitly provided
+    if (options.schema) {
+      validateSchemaExists(options.schema, projectRoot);
+    }
+
+    // loadChangeContext will auto-detect schema from metadata if not provided
+    const context = loadChangeContext(projectRoot, changeName, options.schema);
+
+    if (!artifactId) {
+      spinner.stop();
+      const validIds = context.graph.getAllArtifacts().map((a) => a.id);
+      throw new Error(
+        `Missing required argument <artifact>. Valid artifacts:\n  ${validIds.join('\n  ')}`
+      );
+    }
+
+    const artifact = context.graph.getArtifact(artifactId);
+
+    if (!artifact) {
+      spinner.stop();
+      const validIds = context.graph.getAllArtifacts().map((a) => a.id);
+      throw new Error(
+        `Artifact '${artifactId}' not found in schema '${context.schemaName}'. Valid artifacts:\n  ${validIds.join('\n  ')}`
+      );
+    }
+
+    const instructions = generateInstructions(context, artifactId, projectRoot);
+    const isBlocked = instructions.dependencies.some((d) => !d.done);
+
+    spinner.stop();
+
+    if (options.json) {
+      console.log(JSON.stringify(instructions, null, 2));
+      return;
+    }
+
+    printInstructionsText(instructions, isBlocked);
+  } catch (error) {
+    spinner.stop();
+    throw error;
+  }
+}
+
+export function printInstructionsText(instructions: ArtifactInstructions, isBlocked: boolean): void {
+  const {
+    artifactId,
+    changeName,
+    schemaName,
+    changeDir,
+    outputPath,
+    description,
+    instruction,
+    context,
+    rules,
+    template,
+    dependencies,
+    unlocks,
+  } = instructions;
+
+  // Opening tag
+  console.log(`<artifact id="${artifactId}" change="${changeName}" schema="${schemaName}">`);
+  console.log();
+
+  // Warning for blocked artifacts
+  if (isBlocked) {
+    const missing = dependencies.filter((d) => !d.done).map((d) => d.id);
+    console.log('<warning>');
+    console.log('This artifact has unmet dependencies. Complete them first or proceed with caution.');
+    console.log(`Missing: ${missing.join(', ')}`);
+    console.log('</warning>');
+    console.log();
+  }
+
+  // Task directive
+  console.log('<task>');
+  console.log(`Create the ${artifactId} artifact for change "${changeName}".`);
+  console.log(description);
+  console.log('</task>');
+  console.log();
+
+  // Project context (AI constraint - do not include in output)
+  if (context) {
+    console.log('<project_context>');
+    console.log('<!-- This is background information for you. Do NOT include this in your output. -->');
+    console.log(context);
+    console.log('</project_context>');
+    console.log();
+  }
+
+  // Rules (AI constraint - do not include in output)
+  if (rules && rules.length > 0) {
+    console.log('<rules>');
+    console.log('<!-- These are constraints for you to follow. Do NOT include this in your output. -->');
+    for (const rule of rules) {
+      console.log(`- ${rule}`);
+    }
+    console.log('</rules>');
+    console.log();
+  }
+
+  // Dependencies (files to read for context)
+  if (dependencies.length > 0) {
+    console.log('<dependencies>');
+    console.log('Read these files for context before creating this artifact:');
+    console.log();
+    for (const dep of dependencies) {
+      const status = dep.done ? 'done' : 'missing';
+      const fullPath = path.join(changeDir, dep.path);
+      console.log(`<dependency id="${dep.id}" status="${status}">`);
+      console.log(`  <path>${fullPath}</path>`);
+      console.log(`  <description>${dep.description}</description>`);
+      console.log('</dependency>');
+    }
+    console.log('</dependencies>');
+    console.log();
+  }
+
+  // Output location
+  console.log('<output>');
+  console.log(`Write to: ${path.join(changeDir, outputPath)}`);
+  console.log('</output>');
+  console.log();
+
+  // Instruction (guidance)
+  if (instruction) {
+    console.log('<instruction>');
+    console.log(instruction.trim());
+    console.log('</instruction>');
+    console.log();
+  }
+
+  // Template
+  console.log('<template>');
+  console.log('<!-- Use this as the structure for your output file. Fill in the sections. -->');
+  console.log(template.trim());
+  console.log('</template>');
+  console.log();
+
+  // Success criteria placeholder
+  console.log('<success_criteria>');
+  console.log('<!-- To be defined in schema validation rules -->');
+  console.log('</success_criteria>');
+  console.log();
+
+  // Unlocks
+  if (unlocks.length > 0) {
+    console.log('<unlocks>');
+    console.log(`Completing this artifact enables: ${unlocks.join(', ')}`);
+    console.log('</unlocks>');
+    console.log();
+  }
+
+  // Closing tag
+  console.log('</artifact>');
+}
+
+// -----------------------------------------------------------------------------
+// Apply Instructions Command
+// -----------------------------------------------------------------------------
+
+/**
+ * Parses tasks.md content and extracts task items with their completion status.
+ */
+function parseTasksFile(content: string): TaskItem[] {
+  const tasks: TaskItem[] = [];
+  const lines = content.split('\n');
+  let taskIndex = 0;
+
+  for (const line of lines) {
+    // Match checkbox patterns: - [ ] or - [x] or - [X]
+    const checkboxMatch = line.match(/^[-*]\s*\[([ xX])\]\s*(.+)\s*$/);
+    if (checkboxMatch) {
+      taskIndex++;
+      const done = checkboxMatch[1].toLowerCase() === 'x';
+      const description = checkboxMatch[2].trim();
+      tasks.push({
+        id: `${taskIndex}`,
+        description,
+        done,
+      });
+    }
+  }
+
+  return tasks;
+}
+
+/**
+ * Checks if an artifact output exists in the change directory.
+ * Supports glob patterns (e.g., "specs/*.md") by verifying at least one matching file exists.
+ */
+function artifactOutputExists(changeDir: string, generates: string): boolean {
+  // Normalize the generates path to use platform-specific separators
+  const normalizedGenerates = generates.split('/').join(path.sep);
+  const fullPath = path.join(changeDir, normalizedGenerates);
+
+  // If it's a glob pattern (contains ** or *), check for matching files
+  if (generates.includes('*')) {
+    // Extract the directory part before the glob pattern
+    const parts = normalizedGenerates.split(path.sep);
+    const dirParts: string[] = [];
+    let patternPart = '';
+    for (const part of parts) {
+      if (part.includes('*')) {
+        patternPart = part;
+        break;
+      }
+      dirParts.push(part);
+    }
+    const dirPath = path.join(changeDir, ...dirParts);
+
+    // Check if directory exists
+    if (!fs.existsSync(dirPath) || !fs.statSync(dirPath).isDirectory()) {
+      return false;
+    }
+
+    // Extract expected extension from pattern (e.g., "*.md" -> ".md")
+    const extMatch = patternPart.match(/\*(\.[a-zA-Z0-9]+)$/);
+    const expectedExt = extMatch ? extMatch[1] : null;
+
+    // Recursively check for matching files
+    const hasMatchingFiles = (dir: string): boolean => {
+      try {
+        const entries = fs.readdirSync(dir, { withFileTypes: true });
+        for (const entry of entries) {
+          if (entry.isDirectory()) {
+            // For ** patterns, recurse into subdirectories
+            if (generates.includes('**') && hasMatchingFiles(path.join(dir, entry.name))) {
+              return true;
+            }
+          } else if (entry.isFile()) {
+            // Check if file matches expected extension (or any file if no extension specified)
+            if (!expectedExt || entry.name.endsWith(expectedExt)) {
+              return true;
+            }
+          }
+        }
+      } catch {
+        return false;
+      }
+      return false;
+    };
+
+    return hasMatchingFiles(dirPath);
+  }
+
+  return fs.existsSync(fullPath);
+}
+
+/**
+ * Generates apply instructions for implementing tasks from a change.
+ * Schema-aware: reads apply phase configuration from schema to determine
+ * required artifacts, tracking file, and instruction.
+ */
+export async function generateApplyInstructions(
+  projectRoot: string,
+  changeName: string,
+  schemaName?: string
+): Promise<ApplyInstructions> {
+  // loadChangeContext will auto-detect schema from metadata if not provided
+  const context = loadChangeContext(projectRoot, changeName, schemaName);
+  const changeDir = path.join(projectRoot, 'openspec', 'changes', changeName);
+
+  // Get the full schema to access the apply phase configuration
+  const schema = resolveSchema(context.schemaName, projectRoot);
+  const applyConfig = schema.apply;
+
+  // Determine required artifacts and tracking file from schema
+  // Fallback: if no apply block, require all artifacts
+  const requiredArtifactIds = applyConfig?.requires ?? schema.artifacts.map((a) => a.id);
+  const tracksFile = applyConfig?.tracks ?? null;
+  const schemaInstruction = applyConfig?.instruction ?? null;
+
+  // Check which required artifacts are missing
+  const missingArtifacts: string[] = [];
+  for (const artifactId of requiredArtifactIds) {
+    const artifact = schema.artifacts.find((a) => a.id === artifactId);
+    if (artifact && !artifactOutputExists(changeDir, artifact.generates)) {
+      missingArtifacts.push(artifactId);
+    }
+  }
+
+  // Build context files from all existing artifacts in schema
+  const contextFiles: Record<string, string> = {};
+  for (const artifact of schema.artifacts) {
+    if (artifactOutputExists(changeDir, artifact.generates)) {
+      contextFiles[artifact.id] = path.join(changeDir, artifact.generates);
+    }
+  }
+
+  // Parse tasks if tracking file exists
+  let tasks: TaskItem[] = [];
+  let tracksFileExists = false;
+  if (tracksFile) {
+    const tracksPath = path.join(changeDir, tracksFile);
+    tracksFileExists = fs.existsSync(tracksPath);
+    if (tracksFileExists) {
+      const tasksContent = await fs.promises.readFile(tracksPath, 'utf-8');
+      tasks = parseTasksFile(tasksContent);
+    }
+  }
+
+  // Calculate progress
+  const total = tasks.length;
+  const complete = tasks.filter((t) => t.done).length;
+  const remaining = total - complete;
+
+  // Determine state and instruction
+  let state: ApplyInstructions['state'];
+  let instruction: string;
+
+  if (missingArtifacts.length > 0) {
+    state = 'blocked';
+    instruction = `Cannot apply this change yet. Missing artifacts: ${missingArtifacts.join(', ')}.\nUse the openspec-continue-change skill to create the missing artifacts first.`;
+  } else if (tracksFile && !tracksFileExists) {
+    // Tracking file configured but doesn't exist yet
+    const tracksFilename = path.basename(tracksFile);
+    state = 'blocked';
+    instruction = `The ${tracksFilename} file is missing and must be created.\nUse openspec-continue-change to generate the tracking file.`;
+  } else if (tracksFile && tracksFileExists && total === 0) {
+    // Tracking file exists but contains no tasks
+    const tracksFilename = path.basename(tracksFile);
+    state = 'blocked';
+    instruction = `The ${tracksFilename} file exists but contains no tasks.\nAdd tasks to ${tracksFilename} or regenerate it with openspec-continue-change.`;
+  } else if (tracksFile && remaining === 0 && total > 0) {
+    state = 'all_done';
+    instruction = 'All tasks are complete! This change is ready to be archived.\nConsider running tests and reviewing the changes before archiving.';
+  } else if (!tracksFile) {
+    // No tracking file configured in schema - ready to apply
+    state = 'ready';
+    instruction = schemaInstruction?.trim() ?? 'All required artifacts complete. Proceed with implementation.';
+  } else {
+    state = 'ready';
+    instruction = schemaInstruction?.trim() ?? 'Read context files, work through pending tasks, mark complete as you go.\nPause if you hit blockers or need clarification.';
+  }
+
+  return {
+    changeName,
+    changeDir,
+    schemaName: context.schemaName,
+    contextFiles,
+    progress: { total, complete, remaining },
+    tasks,
+    state,
+    missingArtifacts: missingArtifacts.length > 0 ? missingArtifacts : undefined,
+    instruction,
+  };
+}
+
+export async function applyInstructionsCommand(options: ApplyInstructionsOptions): Promise<void> {
+  const spinner = ora('Generating apply instructions...').start();
+
+  try {
+    const projectRoot = process.cwd();
+    const changeName = await validateChangeExists(options.change, projectRoot);
+
+    // Validate schema if explicitly provided
+    if (options.schema) {
+      validateSchemaExists(options.schema, projectRoot);
+    }
+
+    // generateApplyInstructions uses loadChangeContext which auto-detects schema
+    const instructions = await generateApplyInstructions(projectRoot, changeName, options.schema);
+
+    spinner.stop();
+
+    if (options.json) {
+      console.log(JSON.stringify(instructions, null, 2));
+      return;
+    }
+
+    printApplyInstructionsText(instructions);
+  } catch (error) {
+    spinner.stop();
+    throw error;
+  }
+}
+
+export function printApplyInstructionsText(instructions: ApplyInstructions): void {
+  const { changeName, schemaName, contextFiles, progress, tasks, state, missingArtifacts, instruction } = instructions;
+
+  console.log(`## Apply: ${changeName}`);
+  console.log(`Schema: ${schemaName}`);
+  console.log();
+
+  // Warning for blocked state
+  if (state === 'blocked' && missingArtifacts) {
+    console.log('### âš ï¸ Blocked');
+    console.log();
+    console.log(`Missing artifacts: ${missingArtifacts.join(', ')}`);
+    console.log('Use the openspec-continue-change skill to create these first.');
+    console.log();
+  }
+
+  // Context files (dynamically from schema)
+  const contextFileEntries = Object.entries(contextFiles);
+  if (contextFileEntries.length > 0) {
+    console.log('### Context Files');
+    for (const [artifactId, filePath] of contextFileEntries) {
+      console.log(`- ${artifactId}: ${filePath}`);
+    }
+    console.log();
+  }
+
+  // Progress (only show if we have tracking)
+  if (progress.total > 0 || tasks.length > 0) {
+    console.log('### Progress');
+    if (state === 'all_done') {
+      console.log(`${progress.complete}/${progress.total} complete âœ“`);
+    } else {
+      console.log(`${progress.complete}/${progress.total} complete`);
+    }
+    console.log();
+  }
+
+  // Tasks
+  if (tasks.length > 0) {
+    console.log('### Tasks');
+    for (const task of tasks) {
+      const checkbox = task.done ? '[x]' : '[ ]';
+      console.log(`- ${checkbox} ${task.description}`);
+    }
+    console.log();
+  }
+
+  // Instruction
+  console.log('### Instruction');
+  console.log(instruction);
+}
diff --git a/src/commands/workflow/new-change.ts b/src/commands/workflow/new-change.ts
new file mode 100644
index 0000000..1435e1a
--- /dev/null
+++ b/src/commands/workflow/new-change.ts
@@ -0,0 +1,61 @@
+/**
+ * New Change Command
+ *
+ * Creates a new change directory with optional description and schema.
+ */
+
+import ora from 'ora';
+import path from 'path';
+import { createChange, validateChangeName } from '../../utils/change-utils.js';
+import { validateSchemaExists } from './shared.js';
+
+// -----------------------------------------------------------------------------
+// Types
+// -----------------------------------------------------------------------------
+
+export interface NewChangeOptions {
+  description?: string;
+  schema?: string;
+}
+
+// -----------------------------------------------------------------------------
+// Command Implementation
+// -----------------------------------------------------------------------------
+
+export async function newChangeCommand(name: string | undefined, options: NewChangeOptions): Promise<void> {
+  if (!name) {
+    throw new Error('Missing required argument <name>');
+  }
+
+  const validation = validateChangeName(name);
+  if (!validation.valid) {
+    throw new Error(validation.error);
+  }
+
+  const projectRoot = process.cwd();
+
+  // Validate schema if provided
+  if (options.schema) {
+    validateSchemaExists(options.schema, projectRoot);
+  }
+
+  const schemaDisplay = options.schema ? ` with schema '${options.schema}'` : '';
+  const spinner = ora(`Creating change '${name}'${schemaDisplay}...`).start();
+
+  try {
+    const result = await createChange(projectRoot, name, { schema: options.schema });
+
+    // If description provided, create README.md with description
+    if (options.description) {
+      const { promises: fs } = await import('fs');
+      const changeDir = path.join(projectRoot, 'openspec', 'changes', name);
+      const readmePath = path.join(changeDir, 'README.md');
+      await fs.writeFile(readmePath, `# ${name}\n\n${options.description}\n`, 'utf-8');
+    }
+
+    spinner.succeed(`Created change '${name}' at openspec/changes/${name}/ (schema: ${result.schema})`);
+  } catch (error) {
+    spinner.fail(`Failed to create change '${name}'`);
+    throw error;
+  }
+}
diff --git a/src/commands/workflow/schemas.ts b/src/commands/workflow/schemas.ts
new file mode 100644
index 0000000..b9af74a
--- /dev/null
+++ b/src/commands/workflow/schemas.ts
@@ -0,0 +1,46 @@
+/**
+ * Schemas Command
+ *
+ * Lists available workflow schemas with descriptions.
+ */
+
+import chalk from 'chalk';
+import { listSchemasWithInfo } from '../../core/artifact-graph/index.js';
+
+// -----------------------------------------------------------------------------
+// Types
+// -----------------------------------------------------------------------------
+
+export interface SchemasOptions {
+  json?: boolean;
+}
+
+// -----------------------------------------------------------------------------
+// Command Implementation
+// -----------------------------------------------------------------------------
+
+export async function schemasCommand(options: SchemasOptions): Promise<void> {
+  const projectRoot = process.cwd();
+  const schemas = listSchemasWithInfo(projectRoot);
+
+  if (options.json) {
+    console.log(JSON.stringify(schemas, null, 2));
+    return;
+  }
+
+  console.log('Available schemas:');
+  console.log();
+
+  for (const schema of schemas) {
+    let sourceLabel = '';
+    if (schema.source === 'project') {
+      sourceLabel = chalk.cyan(' (project)');
+    } else if (schema.source === 'user') {
+      sourceLabel = chalk.dim(' (user override)');
+    }
+    console.log(`  ${chalk.bold(schema.name)}${sourceLabel}`);
+    console.log(`    ${schema.description}`);
+    console.log(`    Artifacts: ${schema.artifacts.join(' â†’ ')}`);
+    console.log();
+  }
+}
diff --git a/src/commands/workflow/shared.ts b/src/commands/workflow/shared.ts
new file mode 100644
index 0000000..a2c8bdc
--- /dev/null
+++ b/src/commands/workflow/shared.ts
@@ -0,0 +1,161 @@
+/**
+ * Shared Types and Utilities for Artifact Workflow Commands
+ *
+ * This module contains types, constants, and validation helpers used across
+ * multiple artifact workflow commands.
+ */
+
+import chalk from 'chalk';
+import path from 'path';
+import * as fs from 'fs';
+import { getSchemaDir, listSchemas } from '../../core/artifact-graph/index.js';
+import { validateChangeName } from '../../utils/change-utils.js';
+
+// -----------------------------------------------------------------------------
+// Types
+// -----------------------------------------------------------------------------
+
+export interface TaskItem {
+  id: string;
+  description: string;
+  done: boolean;
+}
+
+export interface ApplyInstructions {
+  changeName: string;
+  changeDir: string;
+  schemaName: string;
+  contextFiles: Record<string, string>;
+  progress: {
+    total: number;
+    complete: number;
+    remaining: number;
+  };
+  tasks: TaskItem[];
+  state: 'blocked' | 'all_done' | 'ready';
+  missingArtifacts?: string[];
+  instruction: string;
+}
+
+// -----------------------------------------------------------------------------
+// Constants
+// -----------------------------------------------------------------------------
+
+export const DEFAULT_SCHEMA = 'spec-driven';
+
+// -----------------------------------------------------------------------------
+// Utility Functions
+// -----------------------------------------------------------------------------
+
+/**
+ * Checks if color output is disabled via NO_COLOR env or --no-color flag.
+ */
+export function isColorDisabled(): boolean {
+  return process.env.NO_COLOR === '1' || process.env.NO_COLOR === 'true';
+}
+
+/**
+ * Gets the color function based on status.
+ */
+export function getStatusColor(status: 'done' | 'ready' | 'blocked'): (text: string) => string {
+  if (isColorDisabled()) {
+    return (text: string) => text;
+  }
+  switch (status) {
+    case 'done':
+      return chalk.green;
+    case 'ready':
+      return chalk.yellow;
+    case 'blocked':
+      return chalk.red;
+  }
+}
+
+/**
+ * Gets the status indicator for an artifact.
+ */
+export function getStatusIndicator(status: 'done' | 'ready' | 'blocked'): string {
+  const color = getStatusColor(status);
+  switch (status) {
+    case 'done':
+      return color('[x]');
+    case 'ready':
+      return color('[ ]');
+    case 'blocked':
+      return color('[-]');
+  }
+}
+
+/**
+ * Validates that a change exists and returns available changes if not.
+ * Checks directory existence directly to support scaffolded changes (without proposal.md).
+ */
+export async function validateChangeExists(
+  changeName: string | undefined,
+  projectRoot: string
+): Promise<string> {
+  const changesPath = path.join(projectRoot, 'openspec', 'changes');
+
+  // Get all change directories (not just those with proposal.md)
+  const getAvailableChanges = async (): Promise<string[]> => {
+    try {
+      const entries = await fs.promises.readdir(changesPath, { withFileTypes: true });
+      return entries
+        .filter((e) => e.isDirectory() && e.name !== 'archive' && !e.name.startsWith('.'))
+        .map((e) => e.name);
+    } catch {
+      return [];
+    }
+  };
+
+  if (!changeName) {
+    const available = await getAvailableChanges();
+    if (available.length === 0) {
+      throw new Error('No changes found. Create one with: openspec new change <name>');
+    }
+    throw new Error(
+      `Missing required option --change. Available changes:\n  ${available.join('\n  ')}`
+    );
+  }
+
+  // Validate change name format to prevent path traversal
+  const nameValidation = validateChangeName(changeName);
+  if (!nameValidation.valid) {
+    throw new Error(`Invalid change name '${changeName}': ${nameValidation.error}`);
+  }
+
+  // Check directory existence directly
+  const changePath = path.join(changesPath, changeName);
+  const exists = fs.existsSync(changePath) && fs.statSync(changePath).isDirectory();
+
+  if (!exists) {
+    const available = await getAvailableChanges();
+    if (available.length === 0) {
+      throw new Error(
+        `Change '${changeName}' not found. No changes exist. Create one with: openspec new change <name>`
+      );
+    }
+    throw new Error(
+      `Change '${changeName}' not found. Available changes:\n  ${available.join('\n  ')}`
+    );
+  }
+
+  return changeName;
+}
+
+/**
+ * Validates that a schema exists and returns available schemas if not.
+ *
+ * @param schemaName - The schema name to validate
+ * @param projectRoot - Optional project root for project-local schema resolution
+ */
+export function validateSchemaExists(schemaName: string, projectRoot?: string): string {
+  const schemaDir = getSchemaDir(schemaName, projectRoot);
+  if (!schemaDir) {
+    const availableSchemas = listSchemas(projectRoot);
+    throw new Error(
+      `Schema '${schemaName}' not found. Available schemas:\n  ${availableSchemas.join('\n  ')}`
+    );
+  }
+  return schemaName;
+}
diff --git a/src/commands/workflow/status.ts b/src/commands/workflow/status.ts
new file mode 100644
index 0000000..59e46c2
--- /dev/null
+++ b/src/commands/workflow/status.ts
@@ -0,0 +1,90 @@
+/**
+ * Status Command
+ *
+ * Displays artifact completion status for a change.
+ */
+
+import ora from 'ora';
+import chalk from 'chalk';
+import {
+  loadChangeContext,
+  formatChangeStatus,
+  type ChangeStatus,
+} from '../../core/artifact-graph/index.js';
+import {
+  validateChangeExists,
+  validateSchemaExists,
+  getStatusIndicator,
+  getStatusColor,
+} from './shared.js';
+
+// -----------------------------------------------------------------------------
+// Types
+// -----------------------------------------------------------------------------
+
+export interface StatusOptions {
+  change?: string;
+  schema?: string;
+  json?: boolean;
+}
+
+// -----------------------------------------------------------------------------
+// Command Implementation
+// -----------------------------------------------------------------------------
+
+export async function statusCommand(options: StatusOptions): Promise<void> {
+  const spinner = ora('Loading change status...').start();
+
+  try {
+    const projectRoot = process.cwd();
+    const changeName = await validateChangeExists(options.change, projectRoot);
+
+    // Validate schema if explicitly provided
+    if (options.schema) {
+      validateSchemaExists(options.schema, projectRoot);
+    }
+
+    // loadChangeContext will auto-detect schema from metadata if not provided
+    const context = loadChangeContext(projectRoot, changeName, options.schema);
+    const status = formatChangeStatus(context);
+
+    spinner.stop();
+
+    if (options.json) {
+      console.log(JSON.stringify(status, null, 2));
+      return;
+    }
+
+    printStatusText(status);
+  } catch (error) {
+    spinner.stop();
+    throw error;
+  }
+}
+
+export function printStatusText(status: ChangeStatus): void {
+  const doneCount = status.artifacts.filter((a) => a.status === 'done').length;
+  const total = status.artifacts.length;
+
+  console.log(`Change: ${status.changeName}`);
+  console.log(`Schema: ${status.schemaName}`);
+  console.log(`Progress: ${doneCount}/${total} artifacts complete`);
+  console.log();
+
+  for (const artifact of status.artifacts) {
+    const indicator = getStatusIndicator(artifact.status);
+    const color = getStatusColor(artifact.status);
+    let line = `${indicator} ${artifact.id}`;
+
+    if (artifact.status === 'blocked' && artifact.missingDeps && artifact.missingDeps.length > 0) {
+      line += color(` (blocked by: ${artifact.missingDeps.join(', ')})`);
+    }
+
+    console.log(line);
+  }
+
+  if (status.isComplete) {
+    console.log();
+    console.log(chalk.green('All artifacts complete!'));
+  }
+}
diff --git a/src/commands/workflow/templates.ts b/src/commands/workflow/templates.ts
new file mode 100644
index 0000000..0660e99
--- /dev/null
+++ b/src/commands/workflow/templates.ts
@@ -0,0 +1,98 @@
+/**
+ * Templates Command
+ *
+ * Shows resolved template paths for all artifacts in a schema.
+ */
+
+import ora from 'ora';
+import path from 'path';
+import {
+  resolveSchema,
+  getSchemaDir,
+  ArtifactGraph,
+} from '../../core/artifact-graph/index.js';
+import { validateSchemaExists, DEFAULT_SCHEMA } from './shared.js';
+
+// -----------------------------------------------------------------------------
+// Types
+// -----------------------------------------------------------------------------
+
+export interface TemplatesOptions {
+  schema?: string;
+  json?: boolean;
+}
+
+export interface TemplateInfo {
+  artifactId: string;
+  templatePath: string;
+  source: 'project' | 'user' | 'package';
+}
+
+// -----------------------------------------------------------------------------
+// Command Implementation
+// -----------------------------------------------------------------------------
+
+export async function templatesCommand(options: TemplatesOptions): Promise<void> {
+  const spinner = ora('Loading templates...').start();
+
+  try {
+    const projectRoot = process.cwd();
+    const schemaName = validateSchemaExists(options.schema ?? DEFAULT_SCHEMA, projectRoot);
+    const schema = resolveSchema(schemaName, projectRoot);
+    const graph = ArtifactGraph.fromSchema(schema);
+    const schemaDir = getSchemaDir(schemaName, projectRoot)!;
+
+    // Determine the source (project, user, or package)
+    const {
+      getUserSchemasDir,
+      getProjectSchemasDir,
+    } = await import('../../core/artifact-graph/resolver.js');
+    const projectSchemasDir = getProjectSchemasDir(projectRoot);
+    const userSchemasDir = getUserSchemasDir();
+
+    // Determine source by checking if schemaDir is inside each base directory
+    // Using path.relative is more robust than startsWith for path comparisons
+    const isInsideDir = (child: string, parent: string): boolean => {
+      const relative = path.relative(parent, child);
+      return !relative.startsWith('..') && !path.isAbsolute(relative);
+    };
+
+    let source: 'project' | 'user' | 'package';
+    if (isInsideDir(schemaDir, projectSchemasDir)) {
+      source = 'project';
+    } else if (isInsideDir(schemaDir, userSchemasDir)) {
+      source = 'user';
+    } else {
+      source = 'package';
+    }
+
+    const templates: TemplateInfo[] = graph.getAllArtifacts().map((artifact) => ({
+      artifactId: artifact.id,
+      templatePath: path.join(schemaDir, 'templates', artifact.template),
+      source,
+    }));
+
+    spinner.stop();
+
+    if (options.json) {
+      const output: Record<string, { path: string; source: string }> = {};
+      for (const t of templates) {
+        output[t.artifactId] = { path: t.templatePath, source: t.source };
+      }
+      console.log(JSON.stringify(output, null, 2));
+      return;
+    }
+
+    console.log(`Schema: ${schemaName}`);
+    console.log(`Source: ${source}`);
+    console.log();
+
+    for (const t of templates) {
+      console.log(`${t.artifactId}:`);
+      console.log(`  ${t.templatePath}`);
+    }
+  } catch (error) {
+    spinner.stop();
+    throw error;
+  }
+}
diff --git a/src/core/command-generation/adapters/amazon-q.ts b/src/core/command-generation/adapters/amazon-q.ts
new file mode 100644
index 0000000..0131c06
--- /dev/null
+++ b/src/core/command-generation/adapters/amazon-q.ts
@@ -0,0 +1,30 @@
+/**
+ * Amazon Q Developer Command Adapter
+ *
+ * Formats commands for Amazon Q Developer following its frontmatter specification.
+ */
+
+import path from 'path';
+import type { CommandContent, ToolCommandAdapter } from '../types.js';
+
+/**
+ * Amazon Q adapter for command generation.
+ * File path: .amazonq/prompts/opsx-<id>.md
+ * Frontmatter: description
+ */
+export const amazonQAdapter: ToolCommandAdapter = {
+  toolId: 'amazon-q',
+
+  getFilePath(commandId: string): string {
+    return path.join('.amazonq', 'prompts', `opsx-${commandId}.md`);
+  },
+
+  formatFile(content: CommandContent): string {
+    return `---
+description: ${content.description}
+---
+
+${content.body}
+`;
+  },
+};
diff --git a/src/core/command-generation/adapters/antigravity.ts b/src/core/command-generation/adapters/antigravity.ts
new file mode 100644
index 0000000..e7a5d49
--- /dev/null
+++ b/src/core/command-generation/adapters/antigravity.ts
@@ -0,0 +1,30 @@
+/**
+ * Antigravity Command Adapter
+ *
+ * Formats commands for Antigravity following its frontmatter specification.
+ */
+
+import path from 'path';
+import type { CommandContent, ToolCommandAdapter } from '../types.js';
+
+/**
+ * Antigravity adapter for command generation.
+ * File path: .agent/workflows/opsx-<id>.md
+ * Frontmatter: description
+ */
+export const antigravityAdapter: ToolCommandAdapter = {
+  toolId: 'antigravity',
+
+  getFilePath(commandId: string): string {
+    return path.join('.agent', 'workflows', `opsx-${commandId}.md`);
+  },
+
+  formatFile(content: CommandContent): string {
+    return `---
+description: ${content.description}
+---
+
+${content.body}
+`;
+  },
+};
diff --git a/src/core/command-generation/adapters/auggie.ts b/src/core/command-generation/adapters/auggie.ts
new file mode 100644
index 0000000..2a52104
--- /dev/null
+++ b/src/core/command-generation/adapters/auggie.ts
@@ -0,0 +1,31 @@
+/**
+ * Auggie (Augment CLI) Command Adapter
+ *
+ * Formats commands for Auggie following its frontmatter specification.
+ */
+
+import path from 'path';
+import type { CommandContent, ToolCommandAdapter } from '../types.js';
+
+/**
+ * Auggie adapter for command generation.
+ * File path: .augment/commands/opsx-<id>.md
+ * Frontmatter: description, argument-hint
+ */
+export const auggieAdapter: ToolCommandAdapter = {
+  toolId: 'auggie',
+
+  getFilePath(commandId: string): string {
+    return path.join('.augment', 'commands', `opsx-${commandId}.md`);
+  },
+
+  formatFile(content: CommandContent): string {
+    return `---
+description: ${content.description}
+argument-hint: command arguments
+---
+
+${content.body}
+`;
+  },
+};
diff --git a/src/core/command-generation/adapters/claude.ts b/src/core/command-generation/adapters/claude.ts
new file mode 100644
index 0000000..532b3a4
--- /dev/null
+++ b/src/core/command-generation/adapters/claude.ts
@@ -0,0 +1,56 @@
+/**
+ * Claude Code Command Adapter
+ *
+ * Formats commands for Claude Code following its frontmatter specification.
+ */
+
+import path from 'path';
+import type { CommandContent, ToolCommandAdapter } from '../types.js';
+
+/**
+ * Escapes a string value for safe YAML output.
+ * Quotes the string if it contains special YAML characters.
+ */
+function escapeYamlValue(value: string): string {
+  // Check if value needs quoting (contains special YAML characters or starts/ends with whitespace)
+  const needsQuoting = /[:\n\r#{}[\],&*!|>'"%@`]|^\s|\s$/.test(value);
+  if (needsQuoting) {
+    // Use double quotes and escape internal double quotes and backslashes
+    const escaped = value.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n');
+    return `"${escaped}"`;
+  }
+  return value;
+}
+
+/**
+ * Formats a tags array as a YAML array with proper escaping.
+ */
+function formatTagsArray(tags: string[]): string {
+  const escapedTags = tags.map((tag) => escapeYamlValue(tag));
+  return `[${escapedTags.join(', ')}]`;
+}
+
+/**
+ * Claude Code adapter for command generation.
+ * File path: .claude/commands/opsx/<id>.md
+ * Frontmatter: name, description, category, tags
+ */
+export const claudeAdapter: ToolCommandAdapter = {
+  toolId: 'claude',
+
+  getFilePath(commandId: string): string {
+    return path.join('.claude', 'commands', 'opsx', `${commandId}.md`);
+  },
+
+  formatFile(content: CommandContent): string {
+    return `---
+name: ${escapeYamlValue(content.name)}
+description: ${escapeYamlValue(content.description)}
+category: ${escapeYamlValue(content.category)}
+tags: ${formatTagsArray(content.tags)}
+---
+
+${content.body}
+`;
+  },
+};
diff --git a/src/core/command-generation/adapters/cline.ts b/src/core/command-generation/adapters/cline.ts
new file mode 100644
index 0000000..abc6431
--- /dev/null
+++ b/src/core/command-generation/adapters/cline.ts
@@ -0,0 +1,31 @@
+/**
+ * Cline Command Adapter
+ *
+ * Formats commands for Cline following its workflow specification.
+ * Cline uses markdown headers instead of YAML frontmatter.
+ */
+
+import path from 'path';
+import type { CommandContent, ToolCommandAdapter } from '../types.js';
+
+/**
+ * Cline adapter for command generation.
+ * File path: .clinerules/workflows/opsx-<id>.md
+ * Format: Markdown header with description
+ */
+export const clineAdapter: ToolCommandAdapter = {
+  toolId: 'cline',
+
+  getFilePath(commandId: string): string {
+    return path.join('.clinerules', 'workflows', `opsx-${commandId}.md`);
+  },
+
+  formatFile(content: CommandContent): string {
+    return `# ${content.name}
+
+${content.description}
+
+${content.body}
+`;
+  },
+};
diff --git a/src/core/command-generation/adapters/codebuddy.ts b/src/core/command-generation/adapters/codebuddy.ts
new file mode 100644
index 0000000..54b7eeb
--- /dev/null
+++ b/src/core/command-generation/adapters/codebuddy.ts
@@ -0,0 +1,32 @@
+/**
+ * CodeBuddy Command Adapter
+ *
+ * Formats commands for CodeBuddy following its frontmatter specification.
+ */
+
+import path from 'path';
+import type { CommandContent, ToolCommandAdapter } from '../types.js';
+
+/**
+ * CodeBuddy adapter for command generation.
+ * File path: .codebuddy/commands/opsx/<id>.md
+ * Frontmatter: name, description, argument-hint
+ */
+export const codebuddyAdapter: ToolCommandAdapter = {
+  toolId: 'codebuddy',
+
+  getFilePath(commandId: string): string {
+    return path.join('.codebuddy', 'commands', 'opsx', `${commandId}.md`);
+  },
+
+  formatFile(content: CommandContent): string {
+    return `---
+name: ${content.name}
+description: "${content.description}"
+argument-hint: "[command arguments]"
+---
+
+${content.body}
+`;
+  },
+};
diff --git a/src/core/command-generation/adapters/codex.ts b/src/core/command-generation/adapters/codex.ts
new file mode 100644
index 0000000..1593dff
--- /dev/null
+++ b/src/core/command-generation/adapters/codex.ts
@@ -0,0 +1,31 @@
+/**
+ * Codex Command Adapter
+ *
+ * Formats commands for Codex following its frontmatter specification.
+ */
+
+import path from 'path';
+import type { CommandContent, ToolCommandAdapter } from '../types.js';
+
+/**
+ * Codex adapter for command generation.
+ * File path: .codex/prompts/opsx-<id>.md
+ * Frontmatter: description, argument-hint
+ */
+export const codexAdapter: ToolCommandAdapter = {
+  toolId: 'codex',
+
+  getFilePath(commandId: string): string {
+    return path.join('.codex', 'prompts', `opsx-${commandId}.md`);
+  },
+
+  formatFile(content: CommandContent): string {
+    return `---
+description: ${content.description}
+argument-hint: command arguments
+---
+
+${content.body}
+`;
+  },
+};
diff --git a/src/core/command-generation/adapters/continue.ts b/src/core/command-generation/adapters/continue.ts
new file mode 100644
index 0000000..f6aac08
--- /dev/null
+++ b/src/core/command-generation/adapters/continue.ts
@@ -0,0 +1,32 @@
+/**
+ * Continue Command Adapter
+ *
+ * Formats commands for Continue following its .prompt specification.
+ */
+
+import path from 'path';
+import type { CommandContent, ToolCommandAdapter } from '../types.js';
+
+/**
+ * Continue adapter for command generation.
+ * File path: .continue/prompts/opsx-<id>.prompt
+ * Frontmatter: name, description, invokable
+ */
+export const continueAdapter: ToolCommandAdapter = {
+  toolId: 'continue',
+
+  getFilePath(commandId: string): string {
+    return path.join('.continue', 'prompts', `opsx-${commandId}.prompt`);
+  },
+
+  formatFile(content: CommandContent): string {
+    return `---
+name: opsx-${content.id}
+description: ${content.description}
+invokable: true
+---
+
+${content.body}
+`;
+  },
+};
diff --git a/src/core/command-generation/adapters/costrict.ts b/src/core/command-generation/adapters/costrict.ts
new file mode 100644
index 0000000..17628a1
--- /dev/null
+++ b/src/core/command-generation/adapters/costrict.ts
@@ -0,0 +1,31 @@
+/**
+ * CoStrict Command Adapter
+ *
+ * Formats commands for CoStrict following its frontmatter specification.
+ */
+
+import path from 'path';
+import type { CommandContent, ToolCommandAdapter } from '../types.js';
+
+/**
+ * CoStrict adapter for command generation.
+ * File path: .cospec/openspec/commands/opsx-<id>.md
+ * Frontmatter: description, argument-hint
+ */
+export const costrictAdapter: ToolCommandAdapter = {
+  toolId: 'costrict',
+
+  getFilePath(commandId: string): string {
+    return path.join('.cospec', 'openspec', 'commands', `opsx-${commandId}.md`);
+  },
+
+  formatFile(content: CommandContent): string {
+    return `---
+description: "${content.description}"
+argument-hint: command arguments
+---
+
+${content.body}
+`;
+  },
+};
diff --git a/src/core/command-generation/adapters/crush.ts b/src/core/command-generation/adapters/crush.ts
new file mode 100644
index 0000000..b4d1a0b
--- /dev/null
+++ b/src/core/command-generation/adapters/crush.ts
@@ -0,0 +1,34 @@
+/**
+ * Crush Command Adapter
+ *
+ * Formats commands for Crush following its frontmatter specification.
+ */
+
+import path from 'path';
+import type { CommandContent, ToolCommandAdapter } from '../types.js';
+
+/**
+ * Crush adapter for command generation.
+ * File path: .crush/commands/opsx/<id>.md
+ * Frontmatter: name, description, category, tags
+ */
+export const crushAdapter: ToolCommandAdapter = {
+  toolId: 'crush',
+
+  getFilePath(commandId: string): string {
+    return path.join('.crush', 'commands', 'opsx', `${commandId}.md`);
+  },
+
+  formatFile(content: CommandContent): string {
+    const tagsStr = content.tags.join(', ');
+    return `---
+name: ${content.name}
+description: ${content.description}
+category: ${content.category}
+tags: [${tagsStr}]
+---
+
+${content.body}
+`;
+  },
+};
diff --git a/src/core/command-generation/adapters/cursor.ts b/src/core/command-generation/adapters/cursor.ts
new file mode 100644
index 0000000..85adedb
--- /dev/null
+++ b/src/core/command-generation/adapters/cursor.ts
@@ -0,0 +1,49 @@
+/**
+ * Cursor Command Adapter
+ *
+ * Formats commands for Cursor following its frontmatter specification.
+ * Cursor uses a different frontmatter format and file naming convention.
+ */
+
+import path from 'path';
+import type { CommandContent, ToolCommandAdapter } from '../types.js';
+
+/**
+ * Escapes a string value for safe YAML output.
+ * Quotes the string if it contains special YAML characters.
+ */
+function escapeYamlValue(value: string): string {
+  // Check if value needs quoting (contains special YAML characters or starts/ends with whitespace)
+  const needsQuoting = /[:\n\r#{}[\],&*!|>'"%@`]|^\s|\s$/.test(value);
+  if (needsQuoting) {
+    // Use double quotes and escape internal double quotes and backslashes
+    const escaped = value.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n');
+    return `"${escaped}"`;
+  }
+  return value;
+}
+
+/**
+ * Cursor adapter for command generation.
+ * File path: .cursor/commands/opsx-<id>.md
+ * Frontmatter: name (as /opsx-<id>), id, category, description
+ */
+export const cursorAdapter: ToolCommandAdapter = {
+  toolId: 'cursor',
+
+  getFilePath(commandId: string): string {
+    return path.join('.cursor', 'commands', `opsx-${commandId}.md`);
+  },
+
+  formatFile(content: CommandContent): string {
+    return `---
+name: /opsx-${content.id}
+id: opsx-${content.id}
+category: ${escapeYamlValue(content.category)}
+description: ${escapeYamlValue(content.description)}
+---
+
+${content.body}
+`;
+  },
+};
diff --git a/src/core/command-generation/adapters/factory.ts b/src/core/command-generation/adapters/factory.ts
new file mode 100644
index 0000000..5031d5d
--- /dev/null
+++ b/src/core/command-generation/adapters/factory.ts
@@ -0,0 +1,31 @@
+/**
+ * Factory Droid Command Adapter
+ *
+ * Formats commands for Factory Droid following its frontmatter specification.
+ */
+
+import path from 'path';
+import type { CommandContent, ToolCommandAdapter } from '../types.js';
+
+/**
+ * Factory adapter for command generation.
+ * File path: .factory/commands/opsx-<id>.md
+ * Frontmatter: description, argument-hint
+ */
+export const factoryAdapter: ToolCommandAdapter = {
+  toolId: 'factory',
+
+  getFilePath(commandId: string): string {
+    return path.join('.factory', 'commands', `opsx-${commandId}.md`);
+  },
+
+  formatFile(content: CommandContent): string {
+    return `---
+description: ${content.description}
+argument-hint: command arguments
+---
+
+${content.body}
+`;
+  },
+};
diff --git a/src/core/command-generation/adapters/gemini.ts b/src/core/command-generation/adapters/gemini.ts
new file mode 100644
index 0000000..2c08656
--- /dev/null
+++ b/src/core/command-generation/adapters/gemini.ts
@@ -0,0 +1,30 @@
+/**
+ * Gemini CLI Command Adapter
+ *
+ * Formats commands for Gemini CLI following its TOML specification.
+ */
+
+import path from 'path';
+import type { CommandContent, ToolCommandAdapter } from '../types.js';
+
+/**
+ * Gemini adapter for command generation.
+ * File path: .gemini/commands/opsx/<id>.toml
+ * Format: TOML with description and prompt fields
+ */
+export const geminiAdapter: ToolCommandAdapter = {
+  toolId: 'gemini',
+
+  getFilePath(commandId: string): string {
+    return path.join('.gemini', 'commands', 'opsx', `${commandId}.toml`);
+  },
+
+  formatFile(content: CommandContent): string {
+    return `description = "${content.description}"
+
+prompt = """
+${content.body}
+"""
+`;
+  },
+};
diff --git a/src/core/command-generation/adapters/github-copilot.ts b/src/core/command-generation/adapters/github-copilot.ts
new file mode 100644
index 0000000..4eac7f1
--- /dev/null
+++ b/src/core/command-generation/adapters/github-copilot.ts
@@ -0,0 +1,30 @@
+/**
+ * GitHub Copilot Command Adapter
+ *
+ * Formats commands for GitHub Copilot following its .prompt.md specification.
+ */
+
+import path from 'path';
+import type { CommandContent, ToolCommandAdapter } from '../types.js';
+
+/**
+ * GitHub Copilot adapter for command generation.
+ * File path: .github/prompts/opsx-<id>.prompt.md
+ * Frontmatter: description
+ */
+export const githubCopilotAdapter: ToolCommandAdapter = {
+  toolId: 'github-copilot',
+
+  getFilePath(commandId: string): string {
+    return path.join('.github', 'prompts', `opsx-${commandId}.prompt.md`);
+  },
+
+  formatFile(content: CommandContent): string {
+    return `---
+description: ${content.description}
+---
+
+${content.body}
+`;
+  },
+};
diff --git a/src/core/command-generation/adapters/iflow.ts b/src/core/command-generation/adapters/iflow.ts
new file mode 100644
index 0000000..d60a3f0
--- /dev/null
+++ b/src/core/command-generation/adapters/iflow.ts
@@ -0,0 +1,33 @@
+/**
+ * iFlow Command Adapter
+ *
+ * Formats commands for iFlow following its frontmatter specification.
+ */
+
+import path from 'path';
+import type { CommandContent, ToolCommandAdapter } from '../types.js';
+
+/**
+ * iFlow adapter for command generation.
+ * File path: .iflow/commands/opsx-<id>.md
+ * Frontmatter: name, id, category, description
+ */
+export const iflowAdapter: ToolCommandAdapter = {
+  toolId: 'iflow',
+
+  getFilePath(commandId: string): string {
+    return path.join('.iflow', 'commands', `opsx-${commandId}.md`);
+  },
+
+  formatFile(content: CommandContent): string {
+    return `---
+name: /opsx-${content.id}
+id: opsx-${content.id}
+category: ${content.category}
+description: ${content.description}
+---
+
+${content.body}
+`;
+  },
+};
diff --git a/src/core/command-generation/adapters/index.ts b/src/core/command-generation/adapters/index.ts
new file mode 100644
index 0000000..83de1f0
--- /dev/null
+++ b/src/core/command-generation/adapters/index.ts
@@ -0,0 +1,27 @@
+/**
+ * Command Adapters Index
+ *
+ * Re-exports all tool command adapters.
+ */
+
+export { amazonQAdapter } from './amazon-q.js';
+export { antigravityAdapter } from './antigravity.js';
+export { auggieAdapter } from './auggie.js';
+export { claudeAdapter } from './claude.js';
+export { clineAdapter } from './cline.js';
+export { codexAdapter } from './codex.js';
+export { codebuddyAdapter } from './codebuddy.js';
+export { continueAdapter } from './continue.js';
+export { costrictAdapter } from './costrict.js';
+export { crushAdapter } from './crush.js';
+export { cursorAdapter } from './cursor.js';
+export { factoryAdapter } from './factory.js';
+export { geminiAdapter } from './gemini.js';
+export { githubCopilotAdapter } from './github-copilot.js';
+export { iflowAdapter } from './iflow.js';
+export { kilocodeAdapter } from './kilocode.js';
+export { opencodeAdapter } from './opencode.js';
+export { qoderAdapter } from './qoder.js';
+export { qwenAdapter } from './qwen.js';
+export { roocodeAdapter } from './roocode.js';
+export { windsurfAdapter } from './windsurf.js';
diff --git a/src/core/command-generation/adapters/kilocode.ts b/src/core/command-generation/adapters/kilocode.ts
new file mode 100644
index 0000000..bb60c4d
--- /dev/null
+++ b/src/core/command-generation/adapters/kilocode.ts
@@ -0,0 +1,27 @@
+/**
+ * Kilo Code Command Adapter
+ *
+ * Formats commands for Kilo Code following its workflow specification.
+ * Kilo Code workflows don't use frontmatter.
+ */
+
+import path from 'path';
+import type { CommandContent, ToolCommandAdapter } from '../types.js';
+
+/**
+ * Kilo Code adapter for command generation.
+ * File path: .kilocode/workflows/opsx-<id>.md
+ * Format: Plain markdown without frontmatter
+ */
+export const kilocodeAdapter: ToolCommandAdapter = {
+  toolId: 'kilocode',
+
+  getFilePath(commandId: string): string {
+    return path.join('.kilocode', 'workflows', `opsx-${commandId}.md`);
+  },
+
+  formatFile(content: CommandContent): string {
+    return `${content.body}
+`;
+  },
+};
diff --git a/src/core/command-generation/adapters/opencode.ts b/src/core/command-generation/adapters/opencode.ts
new file mode 100644
index 0000000..05f9cab
--- /dev/null
+++ b/src/core/command-generation/adapters/opencode.ts
@@ -0,0 +1,30 @@
+/**
+ * OpenCode Command Adapter
+ *
+ * Formats commands for OpenCode following its frontmatter specification.
+ */
+
+import path from 'path';
+import type { CommandContent, ToolCommandAdapter } from '../types.js';
+
+/**
+ * OpenCode adapter for command generation.
+ * File path: .opencode/command/opsx-<id>.md
+ * Frontmatter: description
+ */
+export const opencodeAdapter: ToolCommandAdapter = {
+  toolId: 'opencode',
+
+  getFilePath(commandId: string): string {
+    return path.join('.opencode', 'command', `opsx-${commandId}.md`);
+  },
+
+  formatFile(content: CommandContent): string {
+    return `---
+description: ${content.description}
+---
+
+${content.body}
+`;
+  },
+};
diff --git a/src/core/command-generation/adapters/qoder.ts b/src/core/command-generation/adapters/qoder.ts
new file mode 100644
index 0000000..608fc9a
--- /dev/null
+++ b/src/core/command-generation/adapters/qoder.ts
@@ -0,0 +1,34 @@
+/**
+ * Qoder Command Adapter
+ *
+ * Formats commands for Qoder following its frontmatter specification.
+ */
+
+import path from 'path';
+import type { CommandContent, ToolCommandAdapter } from '../types.js';
+
+/**
+ * Qoder adapter for command generation.
+ * File path: .qoder/commands/opsx/<id>.md
+ * Frontmatter: name, description, category, tags
+ */
+export const qoderAdapter: ToolCommandAdapter = {
+  toolId: 'qoder',
+
+  getFilePath(commandId: string): string {
+    return path.join('.qoder', 'commands', 'opsx', `${commandId}.md`);
+  },
+
+  formatFile(content: CommandContent): string {
+    const tagsStr = content.tags.join(', ');
+    return `---
+name: ${content.name}
+description: ${content.description}
+category: ${content.category}
+tags: [${tagsStr}]
+---
+
+${content.body}
+`;
+  },
+};
diff --git a/src/core/command-generation/adapters/qwen.ts b/src/core/command-generation/adapters/qwen.ts
new file mode 100644
index 0000000..0ee640b
--- /dev/null
+++ b/src/core/command-generation/adapters/qwen.ts
@@ -0,0 +1,30 @@
+/**
+ * Qwen Code Command Adapter
+ *
+ * Formats commands for Qwen Code following its TOML specification.
+ */
+
+import path from 'path';
+import type { CommandContent, ToolCommandAdapter } from '../types.js';
+
+/**
+ * Qwen adapter for command generation.
+ * File path: .qwen/commands/opsx-<id>.toml
+ * Format: TOML with description and prompt fields
+ */
+export const qwenAdapter: ToolCommandAdapter = {
+  toolId: 'qwen',
+
+  getFilePath(commandId: string): string {
+    return path.join('.qwen', 'commands', `opsx-${commandId}.toml`);
+  },
+
+  formatFile(content: CommandContent): string {
+    return `description = "${content.description}"
+
+prompt = """
+${content.body}
+"""
+`;
+  },
+};
diff --git a/src/core/command-generation/adapters/roocode.ts b/src/core/command-generation/adapters/roocode.ts
new file mode 100644
index 0000000..5292985
--- /dev/null
+++ b/src/core/command-generation/adapters/roocode.ts
@@ -0,0 +1,31 @@
+/**
+ * RooCode Command Adapter
+ *
+ * Formats commands for RooCode following its workflow specification.
+ * RooCode uses markdown headers instead of YAML frontmatter.
+ */
+
+import path from 'path';
+import type { CommandContent, ToolCommandAdapter } from '../types.js';
+
+/**
+ * RooCode adapter for command generation.
+ * File path: .roo/commands/opsx-<id>.md
+ * Format: Markdown header with description
+ */
+export const roocodeAdapter: ToolCommandAdapter = {
+  toolId: 'roocode',
+
+  getFilePath(commandId: string): string {
+    return path.join('.roo', 'commands', `opsx-${commandId}.md`);
+  },
+
+  formatFile(content: CommandContent): string {
+    return `# ${content.name}
+
+${content.description}
+
+${content.body}
+`;
+  },
+};
diff --git a/src/core/command-generation/adapters/windsurf.ts b/src/core/command-generation/adapters/windsurf.ts
new file mode 100644
index 0000000..3267808
--- /dev/null
+++ b/src/core/command-generation/adapters/windsurf.ts
@@ -0,0 +1,57 @@
+/**
+ * Windsurf Command Adapter
+ *
+ * Formats commands for Windsurf following its frontmatter specification.
+ * Windsurf uses a similar format to Claude but may have different conventions.
+ */
+
+import path from 'path';
+import type { CommandContent, ToolCommandAdapter } from '../types.js';
+
+/**
+ * Escapes a string value for safe YAML output.
+ * Quotes the string if it contains special YAML characters.
+ */
+function escapeYamlValue(value: string): string {
+  // Check if value needs quoting (contains special YAML characters or starts/ends with whitespace)
+  const needsQuoting = /[:\n\r#{}[\],&*!|>'"%@`]|^\s|\s$/.test(value);
+  if (needsQuoting) {
+    // Use double quotes and escape internal double quotes and backslashes
+    const escaped = value.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n');
+    return `"${escaped}"`;
+  }
+  return value;
+}
+
+/**
+ * Formats a tags array as a YAML array with proper escaping.
+ */
+function formatTagsArray(tags: string[]): string {
+  const escapedTags = tags.map((tag) => escapeYamlValue(tag));
+  return `[${escapedTags.join(', ')}]`;
+}
+
+/**
+ * Windsurf adapter for command generation.
+ * File path: .windsurf/commands/opsx/<id>.md
+ * Frontmatter: name, description, category, tags
+ */
+export const windsurfAdapter: ToolCommandAdapter = {
+  toolId: 'windsurf',
+
+  getFilePath(commandId: string): string {
+    return path.join('.windsurf', 'commands', 'opsx', `${commandId}.md`);
+  },
+
+  formatFile(content: CommandContent): string {
+    return `---
+name: ${escapeYamlValue(content.name)}
+description: ${escapeYamlValue(content.description)}
+category: ${escapeYamlValue(content.category)}
+tags: ${formatTagsArray(content.tags)}
+---
+
+${content.body}
+`;
+  },
+};
diff --git a/src/core/command-generation/generator.ts b/src/core/command-generation/generator.ts
new file mode 100644
index 0000000..e8f22c0
--- /dev/null
+++ b/src/core/command-generation/generator.ts
@@ -0,0 +1,36 @@
+/**
+ * Command Generator
+ *
+ * Functions for generating command files using tool adapters.
+ */
+
+import type { CommandContent, ToolCommandAdapter, GeneratedCommand } from './types.js';
+
+/**
+ * Generate a single command file using the provided adapter.
+ * @param content - The tool-agnostic command content
+ * @param adapter - The tool-specific adapter
+ * @returns Generated command with path and file content
+ */
+export function generateCommand(
+  content: CommandContent,
+  adapter: ToolCommandAdapter
+): GeneratedCommand {
+  return {
+    path: adapter.getFilePath(content.id),
+    fileContent: adapter.formatFile(content),
+  };
+}
+
+/**
+ * Generate multiple command files using the provided adapter.
+ * @param contents - Array of tool-agnostic command contents
+ * @param adapter - The tool-specific adapter
+ * @returns Array of generated commands with paths and file contents
+ */
+export function generateCommands(
+  contents: CommandContent[],
+  adapter: ToolCommandAdapter
+): GeneratedCommand[] {
+  return contents.map((content) => generateCommand(content, adapter));
+}
diff --git a/src/core/command-generation/index.ts b/src/core/command-generation/index.ts
new file mode 100644
index 0000000..a067f33
--- /dev/null
+++ b/src/core/command-generation/index.ts
@@ -0,0 +1,33 @@
+/**
+ * Command Generation Module
+ *
+ * Generic command generation system with tool-specific adapters.
+ *
+ * Usage:
+ * ```typescript
+ * import { generateCommands, CommandAdapterRegistry, type CommandContent } from './command-generation/index.js';
+ *
+ * const contents: CommandContent[] = [...];
+ * const adapter = CommandAdapterRegistry.get('cursor');
+ * if (adapter) {
+ *   const commands = generateCommands(contents, adapter);
+ *   // Write commands to disk
+ * }
+ * ```
+ */
+
+// Types
+export type {
+  CommandContent,
+  ToolCommandAdapter,
+  GeneratedCommand,
+} from './types.js';
+
+// Registry
+export { CommandAdapterRegistry } from './registry.js';
+
+// Generator functions
+export { generateCommand, generateCommands } from './generator.js';
+
+// Adapters (for direct access if needed)
+export { claudeAdapter, cursorAdapter, windsurfAdapter } from './adapters/index.js';
diff --git a/src/core/command-generation/registry.ts b/src/core/command-generation/registry.ts
new file mode 100644
index 0000000..f99edac
--- /dev/null
+++ b/src/core/command-generation/registry.ts
@@ -0,0 +1,95 @@
+/**
+ * Command Adapter Registry
+ *
+ * Centralized registry for tool command adapters.
+ * Similar pattern to existing SlashCommandRegistry in the codebase.
+ */
+
+import type { ToolCommandAdapter } from './types.js';
+import { amazonQAdapter } from './adapters/amazon-q.js';
+import { antigravityAdapter } from './adapters/antigravity.js';
+import { auggieAdapter } from './adapters/auggie.js';
+import { claudeAdapter } from './adapters/claude.js';
+import { clineAdapter } from './adapters/cline.js';
+import { codexAdapter } from './adapters/codex.js';
+import { codebuddyAdapter } from './adapters/codebuddy.js';
+import { continueAdapter } from './adapters/continue.js';
+import { costrictAdapter } from './adapters/costrict.js';
+import { crushAdapter } from './adapters/crush.js';
+import { cursorAdapter } from './adapters/cursor.js';
+import { factoryAdapter } from './adapters/factory.js';
+import { geminiAdapter } from './adapters/gemini.js';
+import { githubCopilotAdapter } from './adapters/github-copilot.js';
+import { iflowAdapter } from './adapters/iflow.js';
+import { kilocodeAdapter } from './adapters/kilocode.js';
+import { opencodeAdapter } from './adapters/opencode.js';
+import { qoderAdapter } from './adapters/qoder.js';
+import { qwenAdapter } from './adapters/qwen.js';
+import { roocodeAdapter } from './adapters/roocode.js';
+import { windsurfAdapter } from './adapters/windsurf.js';
+
+/**
+ * Registry for looking up tool command adapters.
+ */
+export class CommandAdapterRegistry {
+  private static adapters: Map<string, ToolCommandAdapter> = new Map();
+
+  // Static initializer - register built-in adapters
+  static {
+    CommandAdapterRegistry.register(amazonQAdapter);
+    CommandAdapterRegistry.register(antigravityAdapter);
+    CommandAdapterRegistry.register(auggieAdapter);
+    CommandAdapterRegistry.register(claudeAdapter);
+    CommandAdapterRegistry.register(clineAdapter);
+    CommandAdapterRegistry.register(codexAdapter);
+    CommandAdapterRegistry.register(codebuddyAdapter);
+    CommandAdapterRegistry.register(continueAdapter);
+    CommandAdapterRegistry.register(costrictAdapter);
+    CommandAdapterRegistry.register(crushAdapter);
+    CommandAdapterRegistry.register(cursorAdapter);
+    CommandAdapterRegistry.register(factoryAdapter);
+    CommandAdapterRegistry.register(geminiAdapter);
+    CommandAdapterRegistry.register(githubCopilotAdapter);
+    CommandAdapterRegistry.register(iflowAdapter);
+    CommandAdapterRegistry.register(kilocodeAdapter);
+    CommandAdapterRegistry.register(opencodeAdapter);
+    CommandAdapterRegistry.register(qoderAdapter);
+    CommandAdapterRegistry.register(qwenAdapter);
+    CommandAdapterRegistry.register(roocodeAdapter);
+    CommandAdapterRegistry.register(windsurfAdapter);
+  }
+
+  /**
+   * Register a tool command adapter.
+   * @param adapter - The adapter to register
+   */
+  static register(adapter: ToolCommandAdapter): void {
+    CommandAdapterRegistry.adapters.set(adapter.toolId, adapter);
+  }
+
+  /**
+   * Get an adapter by tool ID.
+   * @param toolId - The tool identifier (e.g., 'claude', 'cursor')
+   * @returns The adapter or undefined if not registered
+   */
+  static get(toolId: string): ToolCommandAdapter | undefined {
+    return CommandAdapterRegistry.adapters.get(toolId);
+  }
+
+  /**
+   * Get all registered adapters.
+   * @returns Array of all registered adapters
+   */
+  static getAll(): ToolCommandAdapter[] {
+    return Array.from(CommandAdapterRegistry.adapters.values());
+  }
+
+  /**
+   * Check if an adapter is registered for a tool.
+   * @param toolId - The tool identifier
+   * @returns True if an adapter exists
+   */
+  static has(toolId: string): boolean {
+    return CommandAdapterRegistry.adapters.has(toolId);
+  }
+}
diff --git a/src/core/command-generation/types.ts b/src/core/command-generation/types.ts
new file mode 100644
index 0000000..96a74d3
--- /dev/null
+++ b/src/core/command-generation/types.ts
@@ -0,0 +1,57 @@
+/**
+ * Command Generation Types
+ *
+ * Tool-agnostic interfaces for command generation.
+ * These types separate "what to generate" from "how to format it".
+ */
+
+/**
+ * Tool-agnostic command data.
+ * Represents the content of a command without any tool-specific formatting.
+ */
+export interface CommandContent {
+  /** Command identifier (e.g., 'explore', 'apply', 'new') */
+  id: string;
+  /** Human-readable name (e.g., 'OpenSpec Explore') */
+  name: string;
+  /** Brief description of command purpose */
+  description: string;
+  /** Grouping category (e.g., 'Workflow') */
+  category: string;
+  /** Array of tag strings */
+  tags: string[];
+  /** The command instruction content (body text) */
+  body: string;
+}
+
+/**
+ * Per-tool formatting strategy.
+ * Each AI tool implements this interface to handle its specific file path
+ * and frontmatter format requirements.
+ */
+export interface ToolCommandAdapter {
+  /** Tool identifier matching AIToolOption.value (e.g., 'claude', 'cursor') */
+  toolId: string;
+  /**
+   * Returns the relative file path for a command.
+   * @param commandId - The command identifier (e.g., 'explore')
+   * @returns Relative path from project root (e.g., '.claude/commands/opsx/explore.md')
+   */
+  getFilePath(commandId: string): string;
+  /**
+   * Formats the complete file content including frontmatter.
+   * @param content - The tool-agnostic command content
+   * @returns Complete file content ready to write
+   */
+  formatFile(content: CommandContent): string;
+}
+
+/**
+ * Result of generating a command file.
+ */
+export interface GeneratedCommand {
+  /** Relative file path from project root */
+  path: string;
+  /** Complete file content (frontmatter + body) */
+  fileContent: string;
+}
diff --git a/src/core/config.ts b/src/core/config.ts
index e21361c..a90beb5 100644
--- a/src/core/config.ts
+++ b/src/core/config.ts
@@ -14,29 +14,30 @@ export interface AIToolOption {
   value: string;
   available: boolean;
   successLabel?: string;
+  skillsDir?: string; // e.g., '.claude' - /skills suffix per Agent Skills spec
 }
 
 export const AI_TOOLS: AIToolOption[] = [
-  { name: 'Amazon Q Developer', value: 'amazon-q', available: true, successLabel: 'Amazon Q Developer' },
-  { name: 'Antigravity', value: 'antigravity', available: true, successLabel: 'Antigravity' },
-  { name: 'Auggie (Augment CLI)', value: 'auggie', available: true, successLabel: 'Auggie' },
-  { name: 'Claude Code', value: 'claude', available: true, successLabel: 'Claude Code' },
-  { name: 'Cline', value: 'cline', available: true, successLabel: 'Cline' },
-  { name: 'Codex', value: 'codex', available: true, successLabel: 'Codex' },
-  { name: 'CodeBuddy Code (CLI)', value: 'codebuddy', available: true, successLabel: 'CodeBuddy Code' },
-  { name: 'Continue', value: 'continue', available: true, successLabel: 'Continue (VS Code / JetBrains / Cli)' },
-  { name: 'CoStrict', value: 'costrict', available: true, successLabel: 'CoStrict' },
-  { name: 'Crush', value: 'crush', available: true, successLabel: 'Crush' },
-  { name: 'Cursor', value: 'cursor', available: true, successLabel: 'Cursor' },
-  { name: 'Factory Droid', value: 'factory', available: true, successLabel: 'Factory Droid' },
-  { name: 'Gemini CLI', value: 'gemini', available: true, successLabel: 'Gemini CLI' },
-  { name: 'GitHub Copilot', value: 'github-copilot', available: true, successLabel: 'GitHub Copilot' },
-  { name: 'iFlow', value: 'iflow', available: true, successLabel: 'iFlow' },
-  { name: 'Kilo Code', value: 'kilocode', available: true, successLabel: 'Kilo Code' },
-  { name: 'OpenCode', value: 'opencode', available: true, successLabel: 'OpenCode' },
-  { name: 'Qoder', value: 'qoder', available: true, successLabel: 'Qoder' },
-  { name: 'Qwen Code', value: 'qwen', available: true, successLabel: 'Qwen Code' },
-  { name: 'RooCode', value: 'roocode', available: true, successLabel: 'RooCode' },
-  { name: 'Windsurf', value: 'windsurf', available: true, successLabel: 'Windsurf' },
+  { name: 'Amazon Q Developer', value: 'amazon-q', available: true, successLabel: 'Amazon Q Developer', skillsDir: '.amazonq' },
+  { name: 'Antigravity', value: 'antigravity', available: true, successLabel: 'Antigravity', skillsDir: '.agent' },
+  { name: 'Auggie (Augment CLI)', value: 'auggie', available: true, successLabel: 'Auggie', skillsDir: '.augment' },
+  { name: 'Claude Code', value: 'claude', available: true, successLabel: 'Claude Code', skillsDir: '.claude' },
+  { name: 'Cline', value: 'cline', available: true, successLabel: 'Cline', skillsDir: '.cline' },
+  { name: 'Codex', value: 'codex', available: true, successLabel: 'Codex', skillsDir: '.codex' },
+  { name: 'CodeBuddy Code (CLI)', value: 'codebuddy', available: true, successLabel: 'CodeBuddy Code', skillsDir: '.codebuddy' },
+  { name: 'Continue', value: 'continue', available: true, successLabel: 'Continue (VS Code / JetBrains / Cli)', skillsDir: '.continue' },
+  { name: 'CoStrict', value: 'costrict', available: true, successLabel: 'CoStrict', skillsDir: '.cospec' },
+  { name: 'Crush', value: 'crush', available: true, successLabel: 'Crush', skillsDir: '.crush' },
+  { name: 'Cursor', value: 'cursor', available: true, successLabel: 'Cursor', skillsDir: '.cursor' },
+  { name: 'Factory Droid', value: 'factory', available: true, successLabel: 'Factory Droid', skillsDir: '.factory' },
+  { name: 'Gemini CLI', value: 'gemini', available: true, successLabel: 'Gemini CLI', skillsDir: '.gemini' },
+  { name: 'GitHub Copilot', value: 'github-copilot', available: true, successLabel: 'GitHub Copilot', skillsDir: '.github' },
+  { name: 'iFlow', value: 'iflow', available: true, successLabel: 'iFlow', skillsDir: '.iflow' },
+  { name: 'Kilo Code', value: 'kilocode', available: true, successLabel: 'Kilo Code', skillsDir: '.kilocode' },
+  { name: 'OpenCode', value: 'opencode', available: true, successLabel: 'OpenCode', skillsDir: '.opencode' },
+  { name: 'Qoder', value: 'qoder', available: true, successLabel: 'Qoder', skillsDir: '.qoder' },
+  { name: 'Qwen Code', value: 'qwen', available: true, successLabel: 'Qwen Code', skillsDir: '.qwen' },
+  { name: 'RooCode', value: 'roocode', available: true, successLabel: 'RooCode', skillsDir: '.roo' },
+  { name: 'Windsurf', value: 'windsurf', available: true, successLabel: 'Windsurf', skillsDir: '.windsurf' },
   { name: 'AGENTS.md (works with Amp, VS Code, â€¦)', value: 'agents', available: false, successLabel: 'your AGENTS.md-compatible assistant' }
 ];
diff --git a/src/core/configurators/agents.ts b/src/core/configurators/agents.ts
deleted file mode 100644
index 720bb32..0000000
--- a/src/core/configurators/agents.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-import path from 'path';
-import { ToolConfigurator } from './base.js';
-import { FileSystemUtils } from '../../utils/file-system.js';
-import { TemplateManager } from '../templates/index.js';
-import { OPENSPEC_MARKERS } from '../config.js';
-
-export class AgentsStandardConfigurator implements ToolConfigurator {
-  name = 'AGENTS.md standard';
-  configFileName = 'AGENTS.md';
-  isAvailable = true;
-
-  async configure(projectPath: string, _openspecDir: string): Promise<void> {
-    const filePath = path.join(projectPath, this.configFileName);
-    const content = TemplateManager.getAgentsStandardTemplate();
-
-    await FileSystemUtils.updateFileWithMarkers(
-      filePath,
-      content,
-      OPENSPEC_MARKERS.start,
-      OPENSPEC_MARKERS.end
-    );
-  }
-}
diff --git a/src/core/configurators/base.ts b/src/core/configurators/base.ts
deleted file mode 100644
index 611a284..0000000
--- a/src/core/configurators/base.ts
+++ /dev/null
@@ -1,6 +0,0 @@
-export interface ToolConfigurator {
-  name: string;
-  configFileName: string;
-  isAvailable: boolean;
-  configure(projectPath: string, openspecDir: string): Promise<void>;
-}
\ No newline at end of file
diff --git a/src/core/configurators/claude.ts b/src/core/configurators/claude.ts
deleted file mode 100644
index 59103a4..0000000
--- a/src/core/configurators/claude.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-import path from 'path';
-import { ToolConfigurator } from './base.js';
-import { FileSystemUtils } from '../../utils/file-system.js';
-import { TemplateManager } from '../templates/index.js';
-import { OPENSPEC_MARKERS } from '../config.js';
-
-export class ClaudeConfigurator implements ToolConfigurator {
-  name = 'Claude Code';
-  configFileName = 'CLAUDE.md';
-  isAvailable = true;
-
-  async configure(projectPath: string, openspecDir: string): Promise<void> {
-    const filePath = path.join(projectPath, this.configFileName);
-    const content = TemplateManager.getClaudeTemplate();
-    
-    await FileSystemUtils.updateFileWithMarkers(
-      filePath,
-      content,
-      OPENSPEC_MARKERS.start,
-      OPENSPEC_MARKERS.end
-    );
-  }
-}
\ No newline at end of file
diff --git a/src/core/configurators/cline.ts b/src/core/configurators/cline.ts
deleted file mode 100644
index 9f74e85..0000000
--- a/src/core/configurators/cline.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-import path from 'path';
-import { ToolConfigurator } from './base.js';
-import { FileSystemUtils } from '../../utils/file-system.js';
-import { TemplateManager } from '../templates/index.js';
-import { OPENSPEC_MARKERS } from '../config.js';
-
-export class ClineConfigurator implements ToolConfigurator {
-  name = 'Cline';
-  configFileName = 'CLINE.md';
-  isAvailable = true;
-
-  async configure(projectPath: string, openspecDir: string): Promise<void> {
-    const filePath = path.join(projectPath, this.configFileName);
-    const content = TemplateManager.getClineTemplate();
-    
-    await FileSystemUtils.updateFileWithMarkers(
-      filePath,
-      content,
-      OPENSPEC_MARKERS.start,
-      OPENSPEC_MARKERS.end
-    );
-  }
-}
diff --git a/src/core/configurators/codebuddy.ts b/src/core/configurators/codebuddy.ts
deleted file mode 100644
index 467bdec..0000000
--- a/src/core/configurators/codebuddy.ts
+++ /dev/null
@@ -1,24 +0,0 @@
-import path from 'path';
-import { ToolConfigurator } from './base.js';
-import { FileSystemUtils } from '../../utils/file-system.js';
-import { TemplateManager } from '../templates/index.js';
-import { OPENSPEC_MARKERS } from '../config.js';
-
-export class CodeBuddyConfigurator implements ToolConfigurator {
-  name = 'CodeBuddy';
-  configFileName = 'CODEBUDDY.md';
-  isAvailable = true;
-
-  async configure(projectPath: string, openspecDir: string): Promise<void> {
-    const filePath = path.join(projectPath, this.configFileName);
-    const content = TemplateManager.getClaudeTemplate();
-    
-    await FileSystemUtils.updateFileWithMarkers(
-      filePath,
-      content,
-      OPENSPEC_MARKERS.start,
-      OPENSPEC_MARKERS.end
-    );
-  }
-}
-
diff --git a/src/core/configurators/costrict.ts b/src/core/configurators/costrict.ts
deleted file mode 100644
index 6a1a8d1..0000000
--- a/src/core/configurators/costrict.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-import path from 'path';
-import { ToolConfigurator } from './base.js';
-import { FileSystemUtils } from '../../utils/file-system.js';
-import { TemplateManager } from '../templates/index.js';
-import { OPENSPEC_MARKERS } from '../config.js';
-
-export class CostrictConfigurator implements ToolConfigurator {
-  name = 'CoStrict';
-  configFileName = 'COSTRICT.md';
-  isAvailable = true;
-
-  async configure(projectPath: string, openspecDir: string): Promise<void> {
-    const filePath = path.join(projectPath, this.configFileName);
-    const content = TemplateManager.getCostrictTemplate();
-    
-    await FileSystemUtils.updateFileWithMarkers(
-      filePath,
-      content,
-      OPENSPEC_MARKERS.start,
-      OPENSPEC_MARKERS.end
-    );
-  }
-}
\ No newline at end of file
diff --git a/src/core/configurators/iflow.ts b/src/core/configurators/iflow.ts
deleted file mode 100644
index 1ca9744..0000000
--- a/src/core/configurators/iflow.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-import path from "path";
-import { ToolConfigurator } from "./base.js";
-import { FileSystemUtils } from "../../utils/file-system.js";
-import { TemplateManager } from "../templates/index.js";
-import { OPENSPEC_MARKERS } from "../config.js";
-
-export class IflowConfigurator implements ToolConfigurator {
-  name = "iFlow";
-  configFileName = "IFLOW.md";
-  isAvailable = true;
-
-  async configure(projectPath: string, openspecDir: string): Promise<void> {
-    const filePath = path.join(projectPath, this.configFileName);
-    const content = TemplateManager.getClaudeTemplate();
-
-    await FileSystemUtils.updateFileWithMarkers(
-      filePath,
-      content,
-      OPENSPEC_MARKERS.start,
-      OPENSPEC_MARKERS.end
-    );
-  }
-}
diff --git a/src/core/configurators/qoder.ts b/src/core/configurators/qoder.ts
deleted file mode 100644
index db5e6dc..0000000
--- a/src/core/configurators/qoder.ts
+++ /dev/null
@@ -1,53 +0,0 @@
-import path from 'path';
-import { ToolConfigurator } from './base.js';
-import { FileSystemUtils } from '../../utils/file-system.js';
-import { TemplateManager } from '../templates/index.js';
-import { OPENSPEC_MARKERS } from '../config.js';
-
-/**
- * Qoder AI Tool Configurator
- * 
- * Configures OpenSpec integration for Qoder AI coding assistant.
- * Creates and manages QODER.md configuration file with OpenSpec instructions.
- * 
- * @implements {ToolConfigurator}
- */
-export class QoderConfigurator implements ToolConfigurator {
-  /** Display name for the Qoder tool */
-  name = 'Qoder';
-  
-  /** Configuration file name at project root */
-  configFileName = 'QODER.md';
-  
-  /** Indicates tool is available for configuration */
-  isAvailable = true;
-
-  /**
-   * Configure Qoder integration for a project
-   * 
-   * Creates or updates QODER.md file with OpenSpec instructions.
-   * Uses Claude-compatible template for instruction content.
-   * Wrapped with OpenSpec markers for future updates.
-   * 
-   * @param {string} projectPath - Absolute path to project root directory
-   * @param {string} openspecDir - Path to openspec directory (unused but required by interface)
-   * @returns {Promise<void>} Resolves when configuration is complete
-   */
-  async configure(projectPath: string, openspecDir: string): Promise<void> {
-    // Construct full path to QODER.md at project root
-    const filePath = path.join(projectPath, this.configFileName);
-    
-    // Get Claude-compatible instruction template
-    // This ensures Qoder receives the same high-quality OpenSpec instructions
-    const content = TemplateManager.getClaudeTemplate();
-    
-    // Write or update file with managed content between markers
-    // This allows future updates to refresh instructions automatically
-    await FileSystemUtils.updateFileWithMarkers(
-      filePath,
-      content,
-      OPENSPEC_MARKERS.start,
-      OPENSPEC_MARKERS.end
-    );
-  }
-}
diff --git a/src/core/configurators/qwen.ts b/src/core/configurators/qwen.ts
deleted file mode 100644
index 417b6ab..0000000
--- a/src/core/configurators/qwen.ts
+++ /dev/null
@@ -1,47 +0,0 @@
-/**
- * Qwen Code configurator for OpenSpec integration.
- * This class handles the configuration of Qwen Code as an AI tool within OpenSpec.
- * 
- * @implements {ToolConfigurator}
- */
-import path from 'path';
-import { ToolConfigurator } from './base.js';
-import { FileSystemUtils } from '../../utils/file-system.js';
-import { TemplateManager } from '../templates/index.js';
-import { OPENSPEC_MARKERS } from '../config.js';
-
-/**
- * QwenConfigurator class provides integration with Qwen Code
- * by creating and managing the necessary configuration files.
- * Currently configures the QWEN.md file with OpenSpec instructions.
- */
-export class QwenConfigurator implements ToolConfigurator {
-  /** Display name for the Qwen Code tool */
-  name = 'Qwen Code';
-  
-  /** Configuration file name for Qwen Code */
-  configFileName = 'QWEN.md';
-  
-  /** Availability status for the Qwen Code tool */
-  isAvailable = true;
-
-  /**
-   * Configures the Qwen Code integration by creating or updating the QWEN.md file
-   * with OpenSpec instructions and markers.
-   * 
-   * @param {string} projectPath - The path to the project root
-   * @param {string} _openspecDir - The path to the openspec directory (unused)
-   * @returns {Promise<void>} A promise that resolves when configuration is complete
-   */
-  async configure(projectPath: string, _openspecDir: string): Promise<void> {
-    const filePath = path.join(projectPath, this.configFileName);
-    const content = TemplateManager.getAgentsStandardTemplate();
-    
-    await FileSystemUtils.updateFileWithMarkers(
-      filePath,
-      content,
-      OPENSPEC_MARKERS.start,
-      OPENSPEC_MARKERS.end
-    );
-  }
-}
\ No newline at end of file
diff --git a/src/core/configurators/registry.ts b/src/core/configurators/registry.ts
deleted file mode 100644
index 70a1a20..0000000
--- a/src/core/configurators/registry.ts
+++ /dev/null
@@ -1,49 +0,0 @@
-import { ToolConfigurator } from './base.js';
-import { ClaudeConfigurator } from './claude.js';
-import { ClineConfigurator } from './cline.js';
-import { CodeBuddyConfigurator } from './codebuddy.js';
-import { CostrictConfigurator } from './costrict.js';
-import { QoderConfigurator } from './qoder.js';
-import { IflowConfigurator } from './iflow.js';
-import { AgentsStandardConfigurator } from './agents.js';
-import { QwenConfigurator } from './qwen.js';
-
-export class ToolRegistry {
-  private static tools: Map<string, ToolConfigurator> = new Map();
-
-  static {
-    const claudeConfigurator = new ClaudeConfigurator();
-    const clineConfigurator = new ClineConfigurator();
-    const codeBuddyConfigurator = new CodeBuddyConfigurator();
-    const costrictConfigurator = new CostrictConfigurator();
-    const qoderConfigurator = new QoderConfigurator();
-    const iflowConfigurator = new IflowConfigurator();
-    const agentsConfigurator = new AgentsStandardConfigurator();
-    const qwenConfigurator = new QwenConfigurator();
-    // Register with the ID that matches the checkbox value
-    this.tools.set('claude', claudeConfigurator);
-    this.tools.set('cline', clineConfigurator);
-    this.tools.set('codebuddy', codeBuddyConfigurator);
-    this.tools.set('costrict', costrictConfigurator);
-    this.tools.set('qoder', qoderConfigurator);
-    this.tools.set('iflow', iflowConfigurator);
-    this.tools.set('agents', agentsConfigurator);
-    this.tools.set('qwen', qwenConfigurator);
-  }
-
-  static register(tool: ToolConfigurator): void {
-    this.tools.set(tool.name.toLowerCase().replace(/\s+/g, '-'), tool);
-  }
-
-  static get(toolId: string): ToolConfigurator | undefined {
-    return this.tools.get(toolId);
-  }
-
-  static getAll(): ToolConfigurator[] {
-    return Array.from(this.tools.values());
-  }
-
-  static getAvailable(): ToolConfigurator[] {
-    return this.getAll().filter(tool => tool.isAvailable);
-  }
-}
diff --git a/src/core/configurators/slash/amazon-q.ts b/src/core/configurators/slash/amazon-q.ts
deleted file mode 100644
index e33e399..0000000
--- a/src/core/configurators/slash/amazon-q.ts
+++ /dev/null
@@ -1,51 +0,0 @@
-import { SlashCommandConfigurator } from './base.js';
-import { SlashCommandId } from '../../templates/index.js';
-
-const FILE_PATHS: Record<SlashCommandId, string> = {
-  proposal: '.amazonq/prompts/openspec-proposal.md',
-  apply: '.amazonq/prompts/openspec-apply.md',
-  archive: '.amazonq/prompts/openspec-archive.md'
-};
-
-const FRONTMATTER: Record<SlashCommandId, string> = {
-  proposal: `---
-description: Scaffold a new OpenSpec change and validate strictly.
----
-
-The user has requested the following change proposal. Use the openspec instructions to create their change proposal.
-
-<UserRequest>
-  $ARGUMENTS
-</UserRequest>`,
-  apply: `---
-description: Implement an approved OpenSpec change and keep tasks in sync.
----
-
-The user wants to apply the following change. Use the openspec instructions to implement the approved change.
-
-<ChangeId>
-  $ARGUMENTS
-</ChangeId>`,
-  archive: `---
-description: Archive a deployed OpenSpec change and update specs.
----
-
-The user wants to archive the following deployed change. Use the openspec instructions to archive the change and update specs.
-
-<ChangeId>
-  $ARGUMENTS
-</ChangeId>`
-};
-
-export class AmazonQSlashCommandConfigurator extends SlashCommandConfigurator {
-  readonly toolId = 'amazon-q';
-  readonly isAvailable = true;
-
-  protected getRelativePath(id: SlashCommandId): string {
-    return FILE_PATHS[id];
-  }
-
-  protected getFrontmatter(id: SlashCommandId): string {
-    return FRONTMATTER[id];
-  }
-}
\ No newline at end of file
diff --git a/src/core/configurators/slash/antigravity.ts b/src/core/configurators/slash/antigravity.ts
deleted file mode 100644
index f291f2a..0000000
--- a/src/core/configurators/slash/antigravity.ts
+++ /dev/null
@@ -1,28 +0,0 @@
-import { SlashCommandConfigurator } from './base.js';
-import { SlashCommandId } from '../../templates/index.js';
-
-const FILE_PATHS: Record<SlashCommandId, string> = {
-  proposal: '.agent/workflows/openspec-proposal.md',
-  apply: '.agent/workflows/openspec-apply.md',
-  archive: '.agent/workflows/openspec-archive.md'
-};
-
-const DESCRIPTIONS: Record<SlashCommandId, string> = {
-  proposal: 'Scaffold a new OpenSpec change and validate strictly.',
-  apply: 'Implement an approved OpenSpec change and keep tasks in sync.',
-  archive: 'Archive a deployed OpenSpec change and update specs.'
-};
-
-export class AntigravitySlashCommandConfigurator extends SlashCommandConfigurator {
-  readonly toolId = 'antigravity';
-  readonly isAvailable = true;
-
-  protected getRelativePath(id: SlashCommandId): string {
-    return FILE_PATHS[id];
-  }
-
-  protected getFrontmatter(id: SlashCommandId): string | undefined {
-    const description = DESCRIPTIONS[id];
-    return `---\ndescription: ${description}\n---`;
-  }
-}
diff --git a/src/core/configurators/slash/auggie.ts b/src/core/configurators/slash/auggie.ts
deleted file mode 100644
index 677bc42..0000000
--- a/src/core/configurators/slash/auggie.ts
+++ /dev/null
@@ -1,37 +0,0 @@
-import { SlashCommandConfigurator } from './base.js';
-import { SlashCommandId } from '../../templates/index.js';
-
-const FILE_PATHS: Record<SlashCommandId, string> = {
-  proposal: '.augment/commands/openspec-proposal.md',
-  apply: '.augment/commands/openspec-apply.md',
-  archive: '.augment/commands/openspec-archive.md'
-};
-
-const FRONTMATTER: Record<SlashCommandId, string> = {
-  proposal: `---
-description: Scaffold a new OpenSpec change and validate strictly.
-argument-hint: feature description or request
----`,
-  apply: `---
-description: Implement an approved OpenSpec change and keep tasks in sync.
-argument-hint: change-id
----`,
-  archive: `---
-description: Archive a deployed OpenSpec change and update specs.
-argument-hint: change-id
----`
-};
-
-export class AuggieSlashCommandConfigurator extends SlashCommandConfigurator {
-  readonly toolId = 'auggie';
-  readonly isAvailable = true;
-
-  protected getRelativePath(id: SlashCommandId): string {
-    return FILE_PATHS[id];
-  }
-
-  protected getFrontmatter(id: SlashCommandId): string {
-    return FRONTMATTER[id];
-  }
-}
-
diff --git a/src/core/configurators/slash/base.ts b/src/core/configurators/slash/base.ts
deleted file mode 100644
index beffd84..0000000
--- a/src/core/configurators/slash/base.ts
+++ /dev/null
@@ -1,95 +0,0 @@
-import { FileSystemUtils } from '../../../utils/file-system.js';
-import { TemplateManager, SlashCommandId } from '../../templates/index.js';
-import { OPENSPEC_MARKERS } from '../../config.js';
-
-export interface SlashCommandTarget {
-  id: SlashCommandId;
-  path: string;
-  kind: 'slash';
-}
-
-const ALL_COMMANDS: SlashCommandId[] = ['proposal', 'apply', 'archive'];
-
-export abstract class SlashCommandConfigurator {
-  abstract readonly toolId: string;
-  abstract readonly isAvailable: boolean;
-
-  getTargets(): SlashCommandTarget[] {
-    return ALL_COMMANDS.map((id) => ({
-      id,
-      path: this.getRelativePath(id),
-      kind: 'slash'
-    }));
-  }
-
-  async generateAll(projectPath: string, _openspecDir: string): Promise<string[]> {
-    const createdOrUpdated: string[] = [];
-
-    for (const target of this.getTargets()) {
-      const body = this.getBody(target.id);
-      const filePath = FileSystemUtils.joinPath(projectPath, target.path);
-
-      if (await FileSystemUtils.fileExists(filePath)) {
-        await this.updateBody(filePath, body);
-      } else {
-        const frontmatter = this.getFrontmatter(target.id);
-        const sections: string[] = [];
-        if (frontmatter) {
-          sections.push(frontmatter.trim());
-        }
-        sections.push(`${OPENSPEC_MARKERS.start}\n${body}\n${OPENSPEC_MARKERS.end}`);
-        const content = sections.join('\n') + '\n';
-        await FileSystemUtils.writeFile(filePath, content);
-      }
-
-      createdOrUpdated.push(target.path);
-    }
-
-    return createdOrUpdated;
-  }
-
-  async updateExisting(projectPath: string, _openspecDir: string): Promise<string[]> {
-    const updated: string[] = [];
-
-    for (const target of this.getTargets()) {
-      const filePath = FileSystemUtils.joinPath(projectPath, target.path);
-      if (await FileSystemUtils.fileExists(filePath)) {
-        const body = this.getBody(target.id);
-        await this.updateBody(filePath, body);
-        updated.push(target.path);
-      }
-    }
-
-    return updated;
-  }
-
-  protected abstract getRelativePath(id: SlashCommandId): string;
-  protected abstract getFrontmatter(id: SlashCommandId): string | undefined;
-
-  protected getBody(id: SlashCommandId): string {
-    return TemplateManager.getSlashCommandBody(id).trim();
-  }
-
-  // Resolve absolute path for a given slash command target. Subclasses may override
-  // to redirect to tool-specific locations (e.g., global directories).
-  resolveAbsolutePath(projectPath: string, id: SlashCommandId): string {
-    const rel = this.getRelativePath(id);
-    return FileSystemUtils.joinPath(projectPath, rel);
-  }
-
-  protected async updateBody(filePath: string, body: string): Promise<void> {
-    const content = await FileSystemUtils.readFile(filePath);
-    const startIndex = content.indexOf(OPENSPEC_MARKERS.start);
-    const endIndex = content.indexOf(OPENSPEC_MARKERS.end);
-
-    if (startIndex === -1 || endIndex === -1 || endIndex <= startIndex) {
-      throw new Error(`Missing OpenSpec markers in ${filePath}`);
-    }
-
-    const before = content.slice(0, startIndex + OPENSPEC_MARKERS.start.length);
-    const after = content.slice(endIndex);
-    const updatedContent = `${before}\n${body}\n${after}`;
-
-    await FileSystemUtils.writeFile(filePath, updatedContent);
-  }
-}
diff --git a/src/core/configurators/slash/claude.ts b/src/core/configurators/slash/claude.ts
deleted file mode 100644
index dcdfe3e..0000000
--- a/src/core/configurators/slash/claude.ts
+++ /dev/null
@@ -1,42 +0,0 @@
-import { SlashCommandConfigurator } from './base.js';
-import { SlashCommandId } from '../../templates/index.js';
-
-const FILE_PATHS: Record<SlashCommandId, string> = {
-  proposal: '.claude/commands/openspec/proposal.md',
-  apply: '.claude/commands/openspec/apply.md',
-  archive: '.claude/commands/openspec/archive.md'
-};
-
-const FRONTMATTER: Record<SlashCommandId, string> = {
-  proposal: `---
-name: OpenSpec - Proposal
-description: Scaffold a new OpenSpec change and validate strictly.
-category: OpenSpec
-tags: [openspec, change]
----`,
-  apply: `---
-name: OpenSpec - Apply
-description: Implement an approved OpenSpec change and keep tasks in sync.
-category: OpenSpec
-tags: [openspec, apply]
----`,
-  archive: `---
-name: OpenSpec - Archive
-description: Archive a deployed OpenSpec change and update specs.
-category: OpenSpec
-tags: [openspec, archive]
----`
-};
-
-export class ClaudeSlashCommandConfigurator extends SlashCommandConfigurator {
-  readonly toolId = 'claude';
-  readonly isAvailable = true;
-
-  protected getRelativePath(id: SlashCommandId): string {
-    return FILE_PATHS[id];
-  }
-
-  protected getFrontmatter(id: SlashCommandId): string {
-    return FRONTMATTER[id];
-  }
-}
diff --git a/src/core/configurators/slash/cline.ts b/src/core/configurators/slash/cline.ts
deleted file mode 100644
index 1c7d8c5..0000000
--- a/src/core/configurators/slash/cline.ts
+++ /dev/null
@@ -1,27 +0,0 @@
-import { SlashCommandConfigurator } from './base.js';
-import { SlashCommandId } from '../../templates/index.js';
-
-const FILE_PATHS: Record<SlashCommandId, string> = {
-  proposal: '.clinerules/workflows/openspec-proposal.md',
-  apply: '.clinerules/workflows/openspec-apply.md',
-  archive: '.clinerules/workflows/openspec-archive.md'
-};
-
-export class ClineSlashCommandConfigurator extends SlashCommandConfigurator {
-  readonly toolId = 'cline';
-  readonly isAvailable = true;
-
-  protected getRelativePath(id: SlashCommandId): string {
-    return FILE_PATHS[id];
-  }
-
-  protected getFrontmatter(id: SlashCommandId): string | undefined {
-    const descriptions: Record<SlashCommandId, string> = {
-      proposal: 'Scaffold a new OpenSpec change and validate strictly.',
-      apply: 'Implement an approved OpenSpec change and keep tasks in sync.',
-      archive: 'Archive a deployed OpenSpec change and update specs.'
-    };
-    const description = descriptions[id];
-    return `# OpenSpec: ${id.charAt(0).toUpperCase() + id.slice(1)}\n\n${description}`;
-  }
-}
diff --git a/src/core/configurators/slash/codebuddy.ts b/src/core/configurators/slash/codebuddy.ts
deleted file mode 100644
index 4b0e17c..0000000
--- a/src/core/configurators/slash/codebuddy.ts
+++ /dev/null
@@ -1,40 +0,0 @@
-import { SlashCommandConfigurator } from './base.js';
-import { SlashCommandId } from '../../templates/index.js';
-
-const FILE_PATHS: Record<SlashCommandId, string> = {
-  proposal: '.codebuddy/commands/openspec/proposal.md',
-  apply: '.codebuddy/commands/openspec/apply.md',
-  archive: '.codebuddy/commands/openspec/archive.md'
-};
-
-const FRONTMATTER: Record<SlashCommandId, string> = {
-  proposal: `---
-name: OpenSpec: Proposal
-description: "Scaffold a new OpenSpec change and validate strictly."
-argument-hint: "[feature description or request]"
----`,
-  apply: `---
-name: OpenSpec: Apply
-description: "Implement an approved OpenSpec change and keep tasks in sync."
-argument-hint: "[change-id]"
----`,
-  archive: `---
-name: OpenSpec: Archive
-description: "Archive a deployed OpenSpec change and update specs."
-argument-hint: "[change-id]"
----`
-};
-
-export class CodeBuddySlashCommandConfigurator extends SlashCommandConfigurator {
-  readonly toolId = 'codebuddy';
-  readonly isAvailable = true;
-
-  protected getRelativePath(id: SlashCommandId): string {
-    return FILE_PATHS[id];
-  }
-
-  protected getFrontmatter(id: SlashCommandId): string {
-    return FRONTMATTER[id];
-  }
-}
-
diff --git a/src/core/configurators/slash/codex.ts b/src/core/configurators/slash/codex.ts
deleted file mode 100644
index d9a2d2c..0000000
--- a/src/core/configurators/slash/codex.ts
+++ /dev/null
@@ -1,126 +0,0 @@
-import path from "path";
-import os from "os";
-import { SlashCommandConfigurator } from "./base.js";
-import { SlashCommandId, TemplateManager } from "../../templates/index.js";
-import { FileSystemUtils } from "../../../utils/file-system.js";
-import { OPENSPEC_MARKERS } from "../../config.js";
-
-// Use POSIX-style paths for consistent logging across platforms.
-const FILE_PATHS: Record<SlashCommandId, string> = {
-  proposal: ".codex/prompts/openspec-proposal.md",
-  apply: ".codex/prompts/openspec-apply.md",
-  archive: ".codex/prompts/openspec-archive.md",
-};
-
-export class CodexSlashCommandConfigurator extends SlashCommandConfigurator {
-  readonly toolId = "codex";
-  readonly isAvailable = true;
-
-  protected getRelativePath(id: SlashCommandId): string {
-    return FILE_PATHS[id];
-  }
-
-  protected getFrontmatter(id: SlashCommandId): string | undefined {
-    // Codex supports YAML frontmatter with description and argument-hint fields,
-    // plus $ARGUMENTS to capture all arguments as a single string.
-    const frontmatter: Record<SlashCommandId, string> = {
-      proposal: `---
-description: Scaffold a new OpenSpec change and validate strictly.
-argument-hint: request or feature description
----
-
-$ARGUMENTS`,
-      apply: `---
-description: Implement an approved OpenSpec change and keep tasks in sync.
-argument-hint: change-id
----
-
-$ARGUMENTS`,
-      archive: `---
-description: Archive a deployed OpenSpec change and update specs.
-argument-hint: change-id
----
-
-$ARGUMENTS`,
-    };
-    return frontmatter[id];
-  }
-
-  private getGlobalPromptsDir(): string {
-    const home = (process.env.CODEX_HOME && process.env.CODEX_HOME.trim())
-      ? process.env.CODEX_HOME.trim()
-      : FileSystemUtils.joinPath(os.homedir(), ".codex");
-    return FileSystemUtils.joinPath(home, "prompts");
-  }
-
-  // Codex discovers prompts globally. Generate directly in the global directory
-  // and wrap shared body with markers.
-  async generateAll(projectPath: string, _openspecDir: string): Promise<string[]> {
-    const createdOrUpdated: string[] = [];
-    for (const target of this.getTargets()) {
-      const body = TemplateManager.getSlashCommandBody(target.id).trim();
-      const promptsDir = this.getGlobalPromptsDir();
-      const filePath = FileSystemUtils.joinPath(
-        promptsDir,
-        path.basename(target.path)
-      );
-
-      await FileSystemUtils.createDirectory(path.dirname(filePath));
-
-      if (await FileSystemUtils.fileExists(filePath)) {
-        await this.updateFullFile(filePath, target.id, body);
-      } else {
-        const frontmatter = this.getFrontmatter(target.id);
-        const sections: string[] = [];
-        if (frontmatter) sections.push(frontmatter.trim());
-        sections.push(`${OPENSPEC_MARKERS.start}\n${body}\n${OPENSPEC_MARKERS.end}`);
-        await FileSystemUtils.writeFile(filePath, sections.join("\n") + "\n");
-      }
-
-      createdOrUpdated.push(target.path);
-    }
-    return createdOrUpdated;
-  }
-
-  async updateExisting(projectPath: string, _openspecDir: string): Promise<string[]> {
-    const updated: string[] = [];
-    for (const target of this.getTargets()) {
-      const promptsDir = this.getGlobalPromptsDir();
-      const filePath = FileSystemUtils.joinPath(
-        promptsDir,
-        path.basename(target.path)
-      );
-      if (await FileSystemUtils.fileExists(filePath)) {
-        const body = TemplateManager.getSlashCommandBody(target.id).trim();
-        await this.updateFullFile(filePath, target.id, body);
-        updated.push(target.path);
-      }
-    }
-    return updated;
-  }
-
-  // Update both frontmatter and body in an existing file
-  private async updateFullFile(filePath: string, id: SlashCommandId, body: string): Promise<void> {
-    const content = await FileSystemUtils.readFile(filePath);
-    const startIndex = content.indexOf(OPENSPEC_MARKERS.start);
-
-    if (startIndex === -1) {
-      throw new Error(`Missing OpenSpec start marker in ${filePath}`);
-    }
-
-    // Replace everything before the start marker with the new frontmatter
-    const frontmatter = this.getFrontmatter(id);
-    const sections: string[] = [];
-    if (frontmatter) sections.push(frontmatter.trim());
-    sections.push(`${OPENSPEC_MARKERS.start}\n${body}\n${OPENSPEC_MARKERS.end}`);
-
-    await FileSystemUtils.writeFile(filePath, sections.join("\n") + "\n");
-  }
-
-  // Resolve to the global prompts location for configuration detection
-  resolveAbsolutePath(_projectPath: string, id: SlashCommandId): string {
-    const promptsDir = this.getGlobalPromptsDir();
-    const fileName = path.basename(FILE_PATHS[id]);
-    return FileSystemUtils.joinPath(promptsDir, fileName);
-  }
-}
diff --git a/src/core/configurators/slash/continue.ts b/src/core/configurators/slash/continue.ts
deleted file mode 100644
index 88c9fd3..0000000
--- a/src/core/configurators/slash/continue.ts
+++ /dev/null
@@ -1,51 +0,0 @@
-import { SlashCommandConfigurator } from './base.js';
-import { SlashCommandId } from '../../templates/index.js';
-
-const FILE_PATHS: Record<SlashCommandId, string> = {
-  proposal: '.continue/prompts/openspec-proposal.prompt',
-  apply: '.continue/prompts/openspec-apply.prompt',
-  archive: '.continue/prompts/openspec-archive.prompt'
-};
-
-/*
- * Continue .prompt format requires YAML frontmatter:
- * ---
- * name: commandName
- * description: description
- * invokable: true
- * ---
- * Body...
- *
- * The 'invokable: true' field is required to make the prompt available as a slash command.
- * We use 'openspec-proposal' as the name so the command becomes /openspec-proposal.
- */
-const FRONTMATTER: Record<SlashCommandId, string> = {
-  proposal: `---
-name: openspec-proposal
-description: Scaffold a new OpenSpec change and validate strictly.
-invokable: true
----`,
-  apply: `---
-name: openspec-apply
-description: Implement an approved OpenSpec change and keep tasks in sync.
-invokable: true
----`,
-  archive: `---
-name: openspec-archive
-description: Archive a deployed OpenSpec change and update specs.
-invokable: true
----`
-};
-
-export class ContinueSlashCommandConfigurator extends SlashCommandConfigurator {
-  readonly toolId = 'continue';
-  readonly isAvailable = true;
-
-  protected getRelativePath(id: SlashCommandId): string {
-    return FILE_PATHS[id];
-  }
-
-  protected getFrontmatter(id: SlashCommandId): string {
-    return FRONTMATTER[id];
-  }
-}
diff --git a/src/core/configurators/slash/costrict.ts b/src/core/configurators/slash/costrict.ts
deleted file mode 100644
index 0ba92c6..0000000
--- a/src/core/configurators/slash/costrict.ts
+++ /dev/null
@@ -1,36 +0,0 @@
-import { SlashCommandConfigurator } from './base.js';
-import { SlashCommandId } from '../../templates/index.js';
-
-const FILE_PATHS = {
-  proposal: '.cospec/openspec/commands/openspec-proposal.md',
-  apply: '.cospec/openspec/commands/openspec-apply.md',
-  archive: '.cospec/openspec/commands/openspec-archive.md',
-} as const satisfies Record<SlashCommandId, string>;
-
-const FRONTMATTER = {
-  proposal: `---
-description: "Scaffold a new OpenSpec change and validate strictly."
-argument-hint: feature description or request
----`,
-  apply: `---
-description: "Implement an approved OpenSpec change and keep tasks in sync."
-argument-hint: change-id
----`,
-  archive: `---
-description: "Archive a deployed OpenSpec change and update specs."
-argument-hint: change-id
----`
-} as const satisfies Record<SlashCommandId, string>;
-
-export class CostrictSlashCommandConfigurator extends SlashCommandConfigurator {
-  readonly toolId = 'costrict';
-  readonly isAvailable = true;
-
-  protected getRelativePath(id: SlashCommandId): string {
-    return FILE_PATHS[id];
-  }
-
-  protected getFrontmatter(id: SlashCommandId): string | undefined {
-    return FRONTMATTER[id];
-  }
-}
\ No newline at end of file
diff --git a/src/core/configurators/slash/crush.ts b/src/core/configurators/slash/crush.ts
deleted file mode 100644
index c4ae1f1..0000000
--- a/src/core/configurators/slash/crush.ts
+++ /dev/null
@@ -1,42 +0,0 @@
-import { SlashCommandConfigurator } from './base.js';
-import { SlashCommandId } from '../../templates/index.js';
-
-const FILE_PATHS: Record<SlashCommandId, string> = {
-  proposal: '.crush/commands/openspec/proposal.md',
-  apply: '.crush/commands/openspec/apply.md',
-  archive: '.crush/commands/openspec/archive.md'
-};
-
-const FRONTMATTER: Record<SlashCommandId, string> = {
-  proposal: `---
-name: OpenSpec: Proposal
-description: Scaffold a new OpenSpec change and validate strictly.
-category: OpenSpec
-tags: [openspec, change]
----`,
-  apply: `---
-name: OpenSpec: Apply
-description: Implement an approved OpenSpec change and keep tasks in sync.
-category: OpenSpec
-tags: [openspec, apply]
----`,
-  archive: `---
-name: OpenSpec: Archive
-description: Archive a deployed OpenSpec change and update specs.
-category: OpenSpec
-tags: [openspec, archive]
----`
-};
-
-export class CrushSlashCommandConfigurator extends SlashCommandConfigurator {
-  readonly toolId = 'crush';
-  readonly isAvailable = true;
-
-  protected getRelativePath(id: SlashCommandId): string {
-    return FILE_PATHS[id];
-  }
-
-  protected getFrontmatter(id: SlashCommandId): string {
-    return FRONTMATTER[id];
-  }
-}
\ No newline at end of file
diff --git a/src/core/configurators/slash/cursor.ts b/src/core/configurators/slash/cursor.ts
deleted file mode 100644
index 58b07ce..0000000
--- a/src/core/configurators/slash/cursor.ts
+++ /dev/null
@@ -1,42 +0,0 @@
-import { SlashCommandConfigurator } from './base.js';
-import { SlashCommandId } from '../../templates/index.js';
-
-const FILE_PATHS: Record<SlashCommandId, string> = {
-  proposal: '.cursor/commands/openspec-proposal.md',
-  apply: '.cursor/commands/openspec-apply.md',
-  archive: '.cursor/commands/openspec-archive.md'
-};
-
-const FRONTMATTER: Record<SlashCommandId, string> = {
-  proposal: `---
-name: /openspec-proposal
-id: openspec-proposal
-category: OpenSpec
-description: Scaffold a new OpenSpec change and validate strictly.
----`,
-  apply: `---
-name: /openspec-apply
-id: openspec-apply
-category: OpenSpec
-description: Implement an approved OpenSpec change and keep tasks in sync.
----`,
-  archive: `---
-name: /openspec-archive
-id: openspec-archive
-category: OpenSpec
-description: Archive a deployed OpenSpec change and update specs.
----`
-};
-
-export class CursorSlashCommandConfigurator extends SlashCommandConfigurator {
-  readonly toolId = 'cursor';
-  readonly isAvailable = true;
-
-  protected getRelativePath(id: SlashCommandId): string {
-    return FILE_PATHS[id];
-  }
-
-  protected getFrontmatter(id: SlashCommandId): string {
-    return FRONTMATTER[id];
-  }
-}
diff --git a/src/core/configurators/slash/factory.ts b/src/core/configurators/slash/factory.ts
deleted file mode 100644
index 490a0cc..0000000
--- a/src/core/configurators/slash/factory.ts
+++ /dev/null
@@ -1,41 +0,0 @@
-import { SlashCommandConfigurator } from './base.js';
-import { SlashCommandId } from '../../templates/index.js';
-
-const FILE_PATHS: Record<SlashCommandId, string> = {
-  proposal: '.factory/commands/openspec-proposal.md',
-  apply: '.factory/commands/openspec-apply.md',
-  archive: '.factory/commands/openspec-archive.md'
-};
-
-const FRONTMATTER: Record<SlashCommandId, string> = {
-  proposal: `---
-description: Scaffold a new OpenSpec change and validate strictly.
-argument-hint: request or feature description
----`,
-  apply: `---
-description: Implement an approved OpenSpec change and keep tasks in sync.
-argument-hint: change-id
----`,
-  archive: `---
-description: Archive a deployed OpenSpec change and update specs.
-argument-hint: change-id
----`
-};
-
-export class FactorySlashCommandConfigurator extends SlashCommandConfigurator {
-  readonly toolId = 'factory';
-  readonly isAvailable = true;
-
-  protected getRelativePath(id: SlashCommandId): string {
-    return FILE_PATHS[id];
-  }
-
-  protected getFrontmatter(id: SlashCommandId): string {
-    return FRONTMATTER[id];
-  }
-
-  protected getBody(id: SlashCommandId): string {
-    const baseBody = super.getBody(id);
-    return `${baseBody}\n\n$ARGUMENTS`;
-  }
-}
diff --git a/src/core/configurators/slash/gemini.ts b/src/core/configurators/slash/gemini.ts
deleted file mode 100644
index 91bacc3..0000000
--- a/src/core/configurators/slash/gemini.ts
+++ /dev/null
@@ -1,27 +0,0 @@
-import { TomlSlashCommandConfigurator } from './toml-base.js';
-import { SlashCommandId } from '../../templates/index.js';
-
-const FILE_PATHS: Record<SlashCommandId, string> = {
-  proposal: '.gemini/commands/openspec/proposal.toml',
-  apply: '.gemini/commands/openspec/apply.toml',
-  archive: '.gemini/commands/openspec/archive.toml'
-};
-
-const DESCRIPTIONS: Record<SlashCommandId, string> = {
-  proposal: 'Scaffold a new OpenSpec change and validate strictly.',
-  apply: 'Implement an approved OpenSpec change and keep tasks in sync.',
-  archive: 'Archive a deployed OpenSpec change and update specs.'
-};
-
-export class GeminiSlashCommandConfigurator extends TomlSlashCommandConfigurator {
-  readonly toolId = 'gemini';
-  readonly isAvailable = true;
-
-  protected getRelativePath(id: SlashCommandId): string {
-    return FILE_PATHS[id];
-  }
-
-  protected getDescription(id: SlashCommandId): string {
-    return DESCRIPTIONS[id];
-  }
-}
diff --git a/src/core/configurators/slash/github-copilot.ts b/src/core/configurators/slash/github-copilot.ts
deleted file mode 100644
index d779264..0000000
--- a/src/core/configurators/slash/github-copilot.ts
+++ /dev/null
@@ -1,39 +0,0 @@
-import { SlashCommandConfigurator } from './base.js';
-import { SlashCommandId } from '../../templates/index.js';
-
-const FILE_PATHS: Record<SlashCommandId, string> = {
-  proposal: '.github/prompts/openspec-proposal.prompt.md',
-  apply: '.github/prompts/openspec-apply.prompt.md',
-  archive: '.github/prompts/openspec-archive.prompt.md'
-};
-
-const FRONTMATTER: Record<SlashCommandId, string> = {
-  proposal: `---
-description: Scaffold a new OpenSpec change and validate strictly.
----
-
-$ARGUMENTS`,
-  apply: `---
-description: Implement an approved OpenSpec change and keep tasks in sync.
----
-
-$ARGUMENTS`,
-  archive: `---
-description: Archive a deployed OpenSpec change and update specs.
----
-
-$ARGUMENTS`
-};
-
-export class GitHubCopilotSlashCommandConfigurator extends SlashCommandConfigurator {
-  readonly toolId = 'github-copilot';
-  readonly isAvailable = true;
-
-  protected getRelativePath(id: SlashCommandId): string {
-    return FILE_PATHS[id];
-  }
-
-  protected getFrontmatter(id: SlashCommandId): string {
-    return FRONTMATTER[id];
-  }
-}
diff --git a/src/core/configurators/slash/iflow.ts b/src/core/configurators/slash/iflow.ts
deleted file mode 100644
index c7c7961..0000000
--- a/src/core/configurators/slash/iflow.ts
+++ /dev/null
@@ -1,42 +0,0 @@
-import { SlashCommandConfigurator } from './base.js';
-import { SlashCommandId } from '../../templates/index.js';
-
-const FILE_PATHS: Record<SlashCommandId, string> = {
-  proposal: '.iflow/commands/openspec-proposal.md',
-  apply: '.iflow/commands/openspec-apply.md',
-  archive: '.iflow/commands/openspec-archive.md'
-};
-
-const FRONTMATTER: Record<SlashCommandId, string> = {
-  proposal: `---
-name: /openspec-proposal
-id: openspec-proposal
-category: OpenSpec
-description: Scaffold a new OpenSpec change and validate strictly.
----`,
-  apply: `---
-name: /openspec-apply
-id: openspec-apply
-category: OpenSpec
-description: Implement an approved OpenSpec change and keep tasks in sync.
----`,
-  archive: `---
-name: /openspec-archive
-id: openspec-archive
-category: OpenSpec
-description: Archive a deployed OpenSpec change and update specs.
----`
-};
-
-export class IflowSlashCommandConfigurator extends SlashCommandConfigurator {
-  readonly toolId = 'iflow';
-  readonly isAvailable = true;
-
-  protected getRelativePath(id: SlashCommandId): string {
-    return FILE_PATHS[id];
-  }
-
-  protected getFrontmatter(id: SlashCommandId): string {
-    return FRONTMATTER[id];
-  }
-}
diff --git a/src/core/configurators/slash/kilocode.ts b/src/core/configurators/slash/kilocode.ts
deleted file mode 100644
index 9717bef..0000000
--- a/src/core/configurators/slash/kilocode.ts
+++ /dev/null
@@ -1,21 +0,0 @@
-import { SlashCommandConfigurator } from "./base.js";
-import { SlashCommandId } from "../../templates/index.js";
-
-const FILE_PATHS: Record<SlashCommandId, string> = {
-  proposal: ".kilocode/workflows/openspec-proposal.md",
-  apply: ".kilocode/workflows/openspec-apply.md",
-  archive: ".kilocode/workflows/openspec-archive.md"
-};
-
-export class KiloCodeSlashCommandConfigurator extends SlashCommandConfigurator {
-  readonly toolId = "kilocode";
-  readonly isAvailable = true;
-
-  protected getRelativePath(id: SlashCommandId): string {
-    return FILE_PATHS[id];
-  }
-
-  protected getFrontmatter(_id: SlashCommandId): string | undefined {
-    return undefined;
-  }
-}
diff --git a/src/core/configurators/slash/opencode.ts b/src/core/configurators/slash/opencode.ts
deleted file mode 100644
index 48d3780..0000000
--- a/src/core/configurators/slash/opencode.ts
+++ /dev/null
@@ -1,83 +0,0 @@
-import { SlashCommandConfigurator } from "./base.js";
-import { SlashCommandId } from "../../templates/index.js";
-import { FileSystemUtils } from "../../../utils/file-system.js";
-import { OPENSPEC_MARKERS } from "../../config.js";
-
-const FILE_PATHS: Record<SlashCommandId, string> = {
-  proposal: ".opencode/command/openspec-proposal.md",
-  apply: ".opencode/command/openspec-apply.md",
-  archive: ".opencode/command/openspec-archive.md",
-};
-
-const FRONTMATTER: Record<SlashCommandId, string> = {
-  proposal: `---
-description: Scaffold a new OpenSpec change and validate strictly.
----
-The user has requested the following change proposal. Use the openspec instructions to create their change proposal.
-<UserRequest>
-  $ARGUMENTS
-</UserRequest>
-`,
-  apply: `---
-description: Implement an approved OpenSpec change and keep tasks in sync.
----
-The user has requested to implement the following change proposal. Find the change proposal and follow the instructions below. If you're not sure or if ambiguous, ask for clarification from the user.
-<UserRequest>
-  $ARGUMENTS
-</UserRequest>
-`,
-  archive: `---
-description: Archive a deployed OpenSpec change and update specs.
----
-<ChangeId>
-  $ARGUMENTS
-</ChangeId>
-`,
-};
-
-export class OpenCodeSlashCommandConfigurator extends SlashCommandConfigurator {
-  readonly toolId = "opencode";
-  readonly isAvailable = true;
-
-  protected getRelativePath(id: SlashCommandId): string {
-    return FILE_PATHS[id];
-  }
-
-  protected getFrontmatter(id: SlashCommandId): string | undefined {
-    return FRONTMATTER[id];
-  }
-
-  async generateAll(projectPath: string, _openspecDir: string): Promise<string[]> {
-    const createdOrUpdated = await super.generateAll(projectPath, _openspecDir);
-    await this.rewriteArchiveFile(projectPath);
-    return createdOrUpdated;
-  }
-
-  async updateExisting(projectPath: string, _openspecDir: string): Promise<string[]> {
-    const updated = await super.updateExisting(projectPath, _openspecDir);
-    const rewroteArchive = await this.rewriteArchiveFile(projectPath);
-    if (rewroteArchive && !updated.includes(FILE_PATHS.archive)) {
-      updated.push(FILE_PATHS.archive);
-    }
-    return updated;
-  }
-
-  private async rewriteArchiveFile(projectPath: string): Promise<boolean> {
-    const archivePath = FileSystemUtils.joinPath(projectPath, FILE_PATHS.archive);
-    if (!await FileSystemUtils.fileExists(archivePath)) {
-      return false;
-    }
-
-    const body = this.getBody("archive");
-    const frontmatter = this.getFrontmatter("archive");
-    const sections: string[] = [];
-
-    if (frontmatter) {
-      sections.push(frontmatter.trim());
-    }
-
-    sections.push(`${OPENSPEC_MARKERS.start}\n${body}\n${OPENSPEC_MARKERS.end}`);
-    await FileSystemUtils.writeFile(archivePath, sections.join("\n") + "\n");
-    return true;
-  }
-}
diff --git a/src/core/configurators/slash/qoder.ts b/src/core/configurators/slash/qoder.ts
deleted file mode 100644
index f147e08..0000000
--- a/src/core/configurators/slash/qoder.ts
+++ /dev/null
@@ -1,84 +0,0 @@
-import { SlashCommandConfigurator } from './base.js';
-import { SlashCommandId } from '../../templates/index.js';
-
-/**
- * File paths for Qoder slash commands
- * Maps each OpenSpec workflow stage to its command file location
- * Commands are stored in .qoder/commands/openspec/ directory
- */
-const FILE_PATHS: Record<SlashCommandId, string> = {
-  // Create and validate new change proposals
-  proposal: '.qoder/commands/openspec/proposal.md',
-  
-  // Implement approved changes with task tracking
-  apply: '.qoder/commands/openspec/apply.md',
-  
-  // Archive completed changes and update specs
-  archive: '.qoder/commands/openspec/archive.md'
-};
-
-/**
- * YAML frontmatter for Qoder slash commands
- * Defines metadata displayed in Qoder's command palette
- * Each command is categorized and tagged for easy discovery
- */
-const FRONTMATTER: Record<SlashCommandId, string> = {
-  proposal: `---
-name: OpenSpec: Proposal
-description: Scaffold a new OpenSpec change and validate strictly.
-category: OpenSpec
-tags: [openspec, change]
----`,
-  apply: `---
-name: OpenSpec: Apply
-description: Implement an approved OpenSpec change and keep tasks in sync.
-category: OpenSpec
-tags: [openspec, apply]
----`,
-  archive: `---
-name: OpenSpec: Archive
-description: Archive a deployed OpenSpec change and update specs.
-category: OpenSpec
-tags: [openspec, archive]
----`
-};
-
-/**
- * Qoder Slash Command Configurator
- * 
- * Manages OpenSpec slash commands for Qoder AI assistant.
- * Creates three workflow commands: proposal, apply, and archive.
- * Uses colon-separated command format (/openspec:proposal).
- * 
- * @extends {SlashCommandConfigurator}
- */
-export class QoderSlashCommandConfigurator extends SlashCommandConfigurator {
-  /** Unique identifier for Qoder tool */
-  readonly toolId = 'qoder';
-  
-  /** Indicates slash commands are available for this tool */
-  readonly isAvailable = true;
-
-  /**
-   * Get relative file path for a slash command
-   * 
-   * @param {SlashCommandId} id - Command identifier (proposal, apply, or archive)
-   * @returns {string} Relative path from project root to command file
-   */
-  protected getRelativePath(id: SlashCommandId): string {
-    return FILE_PATHS[id];
-  }
-
-  /**
-   * Get YAML frontmatter for a slash command
-   * 
-   * Frontmatter defines how the command appears in Qoder's UI,
-   * including display name, description, and categorization.
-   * 
-   * @param {SlashCommandId} id - Command identifier (proposal, apply, or archive)
-   * @returns {string} YAML frontmatter block with command metadata
-   */
-  protected getFrontmatter(id: SlashCommandId): string {
-    return FRONTMATTER[id];
-  }
-}
\ No newline at end of file
diff --git a/src/core/configurators/slash/qwen.ts b/src/core/configurators/slash/qwen.ts
deleted file mode 100644
index b1f9ebf..0000000
--- a/src/core/configurators/slash/qwen.ts
+++ /dev/null
@@ -1,55 +0,0 @@
-/**
- * Qwen slash command configurator for OpenSpec integration.
- * This class handles the generation of Qwen-specific slash command files
- * in the .qwen/commands directory structure.
- * 
- * @implements {SlashCommandConfigurator}
- */
-import { TomlSlashCommandConfigurator } from './toml-base.js';
-import { SlashCommandId } from '../../templates/index.js';
-
-/** 
- * Mapping of slash command IDs to their corresponding file paths in .qwen/commands directory.
- * @type {Record<SlashCommandId, string>}
- */
-const FILE_PATHS: Record<SlashCommandId, string> = {
-  proposal: '.qwen/commands/openspec-proposal.toml',
-  apply: '.qwen/commands/openspec-apply.toml',
-  archive: '.qwen/commands/openspec-archive.toml'
-};
-
-const DESCRIPTIONS: Record<SlashCommandId, string> = {
-  proposal: 'Scaffold a new OpenSpec change and validate strictly.',
-  apply: 'Implement an approved OpenSpec change and keep tasks in sync.',
-  archive: 'Archive a deployed OpenSpec change and update specs.'
-};
-
-/**
- * QwenSlashCommandConfigurator class provides integration with Qwen Code
- * by creating the necessary slash command files in the .qwen/commands directory.
- * 
- * The slash commands include:
- * - /openspec-proposal: Create an OpenSpec change proposal
- * - /openspec-apply: Apply an approved OpenSpec change
- * - /openspec-archive: Archive a deployed OpenSpec change
- */
-export class QwenSlashCommandConfigurator extends TomlSlashCommandConfigurator {
-  /** Unique identifier for the Qwen tool */
-  readonly toolId = 'qwen';
-
-  /** Availability status for the Qwen tool */
-  readonly isAvailable = true;
-
-  /**
-   * Returns the relative file path for a given slash command ID.
-   * @param {SlashCommandId} id - The slash command identifier
-   * @returns {string} The relative path to the command file
-   */
-  protected getRelativePath(id: SlashCommandId): string {
-    return FILE_PATHS[id];
-  }
-
-  protected getDescription(id: SlashCommandId): string {
-    return DESCRIPTIONS[id];
-  }
-}
\ No newline at end of file
diff --git a/src/core/configurators/slash/registry.ts b/src/core/configurators/slash/registry.ts
deleted file mode 100644
index 43fb245..0000000
--- a/src/core/configurators/slash/registry.ts
+++ /dev/null
@@ -1,84 +0,0 @@
-import { SlashCommandConfigurator } from './base.js';
-import { ClaudeSlashCommandConfigurator } from './claude.js';
-import { CodeBuddySlashCommandConfigurator } from './codebuddy.js';
-import { QoderSlashCommandConfigurator } from './qoder.js';
-import { CursorSlashCommandConfigurator } from './cursor.js';
-import { WindsurfSlashCommandConfigurator } from './windsurf.js';
-import { KiloCodeSlashCommandConfigurator } from './kilocode.js';
-import { OpenCodeSlashCommandConfigurator } from './opencode.js';
-import { CodexSlashCommandConfigurator } from './codex.js';
-import { GitHubCopilotSlashCommandConfigurator } from './github-copilot.js';
-import { AmazonQSlashCommandConfigurator } from './amazon-q.js';
-import { FactorySlashCommandConfigurator } from './factory.js';
-import { GeminiSlashCommandConfigurator } from './gemini.js';
-import { AuggieSlashCommandConfigurator } from './auggie.js';
-import { ClineSlashCommandConfigurator } from './cline.js';
-import { CrushSlashCommandConfigurator } from './crush.js';
-import { CostrictSlashCommandConfigurator } from './costrict.js';
-import { QwenSlashCommandConfigurator } from './qwen.js';
-import { RooCodeSlashCommandConfigurator } from './roocode.js';
-import { AntigravitySlashCommandConfigurator } from './antigravity.js';
-import { IflowSlashCommandConfigurator } from './iflow.js';
-import { ContinueSlashCommandConfigurator } from './continue.js';
-
-export class SlashCommandRegistry {
-  private static configurators: Map<string, SlashCommandConfigurator> = new Map();
-
-  static {
-    const claude = new ClaudeSlashCommandConfigurator();
-    const codeBuddy = new CodeBuddySlashCommandConfigurator();
-    const qoder = new QoderSlashCommandConfigurator();
-    const cursor = new CursorSlashCommandConfigurator();
-    const windsurf = new WindsurfSlashCommandConfigurator();
-    const kilocode = new KiloCodeSlashCommandConfigurator();
-    const opencode = new OpenCodeSlashCommandConfigurator();
-    const codex = new CodexSlashCommandConfigurator();
-    const githubCopilot = new GitHubCopilotSlashCommandConfigurator();
-    const amazonQ = new AmazonQSlashCommandConfigurator();
-    const factory = new FactorySlashCommandConfigurator();
-    const gemini = new GeminiSlashCommandConfigurator();
-    const auggie = new AuggieSlashCommandConfigurator();
-    const cline = new ClineSlashCommandConfigurator();
-    const crush = new CrushSlashCommandConfigurator();
-    const costrict = new CostrictSlashCommandConfigurator();
-    const qwen = new QwenSlashCommandConfigurator();
-    const roocode = new RooCodeSlashCommandConfigurator();
-    const antigravity = new AntigravitySlashCommandConfigurator();
-    const iflow = new IflowSlashCommandConfigurator();
-    const continueTool = new ContinueSlashCommandConfigurator();
-
-    this.configurators.set(claude.toolId, claude);
-    this.configurators.set(codeBuddy.toolId, codeBuddy);
-    this.configurators.set(qoder.toolId, qoder);
-    this.configurators.set(cursor.toolId, cursor);
-    this.configurators.set(windsurf.toolId, windsurf);
-    this.configurators.set(kilocode.toolId, kilocode);
-    this.configurators.set(opencode.toolId, opencode);
-    this.configurators.set(codex.toolId, codex);
-    this.configurators.set(githubCopilot.toolId, githubCopilot);
-    this.configurators.set(amazonQ.toolId, amazonQ);
-    this.configurators.set(factory.toolId, factory);
-    this.configurators.set(gemini.toolId, gemini);
-    this.configurators.set(auggie.toolId, auggie);
-    this.configurators.set(cline.toolId, cline);
-    this.configurators.set(crush.toolId, crush);
-    this.configurators.set(costrict.toolId, costrict);
-    this.configurators.set(qwen.toolId, qwen);
-    this.configurators.set(roocode.toolId, roocode);
-    this.configurators.set(antigravity.toolId, antigravity);
-    this.configurators.set(iflow.toolId, iflow);
-    this.configurators.set(continueTool.toolId, continueTool);
-  }
-
-  static register(configurator: SlashCommandConfigurator): void {
-    this.configurators.set(configurator.toolId, configurator);
-  }
-
-  static get(toolId: string): SlashCommandConfigurator | undefined {
-    return this.configurators.get(toolId);
-  }
-
-  static getAll(): SlashCommandConfigurator[] {
-    return Array.from(this.configurators.values());
-  }
-}
diff --git a/src/core/configurators/slash/roocode.ts b/src/core/configurators/slash/roocode.ts
deleted file mode 100644
index faf89b4..0000000
--- a/src/core/configurators/slash/roocode.ts
+++ /dev/null
@@ -1,27 +0,0 @@
-import { SlashCommandConfigurator } from './base.js';
-import { SlashCommandId } from '../../templates/index.js';
-
-const NEW_FILE_PATHS: Record<SlashCommandId, string> = {
-  proposal: '.roo/commands/openspec-proposal.md',
-  apply: '.roo/commands/openspec-apply.md',
-  archive: '.roo/commands/openspec-archive.md'
-};
-
-export class RooCodeSlashCommandConfigurator extends SlashCommandConfigurator {
-  readonly toolId = 'roocode';
-  readonly isAvailable = true;
-
-  protected getRelativePath(id: SlashCommandId): string {
-    return NEW_FILE_PATHS[id];
-  }
-
-  protected getFrontmatter(id: SlashCommandId): string | undefined {
-    const descriptions: Record<SlashCommandId, string> = {
-      proposal: 'Scaffold a new OpenSpec change and validate strictly.',
-      apply: 'Implement an approved OpenSpec change and keep tasks in sync.',
-      archive: 'Archive a deployed OpenSpec change and update specs.'
-    };
-    const description = descriptions[id];
-    return `# OpenSpec: ${id.charAt(0).toUpperCase() + id.slice(1)}\n\n${description}`;
-  }
-}
diff --git a/src/core/configurators/slash/toml-base.ts b/src/core/configurators/slash/toml-base.ts
deleted file mode 100644
index 233e1dd..0000000
--- a/src/core/configurators/slash/toml-base.ts
+++ /dev/null
@@ -1,66 +0,0 @@
-import { FileSystemUtils } from '../../../utils/file-system.js';
-import { SlashCommandConfigurator } from './base.js';
-import { SlashCommandId } from '../../templates/index.js';
-import { OPENSPEC_MARKERS } from '../../config.js';
-
-export abstract class TomlSlashCommandConfigurator extends SlashCommandConfigurator {
-  protected getFrontmatter(_id: SlashCommandId): string | undefined {
-    // TOML doesn't use separate frontmatter - it's all in one structure
-    return undefined;
-  }
-
-  protected abstract getDescription(id: SlashCommandId): string;
-
-  // Override to generate TOML format with markers inside the prompt field
-  async generateAll(projectPath: string, _openspecDir: string): Promise<string[]> {
-    const createdOrUpdated: string[] = [];
-
-    for (const target of this.getTargets()) {
-      const body = this.getBody(target.id);
-      const filePath = FileSystemUtils.joinPath(projectPath, target.path);
-
-      if (await FileSystemUtils.fileExists(filePath)) {
-        await this.updateBody(filePath, body);
-      } else {
-        const tomlContent = this.generateTOML(target.id, body);
-        await FileSystemUtils.writeFile(filePath, tomlContent);
-      }
-
-      createdOrUpdated.push(target.path);
-    }
-
-    return createdOrUpdated;
-  }
-
-  private generateTOML(id: SlashCommandId, body: string): string {
-    const description = this.getDescription(id);
-
-    // TOML format with triple-quoted string for multi-line prompt
-    // Markers are inside the prompt value
-    return `description = "${description}"
-
-prompt = """
-${OPENSPEC_MARKERS.start}
-${body}
-${OPENSPEC_MARKERS.end}
-"""
-`;
-  }
-
-  // Override updateBody to handle TOML format
-  protected async updateBody(filePath: string, body: string): Promise<void> {
-    const content = await FileSystemUtils.readFile(filePath);
-    const startIndex = content.indexOf(OPENSPEC_MARKERS.start);
-    const endIndex = content.indexOf(OPENSPEC_MARKERS.end);
-
-    if (startIndex === -1 || endIndex === -1 || endIndex <= startIndex) {
-      throw new Error(`Missing OpenSpec markers in ${filePath}`);
-    }
-
-    const before = content.slice(0, startIndex + OPENSPEC_MARKERS.start.length);
-    const after = content.slice(endIndex);
-    const updatedContent = `${before}\n${body}\n${after}`;
-
-    await FileSystemUtils.writeFile(filePath, updatedContent);
-  }
-}
diff --git a/src/core/configurators/slash/windsurf.ts b/src/core/configurators/slash/windsurf.ts
deleted file mode 100644
index c0542ec..0000000
--- a/src/core/configurators/slash/windsurf.ts
+++ /dev/null
@@ -1,27 +0,0 @@
-import { SlashCommandConfigurator } from './base.js';
-import { SlashCommandId } from '../../templates/index.js';
-
-const FILE_PATHS: Record<SlashCommandId, string> = {
-  proposal: '.windsurf/workflows/openspec-proposal.md',
-  apply: '.windsurf/workflows/openspec-apply.md',
-  archive: '.windsurf/workflows/openspec-archive.md'
-};
-
-export class WindsurfSlashCommandConfigurator extends SlashCommandConfigurator {
-  readonly toolId = 'windsurf';
-  readonly isAvailable = true;
-
-  protected getRelativePath(id: SlashCommandId): string {
-    return FILE_PATHS[id];
-  }
-
-  protected getFrontmatter(id: SlashCommandId): string | undefined {
-    const descriptions: Record<SlashCommandId, string> = {
-      proposal: 'Scaffold a new OpenSpec change and validate strictly.',
-      apply: 'Implement an approved OpenSpec change and keep tasks in sync.',
-      archive: 'Archive a deployed OpenSpec change and update specs.'
-    };
-    const description = descriptions[id];
-    return `---\ndescription: ${description}\nauto_execution_mode: 3\n---`;
-  }
-}
diff --git a/src/core/init.ts b/src/core/init.ts
index ebc98c9..a1f9f3c 100644
--- a/src/core/init.ts
+++ b/src/core/init.ts
@@ -1,496 +1,271 @@
+/**
+ * Init Command
+ *
+ * Sets up OpenSpec with Agent Skills and /opsx:* slash commands.
+ * This is the unified setup command that replaces both the old init and experimental commands.
+ */
+
 import path from 'path';
-import {
-  createPrompt,
-  isBackspaceKey,
-  isDownKey,
-  isEnterKey,
-  isSpaceKey,
-  isUpKey,
-  useKeypress,
-  usePagination,
-  useState,
-} from '@inquirer/core';
 import chalk from 'chalk';
 import ora from 'ora';
+import * as fs from 'fs';
+import { createRequire } from 'module';
 import { FileSystemUtils } from '../utils/file-system.js';
-import { TemplateManager, ProjectContext } from './templates/index.js';
-import { ToolRegistry } from './configurators/registry.js';
-import { SlashCommandRegistry } from './configurators/slash/registry.js';
 import {
-  OpenSpecConfig,
   AI_TOOLS,
   OPENSPEC_DIR_NAME,
   AIToolOption,
-  OPENSPEC_MARKERS,
 } from './config.js';
 import { PALETTE } from './styles/palette.js';
+import { isInteractive } from '../utils/interactive.js';
+import { serializeConfig } from './config-prompts.js';
+import {
+  generateCommands,
+  CommandAdapterRegistry,
+} from './command-generation/index.js';
+import {
+  detectLegacyArtifacts,
+  cleanupLegacyArtifacts,
+  formatCleanupSummary,
+  formatDetectionSummary,
+  type LegacyDetectionResult,
+} from './legacy-cleanup.js';
+import {
+  SKILL_NAMES,
+  getToolsWithSkillsDir,
+  getToolSkillStatus,
+  getToolStates,
+  getSkillTemplates,
+  getCommandContents,
+  generateSkillContent,
+  type ToolSkillStatus,
+} from './shared/index.js';
+
+const require = createRequire(import.meta.url);
+const { version: OPENSPEC_VERSION } = require('../../package.json');
+
+// -----------------------------------------------------------------------------
+// Constants
+// -----------------------------------------------------------------------------
+
+const DEFAULT_SCHEMA = 'spec-driven';
 
 const PROGRESS_SPINNER = {
   interval: 80,
   frames: ['â–‘â–‘â–‘', 'â–’â–‘â–‘', 'â–’â–’â–‘', 'â–’â–’â–’', 'â–“â–’â–’', 'â–“â–“â–’', 'â–“â–“â–“', 'â–’â–“â–“', 'â–‘â–’â–“'],
 };
 
-const LETTER_MAP: Record<string, string[]> = {
-  O: [' â–ˆâ–ˆâ–ˆâ–ˆ ', 'â–ˆâ–ˆ  â–ˆâ–ˆ', 'â–ˆâ–ˆ  â–ˆâ–ˆ', 'â–ˆâ–ˆ  â–ˆâ–ˆ', ' â–ˆâ–ˆâ–ˆâ–ˆ '],
-  P: ['â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ ', 'â–ˆâ–ˆ  â–ˆâ–ˆ', 'â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ ', 'â–ˆâ–ˆ    ', 'â–ˆâ–ˆ    '],
-  E: ['â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ', 'â–ˆâ–ˆ    ', 'â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ ', 'â–ˆâ–ˆ    ', 'â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ'],
-  N: ['â–ˆâ–ˆ  â–ˆâ–ˆ', 'â–ˆâ–ˆâ–ˆ â–ˆâ–ˆ', 'â–ˆâ–ˆ â–ˆâ–ˆâ–ˆ', 'â–ˆâ–ˆ  â–ˆâ–ˆ', 'â–ˆâ–ˆ  â–ˆâ–ˆ'],
-  S: [' â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ', 'â–ˆâ–ˆ    ', ' â–ˆâ–ˆâ–ˆâ–ˆ ', '    â–ˆâ–ˆ', 'â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ '],
-  C: [' â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ', 'â–ˆâ–ˆ    ', 'â–ˆâ–ˆ    ', 'â–ˆâ–ˆ    ', ' â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ'],
-  ' ': ['  ', '  ', '  ', '  ', '  '],
-};
-
-type ToolLabel = {
-  primary: string;
-  annotation?: string;
-};
-
-const sanitizeToolLabel = (raw: string): string =>
-  raw.replace(/âœ…/gu, 'âœ”').trim();
+// -----------------------------------------------------------------------------
+// Types
+// -----------------------------------------------------------------------------
 
-const parseToolLabel = (raw: string): ToolLabel => {
-  const sanitized = sanitizeToolLabel(raw);
-  const match = sanitized.match(/^(.*?)\s*\((.+)\)$/u);
-  if (!match) {
-    return { primary: sanitized };
-  }
-  return {
-    primary: match[1].trim(),
-    annotation: match[2].trim(),
-  };
+type InitCommandOptions = {
+  tools?: string;
+  force?: boolean;
+  interactive?: boolean;
 };
 
-const isSelectableChoice = (
-  choice: ToolWizardChoice
-): choice is Extract<ToolWizardChoice, { selectable: true }> => choice.selectable;
-
-type ToolWizardChoice =
-  | {
-      kind: 'heading' | 'info';
-      value: string;
-      label: ToolLabel;
-      selectable: false;
-    }
-  | {
-      kind: 'option';
-      value: string;
-      label: ToolLabel;
-      configured: boolean;
-      selectable: true;
-    };
-
-type ToolWizardConfig = {
-  extendMode: boolean;
-  baseMessage: string;
-  choices: ToolWizardChoice[];
-  initialSelected?: string[];
-};
+// -----------------------------------------------------------------------------
+// Init Command Class
+// -----------------------------------------------------------------------------
 
-type WizardStep = 'intro' | 'select' | 'review';
+export class InitCommand {
+  private readonly toolsArg?: string;
+  private readonly force: boolean;
+  private readonly interactiveOption?: boolean;
 
-type ToolSelectionPrompt = (config: ToolWizardConfig) => Promise<string[]>;
+  constructor(options: InitCommandOptions = {}) {
+    this.toolsArg = options.tools;
+    this.force = options.force ?? false;
+    this.interactiveOption = options.interactive;
+  }
 
-type RootStubStatus = 'created' | 'updated' | 'skipped';
+  async execute(targetPath: string): Promise<void> {
+    const projectPath = path.resolve(targetPath);
+    const openspecDir = OPENSPEC_DIR_NAME;
+    const openspecPath = path.join(projectPath, openspecDir);
 
-const ROOT_STUB_CHOICE_VALUE = '__root_stub__';
+    // Validation happens silently in the background
+    const extendMode = await this.validate(projectPath, openspecPath);
 
-const OTHER_TOOLS_HEADING_VALUE = '__heading-other__';
-const LIST_SPACER_VALUE = '__list-spacer__';
+    // Check for legacy artifacts and handle cleanup
+    await this.handleLegacyCleanup(projectPath, extendMode);
 
-const toolSelectionWizard = createPrompt<string[], ToolWizardConfig>(
-  (config, done) => {
-    const totalSteps = 3;
-    const [step, setStep] = useState<WizardStep>('intro');
-    const selectableChoices = config.choices.filter(isSelectableChoice);
-    const initialCursorIndex = config.choices.findIndex((choice) =>
-      choice.selectable
-    );
-    const [cursor, setCursor] = useState<number>(
-      initialCursorIndex === -1 ? 0 : initialCursorIndex
-    );
-    const [selected, setSelected] = useState<string[]>(() => {
-      const initial = new Set(
-        (config.initialSelected ?? []).filter((value) =>
-          selectableChoices.some((choice) => choice.value === value)
-        )
-      );
-      return selectableChoices
-        .map((choice) => choice.value)
-        .filter((value) => initial.has(value));
-    });
-    const [error, setError] = useState<string | null>(null);
-
-    const selectedSet = new Set(selected);
-    const pageSize = Math.max(config.choices.length, 1);
-
-    const updateSelected = (next: Set<string>) => {
-      const ordered = selectableChoices
-        .map((choice) => choice.value)
-        .filter((value) => next.has(value));
-      setSelected(ordered);
-    };
-
-    const page = usePagination({
-      items: config.choices,
-      active: cursor,
-      pageSize,
-      loop: false,
-      renderItem: ({ item, isActive }) => {
-        if (!item.selectable) {
-          const prefix = item.kind === 'info' ? '  ' : '';
-          const textColor =
-            item.kind === 'heading' ? PALETTE.lightGray : PALETTE.midGray;
-          return `${PALETTE.midGray(' ')} ${PALETTE.midGray(' ')} ${textColor(
-            `${prefix}${item.label.primary}`
-          )}`;
-        }
+    // Show animated welcome screen (interactive mode only)
+    const canPrompt = this.canPromptInteractively();
+    if (canPrompt) {
+      const { showWelcomeScreen } = await import('../ui/welcome-screen.js');
+      await showWelcomeScreen();
+    }
 
-        const isSelected = selectedSet.has(item.value);
-        const cursorSymbol = isActive
-          ? PALETTE.white('â€º')
-          : PALETTE.midGray(' ');
-        const indicator = isSelected
-          ? PALETTE.white('â—‰')
-          : PALETTE.midGray('â—‹');
-        const nameColor = isActive ? PALETTE.white : PALETTE.midGray;
-        const annotation = item.label.annotation
-          ? PALETTE.midGray(` (${item.label.annotation})`)
-          : '';
-        const configuredNote = item.configured
-          ? PALETTE.midGray(' (already configured)')
-          : '';
-        const label = `${nameColor(item.label.primary)}${annotation}${configuredNote}`;
-        return `${cursorSymbol} ${indicator} ${label}`;
-      },
-    });
+    // Get tool states before processing
+    const toolStates = getToolStates(projectPath);
 
-    const moveCursor = (direction: 1 | -1) => {
-      if (selectableChoices.length === 0) {
-        return;
-      }
+    // Get tool selection
+    const selectedToolIds = await this.getSelectedTools(toolStates, extendMode);
 
-      let nextIndex = cursor;
-      while (true) {
-        nextIndex = nextIndex + direction;
-        if (nextIndex < 0 || nextIndex >= config.choices.length) {
-          return;
-        }
+    // Validate selected tools
+    const validatedTools = this.validateTools(selectedToolIds, toolStates);
 
-        if (config.choices[nextIndex]?.selectable) {
-          setCursor(nextIndex);
-          return;
-        }
-      }
-    };
+    // Create directory structure and config
+    await this.createDirectoryStructure(openspecPath, extendMode);
 
-    useKeypress((key) => {
-      if (step === 'intro') {
-        if (isEnterKey(key)) {
-          setStep('select');
-        }
-        return;
-      }
+    // Generate skills and commands for each tool
+    const results = await this.generateSkillsAndCommands(projectPath, validatedTools);
 
-      if (step === 'select') {
-        if (isUpKey(key)) {
-          moveCursor(-1);
-          setError(null);
-          return;
-        }
+    // Create config.yaml if needed
+    const configStatus = await this.createConfig(openspecPath, extendMode);
 
-        if (isDownKey(key)) {
-          moveCursor(1);
-          setError(null);
-          return;
-        }
-
-        if (isSpaceKey(key)) {
-          const current = config.choices[cursor];
-          if (!current || !current.selectable) return;
+    // Display success message
+    this.displaySuccessMessage(projectPath, validatedTools, results, configStatus);
+  }
 
-          const next = new Set(selected);
-          if (next.has(current.value)) {
-            next.delete(current.value);
-          } else {
-            next.add(current.value);
-          }
+  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+  // VALIDATION & SETUP
+  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 
-          updateSelected(next);
-          setError(null);
-          return;
-        }
+  private async validate(
+    projectPath: string,
+    openspecPath: string
+  ): Promise<boolean> {
+    const extendMode = await FileSystemUtils.directoryExists(openspecPath);
 
-        if (isEnterKey(key)) {
-          const current = config.choices[cursor];
-          if (
-            current &&
-            current.selectable &&
-            !selectedSet.has(current.value)
-          ) {
-            const next = new Set(selected);
-            next.add(current.value);
-            updateSelected(next);
-          }
-          setStep('review');
-          setError(null);
-          return;
-        }
+    // Check write permissions
+    if (!(await FileSystemUtils.ensureWritePermissions(projectPath))) {
+      throw new Error(`Insufficient permissions to write to ${projectPath}`);
+    }
+    return extendMode;
+  }
 
-        if (key.name === 'escape') {
-          const next = new Set<string>();
-          updateSelected(next);
-          setError(null);
-        }
-        return;
-      }
+  private canPromptInteractively(): boolean {
+    if (this.interactiveOption === false) return false;
+    if (this.toolsArg !== undefined) return false;
+    return isInteractive({ interactive: this.interactiveOption });
+  }
 
-      if (step === 'review') {
-        if (isEnterKey(key)) {
-          const finalSelection = config.choices
-            .map((choice) => choice.value)
-            .filter(
-              (value) =>
-                selectedSet.has(value) && value !== ROOT_STUB_CHOICE_VALUE
-            );
-          done(finalSelection);
-          return;
-        }
+  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+  // LEGACY CLEANUP
+  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 
-        if (isBackspaceKey(key) || key.name === 'escape') {
-          setStep('select');
-          setError(null);
-        }
-      }
-    });
+  private async handleLegacyCleanup(projectPath: string, extendMode: boolean): Promise<void> {
+    // Detect legacy artifacts
+    const detection = await detectLegacyArtifacts(projectPath);
 
-    const rootStubChoice = selectableChoices.find(
-      (choice) => choice.value === ROOT_STUB_CHOICE_VALUE
-    );
-    const rootStubSelected = rootStubChoice
-      ? selectedSet.has(ROOT_STUB_CHOICE_VALUE)
-      : false;
-    const nativeChoices = selectableChoices.filter(
-      (choice) => choice.value !== ROOT_STUB_CHOICE_VALUE
-    );
-    const selectedNativeChoices = nativeChoices.filter((choice) =>
-      selectedSet.has(choice.value)
-    );
+    if (!detection.hasLegacyArtifacts) {
+      return; // No legacy artifacts found
+    }
 
-    const formatSummaryLabel = (
-      choice: Extract<ToolWizardChoice, { selectable: true }>
-    ) => {
-      const annotation = choice.label.annotation
-        ? PALETTE.midGray(` (${choice.label.annotation})`)
-        : '';
-      const configuredNote = choice.configured
-        ? PALETTE.midGray(' (already configured)')
-        : '';
-      return `${PALETTE.white(choice.label.primary)}${annotation}${configuredNote}`;
-    };
-
-    const stepIndex = step === 'intro' ? 1 : step === 'select' ? 2 : 3;
-    const lines: string[] = [];
-    lines.push(PALETTE.midGray(`Step ${stepIndex}/${totalSteps}`));
-    lines.push('');
-
-    if (step === 'intro') {
-      const introHeadline = config.extendMode
-        ? 'Extend your OpenSpec tooling'
-        : 'Configure your OpenSpec tooling';
-      const introBody = config.extendMode
-        ? 'We detected an existing setup. We will help you refresh or add integrations.'
-        : "Let's get your AI assistants connected so they understand OpenSpec.";
-
-      lines.push(PALETTE.white(introHeadline));
-      lines.push(PALETTE.midGray(introBody));
-      lines.push('');
-      lines.push(PALETTE.midGray('Press Enter to continue.'));
-    } else if (step === 'select') {
-      lines.push(PALETTE.white(config.baseMessage));
-      lines.push(
-        PALETTE.midGray(
-          'Use â†‘/â†“ to move Â· Space to toggle Â· Enter selects highlighted tool and reviews.'
-        )
-      );
-      lines.push('');
-      lines.push(page);
-      lines.push('');
-      lines.push(PALETTE.midGray('Selected configuration:'));
-      if (rootStubSelected && rootStubChoice) {
-        lines.push(
-          `  ${PALETTE.white('-')} ${formatSummaryLabel(rootStubChoice)}`
-        );
-      }
-      if (selectedNativeChoices.length === 0) {
-        lines.push(
-          `  ${PALETTE.midGray('- No natively supported providers selected')}`
-        );
-      } else {
-        selectedNativeChoices.forEach((choice) => {
-          lines.push(
-            `  ${PALETTE.white('-')} ${formatSummaryLabel(choice)}`
-          );
-        });
-      }
-    } else {
-      lines.push(PALETTE.white('Review selections'));
-      lines.push(
-        PALETTE.midGray('Press Enter to confirm or Backspace to adjust.')
-      );
-      lines.push('');
+    // Show what was detected
+    console.log();
+    console.log(formatDetectionSummary(detection));
+    console.log();
 
-      if (rootStubSelected && rootStubChoice) {
-        lines.push(
-          `${PALETTE.white('â–Œ')} ${formatSummaryLabel(rootStubChoice)}`
-        );
-      }
+    const canPrompt = this.canPromptInteractively();
 
-      if (selectedNativeChoices.length === 0) {
-        lines.push(
-          PALETTE.midGray(
-            'No natively supported providers selected. Universal instructions will still be applied.'
-          )
-        );
-      } else {
-        selectedNativeChoices.forEach((choice) => {
-          lines.push(
-            `${PALETTE.white('â–Œ')} ${formatSummaryLabel(choice)}`
-          );
-        });
-      }
+    if (this.force) {
+      // --force flag: proceed with cleanup automatically
+      await this.performLegacyCleanup(projectPath, detection);
+      return;
     }
 
-    if (error) {
-      return [lines.join('\n'), chalk.red(error)];
+    if (!canPrompt) {
+      // Non-interactive mode without --force: abort
+      console.log(chalk.red('Legacy files detected in non-interactive mode.'));
+      console.log(chalk.dim('Run interactively to upgrade, or use --force to auto-cleanup.'));
+      process.exit(1);
     }
 
-    return lines.join('\n');
-  }
-);
-
-type InitCommandOptions = {
-  prompt?: ToolSelectionPrompt;
-  tools?: string;
-};
+    // Interactive mode: prompt for confirmation
+    const { confirm } = await import('@inquirer/prompts');
+    const shouldCleanup = await confirm({
+      message: 'Upgrade and clean up legacy files?',
+      default: true,
+    });
 
-export class InitCommand {
-  private readonly prompt: ToolSelectionPrompt;
-  private readonly toolsArg?: string;
+    if (!shouldCleanup) {
+      console.log(chalk.dim('Initialization cancelled.'));
+      console.log(chalk.dim('Run with --force to skip this prompt, or manually remove legacy files.'));
+      process.exit(0);
+    }
 
-  constructor(options: InitCommandOptions = {}) {
-    this.prompt = options.prompt ?? ((config) => toolSelectionWizard(config));
-    this.toolsArg = options.tools;
+    await this.performLegacyCleanup(projectPath, detection);
   }
 
-  async execute(targetPath: string): Promise<void> {
-    const projectPath = path.resolve(targetPath);
-    const openspecDir = OPENSPEC_DIR_NAME;
-    const openspecPath = path.join(projectPath, openspecDir);
+  private async performLegacyCleanup(projectPath: string, detection: LegacyDetectionResult): Promise<void> {
+    const spinner = ora('Cleaning up legacy files...').start();
 
-    // Validation happens silently in the background
-    const extendMode = await this.validate(projectPath, openspecPath);
-    const existingToolStates = await this.getExistingToolStates(projectPath, extendMode);
+    const result = await cleanupLegacyArtifacts(projectPath, detection);
 
-    this.renderBanner(extendMode);
+    spinner.succeed('Legacy files cleaned up');
 
-    // Get configuration (after validation to avoid prompts if validation fails)
-    const config = await this.getConfiguration(existingToolStates, extendMode);
-
-    const availableTools = AI_TOOLS.filter((tool) => tool.available);
-    const selectedIds = new Set(config.aiTools);
-    const selectedTools = availableTools.filter((tool) =>
-      selectedIds.has(tool.value)
-    );
-    const created = selectedTools.filter(
-      (tool) => !existingToolStates[tool.value]
-    );
-    const refreshed = selectedTools.filter(
-      (tool) => existingToolStates[tool.value]
-    );
-    const skippedExisting = availableTools.filter(
-      (tool) => !selectedIds.has(tool.value) && existingToolStates[tool.value]
-    );
-    const skipped = availableTools.filter(
-      (tool) => !selectedIds.has(tool.value) && !existingToolStates[tool.value]
-    );
-
-    // Step 1: Create directory structure
-    if (!extendMode) {
-      const structureSpinner = this.startSpinner(
-        'Creating OpenSpec structure...'
-      );
-      await this.createDirectoryStructure(openspecPath);
-      await this.generateFiles(openspecPath, config);
-      structureSpinner.stopAndPersist({
-        symbol: PALETTE.white('â–Œ'),
-        text: PALETTE.white('OpenSpec structure created'),
-      });
-    } else {
-      ora({ stream: process.stdout }).info(
-        PALETTE.midGray(
-          'â„¹ OpenSpec already initialized. Checking for missing files...'
-        )
-      );
-      await this.createDirectoryStructure(openspecPath);
-      await this.ensureTemplateFiles(openspecPath, config);
+    const summary = formatCleanupSummary(result);
+    if (summary) {
+      console.log();
+      console.log(summary);
     }
 
-    // Step 2: Configure AI tools
-    const toolSpinner = this.startSpinner('Configuring AI tools...');
-    const rootStubStatus = await this.configureAITools(
-      projectPath,
-      openspecDir,
-      config.aiTools
-    );
-    toolSpinner.stopAndPersist({
-      symbol: PALETTE.white('â–Œ'),
-      text: PALETTE.white('AI tools configured'),
-    });
-
-    // Success message
-    this.displaySuccessMessage(
-      selectedTools,
-      created,
-      refreshed,
-      skippedExisting,
-      skipped,
-      extendMode,
-      rootStubStatus
-    );
-  }
-
-  private async validate(
-    projectPath: string,
-    _openspecPath: string
-  ): Promise<boolean> {
-    const extendMode = await FileSystemUtils.directoryExists(_openspecPath);
-
-    // Check write permissions
-    if (!(await FileSystemUtils.ensureWritePermissions(projectPath))) {
-      throw new Error(`Insufficient permissions to write to ${projectPath}`);
-    }
-    return extendMode;
+    console.log();
   }
 
-  private async getConfiguration(
-    existingTools: Record<string, boolean>,
-    extendMode: boolean
-  ): Promise<OpenSpecConfig> {
-    const selectedTools = await this.getSelectedTools(existingTools, extendMode);
-    return { aiTools: selectedTools };
-  }
+  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+  // TOOL SELECTION
+  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 
   private async getSelectedTools(
-    existingTools: Record<string, boolean>,
+    toolStates: Map<string, ToolSkillStatus>,
     extendMode: boolean
   ): Promise<string[]> {
+    // Check for --tools flag first
     const nonInteractiveSelection = this.resolveToolsArg();
     if (nonInteractiveSelection !== null) {
       return nonInteractiveSelection;
     }
 
-    // Fall back to interactive mode
-    return this.promptForAITools(existingTools, extendMode);
+    const validTools = getToolsWithSkillsDir();
+    const canPrompt = this.canPromptInteractively();
+
+    if (!canPrompt || validTools.length === 0) {
+      throw new Error(
+        `Missing required option --tools. Valid tools:\n  ${validTools.join('\n  ')}\n\nUse --tools all, --tools none, or --tools claude,cursor,...`
+      );
+    }
+
+    // Interactive mode: show searchable multi-select
+    const { searchableMultiSelect } = await import('../prompts/searchable-multi-select.js');
+
+    // Build choices with configured status and sort configured tools first
+    const sortedChoices = validTools
+      .map((toolId) => {
+        const tool = AI_TOOLS.find((t) => t.value === toolId);
+        const status = toolStates.get(toolId);
+        const configured = status?.configured ?? false;
+
+        return {
+          name: tool?.name || toolId,
+          value: toolId,
+          configured,
+          preSelected: configured, // Pre-select configured tools for easy refresh
+        };
+      })
+      .sort((a, b) => {
+        // Configured tools first
+        if (a.configured && !b.configured) return -1;
+        if (!a.configured && b.configured) return 1;
+        return 0;
+      });
+
+    const selectedTools = await searchableMultiSelect({
+      message: `Select tools to set up (${validTools.length} available)`,
+      pageSize: 15,
+      choices: sortedChoices,
+      validate: (selected: string[]) => selected.length > 0 || 'Select at least one tool',
+    });
+
+    if (selectedTools.length === 0) {
+      throw new Error('At least one tool must be selected');
+    }
+
+    return selectedTools;
   }
 
   private resolveToolsArg(): string[] | null {
@@ -505,14 +280,13 @@ export class InitCommand {
       );
     }
 
-    const availableTools = AI_TOOLS.filter((tool) => tool.available);
-    const availableValues = availableTools.map((tool) => tool.value);
-    const availableSet = new Set(availableValues);
-    const availableList = ['all', 'none', ...availableValues].join(', ');
+    const availableTools = getToolsWithSkillsDir();
+    const availableSet = new Set(availableTools);
+    const availableList = ['all', 'none', ...availableTools].join(', ');
 
     const lowerRaw = raw.toLowerCase();
     if (lowerRaw === 'all') {
-      return availableValues;
+      return availableTools;
     }
 
     if (lowerRaw === 'none') {
@@ -546,6 +320,7 @@ export class InitCommand {
       );
     }
 
+    // Deduplicate while preserving order
     const deduped: string[] = [];
     for (const token of normalizedTokens) {
       if (!deduped.includes(token)) {
@@ -556,156 +331,62 @@ export class InitCommand {
     return deduped;
   }
 
-  private async promptForAITools(
-    existingTools: Record<string, boolean>,
-    extendMode: boolean
-  ): Promise<string[]> {
-    const availableTools = AI_TOOLS.filter((tool) => tool.available);
-
-    const baseMessage = extendMode
-      ? 'Which natively supported AI tools would you like to add or refresh?'
-      : 'Which natively supported AI tools do you use?';
-    const initialNativeSelection = extendMode
-      ? availableTools
-          .filter((tool) => existingTools[tool.value])
-          .map((tool) => tool.value)
-      : [];
-
-    const initialSelected = Array.from(new Set(initialNativeSelection));
-
-    const choices: ToolWizardChoice[] = [
-      {
-        kind: 'heading',
-        value: '__heading-native__',
-        label: {
-          primary:
-            'Natively supported providers (âœ” OpenSpec custom slash commands available)',
-        },
-        selectable: false,
-      },
-      ...availableTools.map<ToolWizardChoice>((tool) => ({
-        kind: 'option',
-        value: tool.value,
-        label: parseToolLabel(tool.name),
-        configured: Boolean(existingTools[tool.value]),
-        selectable: true,
-      })),
-      ...(availableTools.length
-        ? ([
-            {
-              kind: 'info' as const,
-              value: LIST_SPACER_VALUE,
-              label: { primary: '' },
-              selectable: false,
-            },
-          ] as ToolWizardChoice[])
-        : []),
-      {
-        kind: 'heading',
-        value: OTHER_TOOLS_HEADING_VALUE,
-        label: {
-          primary:
-            'Other tools (use Universal AGENTS.md for Amp, VS Code, GitHub Copilot, â€¦)',
-        },
-        selectable: false,
-      },
-      {
-        kind: 'option',
-        value: ROOT_STUB_CHOICE_VALUE,
-        label: {
-          primary: 'Universal AGENTS.md',
-          annotation: 'always available',
-        },
-        configured: extendMode,
-        selectable: true,
-      },
-    ];
+  private validateTools(
+    toolIds: string[],
+    toolStates: Map<string, ToolSkillStatus>
+  ): Array<{ value: string; name: string; skillsDir: string; wasConfigured: boolean }> {
+    const validatedTools: Array<{ value: string; name: string; skillsDir: string; wasConfigured: boolean }> = [];
 
-    return this.prompt({
-      extendMode,
-      baseMessage,
-      choices,
-      initialSelected,
-    });
-  }
+    for (const toolId of toolIds) {
+      const tool = AI_TOOLS.find((t) => t.value === toolId);
+      if (!tool) {
+        const validToolIds = getToolsWithSkillsDir();
+        throw new Error(
+          `Unknown tool '${toolId}'. Valid tools:\n  ${validToolIds.join('\n  ')}`
+        );
+      }
 
-  private async getExistingToolStates(
-    projectPath: string,
-    extendMode: boolean
-  ): Promise<Record<string, boolean>> {
-    // Fresh initialization - no tools configured yet
-    if (!extendMode) {
-      return Object.fromEntries(AI_TOOLS.map(t => [t.value, false]));
+      if (!tool.skillsDir) {
+        const validToolsWithSkills = getToolsWithSkillsDir();
+        throw new Error(
+          `Tool '${toolId}' does not support skill generation.\nTools with skill generation support:\n  ${validToolsWithSkills.join('\n  ')}`
+        );
+      }
+
+      const preState = toolStates.get(tool.value);
+      validatedTools.push({
+        value: tool.value,
+        name: tool.name,
+        skillsDir: tool.skillsDir,
+        wasConfigured: preState?.configured ?? false,
+      });
     }
 
-    // Extend mode - check all tools in parallel for better performance
-    const entries = await Promise.all(
-      AI_TOOLS.map(async (t) => [t.value, await this.isToolConfigured(projectPath, t.value)] as const)
-    );
-    return Object.fromEntries(entries);
+    return validatedTools;
   }
 
-  private async isToolConfigured(
-    projectPath: string,
-    toolId: string
-  ): Promise<boolean> {
-    // A tool is only considered "configured by OpenSpec" if its files contain OpenSpec markers.
-    // For tools with both config files and slash commands, BOTH must have markers.
-    // For slash commands, at least one file with markers is sufficient (not all required).
-
-    // Helper to check if a file exists and contains OpenSpec markers
-    const fileHasMarkers = async (absolutePath: string): Promise<boolean> => {
-      try {
-        const content = await FileSystemUtils.readFile(absolutePath);
-        return content.includes(OPENSPEC_MARKERS.start) && content.includes(OPENSPEC_MARKERS.end);
-      } catch {
-        return false;
-      }
-    };
-
-    let hasConfigFile = false;
-    let hasSlashCommands = false;
-
-    // Check if the tool has a config file with OpenSpec markers
-    const configFile = ToolRegistry.get(toolId)?.configFileName;
-    if (configFile) {
-      const configPath = path.join(projectPath, configFile);
-      hasConfigFile = (await FileSystemUtils.fileExists(configPath)) && (await fileHasMarkers(configPath));
-    }
-
-    // Check if any slash command file exists with OpenSpec markers
-    const slashConfigurator = SlashCommandRegistry.get(toolId);
-    if (slashConfigurator) {
-      for (const target of slashConfigurator.getTargets()) {
-        const absolute = slashConfigurator.resolveAbsolutePath(projectPath, target.id);
-        if ((await FileSystemUtils.fileExists(absolute)) && (await fileHasMarkers(absolute))) {
-          hasSlashCommands = true;
-          break; // At least one file with markers is sufficient
-        }
+  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+  // DIRECTORY STRUCTURE
+  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+
+  private async createDirectoryStructure(openspecPath: string, extendMode: boolean): Promise<void> {
+    if (extendMode) {
+      // In extend mode, just ensure directories exist without spinner
+      const directories = [
+        openspecPath,
+        path.join(openspecPath, 'specs'),
+        path.join(openspecPath, 'changes'),
+        path.join(openspecPath, 'changes', 'archive'),
+      ];
+
+      for (const dir of directories) {
+        await FileSystemUtils.createDirectory(dir);
       }
+      return;
     }
 
-    // Tool is only configured if BOTH exist with markers
-    // OR if the tool has no config file requirement (slash commands only)
-    // OR if the tool has no slash commands requirement (config file only)
-    const hasConfigFileRequirement = configFile !== undefined;
-    const hasSlashCommandRequirement = slashConfigurator !== undefined;
-
-    if (hasConfigFileRequirement && hasSlashCommandRequirement) {
-      // Both are required - both must be present with markers
-      return hasConfigFile && hasSlashCommands;
-    } else if (hasConfigFileRequirement) {
-      // Only config file required
-      return hasConfigFile;
-    } else if (hasSlashCommandRequirement) {
-      // Only slash commands required
-      return hasSlashCommands;
-    }
-
-    return false;
-  }
+    const spinner = this.startSpinner('Creating OpenSpec structure...');
 
-  private async createDirectoryStructure(openspecPath: string): Promise<void> {
     const directories = [
       openspecPath,
       path.join(openspecPath, 'specs'),
@@ -716,262 +397,192 @@ export class InitCommand {
     for (const dir of directories) {
       await FileSystemUtils.createDirectory(dir);
     }
-  }
 
-  private async generateFiles(
-    openspecPath: string,
-    config: OpenSpecConfig
-  ): Promise<void> {
-    await this.writeTemplateFiles(openspecPath, config, false);
+    spinner.stopAndPersist({
+      symbol: PALETTE.white('â–Œ'),
+      text: PALETTE.white('OpenSpec structure created'),
+    });
   }
 
-  private async ensureTemplateFiles(
-    openspecPath: string,
-    config: OpenSpecConfig
-  ): Promise<void> {
-    await this.writeTemplateFiles(openspecPath, config, true);
-  }
+  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+  // SKILL & COMMAND GENERATION
+  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 
-  private async writeTemplateFiles(
-    openspecPath: string,
-    config: OpenSpecConfig,
-    skipExisting: boolean
-  ): Promise<void> {
-    const context: ProjectContext = {
-      // Could be enhanced with prompts for project details
-    };
+  private async generateSkillsAndCommands(
+    projectPath: string,
+    tools: Array<{ value: string; name: string; skillsDir: string; wasConfigured: boolean }>
+  ): Promise<{
+    createdTools: typeof tools;
+    refreshedTools: typeof tools;
+    failedTools: Array<{ name: string; error: Error }>;
+    commandsSkipped: string[];
+  }> {
+    const createdTools: typeof tools = [];
+    const refreshedTools: typeof tools = [];
+    const failedTools: Array<{ name: string; error: Error }> = [];
+    const commandsSkipped: string[] = [];
+
+    // Get skill and command templates once (shared across all tools)
+    const skillTemplates = getSkillTemplates();
+    const commandContents = getCommandContents();
+
+    // Process each tool
+    for (const tool of tools) {
+      const spinner = ora(`Setting up ${tool.name}...`).start();
 
-    const templates = TemplateManager.getTemplates(context);
+      try {
+        // Use tool-specific skillsDir
+        const skillsDir = path.join(projectPath, tool.skillsDir, 'skills');
 
-    for (const template of templates) {
-      const filePath = path.join(openspecPath, template.path);
+        // Create skill directories and SKILL.md files
+        for (const { template, dirName } of skillTemplates) {
+          const skillDir = path.join(skillsDir, dirName);
+          const skillFile = path.join(skillDir, 'SKILL.md');
 
-      // Skip if file exists and we're in skipExisting mode
-      if (skipExisting && (await FileSystemUtils.fileExists(filePath))) {
-        continue;
-      }
+          // Generate SKILL.md content with YAML frontmatter including generatedBy
+          const skillContent = generateSkillContent(template, OPENSPEC_VERSION);
 
-      const content =
-        typeof template.content === 'function'
-          ? template.content(context)
-          : template.content;
+          // Write the skill file
+          await FileSystemUtils.writeFile(skillFile, skillContent);
+        }
 
-      await FileSystemUtils.writeFile(filePath, content);
-    }
-  }
+        // Generate commands using the adapter system
+        const adapter = CommandAdapterRegistry.get(tool.value);
+        if (adapter) {
+          const generatedCommands = generateCommands(commandContents, adapter);
 
-  private async configureAITools(
-    projectPath: string,
-    openspecDir: string,
-    toolIds: string[]
-  ): Promise<RootStubStatus> {
-    const rootStubStatus = await this.configureRootAgentsStub(
-      projectPath,
-      openspecDir
-    );
+          for (const cmd of generatedCommands) {
+            const commandFile = path.join(projectPath, cmd.path);
+            await FileSystemUtils.writeFile(commandFile, cmd.fileContent);
+          }
+        } else {
+          commandsSkipped.push(tool.value);
+        }
 
-    for (const toolId of toolIds) {
-      const configurator = ToolRegistry.get(toolId);
-      if (configurator && configurator.isAvailable) {
-        await configurator.configure(projectPath, openspecDir);
-      }
+        spinner.succeed(`Setup complete for ${tool.name}`);
 
-      const slashConfigurator = SlashCommandRegistry.get(toolId);
-      if (slashConfigurator && slashConfigurator.isAvailable) {
-        await slashConfigurator.generateAll(projectPath, openspecDir);
+        if (tool.wasConfigured) {
+          refreshedTools.push(tool);
+        } else {
+          createdTools.push(tool);
+        }
+      } catch (error) {
+        spinner.fail(`Failed for ${tool.name}`);
+        failedTools.push({ name: tool.name, error: error as Error });
       }
     }
 
-    return rootStubStatus;
+    return { createdTools, refreshedTools, failedTools, commandsSkipped };
   }
 
-  private async configureRootAgentsStub(
-    projectPath: string,
-    openspecDir: string
-  ): Promise<RootStubStatus> {
-    const configurator = ToolRegistry.get('agents');
-    if (!configurator || !configurator.isAvailable) {
-      return 'skipped';
-    }
+  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+  // CONFIG FILE
+  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 
-    const stubPath = path.join(projectPath, configurator.configFileName);
-    const existed = await FileSystemUtils.fileExists(stubPath);
+  private async createConfig(openspecPath: string, extendMode: boolean): Promise<'created' | 'exists' | 'skipped'> {
+    const configPath = path.join(openspecPath, 'config.yaml');
+    const configYmlPath = path.join(openspecPath, 'config.yml');
+    const configYamlExists = fs.existsSync(configPath);
+    const configYmlExists = fs.existsSync(configYmlPath);
 
-    await configurator.configure(projectPath, openspecDir);
+    if (configYamlExists || configYmlExists) {
+      return 'exists';
+    }
 
-    return existed ? 'updated' : 'created';
+    // In non-interactive mode without --force, skip config creation
+    if (!this.canPromptInteractively() && !this.force) {
+      return 'skipped';
+    }
+
+    try {
+      const yamlContent = serializeConfig({ schema: DEFAULT_SCHEMA });
+      await FileSystemUtils.writeFile(configPath, yamlContent);
+      return 'created';
+    } catch {
+      return 'skipped';
+    }
   }
 
+  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+  // UI & OUTPUT
+  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+
   private displaySuccessMessage(
-    selectedTools: AIToolOption[],
-    created: AIToolOption[],
-    refreshed: AIToolOption[],
-    skippedExisting: AIToolOption[],
-    skipped: AIToolOption[],
-    extendMode: boolean,
-    rootStubStatus: RootStubStatus
+    projectPath: string,
+    tools: Array<{ value: string; name: string; skillsDir: string; wasConfigured: boolean }>,
+    results: {
+      createdTools: typeof tools;
+      refreshedTools: typeof tools;
+      failedTools: Array<{ name: string; error: Error }>;
+      commandsSkipped: string[];
+    },
+    configStatus: 'created' | 'exists' | 'skipped'
   ): void {
-    console.log(); // Empty line for spacing
-    const successHeadline = extendMode
-      ? 'OpenSpec tool configuration updated!'
-      : 'OpenSpec initialized successfully!';
-    ora().succeed(PALETTE.white(successHeadline));
-
     console.log();
-    console.log(PALETTE.lightGray('Tool summary:'));
-    const summaryLines = [
-      rootStubStatus === 'created'
-        ? `${PALETTE.white('â–Œ')} ${PALETTE.white(
-            'Root AGENTS.md stub created for other assistants'
-          )}`
-        : null,
-      rootStubStatus === 'updated'
-        ? `${PALETTE.lightGray('â–Œ')} ${PALETTE.lightGray(
-            'Root AGENTS.md stub refreshed for other assistants'
-          )}`
-        : null,
-      created.length
-        ? `${PALETTE.white('â–Œ')} ${PALETTE.white(
-            'Created:'
-          )} ${this.formatToolNames(created)}`
-        : null,
-      refreshed.length
-        ? `${PALETTE.lightGray('â–Œ')} ${PALETTE.lightGray(
-            'Refreshed:'
-          )} ${this.formatToolNames(refreshed)}`
-        : null,
-      skippedExisting.length
-        ? `${PALETTE.midGray('â–Œ')} ${PALETTE.midGray(
-            'Skipped (already configured):'
-          )} ${this.formatToolNames(skippedExisting)}`
-        : null,
-      skipped.length
-        ? `${PALETTE.darkGray('â–Œ')} ${PALETTE.darkGray(
-            'Skipped:'
-          )} ${this.formatToolNames(skipped)}`
-        : null,
-    ].filter((line): line is string => Boolean(line));
-    for (const line of summaryLines) {
-      console.log(line);
-    }
-
+    console.log(chalk.bold('OpenSpec Setup Complete'));
     console.log();
-    console.log(
-      PALETTE.midGray(
-        'Use `openspec update` to refresh shared OpenSpec instructions in the future.'
-      )
-    );
 
-    // Show restart instruction if any tools were configured
-    if (created.length > 0 || refreshed.length > 0) {
-      console.log();
-      console.log(PALETTE.white('Important: Restart your IDE'));
-      console.log(
-        PALETTE.midGray(
-          'Slash commands are loaded at startup. Please restart your coding assistant'
-        )
-      );
-      console.log(
-        PALETTE.midGray(
-          'to ensure the new /openspec commands appear in your command palette.'
-        )
-      );
+    // Show created vs refreshed tools
+    if (results.createdTools.length > 0) {
+      console.log(`Created: ${results.createdTools.map((t) => t.name).join(', ')}`);
+    }
+    if (results.refreshedTools.length > 0) {
+      console.log(`Refreshed: ${results.refreshedTools.map((t) => t.name).join(', ')}`);
     }
 
-    // Get the selected tool name(s) for display
-    const toolName = this.formatToolNames(selectedTools);
-
-    console.log();
-    console.log(`Next steps - Copy these prompts to ${toolName}:`);
-    console.log(
-      chalk.gray('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€')
-    );
-    console.log(PALETTE.white('1. Populate your project context:'));
-    console.log(
-      PALETTE.lightGray(
-        '   "Please read openspec/project.md and help me fill it out'
-      )
-    );
-    console.log(
-      PALETTE.lightGray(
-        '    with details about my project, tech stack, and conventions"\n'
-      )
-    );
-    console.log(PALETTE.white('2. Create your first change proposal:'));
-    console.log(
-      PALETTE.lightGray(
-        '   "I want to add [YOUR FEATURE HERE]. Please create an'
-      )
-    );
-    console.log(
-      PALETTE.lightGray('    OpenSpec change proposal for this feature"\n')
-    );
-    console.log(PALETTE.white('3. Learn the OpenSpec workflow:'));
-    console.log(
-      PALETTE.lightGray(
-        '   "Please explain the OpenSpec workflow from openspec/AGENTS.md'
-      )
-    );
-    console.log(
-      PALETTE.lightGray('    and how I should work with you on this project"')
-    );
-    console.log(
-      PALETTE.darkGray(
-        'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n'
-      )
-    );
+    // Show counts
+    const successfulTools = [...results.createdTools, ...results.refreshedTools];
+    if (successfulTools.length > 0) {
+      const toolDirs = [...new Set(successfulTools.map((t) => t.skillsDir))].join(', ');
+      const hasCommands = results.commandsSkipped.length < successfulTools.length;
+      if (hasCommands) {
+        console.log(`${getSkillTemplates().length} skills and ${getCommandContents().length} commands in ${toolDirs}/`);
+      } else {
+        console.log(`${getSkillTemplates().length} skills in ${toolDirs}/`);
+      }
+    }
 
-    // Codex heads-up: prompts installed globally
-    const selectedToolIds = new Set(selectedTools.map((t) => t.value));
-    if (selectedToolIds.has('codex')) {
-      console.log(PALETTE.white('Codex setup note'));
-      console.log(
-        PALETTE.midGray('Prompts installed to ~/.codex/prompts (or $CODEX_HOME/prompts).')
-      );
-      console.log();
+    // Show failures
+    if (results.failedTools.length > 0) {
+      console.log(chalk.red(`Failed: ${results.failedTools.map((f) => `${f.name} (${f.error.message})`).join(', ')}`));
     }
-  }
 
-  private formatToolNames(tools: AIToolOption[]): string {
-    const names = tools
-      .map((tool) => tool.successLabel ?? tool.name)
-      .filter((name): name is string => Boolean(name));
+    // Show skipped commands
+    if (results.commandsSkipped.length > 0) {
+      console.log(chalk.dim(`Commands skipped for: ${results.commandsSkipped.join(', ')} (no adapter)`));
+    }
 
-    if (names.length === 0)
-      return PALETTE.lightGray('your AGENTS.md-compatible assistant');
-    if (names.length === 1) return PALETTE.white(names[0]);
+    // Config status
+    if (configStatus === 'created') {
+      console.log(`Config: openspec/config.yaml (schema: ${DEFAULT_SCHEMA})`);
+    } else if (configStatus === 'exists') {
+      // Show actual filename (config.yaml or config.yml)
+      const configYaml = path.join(projectPath, OPENSPEC_DIR_NAME, 'config.yaml');
+      const configYml = path.join(projectPath, OPENSPEC_DIR_NAME, 'config.yml');
+      const configName = fs.existsSync(configYaml) ? 'config.yaml' : fs.existsSync(configYml) ? 'config.yml' : 'config.yaml';
+      console.log(`Config: openspec/${configName} (exists)`);
+    } else {
+      console.log(chalk.dim(`Config: skipped (non-interactive mode)`));
+    }
 
-    const base = names.slice(0, -1).map((name) => PALETTE.white(name));
-    const last = PALETTE.white(names[names.length - 1]);
+    // Getting started
+    console.log();
+    console.log(chalk.bold('Getting started:'));
+    console.log('  /opsx:new       Start a new change');
+    console.log('  /opsx:continue  Create the next artifact');
+    console.log('  /opsx:apply     Implement tasks');
 
-    return `${base.join(PALETTE.midGray(', '))}${
-      base.length ? PALETTE.midGray(', and ') : ''
-    }${last}`;
-  }
+    // Links
+    console.log();
+    console.log(`Learn more: ${chalk.cyan('https://github.com/Fission-AI/OpenSpec')}`);
+    console.log(`Feedback:   ${chalk.cyan('https://github.com/Fission-AI/OpenSpec/issues')}`);
 
-  private renderBanner(_extendMode: boolean): void {
-    const rows = ['', '', '', '', ''];
-    for (const char of 'OPENSPEC') {
-      const glyph = LETTER_MAP[char] ?? LETTER_MAP[' '];
-      for (let i = 0; i < rows.length; i += 1) {
-        rows[i] += `${glyph[i]}  `;
-      }
+    // Restart instruction if any tools were configured
+    if (results.createdTools.length > 0 || results.refreshedTools.length > 0) {
+      console.log();
+      console.log(chalk.white('Restart your IDE for slash commands to take effect.'));
     }
 
-    const rowStyles = [
-      PALETTE.white,
-      PALETTE.lightGray,
-      PALETTE.midGray,
-      PALETTE.lightGray,
-      PALETTE.white,
-    ];
-
-    console.log();
-    rows.forEach((row, index) => {
-      console.log(rowStyles[index](row.replace(/\s+$/u, '')));
-    });
-    console.log();
-    console.log(PALETTE.white('Welcome to OpenSpec!'));
     console.log();
   }
 
diff --git a/src/core/legacy-cleanup.ts b/src/core/legacy-cleanup.ts
new file mode 100644
index 0000000..498e49d
--- /dev/null
+++ b/src/core/legacy-cleanup.ts
@@ -0,0 +1,640 @@
+/**
+ * Legacy cleanup module for detecting and removing OpenSpec artifacts
+ * from previous init versions during the migration to the skill-based workflow.
+ */
+
+import path from 'path';
+import { promises as fs } from 'fs';
+import chalk from 'chalk';
+import { FileSystemUtils, removeMarkerBlock as removeMarkerBlockUtil } from '../utils/file-system.js';
+import { OPENSPEC_MARKERS } from './config.js';
+
+/**
+ * Legacy config file names from the old ToolRegistry.
+ * These were config files created at project root with OpenSpec markers.
+ */
+export const LEGACY_CONFIG_FILES = [
+  'CLAUDE.md',
+  'CLINE.md',
+  'CODEBUDDY.md',
+  'COSTRICT.md',
+  'QODER.md',
+  'IFLOW.md',
+  'AGENTS.md', // root AGENTS.md (not openspec/AGENTS.md)
+  'QWEN.md',
+] as const;
+
+/**
+ * Legacy slash command patterns from the old SlashCommandRegistry.
+ * These map toolId to the path pattern where legacy commands were created.
+ * Some tools used a directory structure, others used individual files.
+ */
+export const LEGACY_SLASH_COMMAND_PATHS: Record<string, LegacySlashCommandPattern> = {
+  // Directory-based: .tooldir/commands/openspec/ or .tooldir/commands/openspec/*.md
+  'claude': { type: 'directory', path: '.claude/commands/openspec' },
+  'codebuddy': { type: 'directory', path: '.codebuddy/commands/openspec' },
+  'qoder': { type: 'directory', path: '.qoder/commands/openspec' },
+  'crush': { type: 'directory', path: '.crush/commands/openspec' },
+  'gemini': { type: 'directory', path: '.gemini/commands/openspec' },
+  'costrict': { type: 'directory', path: '.cospec/openspec/commands' },
+
+  // File-based: individual openspec-*.md files in a commands/workflows/prompts folder
+  'cursor': { type: 'files', pattern: '.cursor/commands/openspec-*.md' },
+  'windsurf': { type: 'files', pattern: '.windsurf/workflows/openspec-*.md' },
+  'kilocode': { type: 'files', pattern: '.kilocode/workflows/openspec-*.md' },
+  'github-copilot': { type: 'files', pattern: '.github/prompts/openspec-*.prompt.md' },
+  'amazon-q': { type: 'files', pattern: '.amazonq/prompts/openspec-*.md' },
+  'cline': { type: 'files', pattern: '.clinerules/workflows/openspec-*.md' },
+  'roocode': { type: 'files', pattern: '.roo/commands/openspec-*.md' },
+  'auggie': { type: 'files', pattern: '.augment/commands/openspec-*.md' },
+  'factory': { type: 'files', pattern: '.factory/commands/openspec-*.md' },
+  'opencode': { type: 'files', pattern: '.opencode/command/openspec-*.md' },
+  'continue': { type: 'files', pattern: '.continue/prompts/openspec-*.prompt' },
+  'antigravity': { type: 'files', pattern: '.agent/workflows/openspec-*.md' },
+  'iflow': { type: 'files', pattern: '.iflow/commands/openspec-*.md' },
+  'qwen': { type: 'files', pattern: '.qwen/commands/openspec-*.toml' },
+  'codex': { type: 'files', pattern: '.codex/prompts/openspec-*.md' },
+};
+
+/**
+ * Pattern types for legacy slash commands
+ */
+export interface LegacySlashCommandPattern {
+  type: 'directory' | 'files';
+  path?: string; // For directory type
+  pattern?: string; // For files type (glob pattern)
+}
+
+/**
+ * Result of legacy artifact detection
+ */
+export interface LegacyDetectionResult {
+  /** Config files with OpenSpec markers detected */
+  configFiles: string[];
+  /** Config files to update (remove markers only, never delete) */
+  configFilesToUpdate: string[];
+  /** Legacy slash command directories found */
+  slashCommandDirs: string[];
+  /** Legacy slash command files found (for file-based tools) */
+  slashCommandFiles: string[];
+  /** Whether openspec/AGENTS.md exists */
+  hasOpenspecAgents: boolean;
+  /** Whether openspec/project.md exists (preserved, migration hint only) */
+  hasProjectMd: boolean;
+  /** Whether root AGENTS.md has OpenSpec markers */
+  hasRootAgentsWithMarkers: boolean;
+  /** Whether any legacy artifacts were found */
+  hasLegacyArtifacts: boolean;
+}
+
+/**
+ * Detects all legacy OpenSpec artifacts in a project.
+ *
+ * @param projectPath - The root path of the project
+ * @returns Detection result with all found legacy artifacts
+ */
+export async function detectLegacyArtifacts(
+  projectPath: string
+): Promise<LegacyDetectionResult> {
+  const result: LegacyDetectionResult = {
+    configFiles: [],
+    configFilesToUpdate: [],
+    slashCommandDirs: [],
+    slashCommandFiles: [],
+    hasOpenspecAgents: false,
+    hasProjectMd: false,
+    hasRootAgentsWithMarkers: false,
+    hasLegacyArtifacts: false,
+  };
+
+  // Detect legacy config files
+  const configResult = await detectLegacyConfigFiles(projectPath);
+  result.configFiles = configResult.allFiles;
+  result.configFilesToUpdate = configResult.filesToUpdate;
+
+  // Detect legacy slash commands
+  const slashResult = await detectLegacySlashCommands(projectPath);
+  result.slashCommandDirs = slashResult.directories;
+  result.slashCommandFiles = slashResult.files;
+
+  // Detect legacy structure files
+  const structureResult = await detectLegacyStructureFiles(projectPath);
+  result.hasOpenspecAgents = structureResult.hasOpenspecAgents;
+  result.hasProjectMd = structureResult.hasProjectMd;
+  result.hasRootAgentsWithMarkers = structureResult.hasRootAgentsWithMarkers;
+
+  // Determine if any legacy artifacts exist
+  result.hasLegacyArtifacts =
+    result.configFiles.length > 0 ||
+    result.slashCommandDirs.length > 0 ||
+    result.slashCommandFiles.length > 0 ||
+    result.hasOpenspecAgents ||
+    result.hasRootAgentsWithMarkers ||
+    result.hasProjectMd;
+
+  return result;
+}
+
+/**
+ * Detects legacy config files with OpenSpec markers.
+ * All config files with markers are candidates for update (marker removal only).
+ * Config files are NEVER deleted - they belong to the user's project root.
+ *
+ * @param projectPath - The root path of the project
+ * @returns Object with all files found and files to update
+ */
+export async function detectLegacyConfigFiles(
+  projectPath: string
+): Promise<{
+  allFiles: string[];
+  filesToUpdate: string[];
+}> {
+  const allFiles: string[] = [];
+  const filesToUpdate: string[] = [];
+
+  for (const fileName of LEGACY_CONFIG_FILES) {
+    const filePath = FileSystemUtils.joinPath(projectPath, fileName);
+
+    if (await FileSystemUtils.fileExists(filePath)) {
+      const content = await FileSystemUtils.readFile(filePath);
+
+      if (hasOpenSpecMarkers(content)) {
+        allFiles.push(fileName);
+        filesToUpdate.push(fileName); // Always update, never delete config files
+      }
+    }
+  }
+
+  return { allFiles, filesToUpdate };
+}
+
+/**
+ * Detects legacy slash command directories and files.
+ *
+ * @param projectPath - The root path of the project
+ * @returns Object with directories and individual files found
+ */
+export async function detectLegacySlashCommands(
+  projectPath: string
+): Promise<{
+  directories: string[];
+  files: string[];
+}> {
+  const directories: string[] = [];
+  const files: string[] = [];
+
+  for (const [toolId, pattern] of Object.entries(LEGACY_SLASH_COMMAND_PATHS)) {
+    if (pattern.type === 'directory' && pattern.path) {
+      const dirPath = FileSystemUtils.joinPath(projectPath, pattern.path);
+      if (await FileSystemUtils.directoryExists(dirPath)) {
+        directories.push(pattern.path);
+      }
+    } else if (pattern.type === 'files' && pattern.pattern) {
+      // For file-based patterns, check for individual files
+      const foundFiles = await findLegacySlashCommandFiles(projectPath, pattern.pattern);
+      files.push(...foundFiles);
+    }
+  }
+
+  return { directories, files };
+}
+
+/**
+ * Finds legacy slash command files matching a glob pattern.
+ *
+ * @param projectPath - The root path of the project
+ * @param pattern - Glob pattern like '.cursor/commands/openspec-*.md'
+ * @returns Array of matching file paths relative to projectPath
+ */
+async function findLegacySlashCommandFiles(
+  projectPath: string,
+  pattern: string
+): Promise<string[]> {
+  const foundFiles: string[] = [];
+
+  // Extract directory and file pattern from glob
+  // Handle both forward and backward slashes for Windows compatibility
+  const lastForwardSlash = pattern.lastIndexOf('/');
+  const lastBackSlash = pattern.lastIndexOf('\\');
+  const lastSeparator = Math.max(lastForwardSlash, lastBackSlash);
+  const dirPart = pattern.substring(0, lastSeparator);
+  const filePart = pattern.substring(lastSeparator + 1);
+
+  const dirPath = FileSystemUtils.joinPath(projectPath, dirPart);
+
+  if (!(await FileSystemUtils.directoryExists(dirPath))) {
+    return foundFiles;
+  }
+
+  try {
+    const entries = await fs.readdir(dirPath);
+
+    // Convert glob pattern to regex
+    // openspec-*.md -> /^openspec-.*\.md$/
+    // openspec-*.prompt.md -> /^openspec-.*\.prompt\.md$/
+    // openspec-*.toml -> /^openspec-.*\.toml$/
+    const regexPattern = filePart
+      .replace(/[.+^${}()|[\]\\]/g, '\\$&') // Escape regex special chars except *
+      .replace(/\*/g, '.*'); // Replace * with .*
+    const regex = new RegExp(`^${regexPattern}$`);
+
+    for (const entry of entries) {
+      if (regex.test(entry)) {
+        // Use forward slashes for consistency in relative paths (cross-platform)
+        const normalizedDir = dirPart.replace(/\\/g, '/');
+        foundFiles.push(`${normalizedDir}/${entry}`);
+      }
+    }
+  } catch {
+    // Directory doesn't exist or can't be read
+  }
+
+  return foundFiles;
+}
+
+/**
+ * Detects legacy OpenSpec structure files (AGENTS.md and project.md).
+ *
+ * @param projectPath - The root path of the project
+ * @returns Object with detection results for structure files
+ */
+export async function detectLegacyStructureFiles(
+  projectPath: string
+): Promise<{
+  hasOpenspecAgents: boolean;
+  hasProjectMd: boolean;
+  hasRootAgentsWithMarkers: boolean;
+}> {
+  let hasOpenspecAgents = false;
+  let hasProjectMd = false;
+  let hasRootAgentsWithMarkers = false;
+
+  // Check for openspec/AGENTS.md
+  const openspecAgentsPath = FileSystemUtils.joinPath(projectPath, 'openspec', 'AGENTS.md');
+  hasOpenspecAgents = await FileSystemUtils.fileExists(openspecAgentsPath);
+
+  // Check for openspec/project.md (for migration messaging, not deleted)
+  const projectMdPath = FileSystemUtils.joinPath(projectPath, 'openspec', 'project.md');
+  hasProjectMd = await FileSystemUtils.fileExists(projectMdPath);
+
+  // Check for root AGENTS.md with OpenSpec markers
+  const rootAgentsPath = FileSystemUtils.joinPath(projectPath, 'AGENTS.md');
+  if (await FileSystemUtils.fileExists(rootAgentsPath)) {
+    const content = await FileSystemUtils.readFile(rootAgentsPath);
+    hasRootAgentsWithMarkers = hasOpenSpecMarkers(content);
+  }
+
+  return { hasOpenspecAgents, hasProjectMd, hasRootAgentsWithMarkers };
+}
+
+/**
+ * Checks if content contains OpenSpec markers.
+ *
+ * @param content - File content to check
+ * @returns True if both start and end markers are present
+ */
+export function hasOpenSpecMarkers(content: string): boolean {
+  return (
+    content.includes(OPENSPEC_MARKERS.start) && content.includes(OPENSPEC_MARKERS.end)
+  );
+}
+
+/**
+ * Checks if file content is 100% OpenSpec content (only markers and whitespace outside).
+ *
+ * @param content - File content to check
+ * @returns True if content outside markers is only whitespace
+ */
+export function isOnlyOpenSpecContent(content: string): boolean {
+  const startIndex = content.indexOf(OPENSPEC_MARKERS.start);
+  const endIndex = content.indexOf(OPENSPEC_MARKERS.end);
+
+  if (startIndex === -1 || endIndex === -1 || endIndex <= startIndex) {
+    return false;
+  }
+
+  const before = content.substring(0, startIndex);
+  const after = content.substring(endIndex + OPENSPEC_MARKERS.end.length);
+
+  return before.trim() === '' && after.trim() === '';
+}
+
+/**
+ * Removes the OpenSpec marker block from file content.
+ * Only removes markers that are on their own lines (ignores inline mentions).
+ * Cleans up double blank lines that may result from removal.
+ *
+ * @param content - File content with OpenSpec markers
+ * @returns Content with marker block removed
+ */
+export function removeMarkerBlock(content: string): string {
+  return removeMarkerBlockUtil(content, OPENSPEC_MARKERS.start, OPENSPEC_MARKERS.end);
+}
+
+/**
+ * Result of cleanup operation
+ */
+export interface CleanupResult {
+  /** Files that were deleted entirely */
+  deletedFiles: string[];
+  /** Files that had marker blocks removed */
+  modifiedFiles: string[];
+  /** Directories that were deleted */
+  deletedDirs: string[];
+  /** Whether project.md exists and needs manual migration */
+  projectMdNeedsMigration: boolean;
+  /** Error messages if any operations failed */
+  errors: string[];
+}
+
+/**
+ * Cleans up legacy OpenSpec artifacts from a project.
+ * Preserves openspec/project.md (shows migration hint instead of deleting).
+ *
+ * @param projectPath - The root path of the project
+ * @param detection - Detection result from detectLegacyArtifacts
+ * @returns Cleanup result with summary of actions taken
+ */
+export async function cleanupLegacyArtifacts(
+  projectPath: string,
+  detection: LegacyDetectionResult
+): Promise<CleanupResult> {
+  const result: CleanupResult = {
+    deletedFiles: [],
+    modifiedFiles: [],
+    deletedDirs: [],
+    projectMdNeedsMigration: detection.hasProjectMd,
+    errors: [],
+  };
+
+  // Remove marker blocks from config files (NEVER delete config files)
+  // Config files like CLAUDE.md, AGENTS.md belong to the user's project root
+  for (const fileName of detection.configFilesToUpdate) {
+    const filePath = FileSystemUtils.joinPath(projectPath, fileName);
+    try {
+      const content = await FileSystemUtils.readFile(filePath);
+      const newContent = removeMarkerBlock(content);
+      // Always write the file, even if empty - never delete user config files
+      await FileSystemUtils.writeFile(filePath, newContent);
+      result.modifiedFiles.push(fileName);
+    } catch (error: any) {
+      result.errors.push(`Failed to modify ${fileName}: ${error.message}`);
+    }
+  }
+
+  // Delete legacy slash command directories (these are 100% OpenSpec-managed)
+  for (const dirPath of detection.slashCommandDirs) {
+    const fullPath = FileSystemUtils.joinPath(projectPath, dirPath);
+    try {
+      await fs.rm(fullPath, { recursive: true, force: true });
+      result.deletedDirs.push(dirPath);
+    } catch (error: any) {
+      result.errors.push(`Failed to delete directory ${dirPath}: ${error.message}`);
+    }
+  }
+
+  // Delete legacy slash command files (these are 100% OpenSpec-managed)
+  for (const filePath of detection.slashCommandFiles) {
+    const fullPath = FileSystemUtils.joinPath(projectPath, filePath);
+    try {
+      await fs.unlink(fullPath);
+      result.deletedFiles.push(filePath);
+    } catch (error: any) {
+      result.errors.push(`Failed to delete ${filePath}: ${error.message}`);
+    }
+  }
+
+  // Delete openspec/AGENTS.md (this is inside openspec/, it's OpenSpec-managed)
+  if (detection.hasOpenspecAgents) {
+    const agentsPath = FileSystemUtils.joinPath(projectPath, 'openspec', 'AGENTS.md');
+    if (await FileSystemUtils.fileExists(agentsPath)) {
+      try {
+        await fs.unlink(agentsPath);
+        result.deletedFiles.push('openspec/AGENTS.md');
+      } catch (error: any) {
+        result.errors.push(`Failed to delete openspec/AGENTS.md: ${error.message}`);
+      }
+    }
+  }
+
+  // Handle root AGENTS.md with OpenSpec markers - remove markers only, NEVER delete
+  // Note: Root AGENTS.md is handled via configFilesToUpdate above (it's in LEGACY_CONFIG_FILES)
+  // This hasRootAgentsWithMarkers flag is just for detection, cleanup happens via configFilesToUpdate
+
+  return result;
+}
+
+/**
+ * Generates a cleanup summary message for display.
+ *
+ * @param result - Cleanup result from cleanupLegacyArtifacts
+ * @returns Formatted summary string for console output
+ */
+export function formatCleanupSummary(result: CleanupResult): string {
+  const lines: string[] = [];
+
+  if (result.deletedFiles.length > 0 || result.deletedDirs.length > 0 || result.modifiedFiles.length > 0) {
+    lines.push('Cleaned up legacy files:');
+
+    for (const file of result.deletedFiles) {
+      lines.push(`  âœ“ Removed ${file}`);
+    }
+
+    for (const dir of result.deletedDirs) {
+      lines.push(`  âœ“ Removed ${dir}/ (replaced by /opsx:*)`);
+    }
+
+    for (const file of result.modifiedFiles) {
+      lines.push(`  âœ“ Removed OpenSpec markers from ${file}`);
+    }
+  }
+
+  if (result.projectMdNeedsMigration) {
+    if (lines.length > 0) {
+      lines.push('');
+    }
+    lines.push(formatProjectMdMigrationHint());
+  }
+
+  if (result.errors.length > 0) {
+    if (lines.length > 0) {
+      lines.push('');
+    }
+    lines.push('Errors during cleanup:');
+    for (const error of result.errors) {
+      lines.push(`  âš  ${error}`);
+    }
+  }
+
+  return lines.join('\n');
+}
+
+/**
+ * Build list of files to be removed with explanations.
+ * Only includes OpenSpec-managed files (slash commands, openspec/AGENTS.md).
+ * Config files like CLAUDE.md, AGENTS.md are NEVER deleted.
+ *
+ * @param detection - Detection result from detectLegacyArtifacts
+ * @returns Array of objects with path and explanation
+ */
+function buildRemovalsList(detection: LegacyDetectionResult): Array<{ path: string; explanation: string }> {
+  const removals: Array<{ path: string; explanation: string }> = [];
+
+  // Slash command directories (these are 100% OpenSpec-managed)
+  for (const dir of detection.slashCommandDirs) {
+    // Split on both forward and backward slashes for Windows compatibility
+    const toolDir = dir.split(/[\/\\]/)[0];
+    removals.push({ path: dir + '/', explanation: `replaced by ${toolDir}/skills/` });
+  }
+
+  // Slash command files (these are 100% OpenSpec-managed)
+  for (const file of detection.slashCommandFiles) {
+    removals.push({ path: file, explanation: 'replaced by skills/' });
+  }
+
+  // openspec/AGENTS.md (inside openspec/, it's OpenSpec-managed)
+  if (detection.hasOpenspecAgents) {
+    removals.push({ path: 'openspec/AGENTS.md', explanation: 'obsolete workflow file' });
+  }
+
+  // Note: Config files (CLAUDE.md, AGENTS.md, etc.) are NEVER in the removals list
+  // They always go to the updates list where only markers are removed
+
+  return removals;
+}
+
+/**
+ * Build list of files to be updated with explanations.
+ * Includes ALL config files with markers - markers are removed, file is never deleted.
+ *
+ * @param detection - Detection result from detectLegacyArtifacts
+ * @returns Array of objects with path and explanation
+ */
+function buildUpdatesList(detection: LegacyDetectionResult): Array<{ path: string; explanation: string }> {
+  const updates: Array<{ path: string; explanation: string }> = [];
+
+  // All config files with markers get updated (markers removed, file preserved)
+  for (const file of detection.configFilesToUpdate) {
+    updates.push({ path: file, explanation: 'removing OpenSpec markers' });
+  }
+
+  return updates;
+}
+
+/**
+ * Generates a detection summary message for display before cleanup.
+ * Groups files by action type: removals, updates, and manual migration.
+ *
+ * @param detection - Detection result from detectLegacyArtifacts
+ * @returns Formatted summary string showing what was found
+ */
+export function formatDetectionSummary(detection: LegacyDetectionResult): string {
+  const lines: string[] = [];
+
+  const removals = buildRemovalsList(detection);
+  const updates = buildUpdatesList(detection);
+
+  // If nothing to show, return empty
+  if (removals.length === 0 && updates.length === 0 && !detection.hasProjectMd) {
+    return '';
+  }
+
+  // Header - welcoming upgrade message
+  lines.push(chalk.bold('Upgrading to the new OpenSpec'));
+  lines.push('');
+  lines.push('OpenSpec now uses agent skills, the emerging standard across coding');
+  lines.push('agents. This simplifies your setup while keeping everything working');
+  lines.push('as before.');
+  lines.push('');
+
+  // Section 1: Files to remove (no user content to preserve)
+  if (removals.length > 0) {
+    lines.push(chalk.bold('Files to remove'));
+    lines.push(chalk.dim('No user content to preserve:'));
+    for (const { path } of removals) {
+      lines.push(`  â€¢ ${path}`);
+    }
+  }
+
+  // Section 2: Files to update (markers removed, content preserved)
+  if (updates.length > 0) {
+    if (removals.length > 0) lines.push('');
+    lines.push(chalk.bold('Files to update'));
+    lines.push(chalk.dim('OpenSpec markers will be removed, your content preserved:'));
+    for (const { path } of updates) {
+      lines.push(`  â€¢ ${path}`);
+    }
+  }
+
+  // Section 3: Manual migration (project.md)
+  if (detection.hasProjectMd) {
+    if (removals.length > 0 || updates.length > 0) lines.push('');
+    lines.push(formatProjectMdMigrationHint());
+  }
+
+  return lines.join('\n');
+}
+
+/**
+ * Extract tool IDs from detected legacy artifacts.
+ * Uses LEGACY_SLASH_COMMAND_PATHS to map paths back to tool IDs.
+ *
+ * @param detection - Detection result from detectLegacyArtifacts
+ * @returns Array of tool IDs that had legacy artifacts
+ */
+export function getToolsFromLegacyArtifacts(detection: LegacyDetectionResult): string[] {
+  const tools = new Set<string>();
+
+  // Match directories to tool IDs
+  for (const dir of detection.slashCommandDirs) {
+    for (const [toolId, pattern] of Object.entries(LEGACY_SLASH_COMMAND_PATHS)) {
+      if (pattern.type === 'directory' && pattern.path === dir) {
+        tools.add(toolId);
+        break;
+      }
+    }
+  }
+
+  // Match files to tool IDs using glob patterns
+  for (const file of detection.slashCommandFiles) {
+    // Normalize file path to use forward slashes for consistent matching (Windows compatibility)
+    const normalizedFile = file.replace(/\\/g, '/');
+    for (const [toolId, pattern] of Object.entries(LEGACY_SLASH_COMMAND_PATHS)) {
+      if (pattern.type === 'files' && pattern.pattern) {
+        // Convert glob pattern to regex for matching
+        // e.g., '.cursor/commands/openspec-*.md' -> /^\.cursor\/commands\/openspec-.*\.md$/
+        const regexPattern = pattern.pattern
+          .replace(/[.+^${}()|[\]\\]/g, '\\$&') // Escape regex special chars except *
+          .replace(/\*/g, '.*'); // Replace * with .*
+        const regex = new RegExp(`^${regexPattern}$`);
+        if (regex.test(normalizedFile)) {
+          tools.add(toolId);
+          break;
+        }
+      }
+    }
+  }
+
+  return Array.from(tools);
+}
+
+/**
+ * Generates a migration hint message for project.md.
+ * This is shown when project.md exists and needs manual migration to config.yaml.
+ *
+ * @returns Formatted migration hint string for console output
+ */
+export function formatProjectMdMigrationHint(): string {
+  const lines: string[] = [];
+  lines.push(chalk.yellow.bold('Needs your attention'));
+  lines.push('  â€¢ openspec/project.md');
+  lines.push(chalk.dim('    We won\'t delete this file. It may contain useful project context.'));
+  lines.push('');
+  lines.push(chalk.dim('    The new openspec/config.yaml has a "context:" section for planning'));
+  lines.push(chalk.dim('    context. This is included in every OpenSpec request and works more'));
+  lines.push(chalk.dim('    reliably than the old project.md approach.'));
+  lines.push('');
+  lines.push(chalk.dim('    Review project.md, move any useful content to config.yaml\'s context'));
+  lines.push(chalk.dim('    section, then delete the file when ready.'));
+  return lines.join('\n');
+}
diff --git a/src/core/project-config.ts b/src/core/project-config.ts
index 4574882..6c1ea04 100644
--- a/src/core/project-config.ts
+++ b/src/core/project-config.ts
@@ -17,11 +17,11 @@ import { z } from 'zod';
  * - Consistent with other OpenSpec schemas
  */
 export const ProjectConfigSchema = z.object({
-  // Required: which schema to use (e.g., "spec-driven", "tdd", or project-local schema name)
+  // Required: which schema to use (e.g., "spec-driven", or project-local schema name)
   schema: z
     .string()
     .min(1)
-    .describe('The workflow schema to use (e.g., "spec-driven", "tdd")'),
+    .describe('The workflow schema to use (e.g., "spec-driven")'),
 
   // Optional: project context (injected into all artifact instructions)
   // Max size: 50KB (enforced during parsing)
diff --git a/src/core/shared/index.ts b/src/core/shared/index.ts
new file mode 100644
index 0000000..8ff8560
--- /dev/null
+++ b/src/core/shared/index.ts
@@ -0,0 +1,28 @@
+/**
+ * Shared Utilities
+ *
+ * Common code shared between init and update commands.
+ */
+
+export {
+  SKILL_NAMES,
+  type SkillName,
+  type ToolSkillStatus,
+  type ToolVersionStatus,
+  getToolsWithSkillsDir,
+  getToolSkillStatus,
+  getToolStates,
+  extractGeneratedByVersion,
+  getToolVersionStatus,
+  getConfiguredTools,
+  getAllToolVersionStatus,
+} from './tool-detection.js';
+
+export {
+  type SkillTemplateEntry,
+  type CommandTemplateEntry,
+  getSkillTemplates,
+  getCommandTemplates,
+  getCommandContents,
+  generateSkillContent,
+} from './skill-generation.js';
diff --git a/src/core/shared/skill-generation.ts b/src/core/shared/skill-generation.ts
new file mode 100644
index 0000000..db7c6fe
--- /dev/null
+++ b/src/core/shared/skill-generation.ts
@@ -0,0 +1,122 @@
+/**
+ * Skill Generation Utilities
+ *
+ * Shared utilities for generating skill and command files.
+ */
+
+import {
+  getExploreSkillTemplate,
+  getNewChangeSkillTemplate,
+  getContinueChangeSkillTemplate,
+  getApplyChangeSkillTemplate,
+  getFfChangeSkillTemplate,
+  getSyncSpecsSkillTemplate,
+  getArchiveChangeSkillTemplate,
+  getBulkArchiveChangeSkillTemplate,
+  getVerifyChangeSkillTemplate,
+  getOnboardSkillTemplate,
+  getOpsxExploreCommandTemplate,
+  getOpsxNewCommandTemplate,
+  getOpsxContinueCommandTemplate,
+  getOpsxApplyCommandTemplate,
+  getOpsxFfCommandTemplate,
+  getOpsxSyncCommandTemplate,
+  getOpsxArchiveCommandTemplate,
+  getOpsxBulkArchiveCommandTemplate,
+  getOpsxVerifyCommandTemplate,
+  getOpsxOnboardCommandTemplate,
+  type SkillTemplate,
+} from '../templates/skill-templates.js';
+import type { CommandContent } from '../command-generation/index.js';
+
+/**
+ * Skill template with directory name mapping.
+ */
+export interface SkillTemplateEntry {
+  template: SkillTemplate;
+  dirName: string;
+}
+
+/**
+ * Command template with ID mapping.
+ */
+export interface CommandTemplateEntry {
+  template: ReturnType<typeof getOpsxExploreCommandTemplate>;
+  id: string;
+}
+
+/**
+ * Gets all skill templates with their directory names.
+ */
+export function getSkillTemplates(): SkillTemplateEntry[] {
+  return [
+    { template: getExploreSkillTemplate(), dirName: 'openspec-explore' },
+    { template: getNewChangeSkillTemplate(), dirName: 'openspec-new-change' },
+    { template: getContinueChangeSkillTemplate(), dirName: 'openspec-continue-change' },
+    { template: getApplyChangeSkillTemplate(), dirName: 'openspec-apply-change' },
+    { template: getFfChangeSkillTemplate(), dirName: 'openspec-ff-change' },
+    { template: getSyncSpecsSkillTemplate(), dirName: 'openspec-sync-specs' },
+    { template: getArchiveChangeSkillTemplate(), dirName: 'openspec-archive-change' },
+    { template: getBulkArchiveChangeSkillTemplate(), dirName: 'openspec-bulk-archive-change' },
+    { template: getVerifyChangeSkillTemplate(), dirName: 'openspec-verify-change' },
+    { template: getOnboardSkillTemplate(), dirName: 'openspec-onboard' },
+  ];
+}
+
+/**
+ * Gets all command templates with their IDs.
+ */
+export function getCommandTemplates(): CommandTemplateEntry[] {
+  return [
+    { template: getOpsxExploreCommandTemplate(), id: 'explore' },
+    { template: getOpsxNewCommandTemplate(), id: 'new' },
+    { template: getOpsxContinueCommandTemplate(), id: 'continue' },
+    { template: getOpsxApplyCommandTemplate(), id: 'apply' },
+    { template: getOpsxFfCommandTemplate(), id: 'ff' },
+    { template: getOpsxSyncCommandTemplate(), id: 'sync' },
+    { template: getOpsxArchiveCommandTemplate(), id: 'archive' },
+    { template: getOpsxBulkArchiveCommandTemplate(), id: 'bulk-archive' },
+    { template: getOpsxVerifyCommandTemplate(), id: 'verify' },
+    { template: getOpsxOnboardCommandTemplate(), id: 'onboard' },
+  ];
+}
+
+/**
+ * Converts command templates to CommandContent array.
+ */
+export function getCommandContents(): CommandContent[] {
+  const commandTemplates = getCommandTemplates();
+  return commandTemplates.map(({ template, id }) => ({
+    id,
+    name: template.name,
+    description: template.description,
+    category: template.category,
+    tags: template.tags,
+    body: template.content,
+  }));
+}
+
+/**
+ * Generates skill file content with YAML frontmatter.
+ *
+ * @param template - The skill template
+ * @param generatedByVersion - The OpenSpec version to embed in the file
+ */
+export function generateSkillContent(
+  template: SkillTemplate,
+  generatedByVersion: string
+): string {
+  return `---
+name: ${template.name}
+description: ${template.description}
+license: ${template.license || 'MIT'}
+compatibility: ${template.compatibility || 'Requires openspec CLI.'}
+metadata:
+  author: ${template.metadata?.author || 'openspec'}
+  version: "${template.metadata?.version || '1.0'}"
+  generatedBy: "${generatedByVersion}"
+---
+
+${template.instructions}
+`;
+}
diff --git a/src/core/shared/tool-detection.ts b/src/core/shared/tool-detection.ts
new file mode 100644
index 0000000..b9b39ac
--- /dev/null
+++ b/src/core/shared/tool-detection.ts
@@ -0,0 +1,199 @@
+/**
+ * Tool Detection Utilities
+ *
+ * Shared utilities for detecting tool configurations and version status.
+ */
+
+import path from 'path';
+import * as fs from 'fs';
+import { AI_TOOLS } from '../config.js';
+
+/**
+ * Names of skill directories created by openspec init.
+ */
+export const SKILL_NAMES = [
+  'openspec-explore',
+  'openspec-new-change',
+  'openspec-continue-change',
+  'openspec-apply-change',
+  'openspec-ff-change',
+  'openspec-sync-specs',
+  'openspec-archive-change',
+  'openspec-bulk-archive-change',
+  'openspec-verify-change',
+] as const;
+
+export type SkillName = (typeof SKILL_NAMES)[number];
+
+/**
+ * Status of skill configuration for a tool.
+ */
+export interface ToolSkillStatus {
+  /** Whether the tool has any skills configured */
+  configured: boolean;
+  /** Whether all 9 skills are configured */
+  fullyConfigured: boolean;
+  /** Number of skills currently configured (0-9) */
+  skillCount: number;
+}
+
+/**
+ * Version information for a tool's skills.
+ */
+export interface ToolVersionStatus {
+  /** The tool ID */
+  toolId: string;
+  /** The tool's display name */
+  toolName: string;
+  /** Whether the tool has any skills configured */
+  configured: boolean;
+  /** The generatedBy version found in the skill files, or null if not found */
+  generatedByVersion: string | null;
+  /** Whether the tool needs updating (version mismatch or missing) */
+  needsUpdate: boolean;
+}
+
+/**
+ * Gets the list of tools with skillsDir configured.
+ */
+export function getToolsWithSkillsDir(): string[] {
+  return AI_TOOLS.filter((t) => t.skillsDir).map((t) => t.value);
+}
+
+/**
+ * Checks which skill files exist for a tool.
+ */
+export function getToolSkillStatus(projectRoot: string, toolId: string): ToolSkillStatus {
+  const tool = AI_TOOLS.find((t) => t.value === toolId);
+  if (!tool?.skillsDir) {
+    return { configured: false, fullyConfigured: false, skillCount: 0 };
+  }
+
+  const skillsDir = path.join(projectRoot, tool.skillsDir, 'skills');
+  let skillCount = 0;
+
+  for (const skillName of SKILL_NAMES) {
+    const skillFile = path.join(skillsDir, skillName, 'SKILL.md');
+    if (fs.existsSync(skillFile)) {
+      skillCount++;
+    }
+  }
+
+  return {
+    configured: skillCount > 0,
+    fullyConfigured: skillCount === SKILL_NAMES.length,
+    skillCount,
+  };
+}
+
+/**
+ * Gets the skill status for all tools with skillsDir configured.
+ */
+export function getToolStates(projectRoot: string): Map<string, ToolSkillStatus> {
+  const states = new Map<string, ToolSkillStatus>();
+  const toolIds = AI_TOOLS.filter((t) => t.skillsDir).map((t) => t.value);
+
+  for (const toolId of toolIds) {
+    states.set(toolId, getToolSkillStatus(projectRoot, toolId));
+  }
+
+  return states;
+}
+
+/**
+ * Extracts the generatedBy version from a skill file's YAML frontmatter.
+ * Returns null if the field is not found or the file doesn't exist.
+ */
+export function extractGeneratedByVersion(skillFilePath: string): string | null {
+  try {
+    if (!fs.existsSync(skillFilePath)) {
+      return null;
+    }
+
+    const content = fs.readFileSync(skillFilePath, 'utf-8');
+
+    // Look for generatedBy in the YAML frontmatter
+    // The file format is:
+    // ---
+    // ...
+    // metadata:
+    //   author: openspec
+    //   version: "1.0"
+    //   generatedBy: "0.23.0"
+    // ---
+    const generatedByMatch = content.match(/^\s*generatedBy:\s*["']?([^"'\n]+)["']?\s*$/m);
+
+    if (generatedByMatch && generatedByMatch[1]) {
+      return generatedByMatch[1].trim();
+    }
+
+    return null;
+  } catch {
+    return null;
+  }
+}
+
+/**
+ * Gets version status for a tool by reading the first available skill file.
+ */
+export function getToolVersionStatus(
+  projectRoot: string,
+  toolId: string,
+  currentVersion: string
+): ToolVersionStatus {
+  const tool = AI_TOOLS.find((t) => t.value === toolId);
+  if (!tool?.skillsDir) {
+    return {
+      toolId,
+      toolName: toolId,
+      configured: false,
+      generatedByVersion: null,
+      needsUpdate: false,
+    };
+  }
+
+  const skillsDir = path.join(projectRoot, tool.skillsDir, 'skills');
+  let generatedByVersion: string | null = null;
+
+  // Find the first skill file that exists and read its version
+  for (const skillName of SKILL_NAMES) {
+    const skillFile = path.join(skillsDir, skillName, 'SKILL.md');
+    if (fs.existsSync(skillFile)) {
+      generatedByVersion = extractGeneratedByVersion(skillFile);
+      break;
+    }
+  }
+
+  const configured = getToolSkillStatus(projectRoot, toolId).configured;
+  const needsUpdate = configured && (generatedByVersion === null || generatedByVersion !== currentVersion);
+
+  return {
+    toolId,
+    toolName: tool.name,
+    configured,
+    generatedByVersion,
+    needsUpdate,
+  };
+}
+
+/**
+ * Gets all configured tools in the project.
+ */
+export function getConfiguredTools(projectRoot: string): string[] {
+  return AI_TOOLS
+    .filter((t) => t.skillsDir && getToolSkillStatus(projectRoot, t.value).configured)
+    .map((t) => t.value);
+}
+
+/**
+ * Gets version status for all configured tools.
+ */
+export function getAllToolVersionStatus(
+  projectRoot: string,
+  currentVersion: string
+): ToolVersionStatus[] {
+  const configuredTools = getConfiguredTools(projectRoot);
+  return configuredTools.map((toolId) =>
+    getToolVersionStatus(projectRoot, toolId, currentVersion)
+  );
+}
diff --git a/src/core/templates/agents-root-stub.ts b/src/core/templates/agents-root-stub.ts
deleted file mode 100644
index cbc762f..0000000
--- a/src/core/templates/agents-root-stub.ts
+++ /dev/null
@@ -1,16 +0,0 @@
-export const agentsRootStubTemplate = `# OpenSpec Instructions
-
-These instructions are for AI assistants working in this project.
-
-Always open \`@/openspec/AGENTS.md\` when the request:
-- Mentions planning or proposals (words like proposal, spec, change, plan)
-- Introduces new capabilities, breaking changes, architecture shifts, or big performance/security work
-- Sounds ambiguous and you need the authoritative spec before coding
-
-Use \`@/openspec/AGENTS.md\` to learn:
-- How to create and apply change proposals
-- Spec format and conventions
-- Project structure and guidelines
-
-Keep this managed block so 'openspec update' can refresh the instructions.
-`;
diff --git a/src/core/templates/agents-template.ts b/src/core/templates/agents-template.ts
deleted file mode 100644
index 2a4ad4c..0000000
--- a/src/core/templates/agents-template.ts
+++ /dev/null
@@ -1,457 +0,0 @@
-export const agentsTemplate = `# OpenSpec Instructions
-
-Instructions for AI coding assistants using OpenSpec for spec-driven development.
-
-## TL;DR Quick Checklist
-
-- Search existing work: \`openspec spec list --long\`, \`openspec list\` (use \`rg\` only for full-text search)
-- Decide scope: new capability vs modify existing capability
-- Pick a unique \`change-id\`: kebab-case, verb-led (\`add-\`, \`update-\`, \`remove-\`, \`refactor-\`)
-- Scaffold: \`proposal.md\`, \`tasks.md\`, \`design.md\` (only if needed), and delta specs per affected capability
-- Write deltas: use \`## ADDED|MODIFIED|REMOVED|RENAMED Requirements\`; include at least one \`#### Scenario:\` per requirement
-- Validate: \`openspec validate [change-id] --strict --no-interactive\` and fix issues
-- Request approval: Do not start implementation until proposal is approved
-
-## Three-Stage Workflow
-
-### Stage 1: Creating Changes
-Create proposal when you need to:
-- Add features or functionality
-- Make breaking changes (API, schema)
-- Change architecture or patterns  
-- Optimize performance (changes behavior)
-- Update security patterns
-
-Triggers (examples):
-- "Help me create a change proposal"
-- "Help me plan a change"
-- "Help me create a proposal"
-- "I want to create a spec proposal"
-- "I want to create a spec"
-
-Loose matching guidance:
-- Contains one of: \`proposal\`, \`change\`, \`spec\`
-- With one of: \`create\`, \`plan\`, \`make\`, \`start\`, \`help\`
-
-Skip proposal for:
-- Bug fixes (restore intended behavior)
-- Typos, formatting, comments
-- Dependency updates (non-breaking)
-- Configuration changes
-- Tests for existing behavior
-
-**Workflow**
-1. Review \`openspec/project.md\`, \`openspec list\`, and \`openspec list --specs\` to understand current context.
-2. Choose a unique verb-led \`change-id\` and scaffold \`proposal.md\`, \`tasks.md\`, optional \`design.md\`, and spec deltas under \`openspec/changes/<id>/\`.
-3. Draft spec deltas using \`## ADDED|MODIFIED|REMOVED Requirements\` with at least one \`#### Scenario:\` per requirement.
-4. Run \`openspec validate <id> --strict --no-interactive\` and resolve any issues before sharing the proposal.
-
-### Stage 2: Implementing Changes
-Track these steps as TODOs and complete them one by one.
-1. **Read proposal.md** - Understand what's being built
-2. **Read design.md** (if exists) - Review technical decisions
-3. **Read tasks.md** - Get implementation checklist
-4. **Implement tasks sequentially** - Complete in order
-5. **Confirm completion** - Ensure every item in \`tasks.md\` is finished before updating statuses
-6. **Update checklist** - After all work is done, set every task to \`- [x]\` so the list reflects reality
-7. **Approval gate** - Do not start implementation until the proposal is reviewed and approved
-
-### Stage 3: Archiving Changes
-After deployment, create separate PR to:
-- Move \`changes/[name]/\` â†’ \`changes/archive/YYYY-MM-DD-[name]/\`
-- Update \`specs/\` if capabilities changed
-- Use \`openspec archive <change-id> --skip-specs --yes\` for tooling-only changes (always pass the change ID explicitly)
-- Run \`openspec validate --strict --no-interactive\` to confirm the archived change passes checks
-
-## Before Any Task
-
-**Context Checklist:**
-- [ ] Read relevant specs in \`specs/[capability]/spec.md\`
-- [ ] Check pending changes in \`changes/\` for conflicts
-- [ ] Read \`openspec/project.md\` for conventions
-- [ ] Run \`openspec list\` to see active changes
-- [ ] Run \`openspec list --specs\` to see existing capabilities
-
-**Before Creating Specs:**
-- Always check if capability already exists
-- Prefer modifying existing specs over creating duplicates
-- Use \`openspec show [spec]\` to review current state
-- If request is ambiguous, ask 1â€“2 clarifying questions before scaffolding
-
-### Search Guidance
-- Enumerate specs: \`openspec spec list --long\` (or \`--json\` for scripts)
-- Enumerate changes: \`openspec list\` (or \`openspec change list --json\` - deprecated but available)
-- Show details:
-  - Spec: \`openspec show <spec-id> --type spec\` (use \`--json\` for filters)
-  - Change: \`openspec show <change-id> --json --deltas-only\`
-- Full-text search (use ripgrep): \`rg -n "Requirement:|Scenario:" openspec/specs\`
-
-## Quick Start
-
-### CLI Commands
-
-\`\`\`bash
-# Essential commands
-openspec list                  # List active changes
-openspec list --specs          # List specifications
-openspec show [item]           # Display change or spec
-openspec validate [item]       # Validate changes or specs
-openspec archive <change-id> [--yes|-y]   # Archive after deployment (add --yes for non-interactive runs)
-
-# Project management
-openspec init [path]           # Initialize OpenSpec
-openspec update [path]         # Update instruction files
-
-# Interactive mode
-openspec show                  # Prompts for selection
-openspec validate              # Bulk validation mode
-
-# Debugging
-openspec show [change] --json --deltas-only
-openspec validate [change] --strict --no-interactive
-\`\`\`
-
-### Command Flags
-
-- \`--json\` - Machine-readable output
-- \`--type change|spec\` - Disambiguate items
-- \`--strict\` - Comprehensive validation
-- \`--no-interactive\` - Disable prompts
-- \`--skip-specs\` - Archive without spec updates
-- \`--yes\`/\`-y\` - Skip confirmation prompts (non-interactive archive)
-
-## Directory Structure
-
-\`\`\`
-openspec/
-â”œâ”€â”€ project.md              # Project conventions
-â”œâ”€â”€ specs/                  # Current truth - what IS built
-â”‚   â””â”€â”€ [capability]/       # Single focused capability
-â”‚       â”œâ”€â”€ spec.md         # Requirements and scenarios
-â”‚       â””â”€â”€ design.md       # Technical patterns
-â”œâ”€â”€ changes/                # Proposals - what SHOULD change
-â”‚   â”œâ”€â”€ [change-name]/
-â”‚   â”‚   â”œâ”€â”€ proposal.md     # Why, what, impact
-â”‚   â”‚   â”œâ”€â”€ tasks.md        # Implementation checklist
-â”‚   â”‚   â”œâ”€â”€ design.md       # Technical decisions (optional; see criteria)
-â”‚   â”‚   â””â”€â”€ specs/          # Delta changes
-â”‚   â”‚       â””â”€â”€ [capability]/
-â”‚   â”‚           â””â”€â”€ spec.md # ADDED/MODIFIED/REMOVED
-â”‚   â””â”€â”€ archive/            # Completed changes
-\`\`\`
-
-## Creating Change Proposals
-
-### Decision Tree
-
-\`\`\`
-New request?
-â”œâ”€ Bug fix restoring spec behavior? â†’ Fix directly
-â”œâ”€ Typo/format/comment? â†’ Fix directly  
-â”œâ”€ New feature/capability? â†’ Create proposal
-â”œâ”€ Breaking change? â†’ Create proposal
-â”œâ”€ Architecture change? â†’ Create proposal
-â””â”€ Unclear? â†’ Create proposal (safer)
-\`\`\`
-
-### Proposal Structure
-
-1. **Create directory:** \`changes/[change-id]/\` (kebab-case, verb-led, unique)
-
-2. **Write proposal.md:**
-\`\`\`markdown
-# Change: [Brief description of change]
-
-## Why
-[1-2 sentences on problem/opportunity]
-
-## What Changes
-- [Bullet list of changes]
-- [Mark breaking changes with **BREAKING**]
-
-## Impact
-- Affected specs: [list capabilities]
-- Affected code: [key files/systems]
-\`\`\`
-
-3. **Create spec deltas:** \`specs/[capability]/spec.md\`
-\`\`\`markdown
-## ADDED Requirements
-### Requirement: New Feature
-The system SHALL provide...
-
-#### Scenario: Success case
-- **WHEN** user performs action
-- **THEN** expected result
-
-## MODIFIED Requirements
-### Requirement: Existing Feature
-[Complete modified requirement]
-
-## REMOVED Requirements
-### Requirement: Old Feature
-**Reason**: [Why removing]
-**Migration**: [How to handle]
-\`\`\`
-If multiple capabilities are affected, create multiple delta files under \`changes/[change-id]/specs/<capability>/spec.md\`â€”one per capability.
-
-4. **Create tasks.md:**
-\`\`\`markdown
-## 1. Implementation
-- [ ] 1.1 Create database schema
-- [ ] 1.2 Implement API endpoint
-- [ ] 1.3 Add frontend component
-- [ ] 1.4 Write tests
-\`\`\`
-
-5. **Create design.md when needed:**
-Create \`design.md\` if any of the following apply; otherwise omit it:
-- Cross-cutting change (multiple services/modules) or a new architectural pattern
-- New external dependency or significant data model changes
-- Security, performance, or migration complexity
-- Ambiguity that benefits from technical decisions before coding
-
-Minimal \`design.md\` skeleton:
-\`\`\`markdown
-## Context
-[Background, constraints, stakeholders]
-
-## Goals / Non-Goals
-- Goals: [...]
-- Non-Goals: [...]
-
-## Decisions
-- Decision: [What and why]
-- Alternatives considered: [Options + rationale]
-
-## Risks / Trade-offs
-- [Risk] â†’ Mitigation
-
-## Migration Plan
-[Steps, rollback]
-
-## Open Questions
-- [...]
-\`\`\`
-
-## Spec File Format
-
-### Critical: Scenario Formatting
-
-**CORRECT** (use #### headers):
-\`\`\`markdown
-#### Scenario: User login success
-- **WHEN** valid credentials provided
-- **THEN** return JWT token
-\`\`\`
-
-**WRONG** (don't use bullets or bold):
-\`\`\`markdown
-- **Scenario: User login**  âŒ
-**Scenario**: User login     âŒ
-### Scenario: User login      âŒ
-\`\`\`
-
-Every requirement MUST have at least one scenario.
-
-### Requirement Wording
-- Use SHALL/MUST for normative requirements (avoid should/may unless intentionally non-normative)
-
-### Delta Operations
-
-- \`## ADDED Requirements\` - New capabilities
-- \`## MODIFIED Requirements\` - Changed behavior
-- \`## REMOVED Requirements\` - Deprecated features
-- \`## RENAMED Requirements\` - Name changes
-
-Headers matched with \`trim(header)\` - whitespace ignored.
-
-#### When to use ADDED vs MODIFIED
-- ADDED: Introduces a new capability or sub-capability that can stand alone as a requirement. Prefer ADDED when the change is orthogonal (e.g., adding "Slash Command Configuration") rather than altering the semantics of an existing requirement.
-- MODIFIED: Changes the behavior, scope, or acceptance criteria of an existing requirement. Always paste the full, updated requirement content (header + all scenarios). The archiver will replace the entire requirement with what you provide here; partial deltas will drop previous details.
-- RENAMED: Use when only the name changes. If you also change behavior, use RENAMED (name) plus MODIFIED (content) referencing the new name.
-
-Common pitfall: Using MODIFIED to add a new concern without including the previous text. This causes loss of detail at archive time. If you arenâ€™t explicitly changing the existing requirement, add a new requirement under ADDED instead.
-
-Authoring a MODIFIED requirement correctly:
-1) Locate the existing requirement in \`openspec/specs/<capability>/spec.md\`.
-2) Copy the entire requirement block (from \`### Requirement: ...\` through its scenarios).
-3) Paste it under \`## MODIFIED Requirements\` and edit to reflect the new behavior.
-4) Ensure the header text matches exactly (whitespace-insensitive) and keep at least one \`#### Scenario:\`.
-
-Example for RENAMED:
-\`\`\`markdown
-## RENAMED Requirements
-- FROM: \`### Requirement: Login\`
-- TO: \`### Requirement: User Authentication\`
-\`\`\`
-
-## Troubleshooting
-
-### Common Errors
-
-**"Change must have at least one delta"**
-- Check \`changes/[name]/specs/\` exists with .md files
-- Verify files have operation prefixes (## ADDED Requirements)
-
-**"Requirement must have at least one scenario"**
-- Check scenarios use \`#### Scenario:\` format (4 hashtags)
-- Don't use bullet points or bold for scenario headers
-
-**Silent scenario parsing failures**
-- Exact format required: \`#### Scenario: Name\`
-- Debug with: \`openspec show [change] --json --deltas-only\`
-
-### Validation Tips
-
-\`\`\`bash
-# Always use strict mode for comprehensive checks
-openspec validate [change] --strict --no-interactive
-
-# Debug delta parsing
-openspec show [change] --json | jq '.deltas'
-
-# Check specific requirement
-openspec show [spec] --json -r 1
-\`\`\`
-
-## Happy Path Script
-
-\`\`\`bash
-# 1) Explore current state
-openspec spec list --long
-openspec list
-# Optional full-text search:
-# rg -n "Requirement:|Scenario:" openspec/specs
-# rg -n "^#|Requirement:" openspec/changes
-
-# 2) Choose change id and scaffold
-CHANGE=add-two-factor-auth
-mkdir -p openspec/changes/$CHANGE/{specs/auth}
-printf "## Why\\n...\\n\\n## What Changes\\n- ...\\n\\n## Impact\\n- ...\\n" > openspec/changes/$CHANGE/proposal.md
-printf "## 1. Implementation\\n- [ ] 1.1 ...\\n" > openspec/changes/$CHANGE/tasks.md
-
-# 3) Add deltas (example)
-cat > openspec/changes/$CHANGE/specs/auth/spec.md << 'EOF'
-## ADDED Requirements
-### Requirement: Two-Factor Authentication
-Users MUST provide a second factor during login.
-
-#### Scenario: OTP required
-- **WHEN** valid credentials are provided
-- **THEN** an OTP challenge is required
-EOF
-
-# 4) Validate
-openspec validate $CHANGE --strict --no-interactive
-\`\`\`
-
-## Multi-Capability Example
-
-\`\`\`
-openspec/changes/add-2fa-notify/
-â”œâ”€â”€ proposal.md
-â”œâ”€â”€ tasks.md
-â””â”€â”€ specs/
-    â”œâ”€â”€ auth/
-    â”‚   â””â”€â”€ spec.md   # ADDED: Two-Factor Authentication
-    â””â”€â”€ notifications/
-        â””â”€â”€ spec.md   # ADDED: OTP email notification
-\`\`\`
-
-auth/spec.md
-\`\`\`markdown
-## ADDED Requirements
-### Requirement: Two-Factor Authentication
-...
-\`\`\`
-
-notifications/spec.md
-\`\`\`markdown
-## ADDED Requirements
-### Requirement: OTP Email Notification
-...
-\`\`\`
-
-## Best Practices
-
-### Simplicity First
-- Default to <100 lines of new code
-- Single-file implementations until proven insufficient
-- Avoid frameworks without clear justification
-- Choose boring, proven patterns
-
-### Complexity Triggers
-Only add complexity with:
-- Performance data showing current solution too slow
-- Concrete scale requirements (>1000 users, >100MB data)
-- Multiple proven use cases requiring abstraction
-
-### Clear References
-- Use \`file.ts:42\` format for code locations
-- Reference specs as \`specs/auth/spec.md\`
-- Link related changes and PRs
-
-### Capability Naming
-- Use verb-noun: \`user-auth\`, \`payment-capture\`
-- Single purpose per capability
-- 10-minute understandability rule
-- Split if description needs "AND"
-
-### Change ID Naming
-- Use kebab-case, short and descriptive: \`add-two-factor-auth\`
-- Prefer verb-led prefixes: \`add-\`, \`update-\`, \`remove-\`, \`refactor-\`
-- Ensure uniqueness; if taken, append \`-2\`, \`-3\`, etc.
-
-## Tool Selection Guide
-
-| Task | Tool | Why |
-|------|------|-----|
-| Find files by pattern | Glob | Fast pattern matching |
-| Search code content | Grep | Optimized regex search |
-| Read specific files | Read | Direct file access |
-| Explore unknown scope | Task | Multi-step investigation |
-
-## Error Recovery
-
-### Change Conflicts
-1. Run \`openspec list\` to see active changes
-2. Check for overlapping specs
-3. Coordinate with change owners
-4. Consider combining proposals
-
-### Validation Failures
-1. Run with \`--strict\` flag
-2. Check JSON output for details
-3. Verify spec file format
-4. Ensure scenarios properly formatted
-
-### Missing Context
-1. Read project.md first
-2. Check related specs
-3. Review recent archives
-4. Ask for clarification
-
-## Quick Reference
-
-### Stage Indicators
-- \`changes/\` - Proposed, not yet built
-- \`specs/\` - Built and deployed
-- \`archive/\` - Completed changes
-
-### File Purposes
-- \`proposal.md\` - Why and what
-- \`tasks.md\` - Implementation steps
-- \`design.md\` - Technical decisions
-- \`spec.md\` - Requirements and behavior
-
-### CLI Essentials
-\`\`\`bash
-openspec list              # What's in progress?
-openspec show [item]       # View details
-openspec validate --strict --no-interactive  # Is it correct?
-openspec archive <change-id> [--yes|-y]  # Mark complete (add --yes for automation)
-\`\`\`
-
-Remember: Specs are truth. Changes are proposals. Keep them in sync.
-`;
diff --git a/src/core/templates/claude-template.ts b/src/core/templates/claude-template.ts
deleted file mode 100644
index 41401a8..0000000
--- a/src/core/templates/claude-template.ts
+++ /dev/null
@@ -1 +0,0 @@
-export { agentsRootStubTemplate as claudeTemplate } from './agents-root-stub.js';
diff --git a/src/core/templates/cline-template.ts b/src/core/templates/cline-template.ts
deleted file mode 100644
index bc9cf9f..0000000
--- a/src/core/templates/cline-template.ts
+++ /dev/null
@@ -1 +0,0 @@
-export { agentsRootStubTemplate as clineTemplate } from './agents-root-stub.js';
diff --git a/src/core/templates/costrict-template.ts b/src/core/templates/costrict-template.ts
deleted file mode 100644
index 62f0ca5..0000000
--- a/src/core/templates/costrict-template.ts
+++ /dev/null
@@ -1 +0,0 @@
-export { agentsRootStubTemplate as costrictTemplate } from './agents-root-stub.js';
diff --git a/src/core/templates/index.ts b/src/core/templates/index.ts
index 8dab4b5..1bcc205 100644
--- a/src/core/templates/index.ts
+++ b/src/core/templates/index.ts
@@ -1,50 +1,28 @@
-import { agentsTemplate } from './agents-template.js';
-import { projectTemplate, ProjectContext } from './project-template.js';
-import { claudeTemplate } from './claude-template.js';
-import { clineTemplate } from './cline-template.js';
-import { costrictTemplate } from './costrict-template.js';
-import { agentsRootStubTemplate } from './agents-root-stub.js';
-import { getSlashCommandBody, SlashCommandId } from './slash-command-templates.js';
-
-export interface Template {
-  path: string;
-  content: string | ((context: ProjectContext) => string);
-}
-
-export class TemplateManager {
-  static getTemplates(context: ProjectContext = {}): Template[] {
-    return [
-      {
-        path: 'AGENTS.md',
-        content: agentsTemplate
-      },
-      {
-        path: 'project.md',
-        content: projectTemplate(context)
-      }
-    ];
-  }
-
-  static getClaudeTemplate(): string {
-    return claudeTemplate;
-  }
-
-  static getClineTemplate(): string {
-    return clineTemplate;
-  }
-
-  static getCostrictTemplate(): string {
-    return costrictTemplate;
-  }
-
-  static getAgentsStandardTemplate(): string {
-    return agentsRootStubTemplate;
-  }
-
-  static getSlashCommandBody(id: SlashCommandId): string {
-    return getSlashCommandBody(id);
-  }
-}
-
-export { ProjectContext } from './project-template.js';
-export type { SlashCommandId } from './slash-command-templates.js';
+/**
+ * Template exports for OpenSpec.
+ *
+ * The old config file templates (AGENTS.md, project.md, claude-template, etc.)
+ * have been removed. The skill-based workflow uses skill-templates.ts directly.
+ */
+
+// Re-export skill templates for convenience
+export {
+  getExploreSkillTemplate,
+  getNewChangeSkillTemplate,
+  getContinueChangeSkillTemplate,
+  getApplyChangeSkillTemplate,
+  getFfChangeSkillTemplate,
+  getSyncSpecsSkillTemplate,
+  getArchiveChangeSkillTemplate,
+  getBulkArchiveChangeSkillTemplate,
+  getVerifyChangeSkillTemplate,
+  getOpsxExploreCommandTemplate,
+  getOpsxNewCommandTemplate,
+  getOpsxContinueCommandTemplate,
+  getOpsxApplyCommandTemplate,
+  getOpsxFfCommandTemplate,
+  getOpsxSyncCommandTemplate,
+  getOpsxArchiveCommandTemplate,
+  getOpsxBulkArchiveCommandTemplate,
+  getOpsxVerifyCommandTemplate,
+} from './skill-templates.js';
diff --git a/src/core/templates/project-template.ts b/src/core/templates/project-template.ts
deleted file mode 100644
index fc7cb73..0000000
--- a/src/core/templates/project-template.ts
+++ /dev/null
@@ -1,38 +0,0 @@
-export interface ProjectContext {
-  projectName?: string;
-  description?: string;
-  techStack?: string[];
-  conventions?: string;
-}
-
-export const projectTemplate = (context: ProjectContext = {}) => `# ${context.projectName || 'Project'} Context
-
-## Purpose
-${context.description || '[Describe your project\'s purpose and goals]'}
-
-## Tech Stack
-${context.techStack?.length ? context.techStack.map(tech => `- ${tech}`).join('\n') : '- [List your primary technologies]\n- [e.g., TypeScript, React, Node.js]'}
-
-## Project Conventions
-
-### Code Style
-[Describe your code style preferences, formatting rules, and naming conventions]
-
-### Architecture Patterns
-[Document your architectural decisions and patterns]
-
-### Testing Strategy
-[Explain your testing approach and requirements]
-
-### Git Workflow
-[Describe your branching strategy and commit conventions]
-
-## Domain Context
-[Add domain-specific knowledge that AI assistants need to understand]
-
-## Important Constraints
-[List any technical, business, or regulatory constraints]
-
-## External Dependencies
-[Document key external services, APIs, or systems]
-`;
\ No newline at end of file
diff --git a/src/core/templates/skill-templates.ts b/src/core/templates/skill-templates.ts
index bea1abc..3330d3a 100644
--- a/src/core/templates/skill-templates.ts
+++ b/src/core/templates/skill-templates.ts
@@ -12,6 +12,9 @@ export interface SkillTemplate {
   name: string;
   description: string;
   instructions: string;
+  license?: string;
+  compatibility?: string;
+  metadata?: Record<string, string>;
 }
 
 /**
@@ -300,7 +303,10 @@ But this summary is optional. Sometimes the thinking IS the value.
 - **Don't auto-capture** - Offer to save insights, don't just do it
 - **Do visualize** - A good diagram is worth many paragraphs
 - **Do explore the codebase** - Ground discussions in reality
-- **Do question assumptions** - Including the user's and your own`
+- **Do question assumptions** - Including the user's and your own`,
+    license: 'MIT',
+    compatibility: 'Requires openspec CLI.',
+    metadata: { author: 'openspec', version: '1.0' },
   };
 }
 
@@ -332,7 +338,6 @@ export function getNewChangeSkillTemplate(): SkillTemplate {
    Use the default schema (omit \`--schema\`) unless the user explicitly requests a different workflow.
 
    **Use a different schema only if the user mentions:**
-   - "tdd" or "test-driven" â†’ use \`--schema tdd\`
    - A specific schema name â†’ use \`--schema <name>\`
    - "show workflows" or "what workflows" â†’ run \`openspec schemas --json\` and let them choose
 
@@ -352,7 +357,7 @@ export function getNewChangeSkillTemplate(): SkillTemplate {
    This shows which artifacts need to be created and which are ready (dependencies satisfied).
 
 5. **Get instructions for the first artifact**
-   The first artifact depends on the schema (e.g., \`proposal\` for spec-driven, \`spec\` for tdd).
+   The first artifact depends on the schema (e.g., \`proposal\` for spec-driven).
    Check the status output to find the first artifact with status "ready".
    \`\`\`bash
    openspec instructions <first-artifact-id> --change "<name>"
@@ -375,7 +380,10 @@ After completing the steps, summarize:
 - Do NOT advance beyond showing the first artifact template
 - If the name is invalid (not kebab-case), ask for a valid name
 - If a change with that name already exists, suggest continuing that change instead
-- Pass --schema if using a non-default workflow`
+- Pass --schema if using a non-default workflow`,
+    license: 'MIT',
+    compatibility: 'Requires openspec CLI.',
+    metadata: { author: 'openspec', version: '1.0' },
   };
 }
 
@@ -412,7 +420,7 @@ export function getContinueChangeSkillTemplate(): SkillTemplate {
    openspec status --change "<name>" --json
    \`\`\`
    Parse the JSON to understand current state. The response includes:
-   - \`schemaName\`: The workflow schema being used (e.g., "spec-driven", "tdd")
+   - \`schemaName\`: The workflow schema being used (e.g., "spec-driven")
    - \`artifacts\`: Array of artifacts with their status ("done", "ready", "blocked")
    - \`isComplete\`: Boolean indicating if all artifacts are complete
 
@@ -478,16 +486,10 @@ Common artifact patterns:
 **spec-driven schema** (proposal â†’ specs â†’ design â†’ tasks):
 - **proposal.md**: Ask user about the change if not clear. Fill in Why, What Changes, Capabilities, Impact.
   - The Capabilities section is critical - each capability listed will need a spec file.
-- **specs/*.md**: Create one spec per capability listed in the proposal.
+- **specs/<capability>/spec.md**: Create one spec per capability listed in the proposal's Capabilities section (use the capability name, not the change name).
 - **design.md**: Document technical decisions, architecture, and implementation approach.
 - **tasks.md**: Break down implementation into checkboxed tasks.
 
-**tdd schema** (spec â†’ tests â†’ implementation â†’ docs):
-- **spec.md**: Feature specification defining what to build.
-- **tests/*.test.ts**: Write tests BEFORE implementation (TDD red phase).
-- **src/*.ts**: Implement to make tests pass (TDD green phase).
-- **docs/*.md**: Document the implemented feature.
-
 For other schemas, follow the \`instruction\` field from the CLI output.
 
 **Guardrails**
@@ -499,7 +501,10 @@ For other schemas, follow the \`instruction\` field from the CLI output.
 - Use the schema's artifact sequence, don't assume specific artifact names
 - **IMPORTANT**: \`context\` and \`rules\` are constraints for YOU, not content for the file
   - Do NOT copy \`<context>\`, \`<rules>\`, \`<project_context>\` blocks into the artifact
-  - These guide what you write, but should never appear in the output`
+  - These guide what you write, but should never appear in the output`,
+    license: 'MIT',
+    compatibility: 'Requires openspec CLI.',
+    metadata: { author: 'openspec', version: '1.0' },
   };
 }
 
@@ -531,7 +536,7 @@ export function getApplyChangeSkillTemplate(): SkillTemplate {
    openspec status --change "<name>" --json
    \`\`\`
    Parse the JSON to understand:
-   - \`schemaName\`: The workflow being used (e.g., "spec-driven", "tdd")
+   - \`schemaName\`: The workflow being used (e.g., "spec-driven")
    - Which artifact contains the tasks (typically "tasks" for spec-driven, check status for others)
 
 3. **Get apply instructions**
@@ -556,7 +561,6 @@ export function getApplyChangeSkillTemplate(): SkillTemplate {
    Read the files listed in \`contextFiles\` from the apply instructions output.
    The files depend on the schema being used:
    - **spec-driven**: proposal, specs, design, tasks
-   - **tdd**: spec, tests, implementation, docs
    - Other schemas: follow the contextFiles from CLI output
 
 5. **Show current progress**
@@ -656,7 +660,10 @@ What would you like to do?
 This skill supports the "actions on a change" model:
 
 - **Can be invoked anytime**: Before all artifacts are done (if tasks exist), after partial implementation, interleaved with other actions
-- **Allows artifact updates**: If implementation reveals design issues, suggest updating artifacts - not phase-locked, work fluidly`
+- **Allows artifact updates**: If implementation reveals design issues, suggest updating artifacts - not phase-locked, work fluidly`,
+    license: 'MIT',
+    compatibility: 'Requires openspec CLI.',
+    metadata: { author: 'openspec', version: '1.0' },
   };
 }
 
@@ -757,7 +764,10 @@ After completing all artifacts, summarize:
 - Always read dependency artifacts before creating a new one
 - If context is critically unclear, ask the user - but prefer making reasonable decisions to keep momentum
 - If a change with that name already exists, suggest continuing that change instead
-- Verify each artifact file exists after writing before proceeding to next`
+- Verify each artifact file exists after writing before proceeding to next`,
+    license: 'MIT',
+    compatibility: 'Requires openspec CLI.',
+    metadata: { author: 'openspec', version: '1.0' },
   };
 }
 
@@ -895,10 +905,552 @@ Main specs are now updated. The change remains active - archive when implementat
 - Preserve existing content not mentioned in delta
 - If something is unclear, ask for clarification
 - Show what you're changing as you go
-- The operation should be idempotent - running twice should give same result`
+- The operation should be idempotent - running twice should give same result`,
+    license: 'MIT',
+    compatibility: 'Requires openspec CLI.',
+    metadata: { author: 'openspec', version: '1.0' },
   };
 }
 
+/**
+ * Template for openspec-onboard skill
+ * Guided onboarding through the complete OpenSpec workflow
+ */
+export function getOnboardSkillTemplate(): SkillTemplate {
+  return {
+    name: 'openspec-onboard',
+    description: 'Guided onboarding for OpenSpec - walk through a complete workflow cycle with narration and real codebase work.',
+    instructions: getOnboardInstructions(),
+    license: 'MIT',
+    compatibility: 'Requires openspec CLI.',
+    metadata: { author: 'openspec', version: '1.0' },
+  };
+}
+
+/**
+ * Shared onboarding instructions used by both skill and command templates.
+ */
+function getOnboardInstructions(): string {
+  return `Guide the user through their first complete OpenSpec workflow cycle. This is a teaching experienceâ€”you'll do real work in their codebase while explaining each step.
+
+---
+
+## Preflight
+
+Before starting, check if OpenSpec is initialized:
+
+\`\`\`bash
+openspec status --json 2>&1 || echo "NOT_INITIALIZED"
+\`\`\`
+
+**If not initialized:**
+> OpenSpec isn't set up in this project yet. Run \`openspec init\` first, then come back to \`/opsx:onboard\`.
+
+Stop here if not initialized.
+
+---
+
+## Phase 1: Welcome
+
+Display:
+
+\`\`\`
+## Welcome to OpenSpec!
+
+I'll walk you through a complete change cycleâ€”from idea to implementationâ€”using a real task in your codebase. Along the way, you'll learn the workflow by doing it.
+
+**What we'll do:**
+1. Pick a small, real task in your codebase
+2. Explore the problem briefly
+3. Create a change (the container for our work)
+4. Build the artifacts: proposal â†’ specs â†’ design â†’ tasks
+5. Implement the tasks
+6. Archive the completed change
+
+**Time:** ~15-20 minutes
+
+Let's start by finding something to work on.
+\`\`\`
+
+---
+
+## Phase 2: Task Selection
+
+### Codebase Analysis
+
+Scan the codebase for small improvement opportunities. Look for:
+
+1. **TODO/FIXME comments** - Search for \`TODO\`, \`FIXME\`, \`HACK\`, \`XXX\` in code files
+2. **Missing error handling** - \`catch\` blocks that swallow errors, risky operations without try-catch
+3. **Functions without tests** - Cross-reference \`src/\` with test directories
+4. **Type issues** - \`any\` types in TypeScript files (\`: any\`, \`as any\`)
+5. **Debug artifacts** - \`console.log\`, \`console.debug\`, \`debugger\` statements in non-debug code
+6. **Missing validation** - User input handlers without validation
+
+Also check recent git activity:
+\`\`\`bash
+git log --oneline -10 2>/dev/null || echo "No git history"
+\`\`\`
+
+### Present Suggestions
+
+From your analysis, present 3-4 specific suggestions:
+
+\`\`\`
+## Task Suggestions
+
+Based on scanning your codebase, here are some good starter tasks:
+
+**1. [Most promising task]**
+   Location: \`src/path/to/file.ts:42\`
+   Scope: ~1-2 files, ~20-30 lines
+   Why it's good: [brief reason]
+
+**2. [Second task]**
+   Location: \`src/another/file.ts\`
+   Scope: ~1 file, ~15 lines
+   Why it's good: [brief reason]
+
+**3. [Third task]**
+   Location: [location]
+   Scope: [estimate]
+   Why it's good: [brief reason]
+
+**4. Something else?**
+   Tell me what you'd like to work on.
+
+Which task interests you? (Pick a number or describe your own)
+\`\`\`
+
+**If nothing found:** Fall back to asking what the user wants to build:
+> I didn't find obvious quick wins in your codebase. What's something small you've been meaning to add or fix?
+
+### Scope Guardrail
+
+If the user picks or describes something too large (major feature, multi-day work):
+
+\`\`\`
+That's a valuable task, but it's probably larger than ideal for your first OpenSpec run-through.
+
+For learning the workflow, smaller is betterâ€”it lets you see the full cycle without getting stuck in implementation details.
+
+**Options:**
+1. **Slice it smaller** - What's the smallest useful piece of [their task]? Maybe just [specific slice]?
+2. **Pick something else** - One of the other suggestions, or a different small task?
+3. **Do it anyway** - If you really want to tackle this, we can. Just know it'll take longer.
+
+What would you prefer?
+\`\`\`
+
+Let the user override if they insistâ€”this is a soft guardrail.
+
+---
+
+## Phase 3: Explore Demo
+
+Once a task is selected, briefly demonstrate explore mode:
+
+\`\`\`
+Before we create a change, let me quickly show you **explore mode**â€”it's how you think through problems before committing to a direction.
+\`\`\`
+
+Spend 1-2 minutes investigating the relevant code:
+- Read the file(s) involved
+- Draw a quick ASCII diagram if it helps
+- Note any considerations
+
+\`\`\`
+## Quick Exploration
+
+[Your brief analysisâ€”what you found, any considerations]
+
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚   [Optional: ASCII diagram if helpful]  â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+
+Explore mode (\`/opsx:explore\`) is for this kind of thinkingâ€”investigating before implementing. You can use it anytime you need to think through a problem.
+
+Now let's create a change to hold our work.
+\`\`\`
+
+**PAUSE** - Wait for user acknowledgment before proceeding.
+
+---
+
+## Phase 4: Create the Change
+
+**EXPLAIN:**
+\`\`\`
+## Creating a Change
+
+A "change" in OpenSpec is a container for all the thinking and planning around a piece of work. It lives in \`openspec/changes/<name>/\` and holds your artifactsâ€”proposal, specs, design, tasks.
+
+Let me create one for our task.
+\`\`\`
+
+**DO:** Create the change with a derived kebab-case name:
+\`\`\`bash
+openspec new change "<derived-name>"
+\`\`\`
+
+**SHOW:**
+\`\`\`
+Created: \`openspec/changes/<name>/\`
+
+The folder structure:
+\`\`\`
+openspec/changes/<name>/
+â”œâ”€â”€ proposal.md    â† Why we're doing this (empty, we'll fill it)
+â”œâ”€â”€ design.md      â† How we'll build it (empty)
+â”œâ”€â”€ specs/         â† Detailed requirements (empty)
+â””â”€â”€ tasks.md       â† Implementation checklist (empty)
+\`\`\`
+
+Now let's fill in the first artifactâ€”the proposal.
+\`\`\`
+
+---
+
+## Phase 5: Proposal
+
+**EXPLAIN:**
+\`\`\`
+## The Proposal
+
+The proposal captures **why** we're making this change and **what** it involves at a high level. It's the "elevator pitch" for the work.
+
+I'll draft one based on our task.
+\`\`\`
+
+**DO:** Draft the proposal content (don't save yet):
+
+\`\`\`
+Here's a draft proposal:
+
+---
+
+## Why
+
+[1-2 sentences explaining the problem/opportunity]
+
+## What Changes
+
+[Bullet points of what will be different]
+
+## Capabilities
+
+### New Capabilities
+- \`<capability-name>\`: [brief description]
+
+### Modified Capabilities
+<!-- If modifying existing behavior -->
+
+## Impact
+
+- \`src/path/to/file.ts\`: [what changes]
+- [other files if applicable]
+
+---
+
+Does this capture the intent? I can adjust before we save it.
+\`\`\`
+
+**PAUSE** - Wait for user approval/feedback.
+
+After approval, save the proposal:
+\`\`\`bash
+openspec instructions proposal --change "<name>" --json
+\`\`\`
+Then write the content to \`openspec/changes/<name>/proposal.md\`.
+
+\`\`\`
+Proposal saved. This is your "why" documentâ€”you can always come back and refine it as understanding evolves.
+
+Next up: specs.
+\`\`\`
+
+---
+
+## Phase 6: Specs
+
+**EXPLAIN:**
+\`\`\`
+## Specs
+
+Specs define **what** we're building in precise, testable terms. They use a requirement/scenario format that makes expected behavior crystal clear.
+
+For a small task like this, we might only need one spec file.
+\`\`\`
+
+**DO:** Create the spec file:
+\`\`\`bash
+mkdir -p openspec/changes/<name>/specs/<capability-name>
+\`\`\`
+
+Draft the spec content:
+
+\`\`\`
+Here's the spec:
+
+---
+
+## ADDED Requirements
+
+### Requirement: <Name>
+
+<Description of what the system should do>
+
+#### Scenario: <Scenario name>
+
+- **WHEN** <trigger condition>
+- **THEN** <expected outcome>
+- **AND** <additional outcome if needed>
+
+---
+
+This formatâ€”WHEN/THEN/ANDâ€”makes requirements testable. You can literally read them as test cases.
+\`\`\`
+
+Save to \`openspec/changes/<name>/specs/<capability>/spec.md\`.
+
+---
+
+## Phase 7: Design
+
+**EXPLAIN:**
+\`\`\`
+## Design
+
+The design captures **how** we'll build itâ€”technical decisions, tradeoffs, approach.
+
+For small changes, this might be brief. That's fineâ€”not every change needs deep design discussion.
+\`\`\`
+
+**DO:** Draft design.md:
+
+\`\`\`
+Here's the design:
+
+---
+
+## Context
+
+[Brief context about the current state]
+
+## Goals / Non-Goals
+
+**Goals:**
+- [What we're trying to achieve]
+
+**Non-Goals:**
+- [What's explicitly out of scope]
+
+## Decisions
+
+### Decision 1: [Key decision]
+
+[Explanation of approach and rationale]
+
+---
+
+For a small task, this captures the key decisions without over-engineering.
+\`\`\`
+
+Save to \`openspec/changes/<name>/design.md\`.
+
+---
+
+## Phase 8: Tasks
+
+**EXPLAIN:**
+\`\`\`
+## Tasks
+
+Finally, we break the work into implementation tasksâ€”checkboxes that drive the apply phase.
+
+These should be small, clear, and in logical order.
+\`\`\`
+
+**DO:** Generate tasks based on specs and design:
+
+\`\`\`
+Here are the implementation tasks:
+
+---
+
+## 1. [Category or file]
+
+- [ ] 1.1 [Specific task]
+- [ ] 1.2 [Specific task]
+
+## 2. Verify
+
+- [ ] 2.1 [Verification step]
+
+---
+
+Each checkbox becomes a unit of work in the apply phase. Ready to implement?
+\`\`\`
+
+**PAUSE** - Wait for user to confirm they're ready to implement.
+
+Save to \`openspec/changes/<name>/tasks.md\`.
+
+---
+
+## Phase 9: Apply (Implementation)
+
+**EXPLAIN:**
+\`\`\`
+## Implementation
+
+Now we implement each task, checking them off as we go. I'll announce each one and occasionally note how the specs/design informed the approach.
+\`\`\`
+
+**DO:** For each task:
+
+1. Announce: "Working on task N: [description]"
+2. Implement the change in the codebase
+3. Reference specs/design naturally: "The spec says X, so I'm doing Y"
+4. Mark complete in tasks.md: \`- [ ]\` â†’ \`- [x]\`
+5. Brief status: "âœ“ Task N complete"
+
+Keep narration lightâ€”don't over-explain every line of code.
+
+After all tasks:
+
+\`\`\`
+## Implementation Complete
+
+All tasks done:
+- [x] Task 1
+- [x] Task 2
+- [x] ...
+
+The change is implemented! One more stepâ€”let's archive it.
+\`\`\`
+
+---
+
+## Phase 10: Archive
+
+**EXPLAIN:**
+\`\`\`
+## Archiving
+
+When a change is complete, we archive it. This moves it from \`openspec/changes/\` to \`openspec/changes/archive/YYYY-MM-DD-<name>/\`.
+
+Archived changes become your project's decision historyâ€”you can always find them later to understand why something was built a certain way.
+\`\`\`
+
+**DO:**
+\`\`\`bash
+openspec archive "<name>"
+\`\`\`
+
+**SHOW:**
+\`\`\`
+Archived to: \`openspec/changes/archive/YYYY-MM-DD-<name>/\`
+
+The change is now part of your project's history. The code is in your codebase, the decision record is preserved.
+\`\`\`
+
+---
+
+## Phase 11: Recap & Next Steps
+
+\`\`\`
+## Congratulations!
+
+You just completed a full OpenSpec cycle:
+
+1. **Explore** - Thought through the problem
+2. **New** - Created a change container
+3. **Proposal** - Captured WHY
+4. **Specs** - Defined WHAT in detail
+5. **Design** - Decided HOW
+6. **Tasks** - Broke it into steps
+7. **Apply** - Implemented the work
+8. **Archive** - Preserved the record
+
+This same rhythm works for any size changeâ€”a small fix or a major feature.
+
+---
+
+## Command Reference
+
+| Command | What it does |
+|---------|--------------|
+| \`/opsx:explore\` | Think through problems before/during work |
+| \`/opsx:new\` | Start a new change, step through artifacts |
+| \`/opsx:ff\` | Fast-forward: create all artifacts at once |
+| \`/opsx:continue\` | Continue working on an existing change |
+| \`/opsx:apply\` | Implement tasks from a change |
+| \`/opsx:verify\` | Verify implementation matches artifacts |
+| \`/opsx:archive\` | Archive a completed change |
+
+---
+
+## What's Next?
+
+Try \`/opsx:new\` or \`/opsx:ff\` on something you actually want to build. You've got the rhythm now!
+\`\`\`
+
+---
+
+## Graceful Exit Handling
+
+### User wants to stop mid-way
+
+If the user says they need to stop, want to pause, or seem disengaged:
+
+\`\`\`
+No problem! Your change is saved at \`openspec/changes/<name>/\`.
+
+To pick up where we left off later:
+- \`/opsx:continue <name>\` - Resume artifact creation
+- \`/opsx:apply <name>\` - Jump to implementation (if tasks exist)
+
+The work won't be lost. Come back whenever you're ready.
+\`\`\`
+
+Exit gracefully without pressure.
+
+### User just wants command reference
+
+If the user says they just want to see the commands or skip the tutorial:
+
+\`\`\`
+## OpenSpec Quick Reference
+
+| Command | What it does |
+|---------|--------------|
+| \`/opsx:explore\` | Think through problems (no code changes) |
+| \`/opsx:new <name>\` | Start a new change, step by step |
+| \`/opsx:ff <name>\` | Fast-forward: all artifacts at once |
+| \`/opsx:continue <name>\` | Continue an existing change |
+| \`/opsx:apply <name>\` | Implement tasks |
+| \`/opsx:verify <name>\` | Verify implementation |
+| \`/opsx:archive <name>\` | Archive when done |
+
+Try \`/opsx:new\` to start your first change, or \`/opsx:ff\` if you want to move fast.
+\`\`\`
+
+Exit gracefully.
+
+---
+
+## Guardrails
+
+- **Follow the EXPLAIN â†’ DO â†’ SHOW â†’ PAUSE pattern** at key transitions (after explore, after proposal draft, after tasks, after archive)
+- **Keep narration light** during implementationâ€”teach without lecturing
+- **Don't skip phases** even if the change is smallâ€”the goal is teaching the workflow
+- **Pause for acknowledgment** at marked points, but don't over-pause
+- **Handle exits gracefully**â€”never pressure the user to continue
+- **Use real codebase tasks**â€”don't simulate or use fake examples
+- **Adjust scope gently**â€”guide toward smaller tasks but respect user choice`;
+}
+
 // -----------------------------------------------------------------------------
 // Slash Command Templates
 // -----------------------------------------------------------------------------
@@ -1120,7 +1672,6 @@ export function getOpsxNewCommandTemplate(): CommandTemplate {
    Use the default schema (omit \`--schema\`) unless the user explicitly requests a different workflow.
 
    **Use a different schema only if the user mentions:**
-   - "tdd" or "test-driven" â†’ use \`--schema tdd\`
    - A specific schema name â†’ use \`--schema <name>\`
    - "show workflows" or "what workflows" â†’ run \`openspec schemas --json\` and let them choose
 
@@ -1200,7 +1751,7 @@ export function getOpsxContinueCommandTemplate(): CommandTemplate {
    openspec status --change "<name>" --json
    \`\`\`
    Parse the JSON to understand current state. The response includes:
-   - \`schemaName\`: The workflow schema being used (e.g., "spec-driven", "tdd")
+   - \`schemaName\`: The workflow schema being used (e.g., "spec-driven")
    - \`artifacts\`: Array of artifacts with their status ("done", "ready", "blocked")
    - \`isComplete\`: Boolean indicating if all artifacts are complete
 
@@ -1266,16 +1817,10 @@ Common artifact patterns:
 **spec-driven schema** (proposal â†’ specs â†’ design â†’ tasks):
 - **proposal.md**: Ask user about the change if not clear. Fill in Why, What Changes, Capabilities, Impact.
   - The Capabilities section is critical - each capability listed will need a spec file.
-- **specs/*.md**: Create one spec per capability listed in the proposal.
+- **specs/<capability>/spec.md**: Create one spec per capability listed in the proposal's Capabilities section (use the capability name, not the change name).
 - **design.md**: Document technical decisions, architecture, and implementation approach.
 - **tasks.md**: Break down implementation into checkboxed tasks.
 
-**tdd schema** (spec â†’ tests â†’ implementation â†’ docs):
-- **spec.md**: Feature specification defining what to build.
-- **tests/*.test.ts**: Write tests BEFORE implementation (TDD red phase).
-- **src/*.ts**: Implement to make tests pass (TDD green phase).
-- **docs/*.md**: Document the implemented feature.
-
 For other schemas, follow the \`instruction\` field from the CLI output.
 
 **Guardrails**
@@ -1320,7 +1865,7 @@ export function getOpsxApplyCommandTemplate(): CommandTemplate {
    openspec status --change "<name>" --json
    \`\`\`
    Parse the JSON to understand:
-   - \`schemaName\`: The workflow being used (e.g., "spec-driven", "tdd")
+   - \`schemaName\`: The workflow being used (e.g., "spec-driven")
    - Which artifact contains the tasks (typically "tasks" for spec-driven, check status for others)
 
 3. **Get apply instructions**
@@ -1345,7 +1890,6 @@ export function getOpsxApplyCommandTemplate(): CommandTemplate {
    Read the files listed in \`contextFiles\` from the apply instructions output.
    The files depend on the schema being used:
    - **spec-driven**: proposal, specs, design, tasks
-   - **tdd**: spec, tests, implementation, docs
    - Other schemas: follow the contextFiles from CLI output
 
 5. **Show current progress**
@@ -1659,7 +2203,10 @@ All artifacts complete. All tasks complete.
 - Preserve .openspec.yaml when moving to archive (it moves with the directory)
 - Show clear summary of what happened
 - If sync is requested, use openspec-sync-specs approach (agent-driven)
-- If delta specs exist, always run the sync assessment and show the combined summary before prompting`
+- If delta specs exist, always run the sync assessment and show the combined summary before prompting`,
+    license: 'MIT',
+    compatibility: 'Requires openspec CLI.',
+    metadata: { author: 'openspec', version: '1.0' },
   };
 }
 
@@ -1905,7 +2452,10 @@ No active changes found. Use \`/opsx:new\` to create a new change.
 - Track and report all outcomes (success/skip/fail)
 - Preserve .openspec.yaml when moving to archive
 - Archive directory target uses current date: YYYY-MM-DD-<name>
-- If archive target exists, fail that change but continue with others`
+- If archive target exists, fail that change but continue with others`,
+    license: 'MIT',
+    compatibility: 'Requires openspec CLI.',
+    metadata: { author: 'openspec', version: '1.0' },
   };
 }
 
@@ -2077,7 +2627,7 @@ export function getVerifyChangeSkillTemplate(): SkillTemplate {
    openspec status --change "<name>" --json
    \`\`\`
    Parse the JSON to understand:
-   - \`schemaName\`: The workflow being used (e.g., "spec-driven", "tdd")
+   - \`schemaName\`: The workflow being used (e.g., "spec-driven")
    - Which artifacts exist for this change
 
 3. **Get the change directory and load artifacts**
@@ -2212,7 +2762,10 @@ Use clear markdown with:
 - Grouped lists for issues (CRITICAL/WARNING/SUGGESTION)
 - Code references in format: \`file.ts:123\`
 - Specific, actionable recommendations
-- No vague suggestions like "consider reviewing"`
+- No vague suggestions like "consider reviewing"`,
+    license: 'MIT',
+    compatibility: 'Requires openspec CLI.',
+    metadata: { author: 'openspec', version: '1.0' },
   };
 }
 
@@ -2378,6 +2931,20 @@ Target archive directory already exists.
   };
 }
 
+/**
+ * Template for /opsx:onboard slash command
+ * Guided onboarding through the complete OpenSpec workflow
+ */
+export function getOpsxOnboardCommandTemplate(): CommandTemplate {
+  return {
+    name: 'OPSX: Onboard',
+    description: 'Guided onboarding - walk through a complete OpenSpec workflow cycle with narration',
+    category: 'Workflow',
+    tags: ['workflow', 'onboarding', 'tutorial', 'learning'],
+    content: getOnboardInstructions(),
+  };
+}
+
 /**
  * Template for /opsx:bulk-archive slash command
  */
@@ -2655,7 +3222,7 @@ export function getOpsxVerifyCommandTemplate(): CommandTemplate {
    openspec status --change "<name>" --json
    \`\`\`
    Parse the JSON to understand:
-   - \`schemaName\`: The workflow being used (e.g., "spec-driven", "tdd")
+   - \`schemaName\`: The workflow being used (e.g., "spec-driven")
    - Which artifacts exist for this change
 
 3. **Get the change directory and load artifacts**
diff --git a/src/core/templates/slash-command-templates.ts b/src/core/templates/slash-command-templates.ts
deleted file mode 100644
index 980e5bc..0000000
--- a/src/core/templates/slash-command-templates.ts
+++ /dev/null
@@ -1,60 +0,0 @@
-export type SlashCommandId = 'proposal' | 'apply' | 'archive';
-
-const baseGuardrails = `**Guardrails**
-- Favor straightforward, minimal implementations first and add complexity only when it is requested or clearly required.
-- Keep changes tightly scoped to the requested outcome.
-- Refer to \`openspec/AGENTS.md\` (located inside the \`openspec/\` directoryâ€”run \`ls openspec\` or \`openspec update\` if you don't see it) if you need additional OpenSpec conventions or clarifications.`;
-
-const proposalGuardrails = `${baseGuardrails}\n- Identify any vague or ambiguous details and ask the necessary follow-up questions before editing files.
-- Do not write any code during the proposal stage. Only create design documents (proposal.md, tasks.md, design.md, and spec deltas). Implementation happens in the apply stage after approval.`;
-
-const proposalSteps = `**Steps**
-1. Review \`openspec/project.md\`, run \`openspec list\` and \`openspec list --specs\`, and inspect related code or docs (e.g., via \`rg\`/\`ls\`) to ground the proposal in current behaviour; note any gaps that require clarification.
-2. Choose a unique verb-led \`change-id\` and scaffold \`proposal.md\`, \`tasks.md\`, and \`design.md\` (when needed) under \`openspec/changes/<id>/\`.
-3. Map the change into concrete capabilities or requirements, breaking multi-scope efforts into distinct spec deltas with clear relationships and sequencing.
-4. Capture architectural reasoning in \`design.md\` when the solution spans multiple systems, introduces new patterns, or demands trade-off discussion before committing to specs.
-5. Draft spec deltas in \`changes/<id>/specs/<capability>/spec.md\` (one folder per capability) using \`## ADDED|MODIFIED|REMOVED Requirements\` with at least one \`#### Scenario:\` per requirement and cross-reference related capabilities when relevant.
-6. Draft \`tasks.md\` as an ordered list of small, verifiable work items that deliver user-visible progress, include validation (tests, tooling), and highlight dependencies or parallelizable work.
-7. Validate with \`openspec validate <id> --strict --no-interactive\` and resolve every issue before sharing the proposal.`;
-
-
-const proposalReferences = `**Reference**
-- Use \`openspec show <id> --json --deltas-only\` or \`openspec show <spec> --type spec\` to inspect details when validation fails.
-- Search existing requirements with \`rg -n "Requirement:|Scenario:" openspec/specs\` before writing new ones.
-- Explore the codebase with \`rg <keyword>\`, \`ls\`, or direct file reads so proposals align with current implementation realities.`;
-
-const applySteps = `**Steps**
-Track these steps as TODOs and complete them one by one.
-1. Read \`changes/<id>/proposal.md\`, \`design.md\` (if present), and \`tasks.md\` to confirm scope and acceptance criteria.
-2. Work through tasks sequentially, keeping edits minimal and focused on the requested change.
-3. Confirm completion before updating statusesâ€”make sure every item in \`tasks.md\` is finished.
-4. Update the checklist after all work is done so each task is marked \`- [x]\` and reflects reality.
-5. Reference \`openspec list\` or \`openspec show <item>\` when additional context is required.`;
-
-const applyReferences = `**Reference**
-- Use \`openspec show <id> --json --deltas-only\` if you need additional context from the proposal while implementing.`;
-
-const archiveSteps = `**Steps**
-1. Determine the change ID to archive:
-   - If this prompt already includes a specific change ID (for example inside a \`<ChangeId>\` block populated by slash-command arguments), use that value after trimming whitespace.
-   - If the conversation references a change loosely (for example by title or summary), run \`openspec list\` to surface likely IDs, share the relevant candidates, and confirm which one the user intends.
-   - Otherwise, review the conversation, run \`openspec list\`, and ask the user which change to archive; wait for a confirmed change ID before proceeding.
-   - If you still cannot identify a single change ID, stop and tell the user you cannot archive anything yet.
-2. Validate the change ID by running \`openspec list\` (or \`openspec show <id>\`) and stop if the change is missing, already archived, or otherwise not ready to archive.
-3. Run \`openspec archive <id> --yes\` so the CLI moves the change and applies spec updates without prompts (use \`--skip-specs\` only for tooling-only work).
-4. Review the command output to confirm the target specs were updated and the change landed in \`changes/archive/\`.
-5. Validate with \`openspec validate --strict --no-interactive\` and inspect with \`openspec show <id>\` if anything looks off.`;
-
-const archiveReferences = `**Reference**
-- Use \`openspec list\` to confirm change IDs before archiving.
-- Inspect refreshed specs with \`openspec list --specs\` and address any validation issues before handing off.`;
-
-export const slashCommandBodies: Record<SlashCommandId, string> = {
-  proposal: [proposalGuardrails, proposalSteps, proposalReferences].join('\n\n'),
-  apply: [baseGuardrails, applySteps, applyReferences].join('\n\n'),
-  archive: [baseGuardrails, archiveSteps, archiveReferences].join('\n\n')
-};
-
-export function getSlashCommandBody(id: SlashCommandId): string {
-  return slashCommandBodies[id];
-}
diff --git a/src/core/update.ts b/src/core/update.ts
index 41fd772..b395409 100644
--- a/src/core/update.ts
+++ b/src/core/update.ts
@@ -1,129 +1,398 @@
+/**
+ * Update Command
+ *
+ * Refreshes OpenSpec skills and commands for configured tools.
+ * Supports smart update detection to skip updates when already current.
+ */
+
 import path from 'path';
+import chalk from 'chalk';
+import ora from 'ora';
+import { createRequire } from 'module';
 import { FileSystemUtils } from '../utils/file-system.js';
-import { OPENSPEC_DIR_NAME } from './config.js';
-import { ToolRegistry } from './configurators/registry.js';
-import { SlashCommandRegistry } from './configurators/slash/registry.js';
-import { agentsTemplate } from './templates/agents-template.js';
+import { AI_TOOLS, OPENSPEC_DIR_NAME } from './config.js';
+import {
+  generateCommands,
+  CommandAdapterRegistry,
+} from './command-generation/index.js';
+import {
+  getConfiguredTools,
+  getAllToolVersionStatus,
+  getSkillTemplates,
+  getCommandContents,
+  generateSkillContent,
+  getToolsWithSkillsDir,
+  type ToolVersionStatus,
+} from './shared/index.js';
+import {
+  detectLegacyArtifacts,
+  cleanupLegacyArtifacts,
+  formatCleanupSummary,
+  formatDetectionSummary,
+  getToolsFromLegacyArtifacts,
+  type LegacyDetectionResult,
+} from './legacy-cleanup.js';
+import { isInteractive } from '../utils/interactive.js';
+
+const require = createRequire(import.meta.url);
+const { version: OPENSPEC_VERSION } = require('../../package.json');
+
+/**
+ * Options for the update command.
+ */
+export interface UpdateCommandOptions {
+  /** Force update even when tools are up to date */
+  force?: boolean;
+}
 
 export class UpdateCommand {
+  private readonly force: boolean;
+
+  constructor(options: UpdateCommandOptions = {}) {
+    this.force = options.force ?? false;
+  }
+
   async execute(projectPath: string): Promise<void> {
     const resolvedProjectPath = path.resolve(projectPath);
-    const openspecDirName = OPENSPEC_DIR_NAME;
-    const openspecPath = path.join(resolvedProjectPath, openspecDirName);
+    const openspecPath = path.join(resolvedProjectPath, OPENSPEC_DIR_NAME);
 
     // 1. Check openspec directory exists
     if (!await FileSystemUtils.directoryExists(openspecPath)) {
       throw new Error(`No OpenSpec directory found. Run 'openspec init' first.`);
     }
 
-    // 2. Update AGENTS.md (full replacement)
-    const agentsPath = path.join(openspecPath, 'AGENTS.md');
+    // 2. Detect and handle legacy artifacts + upgrade legacy tools to new skills
+    const newlyConfiguredTools = await this.handleLegacyCleanup(resolvedProjectPath);
 
-    await FileSystemUtils.writeFile(agentsPath, agentsTemplate);
+    // 3. Find configured tools
+    const configuredTools = getConfiguredTools(resolvedProjectPath);
 
-    // 3. Update existing AI tool configuration files only
-    const configurators = ToolRegistry.getAll();
-    const slashConfigurators = SlashCommandRegistry.getAll();
-    const updatedFiles: string[] = [];
-    const createdFiles: string[] = [];
-    const failedFiles: string[] = [];
-    const updatedSlashFiles: string[] = [];
-    const failedSlashTools: string[] = [];
+    if (configuredTools.length === 0 && newlyConfiguredTools.length === 0) {
+      console.log(chalk.yellow('No configured tools found.'));
+      console.log(chalk.dim('Run "openspec init" to set up tools.'));
+      return;
+    }
 
-    for (const configurator of configurators) {
-      const configFilePath = path.join(
-        resolvedProjectPath,
-        configurator.configFileName
-      );
-      const fileExists = await FileSystemUtils.fileExists(configFilePath);
-      const shouldConfigure =
-        fileExists || configurator.configFileName === 'AGENTS.md';
+    // 4. Check version status for all configured tools
+    const toolStatuses = getAllToolVersionStatus(resolvedProjectPath, OPENSPEC_VERSION);
 
-      if (!shouldConfigure) {
-        continue;
-      }
+    // 5. Smart update detection
+    const toolsNeedingUpdate = toolStatuses.filter((s) => s.needsUpdate);
+    const toolsUpToDate = toolStatuses.filter((s) => !s.needsUpdate);
+
+    if (!this.force && toolsNeedingUpdate.length === 0) {
+      // All tools are up to date
+      this.displayUpToDateMessage(toolStatuses);
+      return;
+    }
+
+    // 6. Display update plan
+    if (this.force) {
+      console.log(`Force updating ${configuredTools.length} tool(s): ${configuredTools.join(', ')}`);
+    } else {
+      this.displayUpdatePlan(toolsNeedingUpdate, toolsUpToDate);
+    }
+    console.log();
+
+    // 7. Prepare templates
+    const skillTemplates = getSkillTemplates();
+    const commandContents = getCommandContents();
+
+    // 8. Update tools (all if force, otherwise only those needing update)
+    const toolsToUpdate = this.force ? configuredTools : toolsNeedingUpdate.map((s) => s.toolId);
+    const updatedTools: string[] = [];
+    const failedTools: Array<{ name: string; error: string }> = [];
+
+    for (const toolId of toolsToUpdate) {
+      const tool = AI_TOOLS.find((t) => t.value === toolId);
+      if (!tool?.skillsDir) continue;
+
+      const spinner = ora(`Updating ${tool.name}...`).start();
 
       try {
-        if (fileExists && !await FileSystemUtils.canWriteFile(configFilePath)) {
-          throw new Error(
-            `Insufficient permissions to modify ${configurator.configFileName}`
-          );
+        const skillsDir = path.join(resolvedProjectPath, tool.skillsDir, 'skills');
+
+        // Update skill files
+        for (const { template, dirName } of skillTemplates) {
+          const skillDir = path.join(skillsDir, dirName);
+          const skillFile = path.join(skillDir, 'SKILL.md');
+
+          const skillContent = generateSkillContent(template, OPENSPEC_VERSION);
+          await FileSystemUtils.writeFile(skillFile, skillContent);
         }
 
-        await configurator.configure(resolvedProjectPath, openspecPath);
-        updatedFiles.push(configurator.configFileName);
+        // Update commands
+        const adapter = CommandAdapterRegistry.get(tool.value);
+        if (adapter) {
+          const generatedCommands = generateCommands(commandContents, adapter);
 
-        if (!fileExists) {
-          createdFiles.push(configurator.configFileName);
+          for (const cmd of generatedCommands) {
+            const commandFile = path.join(resolvedProjectPath, cmd.path);
+            await FileSystemUtils.writeFile(commandFile, cmd.fileContent);
+          }
         }
+
+        spinner.succeed(`Updated ${tool.name}`);
+        updatedTools.push(tool.name);
       } catch (error) {
-        failedFiles.push(configurator.configFileName);
-        console.error(
-          `Failed to update ${configurator.configFileName}: ${
-            error instanceof Error ? error.message : String(error)
-          }`
-        );
+        spinner.fail(`Failed to update ${tool.name}`);
+        failedTools.push({
+          name: tool.name,
+          error: error instanceof Error ? error.message : String(error)
+        });
       }
     }
 
-    for (const slashConfigurator of slashConfigurators) {
-      if (!slashConfigurator.isAvailable) {
-        continue;
-      }
+    // 9. Summary
+    console.log();
+    if (updatedTools.length > 0) {
+      console.log(chalk.green(`âœ“ Updated: ${updatedTools.join(', ')} (v${OPENSPEC_VERSION})`));
+    }
+    if (failedTools.length > 0) {
+      console.log(chalk.red(`âœ— Failed: ${failedTools.map(f => `${f.name} (${f.error})`).join(', ')}`));
+    }
 
-      try {
-        const updated = await slashConfigurator.updateExisting(
-          resolvedProjectPath,
-          openspecPath
-        );
-        updatedSlashFiles.push(...updated);
-      } catch (error) {
-        failedSlashTools.push(slashConfigurator.toolId);
-        console.error(
-          `Failed to update slash commands for ${slashConfigurator.toolId}: ${
-            error instanceof Error ? error.message : String(error)
-          }`
-        );
-      }
+    // 10. Show onboarding message for newly configured tools from legacy upgrade
+    if (newlyConfiguredTools.length > 0) {
+      console.log();
+      console.log(chalk.bold('Getting started:'));
+      console.log('  /opsx:new       Start a new change');
+      console.log('  /opsx:continue  Create the next artifact');
+      console.log('  /opsx:apply     Implement tasks');
+      console.log();
+      console.log(`Learn more: ${chalk.cyan('https://github.com/Fission-AI/OpenSpec')}`);
+    }
+
+    console.log();
+    console.log(chalk.dim('Restart your IDE for changes to take effect.'));
+  }
+
+  /**
+   * Display message when all tools are up to date.
+   */
+  private displayUpToDateMessage(toolStatuses: ToolVersionStatus[]): void {
+    const toolNames = toolStatuses.map((s) => s.toolId);
+    console.log(chalk.green(`âœ“ All ${toolStatuses.length} tool(s) up to date (v${OPENSPEC_VERSION})`));
+    console.log(chalk.dim(`  Tools: ${toolNames.join(', ')}`));
+    console.log();
+    console.log(chalk.dim('Use --force to refresh skills anyway.'));
+  }
+
+  /**
+   * Display the update plan showing which tools need updating.
+   */
+  private displayUpdatePlan(
+    needingUpdate: ToolVersionStatus[],
+    upToDate: ToolVersionStatus[]
+  ): void {
+    const updates = needingUpdate.map((s) => {
+      const fromVersion = s.generatedByVersion ?? 'unknown';
+      return `${s.toolId} (${fromVersion} â†’ ${OPENSPEC_VERSION})`;
+    });
+
+    console.log(`Updating ${needingUpdate.length} tool(s): ${updates.join(', ')}`);
+
+    if (upToDate.length > 0) {
+      const upToDateNames = upToDate.map((s) => s.toolId);
+      console.log(chalk.dim(`Already up to date: ${upToDateNames.join(', ')}`));
     }
+  }
 
-    const summaryParts: string[] = [];
-    const instructionFiles: string[] = ['openspec/AGENTS.md'];
+  /**
+   * Detect and handle legacy OpenSpec artifacts.
+   * Unlike init, update warns but continues if legacy files found in non-interactive mode.
+   * Returns array of tool IDs that were newly configured during legacy upgrade.
+   */
+  private async handleLegacyCleanup(projectPath: string): Promise<string[]> {
+    // Detect legacy artifacts
+    const detection = await detectLegacyArtifacts(projectPath);
 
-    if (updatedFiles.includes('AGENTS.md')) {
-      instructionFiles.push(
-        createdFiles.includes('AGENTS.md') ? 'AGENTS.md (created)' : 'AGENTS.md'
-      );
+    if (!detection.hasLegacyArtifacts) {
+      return []; // No legacy artifacts found
     }
 
-    summaryParts.push(
-      `Updated OpenSpec instructions (${instructionFiles.join(', ')})`
-    );
+    // Show what was detected
+    console.log();
+    console.log(formatDetectionSummary(detection));
+    console.log();
 
-    const aiToolFiles = updatedFiles.filter((file) => file !== 'AGENTS.md');
-    if (aiToolFiles.length > 0) {
-      summaryParts.push(`Updated AI tool files: ${aiToolFiles.join(', ')}`);
+    const canPrompt = isInteractive();
+
+    if (this.force) {
+      // --force flag: proceed with cleanup automatically
+      await this.performLegacyCleanup(projectPath, detection);
+      // Then upgrade legacy tools to new skills
+      return this.upgradeLegacyTools(projectPath, detection, canPrompt);
     }
 
-    if (updatedSlashFiles.length > 0) {
-      // Normalize to forward slashes for cross-platform log consistency
-      const normalized = updatedSlashFiles.map((p) => FileSystemUtils.toPosixPath(p));
-      summaryParts.push(`Updated slash commands: ${normalized.join(', ')}`);
+    if (!canPrompt) {
+      // Non-interactive mode without --force: warn and continue
+      // (Unlike init, update doesn't abort - user may just want to update skills)
+      console.log(chalk.yellow('âš  Run with --force to auto-cleanup legacy files, or run interactively.'));
+      console.log();
+      return [];
     }
 
-    const failedItems = [
-      ...failedFiles,
-      ...failedSlashTools.map(
-        (toolId) => `slash command refresh (${toolId})`
-      ),
-    ];
+    // Interactive mode: prompt for confirmation
+    const { confirm } = await import('@inquirer/prompts');
+    const shouldCleanup = await confirm({
+      message: 'Upgrade and clean up legacy files?',
+      default: true,
+    });
 
-    if (failedItems.length > 0) {
-      summaryParts.push(`Failed to update: ${failedItems.join(', ')}`);
+    if (shouldCleanup) {
+      await this.performLegacyCleanup(projectPath, detection);
+      // Then upgrade legacy tools to new skills
+      return this.upgradeLegacyTools(projectPath, detection, canPrompt);
+    } else {
+      console.log(chalk.dim('Skipping legacy cleanup. Continuing with skill update...'));
+      console.log();
+      return [];
     }
+  }
+
+  /**
+   * Perform cleanup of legacy artifacts.
+   */
+  private async performLegacyCleanup(projectPath: string, detection: LegacyDetectionResult): Promise<void> {
+    const spinner = ora('Cleaning up legacy files...').start();
+
+    const result = await cleanupLegacyArtifacts(projectPath, detection);
+
+    spinner.succeed('Legacy files cleaned up');
 
-    console.log(summaryParts.join(' | '));
+    const summary = formatCleanupSummary(result);
+    if (summary) {
+      console.log();
+      console.log(summary);
+    }
+
+    console.log();
+  }
+
+  /**
+   * Upgrade legacy tools to new skills system.
+   * Returns array of tool IDs that were newly configured.
+   */
+  private async upgradeLegacyTools(
+    projectPath: string,
+    detection: LegacyDetectionResult,
+    canPrompt: boolean
+  ): Promise<string[]> {
+    // Get tools that had legacy artifacts
+    const legacyTools = getToolsFromLegacyArtifacts(detection);
+
+    if (legacyTools.length === 0) {
+      return [];
+    }
+
+    // Get currently configured tools
+    const configuredTools = getConfiguredTools(projectPath);
+    const configuredSet = new Set(configuredTools);
+
+    // Filter to tools that aren't already configured
+    const unconfiguredLegacyTools = legacyTools.filter((t) => !configuredSet.has(t));
+
+    if (unconfiguredLegacyTools.length === 0) {
+      return [];
+    }
+
+    // Get valid tools (those with skillsDir)
+    const validToolIds = new Set(getToolsWithSkillsDir());
+    const validUnconfiguredTools = unconfiguredLegacyTools.filter((t) => validToolIds.has(t));
+
+    if (validUnconfiguredTools.length === 0) {
+      return [];
+    }
+
+    // Show what tools were detected from legacy artifacts
+    console.log(chalk.bold('Tools detected from legacy artifacts:'));
+    for (const toolId of validUnconfiguredTools) {
+      const tool = AI_TOOLS.find((t) => t.value === toolId);
+      console.log(`  â€¢ ${tool?.name || toolId}`);
+    }
+    console.log();
+
+    let selectedTools: string[];
+
+    if (this.force || !canPrompt) {
+      // Non-interactive with --force: auto-select detected tools
+      selectedTools = validUnconfiguredTools;
+      console.log(`Setting up skills for: ${selectedTools.join(', ')}`);
+    } else {
+      // Interactive mode: prompt for tool selection with detected tools pre-selected
+      const { searchableMultiSelect } = await import('../prompts/searchable-multi-select.js');
+
+      const sortedChoices = validUnconfiguredTools.map((toolId) => {
+        const tool = AI_TOOLS.find((t) => t.value === toolId);
+        return {
+          name: tool?.name || toolId,
+          value: toolId,
+          configured: false,
+          preSelected: true, // Pre-select all detected legacy tools
+        };
+      });
+
+      selectedTools = await searchableMultiSelect({
+        message: 'Select tools to set up with the new skill system:',
+        pageSize: 15,
+        choices: sortedChoices,
+        validate: (_selected: string[]) => true, // Allow empty selection (user can skip)
+      });
+
+      if (selectedTools.length === 0) {
+        console.log(chalk.dim('Skipping tool setup.'));
+        console.log();
+        return [];
+      }
+    }
+
+    // Create skills for selected tools
+    const newlyConfigured: string[] = [];
+    const skillTemplates = getSkillTemplates();
+    const commandContents = getCommandContents();
+
+    for (const toolId of selectedTools) {
+      const tool = AI_TOOLS.find((t) => t.value === toolId);
+      if (!tool?.skillsDir) continue;
+
+      const spinner = ora(`Setting up ${tool.name}...`).start();
+
+      try {
+        const skillsDir = path.join(projectPath, tool.skillsDir, 'skills');
+
+        // Create skill files
+        for (const { template, dirName } of skillTemplates) {
+          const skillDir = path.join(skillsDir, dirName);
+          const skillFile = path.join(skillDir, 'SKILL.md');
+
+          const skillContent = generateSkillContent(template, OPENSPEC_VERSION);
+          await FileSystemUtils.writeFile(skillFile, skillContent);
+        }
+
+        // Create commands
+        const adapter = CommandAdapterRegistry.get(tool.value);
+        if (adapter) {
+          const generatedCommands = generateCommands(commandContents, adapter);
+
+          for (const cmd of generatedCommands) {
+            const commandFile = path.join(projectPath, cmd.path);
+            await FileSystemUtils.writeFile(commandFile, cmd.fileContent);
+          }
+        }
+
+        spinner.succeed(`Setup complete for ${tool.name}`);
+        newlyConfigured.push(toolId);
+      } catch (error) {
+        spinner.fail(`Failed to set up ${tool.name}`);
+        console.log(chalk.red(`  ${error instanceof Error ? error.message : String(error)}`));
+      }
+    }
+
+    if (newlyConfigured.length > 0) {
+      console.log();
+    }
 
-    // No additional notes
+    return newlyConfigured;
   }
 }
diff --git a/src/prompts/searchable-multi-select.ts b/src/prompts/searchable-multi-select.ts
new file mode 100644
index 0000000..e011e48
--- /dev/null
+++ b/src/prompts/searchable-multi-select.ts
@@ -0,0 +1,210 @@
+import chalk from 'chalk';
+
+interface Choice {
+  name: string;
+  value: string;
+  description?: string;
+  configured?: boolean;
+  configuredLabel?: string;
+  preSelected?: boolean;
+}
+
+interface Config {
+  message: string;
+  choices: Choice[];
+  pageSize?: number;
+  validate?: (selected: string[]) => boolean | string;
+}
+
+/**
+ * Create the searchable multi-select prompt.
+ * Uses dynamic import to prevent pre-commit hook hangs (see #367).
+ */
+async function createSearchableMultiSelect(): Promise<
+  (config: Config) => Promise<string[]>
+> {
+  const {
+    createPrompt,
+    useState,
+    useKeypress,
+    useMemo,
+    usePrefix,
+    isEnterKey,
+    isBackspaceKey,
+    isUpKey,
+    isDownKey,
+  } = await import('@inquirer/core');
+
+  return createPrompt((config: Config, done: (value: string[]) => void): string => {
+    const { message, choices, pageSize = 15, validate } = config;
+
+    const [searchText, setSearchText] = useState('');
+    const [selectedValues, setSelectedValues] = useState<string[]>(
+      () => choices.filter(c => c.preSelected).map(c => c.value)
+    );
+    const [cursor, setCursor] = useState(0);
+    const [status, setStatus] = useState<'idle' | 'done'>('idle');
+    const [error, setError] = useState<string | null>(null);
+
+    const prefix = usePrefix({ status });
+
+    // Filter choices by search
+    const filteredChoices = useMemo(() => {
+      if (!searchText.trim()) return choices;
+      const term = searchText.toLowerCase();
+      return choices.filter(
+        (c) =>
+          c.name.toLowerCase().includes(term) ||
+          c.value.toLowerCase().includes(term)
+      );
+    }, [searchText, choices]);
+
+    const selectedSet = useMemo(() => new Set(selectedValues), [selectedValues]);
+    const choiceMap = useMemo(
+      () => new Map(choices.map((c) => [c.value, c])),
+      [choices]
+    );
+
+    useKeypress((key) => {
+      if (status === 'done') return;
+
+      // Tab to confirm
+      if (key.name === 'tab') {
+        if (validate) {
+          const result = validate(selectedValues);
+          if (result !== true) {
+            setError(typeof result === 'string' ? result : 'Invalid');
+            return;
+          }
+        }
+        setStatus('done');
+        done(selectedValues);
+        return;
+      }
+
+      // Enter to add item
+      if (isEnterKey(key)) {
+        const choice = filteredChoices[cursor];
+        if (choice && !selectedSet.has(choice.value)) {
+          setSelectedValues([...selectedValues, choice.value]);
+          setSearchText('');
+          setCursor(0);
+        }
+        return;
+      }
+
+      // Backspace to remove or delete search char
+      if (isBackspaceKey(key)) {
+        if (searchText === '' && selectedValues.length > 0) {
+          setSelectedValues(selectedValues.slice(0, -1));
+        } else {
+          setSearchText(searchText.slice(0, -1));
+          setCursor(0);
+        }
+        return;
+      }
+
+      // Navigation
+      if (isUpKey(key)) {
+        setCursor(Math.max(0, cursor - 1));
+        return;
+      }
+      if (isDownKey(key)) {
+        setCursor(Math.min(filteredChoices.length - 1, cursor + 1));
+        return;
+      }
+
+      // Character input - handle printable characters
+      if (key.name && key.name.length === 1 && !key.ctrl) {
+        setSearchText(searchText + key.name);
+        setCursor(0);
+      }
+    });
+
+    // Render done state
+    if (status === 'done') {
+      const names = selectedValues
+        .map((v) => choiceMap.get(v)?.name ?? v)
+        .join(', ');
+      return `${prefix} ${chalk.bold(message)} ${chalk.cyan(names || '(none)')}`;
+    }
+
+    // Render active state
+    const lines: string[] = [];
+    lines.push(`${prefix} ${chalk.bold(message)}`);
+
+    // Selected chips
+    const chips =
+      selectedValues.length > 0
+        ? selectedValues
+            .map((v) => chalk.bgCyan.black(` ${choiceMap.get(v)?.name} `))
+            .join(' ')
+        : chalk.dim('(none selected)');
+    lines.push(`  Selected: ${chips}`);
+
+    // Search box
+    lines.push(
+      `  Search: ${chalk.yellow('[')}${searchText || chalk.dim('type to filter')}${chalk.yellow(']')}`
+    );
+
+    // Instructions
+    lines.push(
+      `  ${chalk.cyan('â†‘â†“')} navigate â€¢ ${chalk.cyan('Enter')} add â€¢ ${chalk.cyan('Backspace')} remove â€¢ ${chalk.cyan('Tab')} confirm`
+    );
+
+    // List
+    if (filteredChoices.length === 0) {
+      lines.push(chalk.yellow('  No matches'));
+    } else {
+      // Calculate pagination
+      const startIndex = Math.max(
+        0,
+        Math.min(cursor - Math.floor(pageSize / 2), filteredChoices.length - pageSize)
+      );
+      const endIndex = Math.min(startIndex + pageSize, filteredChoices.length);
+      const visibleChoices = filteredChoices.slice(startIndex, endIndex);
+
+      for (let i = 0; i < visibleChoices.length; i++) {
+        const item = visibleChoices[i];
+        const actualIndex = startIndex + i;
+        const isActive = actualIndex === cursor;
+        const selected = selectedSet.has(item.value);
+        const icon = selected ? chalk.green('â—‰') : chalk.dim('â—‹');
+        const arrow = isActive ? chalk.cyan('â€º') : ' ';
+        const name = isActive ? chalk.cyan(item.name) : item.name;
+        const isRefresh = selected && item.configured;
+        const suffix = selected
+          ? chalk.dim(isRefresh ? ' (refresh)' : ' (selected)')
+          : '';
+        lines.push(`  ${arrow} ${icon} ${name}${suffix}`);
+      }
+
+      // Show pagination indicator if needed
+      if (filteredChoices.length > pageSize) {
+        const currentPage = Math.floor(cursor / pageSize) + 1;
+        const totalPages = Math.ceil(filteredChoices.length / pageSize);
+        lines.push(chalk.dim(`  (${currentPage}/${totalPages})`));
+      }
+    }
+
+    if (error) lines.push(chalk.red(`  ${error}`));
+    return lines.join('\n');
+  });
+}
+
+/**
+ * A searchable multi-select prompt with visible search box,
+ * selected items display, and intuitive keyboard navigation.
+ *
+ * - Type to filter choices
+ * - â†‘â†“ to navigate
+ * - Enter to add highlighted item
+ * - Backspace to remove last selected item (or delete search char)
+ * - Tab to confirm selections
+ */
+export async function searchableMultiSelect(config: Config): Promise<string[]> {
+  const prompt = await createSearchableMultiSelect();
+  return prompt(config);
+}
+
+export default searchableMultiSelect;
diff --git a/src/ui/ascii-patterns.ts b/src/ui/ascii-patterns.ts
new file mode 100644
index 0000000..5c67495
--- /dev/null
+++ b/src/ui/ascii-patterns.ts
@@ -0,0 +1,137 @@
+/**
+ * ASCII art animation patterns for the welcome screen.
+ * OpenSpec logo animation - diamond/rhombus shape with hollow center "O".
+ */
+
+// Detect if full Unicode is supported
+const supportsUnicode =
+  process.platform !== 'win32' ||
+  !!process.env.WT_SESSION || // Windows Terminal
+  !!process.env.TERM_PROGRAM; // Modern terminal
+
+// Character set based on Unicode support
+// Block characters for pixel-art aesthetic
+const CHARS = supportsUnicode
+  ? { full: 'â–ˆâ–ˆ', dim: 'â–‘â–‘', empty: '  ' }
+  : { full: '##', dim: '++', empty: '  ' };
+
+const _ = CHARS.empty;
+const F = CHARS.full;
+const D = CHARS.dim;
+
+/**
+ * Welcome animation frames - OpenSpec logo building from center
+ * 7 rows Ã— 6 columns diamond with hollow center "O"
+ * Center bar is 2 cols Ã— 3 rows (rows 3,4,5 cols 3,4)
+ * Each frame is an array of strings (lines of ASCII art)
+ * Grid: 6 cols Ã— 2 chars = 12 chars wide
+ */
+export const WELCOME_ANIMATION = {
+  interval: 120,
+  frames: [
+    // Frame 1: Empty
+    [
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 1
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 2
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 3
+      `${_}${_}${_}${_}${_}${_}${_}${_}`,
+      `${_}${_}${_}${_}${_}${_}${_}${_}`,
+      `${_}${_}${_}${_}${_}${_}${_}${_}`,
+      `${_}${_}${_}${_}${_}${_}${_}${_}`,
+      `${_}${_}${_}${_}${_}${_}${_}${_}`,
+      `${_}${_}${_}${_}${_}${_}${_}${_}`,
+      `${_}${_}${_}${_}${_}${_}${_}${_}`,
+    ],
+    // Frame 2: Center blocks appear (dim) - 2x3 center bar
+    [
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 1
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 2
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 3
+      `${_}${_}${_}${_}${_}${_}${_}${_}`,
+      `${_}${_}${_}${_}${_}${_}${_}${_}`,
+      `${_}${_}${_}${_}${D}${D}${_}${_}`,
+      `${_}${_}${_}${_}${D}${D}${_}${_}`,
+      `${_}${_}${_}${_}${D}${D}${_}${_}`,
+      `${_}${_}${_}${_}${_}${_}${_}${_}`,
+      `${_}${_}${_}${_}${_}${_}${_}${_}`,
+    ],
+    // Frame 3: Center blocks solidify
+    [
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 1
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 2
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 3
+      `${_}${_}${_}${_}${_}${_}${_}${_}`,
+      `${_}${_}${_}${_}${_}${_}${_}${_}`,
+      `${_}${_}${_}${_}${F}${F}${_}${_}`,
+      `${_}${_}${_}${_}${F}${F}${_}${_}`,
+      `${_}${_}${_}${_}${F}${F}${_}${_}`,
+      `${_}${_}${_}${_}${_}${_}${_}${_}`,
+      `${_}${_}${_}${_}${_}${_}${_}${_}`,
+    ],
+    // Frame 4: Top and bottom points appear
+    [
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 1
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 2
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 3
+      `${_}${_}${_}${_}${D}${D}${_}${_}`,
+      `${_}${_}${_}${_}${_}${_}${_}${_}`,
+      `${_}${_}${_}${_}${F}${F}${_}${_}`,
+      `${_}${_}${_}${_}${F}${F}${_}${_}`,
+      `${_}${_}${_}${_}${F}${F}${_}${_}`,
+      `${_}${_}${_}${_}${_}${_}${_}${_}`,
+      `${_}${_}${_}${_}${D}${D}${_}${_}`,
+    ],
+    // Frame 5: Inner ring forming
+    [
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 1
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 2
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 3
+      `${_}${_}${_}${_}${F}${F}${_}${_}`,
+      `${_}${_}${_}${D}${_}${_}${D}${_}`,
+      `${_}${_}${_}${_}${F}${F}${_}${_}`,
+      `${_}${_}${_}${_}${F}${F}${_}${_}`,
+      `${_}${_}${_}${_}${F}${F}${_}${_}`,
+      `${_}${_}${_}${D}${_}${_}${D}${_}`,
+      `${_}${_}${_}${_}${F}${F}${_}${_}`,
+    ],
+    // Frame 6: Outer ring appearing
+    [
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 1
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 2
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 3
+      `${_}${_}${_}${_}${F}${F}${_}${_}`,
+      `${_}${_}${_}${F}${_}${_}${F}${_}`,
+      `${_}${_}${D}${_}${F}${F}${_}${D}`,
+      `${_}${_}${D}${_}${F}${F}${_}${D}`,
+      `${_}${_}${D}${_}${F}${F}${_}${D}`,
+      `${_}${_}${_}${F}${_}${_}${F}${_}`,
+      `${_}${_}${_}${_}${F}${F}${_}${_}`,
+    ],
+    // Frame 7: Full logo
+    [
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 1
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 2
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 3
+      `${_}${_}${_}${_}${F}${F}${_}${_}`,
+      `${_}${_}${_}${F}${_}${_}${F}${_}`,
+      `${_}${_}${F}${_}${F}${F}${_}${F}`,
+      `${_}${_}${F}${_}${F}${F}${_}${F}`,
+      `${_}${_}${F}${_}${F}${F}${_}${F}`,
+      `${_}${_}${_}${F}${_}${_}${F}${_}`,
+      `${_}${_}${_}${_}${F}${F}${_}${_}`,
+    ],
+    // Frame 8: Hold complete logo
+    [
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 1
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 2
+      `${_}${_}${_}${_}${_}${_}${_}${_}`, // padding row 3
+      `${_}${_}${_}${_}${F}${F}${_}${_}`,
+      `${_}${_}${_}${F}${_}${_}${F}${_}`,
+      `${_}${_}${F}${_}${F}${F}${_}${F}`,
+      `${_}${_}${F}${_}${F}${F}${_}${F}`,
+      `${_}${_}${F}${_}${F}${F}${_}${F}`,
+      `${_}${_}${_}${F}${_}${_}${F}${_}`,
+      `${_}${_}${_}${_}${F}${F}${_}${_}`,
+    ],
+  ],
+};
diff --git a/src/ui/welcome-screen.ts b/src/ui/welcome-screen.ts
new file mode 100644
index 0000000..5ed26b6
--- /dev/null
+++ b/src/ui/welcome-screen.ts
@@ -0,0 +1,177 @@
+/**
+ * Animated welcome screen for the experimental artifact workflow setup.
+ * Shows side-by-side layout with animated ASCII art on left and welcome text on right.
+ */
+
+import chalk from 'chalk';
+import { WELCOME_ANIMATION } from './ascii-patterns.js';
+
+// Minimum terminal width for side-by-side layout
+const MIN_WIDTH = 60;
+
+// Width of the ASCII art column (with padding)
+const ART_COLUMN_WIDTH = 24;
+
+/**
+ * Welcome text content (right column)
+ */
+function getWelcomeText(): string[] {
+  return [
+    chalk.white.bold('Welcome to OpenSpec'),
+    chalk.dim('A lightweight spec-driven framework'),
+    '',
+    chalk.white('This setup will configure:'),
+    chalk.dim('  â€¢ Agent Skills for AI tools'),
+    chalk.dim('  â€¢ /opsx:* slash commands'),
+    '',
+    chalk.white('Quick start after setup:'),
+    `  ${chalk.yellow('/opsx:new')}      ${chalk.dim('Create a change')}`,
+    `  ${chalk.yellow('/opsx:continue')} ${chalk.dim('Next artifact')}`,
+    `  ${chalk.yellow('/opsx:apply')}    ${chalk.dim('Implement tasks')}`,
+    '',
+    chalk.cyan('Press Enter to select tools...'),
+  ];
+}
+
+/**
+ * Renders a single frame with side-by-side layout
+ */
+function renderFrame(artLines: string[], textLines: string[]): string {
+  const maxLines = Math.max(artLines.length, textLines.length);
+  const lines: string[] = [];
+
+  for (let i = 0; i < maxLines; i++) {
+    const artLine = artLines[i] || '';
+    const textLine = textLines[i] || '';
+
+    // Pad the art column to fixed width
+    const paddedArt = artLine.padEnd(ART_COLUMN_WIDTH);
+
+    // Color the ASCII art with cyan for visual appeal
+    const coloredArt = chalk.cyan(paddedArt);
+
+    // Clear line before writing to prevent residual characters
+    lines.push(`\x1b[2K${coloredArt}${textLine}`);
+  }
+
+  return lines.join('\n');
+}
+
+/**
+ * Checks if the terminal supports animation
+ */
+function canAnimate(): boolean {
+  // Must be TTY
+  if (!process.stdout.isTTY) return false;
+
+  // Respect NO_COLOR
+  if (process.env.NO_COLOR) return false;
+
+  // Check terminal width
+  const columns = process.stdout.columns || 80;
+  if (columns < MIN_WIDTH) return false;
+
+  return true;
+}
+
+/**
+ * Wait for Enter key press
+ */
+function waitForEnter(): Promise<void> {
+  return new Promise((resolve) => {
+    const { stdin } = process;
+
+    // Handle non-TTY gracefully
+    if (!stdin.isTTY) {
+      resolve();
+      return;
+    }
+
+    const wasRaw = stdin.isRaw;
+    stdin.setRawMode(true);
+    stdin.resume();
+
+    const onData = (data: Buffer): void => {
+      const char = data.toString();
+
+      // Enter key or Ctrl+C
+      if (char === '\r' || char === '\n' || char === '\u0003') {
+        stdin.removeListener('data', onData);
+        stdin.setRawMode(wasRaw);
+        stdin.pause();
+
+        // Handle Ctrl+C
+        if (char === '\u0003') {
+          process.stdout.write('\n');
+          process.exit(0);
+        }
+
+        resolve();
+      }
+    };
+
+    stdin.on('data', onData);
+  });
+}
+
+/**
+ * Shows the animated welcome screen.
+ * Returns when user presses Enter.
+ */
+export async function showWelcomeScreen(): Promise<void> {
+  const textLines = getWelcomeText();
+
+  if (!canAnimate()) {
+    // Fallback: show static welcome
+    const frame = WELCOME_ANIMATION.frames[3]; // Peak frame
+    process.stdout.write('\n' + renderFrame(frame, textLines) + '\n\n');
+    return;
+  }
+
+  let frameIndex = 0;
+  let running = true;
+  let isFirstRender = true;
+
+  // Content height for cursor movement between frames
+  const numContentLines = Math.max(WELCOME_ANIMATION.frames[0].length, textLines.length);
+  const frameHeight = numContentLines + 1; // internal newlines (11) + trailing newlines (2) = 13
+
+  // Total height including initial newline (for cleanup)
+  const totalHeight = frameHeight + 1; // 14
+
+  // Initial render
+  process.stdout.write('\n');
+
+  // Animation loop
+  const interval = setInterval(() => {
+    if (!running) return;
+
+    const frame = WELCOME_ANIMATION.frames[frameIndex];
+
+    // Move cursor up to overwrite previous frame (always after first render)
+    if (!isFirstRender) {
+      process.stdout.write(`\x1b[${frameHeight}A`);
+    }
+    isFirstRender = false;
+
+    // Render current frame
+    process.stdout.write(renderFrame(frame, textLines) + '\n\n');
+
+    // Advance to next frame
+    frameIndex = (frameIndex + 1) % WELCOME_ANIMATION.frames.length;
+  }, WELCOME_ANIMATION.interval);
+
+  // Wait for Enter
+  await waitForEnter();
+
+  // Stop animation
+  running = false;
+  clearInterval(interval);
+
+  // Clear the welcome screen and move on
+  process.stdout.write(`\x1b[${totalHeight}A`);
+  for (let i = 0; i < totalHeight; i++) {
+    process.stdout.write('\x1b[2K\n'); // Clear line
+  }
+  process.stdout.write(`\x1b[${totalHeight}A`); // Move back up
+}
diff --git a/src/utils/change-utils.ts b/src/utils/change-utils.ts
index 44178b0..671a92b 100644
--- a/src/utils/change-utils.ts
+++ b/src/utils/change-utils.ts
@@ -105,9 +105,9 @@ export function validateChangeName(name: string): ValidationResult {
  * console.log(result.schema) // 'spec-driven' or value from config
  *
  * @example
- * // Creates openspec/changes/add-auth/ with TDD schema
- * const result = await createChange('/path/to/project', 'add-auth', { schema: 'tdd' })
- * console.log(result.schema) // 'tdd'
+ * // Creates openspec/changes/add-auth/ with custom schema
+ * const result = await createChange('/path/to/project', 'add-auth', { schema: 'my-workflow' })
+ * console.log(result.schema) // 'my-workflow'
  */
 export async function createChange(
   projectRoot: string,
diff --git a/src/utils/file-system.ts b/src/utils/file-system.ts
index f086a49..5d98dff 100644
--- a/src/utils/file-system.ts
+++ b/src/utils/file-system.ts
@@ -239,10 +239,28 @@ export class FileSystemUtils {
         }
         return await this.ensureWritePermissions(parentDir);
       }
-      
-      const testFile = path.join(dirPath, '.openspec-test-' + Date.now());
+
+      const testFile = path.join(dirPath, '.openspec-test-' + Date.now() + '-' + Math.random().toString(36).slice(2));
       await fs.writeFile(testFile, '');
-      await fs.unlink(testFile);
+
+      // On Windows, file may be temporarily locked by antivirus or indexing services.
+      // Retry unlink with a small delay if it fails.
+      const maxRetries = 3;
+      for (let attempt = 0; attempt < maxRetries; attempt++) {
+        try {
+          await fs.unlink(testFile);
+          break;
+        } catch (unlinkError: any) {
+          if (attempt === maxRetries - 1) {
+            // Last attempt failed, but we successfully wrote the file, so permissions are OK
+            // Just log and continue - the temp file will be cleaned up eventually
+            console.debug(`Could not clean up test file ${testFile}: ${unlinkError.message}`);
+          } else {
+            // Wait briefly before retrying (Windows file lock release)
+            await new Promise((resolve) => setTimeout(resolve, 50));
+          }
+        }
+      }
       return true;
     } catch (error: any) {
       console.debug(`Insufficient permissions to write to ${dirPath}: ${error.message}`);
@@ -250,3 +268,58 @@ export class FileSystemUtils {
     }
   }
 }
+
+/**
+ * Removes a marker block from file content.
+ * Only removes markers that are on their own lines (ignores inline mentions).
+ * Cleans up double blank lines that may result from removal.
+ *
+ * @param content - File content with markers
+ * @param startMarker - The start marker string
+ * @param endMarker - The end marker string
+ * @returns Content with marker block removed, or original content if markers not found/invalid
+ */
+export function removeMarkerBlock(
+  content: string,
+  startMarker: string,
+  endMarker: string
+): string {
+  const startIndex = findMarkerIndex(content, startMarker);
+  const endIndex = startIndex !== -1
+    ? findMarkerIndex(content, endMarker, startIndex + startMarker.length)
+    : findMarkerIndex(content, endMarker);
+
+  if (startIndex === -1 || endIndex === -1 || endIndex <= startIndex) {
+    return content;
+  }
+
+  // Find the start of the line containing the start marker
+  let lineStart = startIndex;
+  while (lineStart > 0 && content[lineStart - 1] !== '\n') {
+    lineStart--;
+  }
+
+  // Find the end of the line containing the end marker
+  let lineEnd = endIndex + endMarker.length;
+  while (lineEnd < content.length && content[lineEnd] !== '\n') {
+    lineEnd++;
+  }
+  // Include the trailing newline if present
+  if (lineEnd < content.length && content[lineEnd] === '\n') {
+    lineEnd++;
+  }
+
+  const before = content.substring(0, lineStart);
+  const after = content.substring(lineEnd);
+
+  // Clean up double blank lines (handle both Unix \n and Windows \r\n)
+  let result = before + after;
+  result = result.replace(/(\r?\n){3,}/g, '\n\n');
+
+  // Trim trailing whitespace but preserve leading whitespace and original newline style
+  if (result.trimEnd() === '') {
+    return '';
+  }
+  const newline = content.includes('\r\n') ? '\r\n' : '\n';
+  return result.trimEnd() + newline;
+}
diff --git a/src/utils/index.ts b/src/utils/index.ts
index 6e21a30..d0cf29e 100644
--- a/src/utils/index.ts
+++ b/src/utils/index.ts
@@ -9,4 +9,7 @@ export {
   resolveSchemaForChange,
   validateSchemaName,
   ChangeMetadataError,
-} from './change-metadata.js';
\ No newline at end of file
+} from './change-metadata.js';
+
+// File system utilities
+export { FileSystemUtils, removeMarkerBlock } from './file-system.js';
\ No newline at end of file
diff --git a/test/cli-e2e/basic.test.ts b/test/cli-e2e/basic.test.ts
index 3f0af11..33d045a 100644
--- a/test/cli-e2e/basic.test.ts
+++ b/test/cli-e2e/basic.test.ts
@@ -90,13 +90,13 @@ describe('openspec CLI e2e basics', () => {
         env: { CODEX_HOME: codexHome },
       });
       expect(result.exitCode).toBe(0);
-      expect(result.stdout).toContain('Tool summary:');
+      expect(result.stdout).toContain('OpenSpec Setup Complete');
 
-      // Check that tool configurations were created
-      const claudePath = path.join(emptyProjectDir, 'CLAUDE.md');
-      const cursorProposal = path.join(emptyProjectDir, '.cursor/commands/openspec-proposal.md');
-      expect(await fileExists(claudePath)).toBe(true);
-      expect(await fileExists(cursorProposal)).toBe(true);
+      // Check that skills were created for multiple tools
+      const claudeSkillPath = path.join(emptyProjectDir, '.claude/skills/openspec-explore/SKILL.md');
+      const cursorSkillPath = path.join(emptyProjectDir, '.cursor/skills/openspec-explore/SKILL.md');
+      expect(await fileExists(claudeSkillPath)).toBe(true);
+      expect(await fileExists(cursorSkillPath)).toBe(true);
     });
 
     it('initializes with --tools list option', async () => {
@@ -106,12 +106,14 @@ describe('openspec CLI e2e basics', () => {
 
       const result = await runCLI(['init', '--tools', 'claude'], { cwd: emptyProjectDir });
       expect(result.exitCode).toBe(0);
-      expect(result.stdout).toContain('Tool summary:');
-
-      const claudePath = path.join(emptyProjectDir, 'CLAUDE.md');
-      const cursorProposal = path.join(emptyProjectDir, '.cursor/commands/openspec-proposal.md');
-      expect(await fileExists(claudePath)).toBe(true);
-      expect(await fileExists(cursorProposal)).toBe(false); // Not selected
+      expect(result.stdout).toContain('OpenSpec Setup Complete');
+      expect(result.stdout).toContain('Claude Code');
+
+      // New init creates skills, not CLAUDE.md
+      const claudeSkillPath = path.join(emptyProjectDir, '.claude/skills/openspec-explore/SKILL.md');
+      const cursorSkillPath = path.join(emptyProjectDir, '.cursor/skills/openspec-explore/SKILL.md');
+      expect(await fileExists(claudeSkillPath)).toBe(true);
+      expect(await fileExists(cursorSkillPath)).toBe(false); // Not selected
     });
 
     it('initializes with --tools none option', async () => {
@@ -121,15 +123,14 @@ describe('openspec CLI e2e basics', () => {
 
       const result = await runCLI(['init', '--tools', 'none'], { cwd: emptyProjectDir });
       expect(result.exitCode).toBe(0);
-      expect(result.stdout).toContain('Tool summary:');
+      expect(result.stdout).toContain('OpenSpec Setup Complete');
 
-      const claudePath = path.join(emptyProjectDir, 'CLAUDE.md');
-      const cursorProposal = path.join(emptyProjectDir, '.cursor/commands/openspec-proposal.md');
-      const rootAgentsPath = path.join(emptyProjectDir, 'AGENTS.md');
+      // With --tools none, no tool skills should be created
+      const claudeSkillPath = path.join(emptyProjectDir, '.claude/skills/openspec-explore/SKILL.md');
+      const cursorSkillPath = path.join(emptyProjectDir, '.cursor/skills/openspec-explore/SKILL.md');
 
-      expect(await fileExists(rootAgentsPath)).toBe(true);
-      expect(await fileExists(claudePath)).toBe(false);
-      expect(await fileExists(cursorProposal)).toBe(false);
+      expect(await fileExists(claudeSkillPath)).toBe(false);
+      expect(await fileExists(cursorSkillPath)).toBe(false);
     });
 
     it('returns error for invalid tool names', async () => {
diff --git a/test/commands/artifact-workflow.test.ts b/test/commands/artifact-workflow.test.ts
index 8d05518..1816299 100644
--- a/test/commands/artifact-workflow.test.ts
+++ b/test/commands/artifact-workflow.test.ts
@@ -27,6 +27,13 @@ describe('artifact-workflow CLI commands', () => {
     return result.stdout + result.stderr;
   }
 
+  /**
+   * Normalizes path separators to forward slashes for cross-platform assertions.
+   */
+  function normalizePaths(str: string): string {
+    return str.replace(/\\/g, '/');
+  }
+
   /**
    * Creates a test change with the specified artifacts completed.
    * Note: An "active" change requires at least a proposal.md file to be detected.
@@ -145,13 +152,13 @@ describe('artifact-workflow CLI commands', () => {
     });
 
     it('supports --schema option', async () => {
-      await createTestChange('tdd-change');
+      await createTestChange('schema-change');
 
-      const result = await runCLI(['status', '--change', 'tdd-change', '--schema', 'tdd'], {
+      const result = await runCLI(['status', '--change', 'schema-change', '--schema', 'spec-driven'], {
         cwd: tempDir,
       });
       expect(result.exitCode).toBe(0);
-      expect(result.stdout).toContain('tdd');
+      expect(result.stdout).toContain('spec-driven');
     });
 
     it('errors for unknown schema', async () => {
@@ -275,12 +282,12 @@ describe('artifact-workflow CLI commands', () => {
       expect(result.stdout).toContain('tasks:');
     });
 
-    it('shows template paths for custom schema', async () => {
-      const result = await runCLI(['templates', '--schema', 'tdd'], { cwd: tempDir });
+    it('shows template paths for specified schema', async () => {
+      const result = await runCLI(['templates', '--schema', 'spec-driven'], { cwd: tempDir });
       expect(result.exitCode).toBe(0);
-      expect(result.stdout).toContain('Schema: tdd');
-      expect(result.stdout).toContain('spec:');
-      expect(result.stdout).toContain('tests:');
+      expect(result.stdout).toContain('Schema: spec-driven');
+      expect(result.stdout).toContain('proposal:');
+      expect(result.stdout).toContain('design:');
     });
 
     it('outputs JSON mapping of templates', async () => {
@@ -423,23 +430,16 @@ describe('artifact-workflow CLI commands', () => {
       expect(result.stdout).toContain('ready to be archived');
     });
 
-    it('uses tdd schema apply configuration', async () => {
-      // Create a TDD-style change with spec and tests
-      const changeDir = path.join(changesDir, 'tdd-apply');
-      await fs.mkdir(changeDir, { recursive: true });
-      await fs.writeFile(path.join(changeDir, 'spec.md'), '## Feature\nTest spec.');
-      const testsDir = path.join(changeDir, 'tests');
-      await fs.mkdir(testsDir, { recursive: true });
-      await fs.writeFile(path.join(testsDir, 'test.test.ts'), 'test("works", () => {})');
+    it('uses spec-driven schema apply configuration', async () => {
+      // Create a spec-driven style change with all artifacts
+      await createTestChange('apply-schema-test', ['proposal', 'design', 'specs', 'tasks']);
 
       const result = await runCLI(
-        ['instructions', 'apply', '--change', 'tdd-apply', '--schema', 'tdd'],
+        ['instructions', 'apply', '--change', 'apply-schema-test', '--schema', 'spec-driven'],
         { cwd: tempDir }
       );
       expect(result.exitCode).toBe(0);
-      expect(result.stdout).toContain('Schema: tdd');
-      // TDD schema has no task tracking, so should show schema instruction
-      expect(result.stdout).toContain('Run tests to see failures');
+      expect(result.stdout).toContain('Schema: spec-driven');
     });
 
     it('spec-driven schema uses apply block configuration', async () => {
@@ -552,57 +552,135 @@ artifacts:
   });
 
   describe('help text', () => {
-    it('marks status command as experimental in help', async () => {
+    it('status command help shows description', async () => {
       const result = await runCLI(['status', '--help']);
       expect(result.exitCode).toBe(0);
-      expect(result.stdout).toContain('[Experimental]');
+      expect(result.stdout).toContain('Display artifact completion status');
     });
 
-    it('marks instructions command as experimental in help', async () => {
+    it('instructions command help shows description', async () => {
       const result = await runCLI(['instructions', '--help']);
       expect(result.exitCode).toBe(0);
-      expect(result.stdout).toContain('[Experimental]');
+      expect(result.stdout).toContain('Output enriched instructions');
     });
 
-    it('marks templates command as experimental in help', async () => {
+    it('templates command help shows description', async () => {
       const result = await runCLI(['templates', '--help']);
       expect(result.exitCode).toBe(0);
-      expect(result.stdout).toContain('[Experimental]');
+      expect(result.stdout).toContain('Show resolved template paths');
     });
 
-    it('marks new command as experimental in help', async () => {
+    it('new command help shows description', async () => {
       const result = await runCLI(['new', '--help']);
       expect(result.exitCode).toBe(0);
-      expect(result.stdout).toContain('[Experimental]');
+      expect(result.stdout).toContain('Create new items');
+    });
+  });
+
+  describe('experimental command (deprecated alias for init)', () => {
+    it('shows deprecation notice', async () => {
+      const result = await runCLI(['experimental', '--tool', 'claude'], { cwd: tempDir });
+      // May succeed or fail depending on setup, but should show deprecation notice
+      const output = getOutput(result);
+      expect(output).toContain('deprecated');
+    });
+
+    it('errors for unknown tool', async () => {
+      const result = await runCLI(['experimental', '--tool', 'unknown-tool'], {
+        cwd: tempDir,
+      });
+      expect(result.exitCode).toBe(1);
+      const output = getOutput(result);
+      expect(output).toContain('Invalid tool(s): unknown-tool');
+    });
+
+    it('errors for tool without skillsDir', async () => {
+      // Using 'agents' which doesn't have skillsDir configured
+      const result = await runCLI(['experimental', '--tool', 'agents'], {
+        cwd: tempDir,
+      });
+      expect(result.exitCode).toBe(1);
+      const output = getOutput(result);
+      expect(output).toContain('Invalid tool(s): agents');
+    });
+
+    it('creates skills for Claude tool', async () => {
+      const result = await runCLI(['experimental', '--tool', 'claude'], {
+        cwd: tempDir,
+      });
+      expect(result.exitCode).toBe(0);
+      const output = normalizePaths(getOutput(result));
+      expect(output).toContain('Claude Code');
+      expect(output).toContain('.claude/');
+
+      // Verify skill files were created
+      const skillFile = path.join(tempDir, '.claude', 'skills', 'openspec-explore', 'SKILL.md');
+      const stat = await fs.stat(skillFile);
+      expect(stat.isFile()).toBe(true);
+    });
+
+    it('creates skills for Cursor tool', async () => {
+      const result = await runCLI(['experimental', '--tool', 'cursor'], {
+        cwd: tempDir,
+      });
+      expect(result.exitCode).toBe(0);
+      const output = normalizePaths(getOutput(result));
+      expect(output).toContain('Cursor');
+      expect(output).toContain('.cursor/');
+
+      // Verify skill files were created
+      const skillFile = path.join(tempDir, '.cursor', 'skills', 'openspec-explore', 'SKILL.md');
+      const stat = await fs.stat(skillFile);
+      expect(stat.isFile()).toBe(true);
+
+      // Verify commands were created with Cursor format
+      const commandFile = path.join(tempDir, '.cursor', 'commands', 'opsx-explore.md');
+      const content = await fs.readFile(commandFile, 'utf-8');
+      expect(content).toContain('name: /opsx-explore');
+    });
+
+    it('creates skills for Windsurf tool', async () => {
+      const result = await runCLI(['experimental', '--tool', 'windsurf'], {
+        cwd: tempDir,
+      });
+      expect(result.exitCode).toBe(0);
+      const output = normalizePaths(getOutput(result));
+      expect(output).toContain('Windsurf');
+      expect(output).toContain('.windsurf/');
+
+      // Verify skill files were created
+      const skillFile = path.join(tempDir, '.windsurf', 'skills', 'openspec-explore', 'SKILL.md');
+      const stat = await fs.stat(skillFile);
+      expect(stat.isFile()).toBe(true);
     });
   });
 
   describe('project config integration', () => {
     describe('new change uses config schema', () => {
       it('creates change with schema from project config', async () => {
-        // Create project config with tdd schema
+        // Create project config with spec-driven schema
         // Note: changesDir is already at tempDir/openspec/changes (created in beforeEach)
         await fs.writeFile(
           path.join(tempDir, 'openspec', 'config.yaml'),
-          'schema: tdd\n'
+          'schema: spec-driven\n'
         );
 
         // Create a new change without specifying schema
         const result = await runCLI(['new', 'change', 'test-change'], { cwd: tempDir, timeoutMs: 30000 });
         expect(result.exitCode).toBe(0);
 
-        // Verify the change was created with tdd schema
+        // Verify the change was created with spec-driven schema
         const metadataPath = path.join(changesDir, 'test-change', '.openspec.yaml');
         const metadata = await fs.readFile(metadataPath, 'utf-8');
-        expect(metadata).toContain('schema: tdd');
+        expect(metadata).toContain('schema: spec-driven');
       }, 60000);
 
       it('CLI schema overrides config schema', async () => {
-        // Create project config with tdd schema
+        // Create project config with spec-driven schema
         // Note: openspec directory already exists (from changesDir creation in beforeEach)
         await fs.writeFile(
           path.join(tempDir, 'openspec', 'config.yaml'),
-          'schema: tdd\n'
+          'schema: spec-driven\n'
         );
 
         // Create change with explicit schema
@@ -710,7 +788,7 @@ rules:
         const changeDir = await createTestChange('metadata-only-change');
         await fs.writeFile(
           path.join(changeDir, '.openspec.yaml'),
-          'schema: tdd\ncreated: "2025-01-05"\n'
+          'schema: spec-driven\ncreated: "2025-01-05"\n'
         );
 
         // Status should use schema from metadata
@@ -719,7 +797,7 @@ rules:
           { cwd: tempDir, timeoutMs: 30000 }
         );
         expect(result.exitCode).toBe(0);
-        expect(result.stdout).toContain('tdd');
+        expect(result.stdout).toContain('spec-driven');
       }, 60000);
     });
 
diff --git a/test/core/artifact-graph/instruction-loader.test.ts b/test/core/artifact-graph/instruction-loader.test.ts
index bc9a67c..9d8f612 100644
--- a/test/core/artifact-graph/instruction-loader.test.ts
+++ b/test/core/artifact-graph/instruction-loader.test.ts
@@ -63,11 +63,11 @@ describe('instruction-loader', () => {
       expect(context.completed.size).toBe(0);
     });
 
-    it('should load context with custom schema', () => {
-      const context = loadChangeContext(tempDir, 'my-change', 'tdd');
+    it('should load context with explicit schema', () => {
+      const context = loadChangeContext(tempDir, 'my-change', 'spec-driven');
 
-      expect(context.schemaName).toBe('tdd');
-      expect(context.graph.getName()).toBe('tdd');
+      expect(context.schemaName).toBe('spec-driven');
+      expect(context.graph.getName()).toBe('spec-driven');
     });
 
     it('should detect completed artifacts', () => {
@@ -91,20 +91,20 @@ describe('instruction-loader', () => {
       // Create change directory with metadata file
       const changeDir = path.join(tempDir, 'openspec', 'changes', 'my-change');
       fs.mkdirSync(changeDir, { recursive: true });
-      fs.writeFileSync(path.join(changeDir, '.openspec.yaml'), 'schema: tdd\ncreated: "2025-01-05"\n');
+      fs.writeFileSync(path.join(changeDir, '.openspec.yaml'), 'schema: spec-driven\ncreated: "2025-01-05"\n');
 
       // Load without explicit schema - should detect from metadata
       const context = loadChangeContext(tempDir, 'my-change');
 
-      expect(context.schemaName).toBe('tdd');
-      expect(context.graph.getName()).toBe('tdd');
+      expect(context.schemaName).toBe('spec-driven');
+      expect(context.graph.getName()).toBe('spec-driven');
     });
 
     it('should use explicit schema over metadata schema', () => {
-      // Create change directory with metadata file using tdd
+      // Create change directory with metadata file using spec-driven
       const changeDir = path.join(tempDir, 'openspec', 'changes', 'my-change');
       fs.mkdirSync(changeDir, { recursive: true });
-      fs.writeFileSync(path.join(changeDir, '.openspec.yaml'), 'schema: tdd\n');
+      fs.writeFileSync(path.join(changeDir, '.openspec.yaml'), 'schema: spec-driven\n');
 
       // Load with explicit schema - should override metadata
       const context = loadChangeContext(tempDir, 'my-change', 'spec-driven');
diff --git a/test/core/artifact-graph/resolver.test.ts b/test/core/artifact-graph/resolver.test.ts
index 8c5f19f..484cc3b 100644
--- a/test/core/artifact-graph/resolver.test.ts
+++ b/test/core/artifact-graph/resolver.test.ts
@@ -80,14 +80,6 @@ describe('artifact-graph/resolver', () => {
       expect(schema.artifacts.length).toBeGreaterThan(0);
     });
 
-    it('should return built-in tdd schema', () => {
-      const schema = resolveSchema('tdd');
-
-      expect(schema.name).toBe('tdd');
-      expect(schema.version).toBe(1);
-      expect(schema.artifacts.length).toBeGreaterThan(0);
-    });
-
     it('should strip .yaml extension from name', () => {
       const schema1 = resolveSchema('spec-driven');
       const schema2 = resolveSchema('spec-driven.yaml');
@@ -261,7 +253,6 @@ version: [[[invalid yaml
       } catch (e) {
         const error = e as Error;
         expect(error.message).toContain('spec-driven');
-        expect(error.message).toContain('tdd');
       }
     });
   });
@@ -271,7 +262,6 @@ version: [[[invalid yaml
       const schemas = listSchemas();
 
       expect(schemas).toContain('spec-driven');
-      expect(schemas).toContain('tdd');
     });
 
     it('should include user override schemas', () => {
diff --git a/test/core/artifact-graph/workflow.integration.test.ts b/test/core/artifact-graph/workflow.integration.test.ts
index 337c76a..64dd6fa 100644
--- a/test/core/artifact-graph/workflow.integration.test.ts
+++ b/test/core/artifact-graph/workflow.integration.test.ts
@@ -131,46 +131,6 @@ describe('artifact-graph workflow integration', () => {
     });
   });
 
-  describe('tdd workflow', () => {
-    it('should progress through complete workflow', () => {
-      const schema = resolveSchema('tdd');
-      const graph = ArtifactGraph.fromSchema(schema);
-
-      expect(graph.getName()).toBe('tdd');
-      expect(graph.getBuildOrder()).toEqual(['spec', 'tests', 'implementation', 'docs']);
-
-      // Initial state
-      let completed = detectCompleted(graph, tempDir);
-      expect(graph.getNextArtifacts(completed)).toEqual(['spec']);
-
-      // Create spec
-      fs.writeFileSync(path.join(tempDir, 'spec.md'), '# Feature Spec');
-      completed = detectCompleted(graph, tempDir);
-      expect(graph.getNextArtifacts(completed)).toEqual(['tests']);
-
-      // Create tests directory with test file
-      const testsDir = path.join(tempDir, 'tests');
-      fs.mkdirSync(testsDir, { recursive: true });
-      fs.writeFileSync(path.join(testsDir, 'feature.test.ts'), 'describe("feature", () => {});');
-      completed = detectCompleted(graph, tempDir);
-      expect(graph.getNextArtifacts(completed)).toEqual(['implementation']);
-
-      // Create src directory with implementation
-      const srcDir = path.join(tempDir, 'src');
-      fs.mkdirSync(srcDir, { recursive: true });
-      fs.writeFileSync(path.join(srcDir, 'feature.ts'), 'export function feature() {}');
-      completed = detectCompleted(graph, tempDir);
-      expect(graph.getNextArtifacts(completed)).toEqual(['docs']);
-
-      // Create docs
-      const docsDir = path.join(tempDir, 'docs');
-      fs.mkdirSync(docsDir, { recursive: true });
-      fs.writeFileSync(path.join(docsDir, 'feature.md'), '# Feature Documentation');
-      completed = detectCompleted(graph, tempDir);
-      expect(graph.isComplete(completed)).toBe(true);
-    });
-  });
-
   describe('build order consistency', () => {
     it('should return consistent build order across multiple calls', () => {
       const schema = resolveSchema('spec-driven');
diff --git a/test/core/command-generation/adapters.test.ts b/test/core/command-generation/adapters.test.ts
new file mode 100644
index 0000000..c40455d
--- /dev/null
+++ b/test/core/command-generation/adapters.test.ts
@@ -0,0 +1,517 @@
+import { describe, it, expect } from 'vitest';
+import path from 'path';
+import { amazonQAdapter } from '../../../src/core/command-generation/adapters/amazon-q.js';
+import { antigravityAdapter } from '../../../src/core/command-generation/adapters/antigravity.js';
+import { auggieAdapter } from '../../../src/core/command-generation/adapters/auggie.js';
+import { claudeAdapter } from '../../../src/core/command-generation/adapters/claude.js';
+import { clineAdapter } from '../../../src/core/command-generation/adapters/cline.js';
+import { codexAdapter } from '../../../src/core/command-generation/adapters/codex.js';
+import { codebuddyAdapter } from '../../../src/core/command-generation/adapters/codebuddy.js';
+import { continueAdapter } from '../../../src/core/command-generation/adapters/continue.js';
+import { costrictAdapter } from '../../../src/core/command-generation/adapters/costrict.js';
+import { crushAdapter } from '../../../src/core/command-generation/adapters/crush.js';
+import { cursorAdapter } from '../../../src/core/command-generation/adapters/cursor.js';
+import { factoryAdapter } from '../../../src/core/command-generation/adapters/factory.js';
+import { geminiAdapter } from '../../../src/core/command-generation/adapters/gemini.js';
+import { githubCopilotAdapter } from '../../../src/core/command-generation/adapters/github-copilot.js';
+import { iflowAdapter } from '../../../src/core/command-generation/adapters/iflow.js';
+import { kilocodeAdapter } from '../../../src/core/command-generation/adapters/kilocode.js';
+import { opencodeAdapter } from '../../../src/core/command-generation/adapters/opencode.js';
+import { qoderAdapter } from '../../../src/core/command-generation/adapters/qoder.js';
+import { qwenAdapter } from '../../../src/core/command-generation/adapters/qwen.js';
+import { roocodeAdapter } from '../../../src/core/command-generation/adapters/roocode.js';
+import { windsurfAdapter } from '../../../src/core/command-generation/adapters/windsurf.js';
+import type { CommandContent } from '../../../src/core/command-generation/types.js';
+
+describe('command-generation/adapters', () => {
+  const sampleContent: CommandContent = {
+    id: 'explore',
+    name: 'OpenSpec Explore',
+    description: 'Enter explore mode for thinking',
+    category: 'Workflow',
+    tags: ['workflow', 'explore', 'experimental'],
+    body: 'This is the command body.\n\nWith multiple lines.',
+  };
+
+  describe('claudeAdapter', () => {
+    it('should have correct toolId', () => {
+      expect(claudeAdapter.toolId).toBe('claude');
+    });
+
+    it('should generate correct file path', () => {
+      const filePath = claudeAdapter.getFilePath('explore');
+      expect(filePath).toBe(path.join('.claude', 'commands', 'opsx', 'explore.md'));
+    });
+
+    it('should generate correct file path for different command IDs', () => {
+      expect(claudeAdapter.getFilePath('new')).toBe(path.join('.claude', 'commands', 'opsx', 'new.md'));
+      expect(claudeAdapter.getFilePath('bulk-archive')).toBe(path.join('.claude', 'commands', 'opsx', 'bulk-archive.md'));
+    });
+
+    it('should format file with correct YAML frontmatter', () => {
+      const output = claudeAdapter.formatFile(sampleContent);
+
+      expect(output).toContain('---\n');
+      expect(output).toContain('name: OpenSpec Explore');
+      expect(output).toContain('description: Enter explore mode for thinking');
+      expect(output).toContain('category: Workflow');
+      expect(output).toContain('tags: [workflow, explore, experimental]');
+      expect(output).toContain('---\n\n');
+      expect(output).toContain('This is the command body.\n\nWith multiple lines.');
+    });
+
+    it('should handle empty tags', () => {
+      const contentNoTags: CommandContent = { ...sampleContent, tags: [] };
+      const output = claudeAdapter.formatFile(contentNoTags);
+      expect(output).toContain('tags: []');
+    });
+  });
+
+  describe('cursorAdapter', () => {
+    it('should have correct toolId', () => {
+      expect(cursorAdapter.toolId).toBe('cursor');
+    });
+
+    it('should generate correct file path with opsx- prefix', () => {
+      const filePath = cursorAdapter.getFilePath('explore');
+      expect(filePath).toBe(path.join('.cursor', 'commands', 'opsx-explore.md'));
+    });
+
+    it('should generate correct file paths for different commands', () => {
+      expect(cursorAdapter.getFilePath('new')).toBe(path.join('.cursor', 'commands', 'opsx-new.md'));
+      expect(cursorAdapter.getFilePath('bulk-archive')).toBe(path.join('.cursor', 'commands', 'opsx-bulk-archive.md'));
+    });
+
+    it('should format file with Cursor-specific frontmatter', () => {
+      const output = cursorAdapter.formatFile(sampleContent);
+
+      expect(output).toContain('---\n');
+      expect(output).toContain('name: /opsx-explore');
+      expect(output).toContain('id: opsx-explore');
+      expect(output).toContain('category: Workflow');
+      expect(output).toContain('description: Enter explore mode for thinking');
+      expect(output).toContain('---\n\n');
+      expect(output).toContain('This is the command body.');
+    });
+
+    it('should not include tags in Cursor format', () => {
+      const output = cursorAdapter.formatFile(sampleContent);
+      expect(output).not.toContain('tags:');
+    });
+  });
+
+  describe('windsurfAdapter', () => {
+    it('should have correct toolId', () => {
+      expect(windsurfAdapter.toolId).toBe('windsurf');
+    });
+
+    it('should generate correct file path', () => {
+      const filePath = windsurfAdapter.getFilePath('explore');
+      expect(filePath).toBe(path.join('.windsurf', 'commands', 'opsx', 'explore.md'));
+    });
+
+    it('should format file similar to Claude format', () => {
+      const output = windsurfAdapter.formatFile(sampleContent);
+
+      expect(output).toContain('---\n');
+      expect(output).toContain('name: OpenSpec Explore');
+      expect(output).toContain('description: Enter explore mode for thinking');
+      expect(output).toContain('category: Workflow');
+      expect(output).toContain('tags: [workflow, explore, experimental]');
+      expect(output).toContain('---\n\n');
+      expect(output).toContain('This is the command body.');
+    });
+  });
+
+  describe('amazonQAdapter', () => {
+    it('should have correct toolId', () => {
+      expect(amazonQAdapter.toolId).toBe('amazon-q');
+    });
+
+    it('should generate correct file path', () => {
+      const filePath = amazonQAdapter.getFilePath('explore');
+      expect(filePath).toBe(path.join('.amazonq', 'prompts', 'opsx-explore.md'));
+    });
+
+    it('should format file with description frontmatter', () => {
+      const output = amazonQAdapter.formatFile(sampleContent);
+      expect(output).toContain('---\n');
+      expect(output).toContain('description: Enter explore mode for thinking');
+      expect(output).toContain('---\n\n');
+      expect(output).toContain('This is the command body.');
+    });
+  });
+
+  describe('antigravityAdapter', () => {
+    it('should have correct toolId', () => {
+      expect(antigravityAdapter.toolId).toBe('antigravity');
+    });
+
+    it('should generate correct file path', () => {
+      const filePath = antigravityAdapter.getFilePath('explore');
+      expect(filePath).toBe(path.join('.agent', 'workflows', 'opsx-explore.md'));
+    });
+
+    it('should format file with description frontmatter', () => {
+      const output = antigravityAdapter.formatFile(sampleContent);
+      expect(output).toContain('---\n');
+      expect(output).toContain('description: Enter explore mode for thinking');
+      expect(output).toContain('---\n\n');
+      expect(output).toContain('This is the command body.');
+    });
+  });
+
+  describe('auggieAdapter', () => {
+    it('should have correct toolId', () => {
+      expect(auggieAdapter.toolId).toBe('auggie');
+    });
+
+    it('should generate correct file path', () => {
+      const filePath = auggieAdapter.getFilePath('explore');
+      expect(filePath).toBe(path.join('.augment', 'commands', 'opsx-explore.md'));
+    });
+
+    it('should format file with description and argument-hint', () => {
+      const output = auggieAdapter.formatFile(sampleContent);
+      expect(output).toContain('---\n');
+      expect(output).toContain('description: Enter explore mode for thinking');
+      expect(output).toContain('argument-hint: command arguments');
+      expect(output).toContain('---\n\n');
+      expect(output).toContain('This is the command body.');
+    });
+  });
+
+  describe('clineAdapter', () => {
+    it('should have correct toolId', () => {
+      expect(clineAdapter.toolId).toBe('cline');
+    });
+
+    it('should generate correct file path', () => {
+      const filePath = clineAdapter.getFilePath('explore');
+      expect(filePath).toBe(path.join('.clinerules', 'workflows', 'opsx-explore.md'));
+    });
+
+    it('should format file with markdown header (no YAML frontmatter)', () => {
+      const output = clineAdapter.formatFile(sampleContent);
+      expect(output).toContain('# OpenSpec Explore');
+      expect(output).toContain('Enter explore mode for thinking');
+      expect(output).toContain('This is the command body.');
+      expect(output).not.toContain('---');
+    });
+  });
+
+  describe('codexAdapter', () => {
+    it('should have correct toolId', () => {
+      expect(codexAdapter.toolId).toBe('codex');
+    });
+
+    it('should generate correct file path', () => {
+      const filePath = codexAdapter.getFilePath('explore');
+      expect(filePath).toBe(path.join('.codex', 'prompts', 'opsx-explore.md'));
+    });
+
+    it('should format file with description and argument-hint', () => {
+      const output = codexAdapter.formatFile(sampleContent);
+      expect(output).toContain('---\n');
+      expect(output).toContain('description: Enter explore mode for thinking');
+      expect(output).toContain('argument-hint: command arguments');
+      expect(output).toContain('---\n\n');
+      expect(output).toContain('This is the command body.');
+    });
+  });
+
+  describe('codebuddyAdapter', () => {
+    it('should have correct toolId', () => {
+      expect(codebuddyAdapter.toolId).toBe('codebuddy');
+    });
+
+    it('should generate correct file path with nested opsx folder', () => {
+      const filePath = codebuddyAdapter.getFilePath('explore');
+      expect(filePath).toBe(path.join('.codebuddy', 'commands', 'opsx', 'explore.md'));
+    });
+
+    it('should format file with name, description, and argument-hint', () => {
+      const output = codebuddyAdapter.formatFile(sampleContent);
+      expect(output).toContain('---\n');
+      expect(output).toContain('name: OpenSpec Explore');
+      expect(output).toContain('description: "Enter explore mode for thinking"');
+      expect(output).toContain('argument-hint: "[command arguments]"');
+      expect(output).toContain('---\n\n');
+      expect(output).toContain('This is the command body.');
+    });
+  });
+
+  describe('continueAdapter', () => {
+    it('should have correct toolId', () => {
+      expect(continueAdapter.toolId).toBe('continue');
+    });
+
+    it('should generate correct file path with .prompt extension', () => {
+      const filePath = continueAdapter.getFilePath('explore');
+      expect(filePath).toBe(path.join('.continue', 'prompts', 'opsx-explore.prompt'));
+    });
+
+    it('should format file with name, description, and invokable', () => {
+      const output = continueAdapter.formatFile(sampleContent);
+      expect(output).toContain('---\n');
+      expect(output).toContain('name: opsx-explore');
+      expect(output).toContain('description: Enter explore mode for thinking');
+      expect(output).toContain('invokable: true');
+      expect(output).toContain('---\n\n');
+      expect(output).toContain('This is the command body.');
+    });
+  });
+
+  describe('costrictAdapter', () => {
+    it('should have correct toolId', () => {
+      expect(costrictAdapter.toolId).toBe('costrict');
+    });
+
+    it('should generate correct file path', () => {
+      const filePath = costrictAdapter.getFilePath('explore');
+      expect(filePath).toBe(path.join('.cospec', 'openspec', 'commands', 'opsx-explore.md'));
+    });
+
+    it('should format file with description and argument-hint', () => {
+      const output = costrictAdapter.formatFile(sampleContent);
+      expect(output).toContain('---\n');
+      expect(output).toContain('description: "Enter explore mode for thinking"');
+      expect(output).toContain('argument-hint: command arguments');
+      expect(output).toContain('---\n\n');
+      expect(output).toContain('This is the command body.');
+    });
+  });
+
+  describe('crushAdapter', () => {
+    it('should have correct toolId', () => {
+      expect(crushAdapter.toolId).toBe('crush');
+    });
+
+    it('should generate correct file path with nested opsx folder', () => {
+      const filePath = crushAdapter.getFilePath('explore');
+      expect(filePath).toBe(path.join('.crush', 'commands', 'opsx', 'explore.md'));
+    });
+
+    it('should format file with name, description, category, and tags', () => {
+      const output = crushAdapter.formatFile(sampleContent);
+      expect(output).toContain('---\n');
+      expect(output).toContain('name: OpenSpec Explore');
+      expect(output).toContain('description: Enter explore mode for thinking');
+      expect(output).toContain('category: Workflow');
+      expect(output).toContain('tags: [workflow, explore, experimental]');
+      expect(output).toContain('---\n\n');
+      expect(output).toContain('This is the command body.');
+    });
+  });
+
+  describe('factoryAdapter', () => {
+    it('should have correct toolId', () => {
+      expect(factoryAdapter.toolId).toBe('factory');
+    });
+
+    it('should generate correct file path', () => {
+      const filePath = factoryAdapter.getFilePath('explore');
+      expect(filePath).toBe(path.join('.factory', 'commands', 'opsx-explore.md'));
+    });
+
+    it('should format file with description and argument-hint', () => {
+      const output = factoryAdapter.formatFile(sampleContent);
+      expect(output).toContain('---\n');
+      expect(output).toContain('description: Enter explore mode for thinking');
+      expect(output).toContain('argument-hint: command arguments');
+      expect(output).toContain('---\n\n');
+      expect(output).toContain('This is the command body.');
+    });
+  });
+
+  describe('geminiAdapter', () => {
+    it('should have correct toolId', () => {
+      expect(geminiAdapter.toolId).toBe('gemini');
+    });
+
+    it('should generate correct file path with .toml extension', () => {
+      const filePath = geminiAdapter.getFilePath('explore');
+      expect(filePath).toBe(path.join('.gemini', 'commands', 'opsx', 'explore.toml'));
+    });
+
+    it('should format file in TOML format', () => {
+      const output = geminiAdapter.formatFile(sampleContent);
+      expect(output).toContain('description = "Enter explore mode for thinking"');
+      expect(output).toContain('prompt = """');
+      expect(output).toContain('This is the command body.');
+      expect(output).toContain('"""');
+    });
+  });
+
+  describe('githubCopilotAdapter', () => {
+    it('should have correct toolId', () => {
+      expect(githubCopilotAdapter.toolId).toBe('github-copilot');
+    });
+
+    it('should generate correct file path with .prompt.md extension', () => {
+      const filePath = githubCopilotAdapter.getFilePath('explore');
+      expect(filePath).toBe(path.join('.github', 'prompts', 'opsx-explore.prompt.md'));
+    });
+
+    it('should format file with description frontmatter', () => {
+      const output = githubCopilotAdapter.formatFile(sampleContent);
+      expect(output).toContain('---\n');
+      expect(output).toContain('description: Enter explore mode for thinking');
+      expect(output).toContain('---\n\n');
+      expect(output).toContain('This is the command body.');
+    });
+  });
+
+  describe('iflowAdapter', () => {
+    it('should have correct toolId', () => {
+      expect(iflowAdapter.toolId).toBe('iflow');
+    });
+
+    it('should generate correct file path', () => {
+      const filePath = iflowAdapter.getFilePath('explore');
+      expect(filePath).toBe(path.join('.iflow', 'commands', 'opsx-explore.md'));
+    });
+
+    it('should format file with name, id, category, and description', () => {
+      const output = iflowAdapter.formatFile(sampleContent);
+      expect(output).toContain('---\n');
+      expect(output).toContain('name: /opsx-explore');
+      expect(output).toContain('id: opsx-explore');
+      expect(output).toContain('category: Workflow');
+      expect(output).toContain('description: Enter explore mode for thinking');
+      expect(output).toContain('---\n\n');
+      expect(output).toContain('This is the command body.');
+    });
+  });
+
+  describe('kilocodeAdapter', () => {
+    it('should have correct toolId', () => {
+      expect(kilocodeAdapter.toolId).toBe('kilocode');
+    });
+
+    it('should generate correct file path', () => {
+      const filePath = kilocodeAdapter.getFilePath('explore');
+      expect(filePath).toBe(path.join('.kilocode', 'workflows', 'opsx-explore.md'));
+    });
+
+    it('should format file without frontmatter', () => {
+      const output = kilocodeAdapter.formatFile(sampleContent);
+      expect(output).not.toContain('---');
+      expect(output).toContain('This is the command body.');
+    });
+  });
+
+  describe('opencodeAdapter', () => {
+    it('should have correct toolId', () => {
+      expect(opencodeAdapter.toolId).toBe('opencode');
+    });
+
+    it('should generate correct file path', () => {
+      const filePath = opencodeAdapter.getFilePath('explore');
+      expect(filePath).toBe(path.join('.opencode', 'command', 'opsx-explore.md'));
+    });
+
+    it('should format file with description frontmatter', () => {
+      const output = opencodeAdapter.formatFile(sampleContent);
+      expect(output).toContain('---\n');
+      expect(output).toContain('description: Enter explore mode for thinking');
+      expect(output).toContain('---\n\n');
+      expect(output).toContain('This is the command body.');
+    });
+  });
+
+  describe('qoderAdapter', () => {
+    it('should have correct toolId', () => {
+      expect(qoderAdapter.toolId).toBe('qoder');
+    });
+
+    it('should generate correct file path with nested opsx folder', () => {
+      const filePath = qoderAdapter.getFilePath('explore');
+      expect(filePath).toBe(path.join('.qoder', 'commands', 'opsx', 'explore.md'));
+    });
+
+    it('should format file with name, description, category, and tags', () => {
+      const output = qoderAdapter.formatFile(sampleContent);
+      expect(output).toContain('---\n');
+      expect(output).toContain('name: OpenSpec Explore');
+      expect(output).toContain('description: Enter explore mode for thinking');
+      expect(output).toContain('category: Workflow');
+      expect(output).toContain('tags: [workflow, explore, experimental]');
+      expect(output).toContain('---\n\n');
+      expect(output).toContain('This is the command body.');
+    });
+  });
+
+  describe('qwenAdapter', () => {
+    it('should have correct toolId', () => {
+      expect(qwenAdapter.toolId).toBe('qwen');
+    });
+
+    it('should generate correct file path with .toml extension', () => {
+      const filePath = qwenAdapter.getFilePath('explore');
+      expect(filePath).toBe(path.join('.qwen', 'commands', 'opsx-explore.toml'));
+    });
+
+    it('should format file in TOML format', () => {
+      const output = qwenAdapter.formatFile(sampleContent);
+      expect(output).toContain('description = "Enter explore mode for thinking"');
+      expect(output).toContain('prompt = """');
+      expect(output).toContain('This is the command body.');
+      expect(output).toContain('"""');
+    });
+  });
+
+  describe('roocodeAdapter', () => {
+    it('should have correct toolId', () => {
+      expect(roocodeAdapter.toolId).toBe('roocode');
+    });
+
+    it('should generate correct file path', () => {
+      const filePath = roocodeAdapter.getFilePath('explore');
+      expect(filePath).toBe(path.join('.roo', 'commands', 'opsx-explore.md'));
+    });
+
+    it('should format file with markdown header (no YAML frontmatter)', () => {
+      const output = roocodeAdapter.formatFile(sampleContent);
+      expect(output).toContain('# OpenSpec Explore');
+      expect(output).toContain('Enter explore mode for thinking');
+      expect(output).toContain('This is the command body.');
+      expect(output).not.toContain('---');
+    });
+  });
+
+  describe('cross-platform path handling', () => {
+    it('Claude adapter uses path.join for paths', () => {
+      // path.join handles platform-specific separators
+      const filePath = claudeAdapter.getFilePath('test');
+      // On any platform, path.join returns the correct separator
+      expect(filePath.split(path.sep)).toEqual(['.claude', 'commands', 'opsx', 'test.md']);
+    });
+
+    it('Cursor adapter uses path.join for paths', () => {
+      const filePath = cursorAdapter.getFilePath('test');
+      expect(filePath.split(path.sep)).toEqual(['.cursor', 'commands', 'opsx-test.md']);
+    });
+
+    it('Windsurf adapter uses path.join for paths', () => {
+      const filePath = windsurfAdapter.getFilePath('test');
+      expect(filePath.split(path.sep)).toEqual(['.windsurf', 'commands', 'opsx', 'test.md']);
+    });
+
+    it('All adapters use path.join for paths', () => {
+      // Verify all adapters produce valid paths
+      const adapters = [
+        amazonQAdapter, antigravityAdapter, auggieAdapter, clineAdapter,
+        codexAdapter, codebuddyAdapter, continueAdapter, costrictAdapter,
+        crushAdapter, factoryAdapter, geminiAdapter, githubCopilotAdapter,
+        iflowAdapter, kilocodeAdapter, opencodeAdapter, qoderAdapter,
+        qwenAdapter, roocodeAdapter
+      ];
+      for (const adapter of adapters) {
+        const filePath = adapter.getFilePath('test');
+        expect(filePath.length).toBeGreaterThan(0);
+        expect(filePath.includes(path.sep) || filePath.includes('.')).toBe(true);
+      }
+    });
+  });
+});
diff --git a/test/core/command-generation/generator.test.ts b/test/core/command-generation/generator.test.ts
new file mode 100644
index 0000000..903aac3
--- /dev/null
+++ b/test/core/command-generation/generator.test.ts
@@ -0,0 +1,110 @@
+import { describe, it, expect } from 'vitest';
+import { generateCommand, generateCommands } from '../../../src/core/command-generation/generator.js';
+import { claudeAdapter } from '../../../src/core/command-generation/adapters/claude.js';
+import { cursorAdapter } from '../../../src/core/command-generation/adapters/cursor.js';
+import type { CommandContent, ToolCommandAdapter } from '../../../src/core/command-generation/types.js';
+
+describe('command-generation/generator', () => {
+  const sampleContent: CommandContent = {
+    id: 'explore',
+    name: 'OpenSpec Explore',
+    description: 'Enter explore mode',
+    category: 'Workflow',
+    tags: ['workflow'],
+    body: 'Command body here.',
+  };
+
+  describe('generateCommand', () => {
+    it('should generate command with path and content using Claude adapter', () => {
+      const result = generateCommand(sampleContent, claudeAdapter);
+
+      expect(result.path).toContain('.claude');
+      expect(result.path).toContain('explore.md');
+      expect(result.fileContent).toContain('name: OpenSpec Explore');
+      expect(result.fileContent).toContain('Command body here.');
+    });
+
+    it('should generate command with path and content using Cursor adapter', () => {
+      const result = generateCommand(sampleContent, cursorAdapter);
+
+      expect(result.path).toContain('.cursor');
+      expect(result.path).toContain('opsx-explore.md');
+      expect(result.fileContent).toContain('name: /opsx-explore');
+      expect(result.fileContent).toContain('id: opsx-explore');
+      expect(result.fileContent).toContain('Command body here.');
+    });
+
+    it('should use command id for path', () => {
+      const content: CommandContent = { ...sampleContent, id: 'custom-cmd' };
+      const result = generateCommand(content, claudeAdapter);
+
+      expect(result.path).toContain('custom-cmd.md');
+    });
+
+    it('should work with custom adapter', () => {
+      const customAdapter: ToolCommandAdapter = {
+        toolId: 'custom',
+        getFilePath: (id) => `.custom/${id}.txt`,
+        formatFile: (content) => `# ${content.name}\n\n${content.body}`,
+      };
+
+      const result = generateCommand(sampleContent, customAdapter);
+
+      expect(result.path).toBe('.custom/explore.txt');
+      expect(result.fileContent).toBe('# OpenSpec Explore\n\nCommand body here.');
+    });
+  });
+
+  describe('generateCommands', () => {
+    it('should generate multiple commands', () => {
+      const contents: CommandContent[] = [
+        { ...sampleContent, id: 'explore', name: 'Explore' },
+        { ...sampleContent, id: 'new', name: 'New' },
+        { ...sampleContent, id: 'apply', name: 'Apply' },
+      ];
+
+      const results = generateCommands(contents, claudeAdapter);
+
+      expect(results).toHaveLength(3);
+      expect(results[0].path).toContain('explore.md');
+      expect(results[1].path).toContain('new.md');
+      expect(results[2].path).toContain('apply.md');
+    });
+
+    it('should return empty array for empty input', () => {
+      const results = generateCommands([], claudeAdapter);
+      expect(results).toEqual([]);
+    });
+
+    it('should preserve order of input', () => {
+      const contents: CommandContent[] = [
+        { ...sampleContent, id: 'c', name: 'C' },
+        { ...sampleContent, id: 'a', name: 'A' },
+        { ...sampleContent, id: 'b', name: 'B' },
+      ];
+
+      const results = generateCommands(contents, claudeAdapter);
+
+      expect(results[0].path).toContain('c.md');
+      expect(results[1].path).toContain('a.md');
+      expect(results[2].path).toContain('b.md');
+    });
+
+    it('should generate each command independently', () => {
+      const contents: CommandContent[] = [
+        { id: 'a', name: 'A', description: 'DA', category: 'C1', tags: ['t1'], body: 'B1' },
+        { id: 'b', name: 'B', description: 'DB', category: 'C2', tags: ['t2'], body: 'B2' },
+      ];
+
+      const results = generateCommands(contents, claudeAdapter);
+
+      expect(results[0].fileContent).toContain('name: A');
+      expect(results[0].fileContent).toContain('B1');
+      expect(results[0].fileContent).not.toContain('name: B');
+
+      expect(results[1].fileContent).toContain('name: B');
+      expect(results[1].fileContent).toContain('B2');
+      expect(results[1].fileContent).not.toContain('name: A');
+    });
+  });
+});
diff --git a/test/core/command-generation/registry.test.ts b/test/core/command-generation/registry.test.ts
new file mode 100644
index 0000000..8a86cd3
--- /dev/null
+++ b/test/core/command-generation/registry.test.ts
@@ -0,0 +1,101 @@
+import { describe, it, expect } from 'vitest';
+import { CommandAdapterRegistry } from '../../../src/core/command-generation/registry.js';
+
+describe('command-generation/registry', () => {
+  describe('get', () => {
+    it('should return Claude adapter for "claude"', () => {
+      const adapter = CommandAdapterRegistry.get('claude');
+      expect(adapter).toBeDefined();
+      expect(adapter?.toolId).toBe('claude');
+    });
+
+    it('should return Cursor adapter for "cursor"', () => {
+      const adapter = CommandAdapterRegistry.get('cursor');
+      expect(adapter).toBeDefined();
+      expect(adapter?.toolId).toBe('cursor');
+    });
+
+    it('should return Windsurf adapter for "windsurf"', () => {
+      const adapter = CommandAdapterRegistry.get('windsurf');
+      expect(adapter).toBeDefined();
+      expect(adapter?.toolId).toBe('windsurf');
+    });
+
+    it('should return undefined for unregistered tool', () => {
+      const adapter = CommandAdapterRegistry.get('unknown-tool');
+      expect(adapter).toBeUndefined();
+    });
+
+    it('should return undefined for empty string', () => {
+      const adapter = CommandAdapterRegistry.get('');
+      expect(adapter).toBeUndefined();
+    });
+  });
+
+  describe('getAll', () => {
+    it('should return array of all registered adapters', () => {
+      const adapters = CommandAdapterRegistry.getAll();
+      expect(Array.isArray(adapters)).toBe(true);
+      expect(adapters.length).toBeGreaterThanOrEqual(3); // At least Claude, Cursor, Windsurf
+    });
+
+    it('should include Claude, Cursor, and Windsurf adapters', () => {
+      const adapters = CommandAdapterRegistry.getAll();
+      const toolIds = adapters.map((a) => a.toolId);
+
+      expect(toolIds).toContain('claude');
+      expect(toolIds).toContain('cursor');
+      expect(toolIds).toContain('windsurf');
+    });
+  });
+
+  describe('has', () => {
+    it('should return true for registered tools', () => {
+      expect(CommandAdapterRegistry.has('claude')).toBe(true);
+      expect(CommandAdapterRegistry.has('cursor')).toBe(true);
+      expect(CommandAdapterRegistry.has('windsurf')).toBe(true);
+    });
+
+    it('should return false for unregistered tools', () => {
+      expect(CommandAdapterRegistry.has('unknown')).toBe(false);
+      expect(CommandAdapterRegistry.has('')).toBe(false);
+    });
+  });
+
+  describe('adapter functionality', () => {
+    it('registered adapters should have working getFilePath', () => {
+      const claudeAdapter = CommandAdapterRegistry.get('claude');
+      const cursorAdapter = CommandAdapterRegistry.get('cursor');
+      const windsurfAdapter = CommandAdapterRegistry.get('windsurf');
+
+      expect(claudeAdapter?.getFilePath('test')).toContain('.claude');
+      expect(cursorAdapter?.getFilePath('test')).toContain('.cursor');
+      expect(windsurfAdapter?.getFilePath('test')).toContain('.windsurf');
+    });
+
+    it('registered adapters should have working formatFile', () => {
+      const content = {
+        id: 'test',
+        name: 'Test',
+        description: 'Test desc',
+        category: 'Test',
+        tags: ['tag1'],
+        body: 'Body content',
+      };
+
+      // Tools that don't use YAML frontmatter (markdown headers or TOML or plain)
+      const noYamlFrontmatter = ['cline', 'kilocode', 'roocode', 'gemini', 'qwen'];
+
+      const adapters = CommandAdapterRegistry.getAll();
+      for (const adapter of adapters) {
+        const output = adapter.formatFile(content);
+        // All adapters should include the body content
+        expect(output).toContain('Body content');
+        // Only check for YAML frontmatter for tools that use it
+        if (!noYamlFrontmatter.includes(adapter.toolId)) {
+          expect(output).toContain('---');
+        }
+      }
+    });
+  });
+});
diff --git a/test/core/command-generation/types.test.ts b/test/core/command-generation/types.test.ts
new file mode 100644
index 0000000..ded7daf
--- /dev/null
+++ b/test/core/command-generation/types.test.ts
@@ -0,0 +1,79 @@
+import { describe, it, expect } from 'vitest';
+import type { CommandContent, ToolCommandAdapter, GeneratedCommand } from '../../../src/core/command-generation/types.js';
+
+describe('command-generation/types', () => {
+  describe('CommandContent interface', () => {
+    it('should allow creating valid command content', () => {
+      const content: CommandContent = {
+        id: 'explore',
+        name: 'OpenSpec Explore',
+        description: 'Enter explore mode for thinking',
+        category: 'Workflow',
+        tags: ['workflow', 'explore'],
+        body: 'This is the command body content.',
+      };
+
+      expect(content.id).toBe('explore');
+      expect(content.name).toBe('OpenSpec Explore');
+      expect(content.description).toBe('Enter explore mode for thinking');
+      expect(content.category).toBe('Workflow');
+      expect(content.tags).toEqual(['workflow', 'explore']);
+      expect(content.body).toBe('This is the command body content.');
+    });
+
+    it('should allow empty tags array', () => {
+      const content: CommandContent = {
+        id: 'test',
+        name: 'Test',
+        description: 'Test command',
+        category: 'Test',
+        tags: [],
+        body: 'Body',
+      };
+
+      expect(content.tags).toEqual([]);
+    });
+  });
+
+  describe('ToolCommandAdapter interface contract', () => {
+    it('should implement adapter with getFilePath and formatFile', () => {
+      const mockAdapter: ToolCommandAdapter = {
+        toolId: 'test-tool',
+        getFilePath(commandId: string): string {
+          return `.test/${commandId}.md`;
+        },
+        formatFile(content: CommandContent): string {
+          return `---\nname: ${content.name}\n---\n\n${content.body}\n`;
+        },
+      };
+
+      expect(mockAdapter.toolId).toBe('test-tool');
+      expect(mockAdapter.getFilePath('explore')).toBe('.test/explore.md');
+
+      const content: CommandContent = {
+        id: 'test',
+        name: 'Test Command',
+        description: 'Desc',
+        category: 'Cat',
+        tags: [],
+        body: 'Body content',
+      };
+
+      const formatted = mockAdapter.formatFile(content);
+      expect(formatted).toContain('name: Test Command');
+      expect(formatted).toContain('Body content');
+    });
+  });
+
+  describe('GeneratedCommand interface', () => {
+    it('should represent generated command output', () => {
+      const generated: GeneratedCommand = {
+        path: '.claude/commands/opsx/explore.md',
+        fileContent: '---\nname: Test\n---\n\nBody\n',
+      };
+
+      expect(generated.path).toBe('.claude/commands/opsx/explore.md');
+      expect(generated.fileContent).toContain('name: Test');
+    });
+  });
+});
diff --git a/test/core/init.test.ts b/test/core/init.test.ts
index 8a8188e..f4b02bc 100644
--- a/test/core/init.test.ts
+++ b/test/core/init.test.ts
@@ -4,1748 +4,411 @@ import path from 'path';
 import os from 'os';
 import { InitCommand } from '../../src/core/init.js';
 
-const DONE = '__done__';
-
-type SelectionQueue = string[][];
-
-let selectionQueue: SelectionQueue = [];
-
-const mockPrompt = vi.fn(async () => {
-  if (selectionQueue.length === 0) {
-    throw new Error('No queued selections provided to init prompt.');
-  }
-  return selectionQueue.shift() ?? [];
-});
-
-function queueSelections(...values: string[]) {
-  let current: string[] = [];
-  values.forEach((value) => {
-    if (value === DONE) {
-      selectionQueue.push(current);
-      current = [];
-    } else {
-      current.push(value);
-    }
-  });
-
-  if (current.length > 0) {
-    selectionQueue.push(current);
-  }
-}
-
 describe('InitCommand', () => {
   let testDir: string;
-  let initCommand: InitCommand;
-  let prevCodexHome: string | undefined;
 
   beforeEach(async () => {
     testDir = path.join(os.tmpdir(), `openspec-init-test-${Date.now()}`);
     await fs.mkdir(testDir, { recursive: true });
-    selectionQueue = [];
-    mockPrompt.mockReset();
-    initCommand = new InitCommand({ prompt: mockPrompt });
-
-    // Route Codex global directory into the test sandbox
-    prevCodexHome = process.env.CODEX_HOME;
-    process.env.CODEX_HOME = path.join(testDir, '.codex');
 
     // Mock console.log to suppress output during tests
-    vi.spyOn(console, 'log').mockImplementation(() => { });
+    vi.spyOn(console, 'log').mockImplementation(() => {});
   });
 
   afterEach(async () => {
     await fs.rm(testDir, { recursive: true, force: true });
     vi.restoreAllMocks();
-    if (prevCodexHome === undefined) delete process.env.CODEX_HOME;
-    else process.env.CODEX_HOME = prevCodexHome;
   });
 
-  describe('execute', () => {
+  describe('execute with --tools flag', () => {
     it('should create OpenSpec directory structure', async () => {
-      queueSelections('claude', DONE);
+      const initCommand = new InitCommand({ tools: 'claude', force: true });
 
       await initCommand.execute(testDir);
 
       const openspecPath = path.join(testDir, 'openspec');
       expect(await directoryExists(openspecPath)).toBe(true);
-      expect(await directoryExists(path.join(openspecPath, 'specs'))).toBe(
-        true
-      );
-      expect(await directoryExists(path.join(openspecPath, 'changes'))).toBe(
-        true
-      );
-      expect(
-        await directoryExists(path.join(openspecPath, 'changes', 'archive'))
-      ).toBe(true);
-    });
-
-    it('should create AGENTS.md and project.md', async () => {
-      queueSelections('claude', DONE);
-
-      await initCommand.execute(testDir);
-
-      const openspecPath = path.join(testDir, 'openspec');
-      expect(await fileExists(path.join(openspecPath, 'AGENTS.md'))).toBe(true);
-      expect(await fileExists(path.join(openspecPath, 'project.md'))).toBe(
-        true
-      );
-
-      const agentsContent = await fs.readFile(
-        path.join(openspecPath, 'AGENTS.md'),
-        'utf-8'
-      );
-      expect(agentsContent).toContain('OpenSpec Instructions');
-
-      const projectContent = await fs.readFile(
-        path.join(openspecPath, 'project.md'),
-        'utf-8'
-      );
-      expect(projectContent).toContain('Project Context');
-    });
-
-    it('should create CLAUDE.md when Claude Code is selected', async () => {
-      queueSelections('claude', DONE);
-
-      await initCommand.execute(testDir);
-
-      const claudePath = path.join(testDir, 'CLAUDE.md');
-      expect(await fileExists(claudePath)).toBe(true);
-
-      const content = await fs.readFile(claudePath, 'utf-8');
-      expect(content).toContain('<!-- OPENSPEC:START -->');
-      expect(content).toContain("@/openspec/AGENTS.md");
-      expect(content).toContain('openspec update');
-      expect(content).toContain('<!-- OPENSPEC:END -->');
-    });
-
-    it('should update existing CLAUDE.md with markers', async () => {
-      queueSelections('claude', DONE);
-
-      const claudePath = path.join(testDir, 'CLAUDE.md');
-      const existingContent =
-        '# My Project Instructions\nCustom instructions here';
-      await fs.writeFile(claudePath, existingContent);
-
-      await initCommand.execute(testDir);
-
-      const updatedContent = await fs.readFile(claudePath, 'utf-8');
-      expect(updatedContent).toContain('<!-- OPENSPEC:START -->');
-      expect(updatedContent).toContain("@/openspec/AGENTS.md");
-      expect(updatedContent).toContain('openspec update');
-      expect(updatedContent).toContain('<!-- OPENSPEC:END -->');
-      expect(updatedContent).toContain('Custom instructions here');
+      expect(await directoryExists(path.join(openspecPath, 'specs'))).toBe(true);
+      expect(await directoryExists(path.join(openspecPath, 'changes'))).toBe(true);
+      expect(await directoryExists(path.join(openspecPath, 'changes', 'archive'))).toBe(true);
     });
 
-    it('should create CLINE.md when Cline is selected', async () => {
-      queueSelections('cline', DONE);
+    it('should create config.yaml with default schema', async () => {
+      const initCommand = new InitCommand({ tools: 'claude', force: true });
 
       await initCommand.execute(testDir);
 
-      const clinePath = path.join(testDir, 'CLINE.md');
-      expect(await fileExists(clinePath)).toBe(true);
+      const configPath = path.join(testDir, 'openspec', 'config.yaml');
+      expect(await fileExists(configPath)).toBe(true);
 
-      const content = await fs.readFile(clinePath, 'utf-8');
-      expect(content).toContain('<!-- OPENSPEC:START -->');
-      expect(content).toContain("@/openspec/AGENTS.md");
-      expect(content).toContain('openspec update');
-      expect(content).toContain('<!-- OPENSPEC:END -->');
+      const content = await fs.readFile(configPath, 'utf-8');
+      expect(content).toContain('schema: spec-driven');
     });
 
-    it('should update existing CLINE.md with markers', async () => {
-      queueSelections('cline', DONE);
-
-      const clinePath = path.join(testDir, 'CLINE.md');
-      const existingContent =
-        '# My Cline Rules\nCustom Cline instructions here';
-      await fs.writeFile(clinePath, existingContent);
-
-      await initCommand.execute(testDir);
-
-      const updatedContent = await fs.readFile(clinePath, 'utf-8');
-      expect(updatedContent).toContain('<!-- OPENSPEC:START -->');
-      expect(updatedContent).toContain("@/openspec/AGENTS.md");
-      expect(updatedContent).toContain('openspec update');
-      expect(updatedContent).toContain('<!-- OPENSPEC:END -->');
-      expect(updatedContent).toContain('Custom Cline instructions here');
-    });
-
-    it('should create Windsurf workflows when Windsurf is selected', async () => {
-      queueSelections('windsurf', DONE);
-
-      await initCommand.execute(testDir);
-
-      const wsProposal = path.join(
-        testDir,
-        '.windsurf/workflows/openspec-proposal.md'
-      );
-      const wsApply = path.join(
-        testDir,
-        '.windsurf/workflows/openspec-apply.md'
-      );
-      const wsArchive = path.join(
-        testDir,
-        '.windsurf/workflows/openspec-archive.md'
-      );
-
-      expect(await fileExists(wsProposal)).toBe(true);
-      expect(await fileExists(wsApply)).toBe(true);
-      expect(await fileExists(wsArchive)).toBe(true);
-
-      const proposalContent = await fs.readFile(wsProposal, 'utf-8');
-      expect(proposalContent).toContain('---');
-      expect(proposalContent).toContain('description: Scaffold a new OpenSpec change and validate strictly.');
-      expect(proposalContent).toContain('auto_execution_mode: 3');
-      expect(proposalContent).toContain('<!-- OPENSPEC:START -->');
-      expect(proposalContent).toContain('**Guardrails**');
-
-      const applyContent = await fs.readFile(wsApply, 'utf-8');
-      expect(applyContent).toContain('---');
-      expect(applyContent).toContain('description: Implement an approved OpenSpec change and keep tasks in sync.');
-      expect(applyContent).toContain('auto_execution_mode: 3');
-      expect(applyContent).toContain('<!-- OPENSPEC:START -->');
-      expect(applyContent).toContain('Work through tasks sequentially');
-
-      const archiveContent = await fs.readFile(wsArchive, 'utf-8');
-      expect(archiveContent).toContain('---');
-      expect(archiveContent).toContain('description: Archive a deployed OpenSpec change and update specs.');
-      expect(archiveContent).toContain('auto_execution_mode: 3');
-      expect(archiveContent).toContain('<!-- OPENSPEC:START -->');
-      expect(archiveContent).toContain('Run `openspec archive <id> --yes`');
-    });
-
-    it('should create Antigravity workflows when Antigravity is selected', async () => {
-      queueSelections('antigravity', DONE);
-
-      await initCommand.execute(testDir);
-
-      const agProposal = path.join(
-        testDir,
-        '.agent/workflows/openspec-proposal.md'
-      );
-      const agApply = path.join(
-        testDir,
-        '.agent/workflows/openspec-apply.md'
-      );
-      const agArchive = path.join(
-        testDir,
-        '.agent/workflows/openspec-archive.md'
-      );
-
-      expect(await fileExists(agProposal)).toBe(true);
-      expect(await fileExists(agApply)).toBe(true);
-      expect(await fileExists(agArchive)).toBe(true);
-
-      const proposalContent = await fs.readFile(agProposal, 'utf-8');
-      expect(proposalContent).toContain('---');
-      expect(proposalContent).toContain('description: Scaffold a new OpenSpec change and validate strictly.');
-      expect(proposalContent).toContain('<!-- OPENSPEC:START -->');
-      expect(proposalContent).toContain('**Guardrails**');
-      expect(proposalContent).not.toContain('auto_execution_mode');
-
-      const applyContent = await fs.readFile(agApply, 'utf-8');
-      expect(applyContent).toContain('---');
-      expect(applyContent).toContain('description: Implement an approved OpenSpec change and keep tasks in sync.');
-      expect(applyContent).toContain('<!-- OPENSPEC:START -->');
-      expect(applyContent).toContain('Work through tasks sequentially');
-      expect(applyContent).not.toContain('auto_execution_mode');
-
-      const archiveContent = await fs.readFile(agArchive, 'utf-8');
-      expect(archiveContent).toContain('---');
-      expect(archiveContent).toContain('description: Archive a deployed OpenSpec change and update specs.');
-      expect(archiveContent).toContain('<!-- OPENSPEC:START -->');
-      expect(archiveContent).toContain('Run `openspec archive <id> --yes`');
-      expect(archiveContent).not.toContain('auto_execution_mode');
-    });
-
-    it('should always create AGENTS.md in project root', async () => {
-      queueSelections(DONE);
-
-      await initCommand.execute(testDir);
-
-      const rootAgentsPath = path.join(testDir, 'AGENTS.md');
-      expect(await fileExists(rootAgentsPath)).toBe(true);
-
-      const content = await fs.readFile(rootAgentsPath, 'utf-8');
-      expect(content).toContain('<!-- OPENSPEC:START -->');
-      expect(content).toContain("@/openspec/AGENTS.md");
-      expect(content).toContain('openspec update');
-      expect(content).toContain('<!-- OPENSPEC:END -->');
-
-      const claudeExists = await fileExists(path.join(testDir, 'CLAUDE.md'));
-      expect(claudeExists).toBe(false);
-    });
-
-    it('should create Claude slash command files with templates', async () => {
-      queueSelections('claude', DONE);
-
-      await initCommand.execute(testDir);
-
-      const claudeProposal = path.join(
-        testDir,
-        '.claude/commands/openspec/proposal.md'
-      );
-      const claudeApply = path.join(
-        testDir,
-        '.claude/commands/openspec/apply.md'
-      );
-      const claudeArchive = path.join(
-        testDir,
-        '.claude/commands/openspec/archive.md'
-      );
-
-      expect(await fileExists(claudeProposal)).toBe(true);
-      expect(await fileExists(claudeApply)).toBe(true);
-      expect(await fileExists(claudeArchive)).toBe(true);
-
-      const proposalContent = await fs.readFile(claudeProposal, 'utf-8');
-      expect(proposalContent).toContain('name: OpenSpec - Proposal');
-      expect(proposalContent).toContain('<!-- OPENSPEC:START -->');
-      expect(proposalContent).toContain('**Guardrails**');
-
-      const applyContent = await fs.readFile(claudeApply, 'utf-8');
-      expect(applyContent).toContain('name: OpenSpec - Apply');
-      expect(applyContent).toContain('Work through tasks sequentially');
-
-      const archiveContent = await fs.readFile(claudeArchive, 'utf-8');
-      expect(archiveContent).toContain('name: OpenSpec - Archive');
-      expect(archiveContent).toContain('openspec archive <id>');
-      expect(archiveContent).toContain(
-        '`--skip-specs` only for tooling-only work'
-      );
-    });
-
-    it('should create Cursor slash command files with templates', async () => {
-      queueSelections('cursor', DONE);
-
-      await initCommand.execute(testDir);
-
-      const cursorProposal = path.join(
-        testDir,
-        '.cursor/commands/openspec-proposal.md'
-      );
-      const cursorApply = path.join(
-        testDir,
-        '.cursor/commands/openspec-apply.md'
-      );
-      const cursorArchive = path.join(
-        testDir,
-        '.cursor/commands/openspec-archive.md'
-      );
-
-      expect(await fileExists(cursorProposal)).toBe(true);
-      expect(await fileExists(cursorApply)).toBe(true);
-      expect(await fileExists(cursorArchive)).toBe(true);
-
-      const proposalContent = await fs.readFile(cursorProposal, 'utf-8');
-      expect(proposalContent).toContain('name: /openspec-proposal');
-      expect(proposalContent).toContain('<!-- OPENSPEC:END -->');
-
-      const applyContent = await fs.readFile(cursorApply, 'utf-8');
-      expect(applyContent).toContain('id: openspec-apply');
-      expect(applyContent).toContain('Work through tasks sequentially');
-
-      const archiveContent = await fs.readFile(cursorArchive, 'utf-8');
-      expect(archiveContent).toContain('name: /openspec-archive');
-      expect(archiveContent).toContain('openspec list --specs');
-    });
-
-    it('should create Gemini CLI TOML files when selected', async () => {
-      queueSelections('gemini', DONE);
-
-      await initCommand.execute(testDir);
-
-      const geminiProposal = path.join(
-        testDir,
-        '.gemini/commands/openspec/proposal.toml'
-      );
-      const geminiApply = path.join(
-        testDir,
-        '.gemini/commands/openspec/apply.toml'
-      );
-      const geminiArchive = path.join(
-        testDir,
-        '.gemini/commands/openspec/archive.toml'
-      );
-
-      expect(await fileExists(geminiProposal)).toBe(true);
-      expect(await fileExists(geminiApply)).toBe(true);
-      expect(await fileExists(geminiArchive)).toBe(true);
-
-      const proposalContent = await fs.readFile(geminiProposal, 'utf-8');
-      expect(proposalContent).toContain('description = "Scaffold a new OpenSpec change and validate strictly."');
-      expect(proposalContent).toContain('prompt = """');
-      expect(proposalContent).toContain('<!-- OPENSPEC:START -->');
-      expect(proposalContent).toContain('**Guardrails**');
-      expect(proposalContent).toContain('<!-- OPENSPEC:END -->');
-
-      const applyContent = await fs.readFile(geminiApply, 'utf-8');
-      expect(applyContent).toContain('description = "Implement an approved OpenSpec change and keep tasks in sync."');
-      expect(applyContent).toContain('Work through tasks sequentially');
-
-      const archiveContent = await fs.readFile(geminiArchive, 'utf-8');
-      expect(archiveContent).toContain('description = "Archive a deployed OpenSpec change and update specs."');
-      expect(archiveContent).toContain('openspec archive <id>');
-    });
-
-    it('should update existing Gemini CLI TOML files with refreshed content', async () => {
-      queueSelections('gemini', DONE);
-
-      await initCommand.execute(testDir);
-
-      const geminiProposal = path.join(
-        testDir,
-        '.gemini/commands/openspec/proposal.toml'
-      );
-
-      // Modify the file to simulate user customization
-      const originalContent = await fs.readFile(geminiProposal, 'utf-8');
-      const modifiedContent = originalContent.replace(
-        '<!-- OPENSPEC:START -->',
-        '<!-- OPENSPEC:START -->\nCustom instruction added by user\n'
-      );
-      await fs.writeFile(geminiProposal, modifiedContent);
-
-      // Run init again to test update/refresh path
-      queueSelections('gemini', DONE);
-      await initCommand.execute(testDir);
-
-      const updatedContent = await fs.readFile(geminiProposal, 'utf-8');
-      expect(updatedContent).toContain('<!-- OPENSPEC:START -->');
-      expect(updatedContent).toContain('**Guardrails**');
-      expect(updatedContent).toContain('<!-- OPENSPEC:END -->');
-      expect(updatedContent).not.toContain('Custom instruction added by user');
-    });
+    it('should create 9 Agent Skills for Claude Code', async () => {
+      const initCommand = new InitCommand({ tools: 'claude', force: true });
 
-    it('should create IFlow CLI slash command files with templates', async () => {
-      queueSelections('iflow', DONE);
       await initCommand.execute(testDir);
 
-      const iflowProposal = path.join(
-        testDir,
-        '.iflow/commands/openspec-proposal.md'
-      );
-      const iflowApply = path.join(
-        testDir,
-        '.iflow/commands/openspec-apply.md'
-      );
-      const iflowArchive = path.join(
-        testDir,
-        '.iflow/commands/openspec-archive.md'
-      );
-
-      expect(await fileExists(iflowProposal)).toBe(true);
-      expect(await fileExists(iflowApply)).toBe(true);
-      expect(await fileExists(iflowArchive)).toBe(true);
+      const skillNames = [
+        'openspec-explore',
+        'openspec-new-change',
+        'openspec-continue-change',
+        'openspec-apply-change',
+        'openspec-ff-change',
+        'openspec-sync-specs',
+        'openspec-archive-change',
+        'openspec-bulk-archive-change',
+        'openspec-verify-change',
+      ];
 
-      const proposalContent = await fs.readFile(iflowProposal, 'utf-8');
-      expect(proposalContent).toContain('description: Scaffold a new OpenSpec change and validate strictly.');
-      expect(proposalContent).toContain('<!-- OPENSPEC:START -->');
-      expect(proposalContent).toContain('**Guardrails**');
-      expect(proposalContent).toContain('<!-- OPENSPEC:END -->');
+      for (const skillName of skillNames) {
+        const skillFile = path.join(testDir, '.claude', 'skills', skillName, 'SKILL.md');
+        expect(await fileExists(skillFile)).toBe(true);
 
-      const applyContent = await fs.readFile(iflowApply, 'utf-8');
-      expect(applyContent).toContain('description: Implement an approved OpenSpec change and keep tasks in sync.');
-      expect(applyContent).toContain('Work through tasks sequentially');
-
-      const archiveContent = await fs.readFile(iflowArchive, 'utf-8');
-      expect(archiveContent).toContain('description: Archive a deployed OpenSpec change and update specs.');
-      expect(archiveContent).toContain('openspec archive <id>');
+        const content = await fs.readFile(skillFile, 'utf-8');
+        expect(content).toContain('---');
+        expect(content).toContain('name:');
+        expect(content).toContain('description:');
+      }
     });
 
-    it('should update existing IFLOW.md with markers', async () => {
-      queueSelections('iflow', DONE);
-
-      const iflowPath = path.join(testDir, 'IFLOW.md');
-      const existingContent = '# My IFLOW Instructions\nCustom instructions here';
-      await fs.writeFile(iflowPath, existingContent);
+    it('should create 9 slash commands for Claude Code', async () => {
+      const initCommand = new InitCommand({ tools: 'claude', force: true });
 
       await initCommand.execute(testDir);
 
-      const updatedContent = await fs.readFile(iflowPath, 'utf-8');
-      expect(updatedContent).toContain('<!-- OPENSPEC:START -->');
-      expect(updatedContent).toContain("@/openspec/AGENTS.md");
-      expect(updatedContent).toContain('openspec update');
-      expect(updatedContent).toContain('<!-- OPENSPEC:END -->');
-      expect(updatedContent).toContain('Custom instructions here');
-    });
-
-    it('should create OpenCode slash command files with templates', async () => {
-      queueSelections('opencode', DONE);
-
-      await initCommand.execute(testDir);
-
-      const openCodeProposal = path.join(
-        testDir,
-        '.opencode/command/openspec-proposal.md'
-      );
-      const openCodeApply = path.join(
-        testDir,
-        '.opencode/command/openspec-apply.md'
-      );
-      const openCodeArchive = path.join(
-        testDir,
-        '.opencode/command/openspec-archive.md'
-      );
-
-      expect(await fileExists(openCodeProposal)).toBe(true);
-      expect(await fileExists(openCodeApply)).toBe(true);
-      expect(await fileExists(openCodeArchive)).toBe(true);
+      const commandNames = [
+        'opsx/explore.md',
+        'opsx/new.md',
+        'opsx/continue.md',
+        'opsx/apply.md',
+        'opsx/ff.md',
+        'opsx/sync.md',
+        'opsx/archive.md',
+        'opsx/bulk-archive.md',
+        'opsx/verify.md',
+      ];
 
-      const proposalContent = await fs.readFile(openCodeProposal, 'utf-8');
-      expect(proposalContent).not.toContain('agent:');
-      expect(proposalContent).toContain(
-        'description: Scaffold a new OpenSpec change and validate strictly.'
-      );
-      expect(proposalContent).toContain('<!-- OPENSPEC:START -->');
-
-      const applyContent = await fs.readFile(openCodeApply, 'utf-8');
-      expect(applyContent).not.toContain('agent:');
-      expect(applyContent).toContain(
-        'description: Implement an approved OpenSpec change and keep tasks in sync.'
-      );
-      expect(applyContent).toContain('Work through tasks sequentially');
-
-      const archiveContent = await fs.readFile(openCodeArchive, 'utf-8');
-      expect(archiveContent).not.toContain('agent:');
-      expect(archiveContent).toContain(
-        'description: Archive a deployed OpenSpec change and update specs.'
-      );
-      expect(archiveContent).toContain('openspec list --specs');
+      for (const cmdName of commandNames) {
+        const cmdFile = path.join(testDir, '.claude', 'commands', cmdName);
+        expect(await fileExists(cmdFile)).toBe(true);
+      }
     });
 
-    it('should create Qwen configuration and slash command files with templates', async () => {
-      queueSelections('qwen', DONE);
+    it('should create skills in Cursor skills directory', async () => {
+      const initCommand = new InitCommand({ tools: 'cursor', force: true });
 
       await initCommand.execute(testDir);
 
-      const qwenConfigPath = path.join(testDir, 'QWEN.md');
-      const proposalPath = path.join(
-        testDir,
-        '.qwen/commands/openspec-proposal.toml'
-      );
-      const applyPath = path.join(
-        testDir,
-        '.qwen/commands/openspec-apply.toml'
-      );
-      const archivePath = path.join(
-        testDir,
-        '.qwen/commands/openspec-archive.toml'
-      );
-
-      expect(await fileExists(qwenConfigPath)).toBe(true);
-      expect(await fileExists(proposalPath)).toBe(true);
-      expect(await fileExists(applyPath)).toBe(true);
-      expect(await fileExists(archivePath)).toBe(true);
-
-      const qwenConfigContent = await fs.readFile(qwenConfigPath, 'utf-8');
-      expect(qwenConfigContent).toContain('<!-- OPENSPEC:START -->');
-      expect(qwenConfigContent).toContain("@/openspec/AGENTS.md");
-      expect(qwenConfigContent).toContain('<!-- OPENSPEC:END -->');
-
-      const proposalContent = await fs.readFile(proposalPath, 'utf-8');
-      expect(proposalContent).toContain('description = "Scaffold a new OpenSpec change and validate strictly."');
-      expect(proposalContent).toContain('prompt = """');
-      expect(proposalContent).toContain('<!-- OPENSPEC:START -->');
-
-      const applyContent = await fs.readFile(applyPath, 'utf-8');
-      expect(applyContent).toContain('description = "Implement an approved OpenSpec change and keep tasks in sync."');
-      expect(applyContent).toContain('Work through tasks sequentially');
-
-      const archiveContent = await fs.readFile(archivePath, 'utf-8');
-      expect(archiveContent).toContain('description = "Archive a deployed OpenSpec change and update specs."');
-      expect(archiveContent).toContain('openspec archive <id>');
+      const skillFile = path.join(testDir, '.cursor', 'skills', 'openspec-explore', 'SKILL.md');
+      expect(await fileExists(skillFile)).toBe(true);
     });
 
-    it('should update existing QWEN.md with markers', async () => {
-      queueSelections('qwen', DONE);
-
-      const qwenPath = path.join(testDir, 'QWEN.md');
-      const existingContent = '# My Qwen Instructions\nCustom instructions here';
-      await fs.writeFile(qwenPath, existingContent);
+    it('should create skills in Windsurf skills directory', async () => {
+      const initCommand = new InitCommand({ tools: 'windsurf', force: true });
 
       await initCommand.execute(testDir);
 
-      const updatedContent = await fs.readFile(qwenPath, 'utf-8');
-      expect(updatedContent).toContain('<!-- OPENSPEC:START -->');
-      expect(updatedContent).toContain("@/openspec/AGENTS.md");
-      expect(updatedContent).toContain('openspec update');
-      expect(updatedContent).toContain('<!-- OPENSPEC:END -->');
-      expect(updatedContent).toContain('Custom instructions here');
+      const skillFile = path.join(testDir, '.windsurf', 'skills', 'openspec-explore', 'SKILL.md');
+      expect(await fileExists(skillFile)).toBe(true);
     });
 
-    it('should create Cline workflow files with templates', async () => {
-      queueSelections('cline', DONE);
+    it('should create skills for multiple tools at once', async () => {
+      const initCommand = new InitCommand({ tools: 'claude,cursor', force: true });
 
       await initCommand.execute(testDir);
 
-      const clineProposal = path.join(
-        testDir,
-        '.clinerules/workflows/openspec-proposal.md'
-      );
-      const clineApply = path.join(
-        testDir,
-        '.clinerules/workflows/openspec-apply.md'
-      );
-      const clineArchive = path.join(
-        testDir,
-        '.clinerules/workflows/openspec-archive.md'
-      );
+      const claudeSkill = path.join(testDir, '.claude', 'skills', 'openspec-explore', 'SKILL.md');
+      const cursorSkill = path.join(testDir, '.cursor', 'skills', 'openspec-explore', 'SKILL.md');
 
-      expect(await fileExists(clineProposal)).toBe(true);
-      expect(await fileExists(clineApply)).toBe(true);
-      expect(await fileExists(clineArchive)).toBe(true);
-
-      const proposalContent = await fs.readFile(clineProposal, 'utf-8');
-      expect(proposalContent).toContain('# OpenSpec: Proposal');
-      expect(proposalContent).toContain('Scaffold a new OpenSpec change and validate strictly.');
-      expect(proposalContent).toContain('<!-- OPENSPEC:START -->');
-      expect(proposalContent).toContain('**Guardrails**');
-
-      const applyContent = await fs.readFile(clineApply, 'utf-8');
-      expect(applyContent).toContain('# OpenSpec: Apply');
-      expect(applyContent).toContain('Implement an approved OpenSpec change and keep tasks in sync.');
-      expect(applyContent).toContain('Work through tasks sequentially');
-
-      const archiveContent = await fs.readFile(clineArchive, 'utf-8');
-      expect(archiveContent).toContain('# OpenSpec: Archive');
-      expect(archiveContent).toContain('Archive a deployed OpenSpec change and update specs.');
-      expect(archiveContent).toContain('openspec archive <id>');
+      expect(await fileExists(claudeSkill)).toBe(true);
+      expect(await fileExists(cursorSkill)).toBe(true);
     });
 
-    it('should create Factory slash command files with templates', async () => {
-      queueSelections('factory', DONE);
+    it('should select all tools with --tools all option', async () => {
+      const initCommand = new InitCommand({ tools: 'all', force: true });
 
       await initCommand.execute(testDir);
 
-      const factoryProposal = path.join(
-        testDir,
-        '.factory/commands/openspec-proposal.md'
-      );
-      const factoryApply = path.join(
-        testDir,
-        '.factory/commands/openspec-apply.md'
-      );
-      const factoryArchive = path.join(
-        testDir,
-        '.factory/commands/openspec-archive.md'
-      );
+      // Check a few representative tools
+      const claudeSkill = path.join(testDir, '.claude', 'skills', 'openspec-explore', 'SKILL.md');
+      const cursorSkill = path.join(testDir, '.cursor', 'skills', 'openspec-explore', 'SKILL.md');
+      const windsurfSkill = path.join(testDir, '.windsurf', 'skills', 'openspec-explore', 'SKILL.md');
 
-      expect(await fileExists(factoryProposal)).toBe(true);
-      expect(await fileExists(factoryApply)).toBe(true);
-      expect(await fileExists(factoryArchive)).toBe(true);
-
-      const proposalContent = await fs.readFile(factoryProposal, 'utf-8');
-      expect(proposalContent).toContain('description: Scaffold a new OpenSpec change and validate strictly.');
-      expect(proposalContent).toContain('argument-hint: request or feature description');
-      expect(proposalContent).toContain('<!-- OPENSPEC:START -->');
-      expect(
-        /<!-- OPENSPEC:START -->([\s\S]*?)<!-- OPENSPEC:END -->/u.exec(
-          proposalContent
-        )?.[1]
-      ).toContain('$ARGUMENTS');
-
-      const applyContent = await fs.readFile(factoryApply, 'utf-8');
-      expect(applyContent).toContain('description: Implement an approved OpenSpec change and keep tasks in sync.');
-      expect(applyContent).toContain('argument-hint: change-id');
-      expect(applyContent).toContain('Work through tasks sequentially');
-      expect(
-        /<!-- OPENSPEC:START -->([\s\S]*?)<!-- OPENSPEC:END -->/u.exec(
-          applyContent
-        )?.[1]
-      ).toContain('$ARGUMENTS');
-
-      const archiveContent = await fs.readFile(factoryArchive, 'utf-8');
-      expect(archiveContent).toContain('description: Archive a deployed OpenSpec change and update specs.');
-      expect(archiveContent).toContain('argument-hint: change-id');
-      expect(archiveContent).toContain('openspec archive <id> --yes');
-      expect(
-        /<!-- OPENSPEC:START -->([\s\S]*?)<!-- OPENSPEC:END -->/u.exec(
-          archiveContent
-        )?.[1]
-      ).toContain('$ARGUMENTS');
+      expect(await fileExists(claudeSkill)).toBe(true);
+      expect(await fileExists(cursorSkill)).toBe(true);
+      expect(await fileExists(windsurfSkill)).toBe(true);
     });
 
-    it('should create Codex prompts with templates and placeholders', async () => {
-      queueSelections('codex', DONE);
+    it('should skip tool configuration with --tools none option', async () => {
+      const initCommand = new InitCommand({ tools: 'none', force: true });
 
       await initCommand.execute(testDir);
 
-      const proposalPath = path.join(
-        testDir,
-        '.codex/prompts/openspec-proposal.md'
-      );
-      const applyPath = path.join(
-        testDir,
-        '.codex/prompts/openspec-apply.md'
-      );
-      const archivePath = path.join(
-        testDir,
-        '.codex/prompts/openspec-archive.md'
-      );
+      // Should create OpenSpec structure but no skills
+      const openspecPath = path.join(testDir, 'openspec');
+      expect(await directoryExists(openspecPath)).toBe(true);
 
-      expect(await fileExists(proposalPath)).toBe(true);
-      expect(await fileExists(applyPath)).toBe(true);
-      expect(await fileExists(archivePath)).toBe(true);
-
-      const proposalContent = await fs.readFile(proposalPath, 'utf-8');
-      expect(proposalContent).toContain('description: Scaffold a new OpenSpec change and validate strictly.');
-      expect(proposalContent).toContain('argument-hint: request or feature description');
-      expect(proposalContent).toContain('$ARGUMENTS');
-      expect(proposalContent).toContain('<!-- OPENSPEC:START -->');
-      expect(proposalContent).toContain('**Guardrails**');
-
-      const applyContent = await fs.readFile(applyPath, 'utf-8');
-      expect(applyContent).toContain('description: Implement an approved OpenSpec change and keep tasks in sync.');
-      expect(applyContent).toContain('argument-hint: change-id');
-      expect(applyContent).toContain('$ARGUMENTS');
-      expect(applyContent).toContain('Work through tasks sequentially');
-
-      const archiveContent = await fs.readFile(archivePath, 'utf-8');
-      expect(archiveContent).toContain('description: Archive a deployed OpenSpec change and update specs.');
-      expect(archiveContent).toContain('argument-hint: change-id');
-      expect(archiveContent).toContain('$ARGUMENTS');
-      expect(archiveContent).toContain('openspec archive <id> --yes');
+      // No tool-specific directories should be created
+      const claudeSkillsDir = path.join(testDir, '.claude', 'skills');
+      expect(await directoryExists(claudeSkillsDir)).toBe(false);
     });
 
-    it('should create Kilo Code workflows with templates', async () => {
-      queueSelections('kilocode', DONE);
-
-      await initCommand.execute(testDir);
-
-      const proposalPath = path.join(
-        testDir,
-        '.kilocode/workflows/openspec-proposal.md'
-      );
-      const applyPath = path.join(
-        testDir,
-        '.kilocode/workflows/openspec-apply.md'
-      );
-      const archivePath = path.join(
-        testDir,
-        '.kilocode/workflows/openspec-archive.md'
-      );
-
-      expect(await fileExists(proposalPath)).toBe(true);
-      expect(await fileExists(applyPath)).toBe(true);
-      expect(await fileExists(archivePath)).toBe(true);
-
-      const proposalContent = await fs.readFile(proposalPath, 'utf-8');
-      expect(proposalContent).toContain('<!-- OPENSPEC:START -->');
-      expect(proposalContent).toContain('**Guardrails**');
-      expect(proposalContent).not.toContain('---\n');
-
-      const applyContent = await fs.readFile(applyPath, 'utf-8');
-      expect(applyContent).toContain('Work through tasks sequentially');
-      expect(applyContent).not.toContain('---\n');
+    it('should throw error for invalid tool names', async () => {
+      const initCommand = new InitCommand({ tools: 'invalid-tool', force: true });
 
-      const archiveContent = await fs.readFile(archivePath, 'utf-8');
-      expect(archiveContent).toContain('openspec list --specs');
-      expect(archiveContent).not.toContain('---\n');
+      await expect(initCommand.execute(testDir)).rejects.toThrow(/Invalid tool\(s\): invalid-tool/);
     });
 
-    it('should create GitHub Copilot prompt files with templates', async () => {
-      queueSelections('github-copilot', DONE);
-
-      await initCommand.execute(testDir);
-
-      const proposalPath = path.join(
-        testDir,
-        '.github/prompts/openspec-proposal.prompt.md'
-      );
-      const applyPath = path.join(
-        testDir,
-        '.github/prompts/openspec-apply.prompt.md'
-      );
-      const archivePath = path.join(
-        testDir,
-        '.github/prompts/openspec-archive.prompt.md'
-      );
-
-      expect(await fileExists(proposalPath)).toBe(true);
-      expect(await fileExists(applyPath)).toBe(true);
-      expect(await fileExists(archivePath)).toBe(true);
-
-      const proposalContent = await fs.readFile(proposalPath, 'utf-8');
-      expect(proposalContent).toContain('---');
-      expect(proposalContent).toContain('description: Scaffold a new OpenSpec change and validate strictly.');
-      expect(proposalContent).toContain('$ARGUMENTS');
-      expect(proposalContent).toContain('<!-- OPENSPEC:START -->');
-      expect(proposalContent).toContain('**Guardrails**');
-
-      const applyContent = await fs.readFile(applyPath, 'utf-8');
-      expect(applyContent).toContain('---');
-      expect(applyContent).toContain('description: Implement an approved OpenSpec change and keep tasks in sync.');
-      expect(applyContent).toContain('$ARGUMENTS');
-      expect(applyContent).toContain('Work through tasks sequentially');
-
-      const archiveContent = await fs.readFile(archivePath, 'utf-8');
-      expect(archiveContent).toContain('---');
-      expect(archiveContent).toContain('description: Archive a deployed OpenSpec change and update specs.');
-      expect(archiveContent).toContain('$ARGUMENTS');
-      expect(archiveContent).toContain('openspec archive <id> --yes');
-    });
+    it('should handle comma-separated tool names with spaces', async () => {
+      const initCommand = new InitCommand({ tools: 'claude, cursor', force: true });
 
-    it('should add new tool when OpenSpec already exists', async () => {
-      queueSelections('claude', DONE, 'cursor', DONE);
-      await initCommand.execute(testDir);
       await initCommand.execute(testDir);
 
-      const cursorProposal = path.join(
-        testDir,
-        '.cursor/commands/openspec-proposal.md'
-      );
-      expect(await fileExists(cursorProposal)).toBe(true);
-    });
+      const claudeSkill = path.join(testDir, '.claude', 'skills', 'openspec-explore', 'SKILL.md');
+      const cursorSkill = path.join(testDir, '.cursor', 'skills', 'openspec-explore', 'SKILL.md');
 
-    it('should allow extend mode with no additional native tools', async () => {
-      queueSelections('claude', DONE, DONE);
-      await initCommand.execute(testDir);
-      await expect(initCommand.execute(testDir)).resolves.toBeUndefined();
+      expect(await fileExists(claudeSkill)).toBe(true);
+      expect(await fileExists(cursorSkill)).toBe(true);
     });
 
-    it('should recreate deleted openspec/AGENTS.md in extend mode', async () => {
-      await testFileRecreationInExtendMode(
-        testDir,
-        initCommand,
-        'openspec/AGENTS.md',
-        'OpenSpec Instructions'
-      );
-    });
+    it('should reject combining reserved keywords with explicit tool ids', async () => {
+      const initCommand = new InitCommand({ tools: 'all,claude', force: true });
 
-    it('should recreate deleted openspec/project.md in extend mode', async () => {
-      await testFileRecreationInExtendMode(
-        testDir,
-        initCommand,
-        'openspec/project.md',
-        'Project Context'
+      await expect(initCommand.execute(testDir)).rejects.toThrow(
+        /Cannot combine reserved values "all" or "none" with specific tool IDs/
       );
     });
 
-    it('should preserve existing template files in extend mode', async () => {
-      queueSelections('claude', DONE, DONE);
+    it('should not create config.yaml if it already exists', async () => {
+      // Pre-create config.yaml
+      const openspecDir = path.join(testDir, 'openspec');
+      await fs.mkdir(openspecDir, { recursive: true });
+      const configPath = path.join(openspecDir, 'config.yaml');
+      const existingContent = 'schema: custom-schema\n';
+      await fs.writeFile(configPath, existingContent);
 
-      // First init
+      const initCommand = new InitCommand({ tools: 'claude', force: true });
       await initCommand.execute(testDir);
 
-      const agentsPath = path.join(testDir, 'openspec', 'AGENTS.md');
-      const customContent = '# My Custom AGENTS Content\nDo not overwrite this!';
-
-      // Modify the file with custom content
-      await fs.writeFile(agentsPath, customContent);
-
-      // Run init again - should NOT overwrite
-      await initCommand.execute(testDir);
-
-      const content = await fs.readFile(agentsPath, 'utf-8');
-      expect(content).toBe(customContent);
-      expect(content).not.toContain('OpenSpec Instructions');
+      const content = await fs.readFile(configPath, 'utf-8');
+      expect(content).toBe(existingContent);
     });
 
     it('should handle non-existent target directory', async () => {
-      queueSelections('claude', DONE);
-
       const newDir = path.join(testDir, 'new-project');
+      const initCommand = new InitCommand({ tools: 'claude', force: true });
+
       await initCommand.execute(newDir);
 
       const openspecPath = path.join(newDir, 'openspec');
       expect(await directoryExists(openspecPath)).toBe(true);
     });
 
-    it('should display success message with selected tool name', async () => {
-      queueSelections('claude', DONE);
-      const logSpy = vi.spyOn(console, 'log');
-
-      await initCommand.execute(testDir);
-
-      const calls = logSpy.mock.calls.flat().join('\n');
-      expect(calls).toContain('Copy these prompts to Claude Code');
-    });
-
-    it('should reference AGENTS compatible assistants in success message', async () => {
-      queueSelections(DONE);
-      const logSpy = vi.spyOn(console, 'log');
-
-      await initCommand.execute(testDir);
-
-      const calls = logSpy.mock.calls.flat().join('\n');
-      expect(calls).toContain(
-        'Copy these prompts to your AGENTS.md-compatible assistant'
-      );
-    });
-  });
-
-  describe('AI tool selection', () => {
-    it('should prompt for AI tool selection', async () => {
-      queueSelections('claude', DONE);
-
-      await initCommand.execute(testDir);
-
-      expect(mockPrompt).toHaveBeenCalledWith(
-        expect.objectContaining({
-          baseMessage: expect.stringContaining(
-            'Which natively supported AI tools do you use?'
-          ),
-        })
-      );
-    });
-
-    it('should handle different AI tool selections', async () => {
-      // For now, only Claude is available, but test the structure
-      queueSelections('claude', DONE);
-
-      await initCommand.execute(testDir);
-
-      // When other tools are added, we'd test their specific configurations here
-      const claudePath = path.join(testDir, 'CLAUDE.md');
-      expect(await fileExists(claudePath)).toBe(true);
-    });
-
-    it('should mark existing tools as already configured during extend mode', async () => {
-      queueSelections('claude', DONE, 'cursor', DONE);
-      await initCommand.execute(testDir);
-      await initCommand.execute(testDir);
-
-      const secondRunArgs = mockPrompt.mock.calls[1][0];
-      const claudeChoice = secondRunArgs.choices.find(
-        (choice: any) => choice.value === 'claude'
-      );
-      expect(claudeChoice.configured).toBe(true);
-    });
-
-    it('should mark Qwen as already configured during extend mode', async () => {
-      queueSelections('qwen', DONE, 'qwen', DONE);
-      await initCommand.execute(testDir);
-      await initCommand.execute(testDir);
-
-      const secondRunArgs = mockPrompt.mock.calls[1][0];
-      const qwenChoice = secondRunArgs.choices.find(
-        (choice: any) => choice.value === 'qwen'
-      );
-      expect(qwenChoice.configured).toBe(true);
-    });
-
-    it('should preselect Kilo Code when workflows already exist', async () => {
-      queueSelections('kilocode', DONE, 'kilocode', DONE);
-      await initCommand.execute(testDir);
-      await initCommand.execute(testDir);
-
-      const secondRunArgs = mockPrompt.mock.calls[1][0];
-      const preselected = secondRunArgs.initialSelected ?? [];
-      expect(preselected).toContain('kilocode');
-    });
-
-    it('should mark Windsurf as already configured during extend mode', async () => {
-      queueSelections('windsurf', DONE, 'windsurf', DONE);
-      await initCommand.execute(testDir);
-      await initCommand.execute(testDir);
-
-      const secondRunArgs = mockPrompt.mock.calls[1][0];
-      const wsChoice = secondRunArgs.choices.find(
-        (choice: any) => choice.value === 'windsurf'
-      );
-      expect(wsChoice.configured).toBe(true);
-    });
-
-    it('should mark Antigravity as already configured during extend mode', async () => {
-      queueSelections('antigravity', DONE, 'antigravity', DONE);
-      await initCommand.execute(testDir);
-      await initCommand.execute(testDir);
-
-      const secondRunArgs = mockPrompt.mock.calls[1][0];
-      const antigravityChoice = secondRunArgs.choices.find(
-        (choice: any) => choice.value === 'antigravity'
-      );
-      expect(antigravityChoice.configured).toBe(true);
-    });
-
-    it('should mark Codex as already configured during extend mode', async () => {
-      queueSelections('codex', DONE, 'codex', DONE);
-      await initCommand.execute(testDir);
-      await initCommand.execute(testDir);
-
-      const secondRunArgs = mockPrompt.mock.calls[1][0];
-      const codexChoice = secondRunArgs.choices.find(
-        (choice: any) => choice.value === 'codex'
-      );
-      expect(codexChoice.configured).toBe(true);
-    });
-
-    it('should mark Factory Droid as already configured during extend mode', async () => {
-      queueSelections('factory', DONE, 'factory', DONE);
-      await initCommand.execute(testDir);
-      await initCommand.execute(testDir);
-
-      const secondRunArgs = mockPrompt.mock.calls[1][0];
-      const factoryChoice = secondRunArgs.choices.find(
-        (choice: any) => choice.value === 'factory'
-      );
-      expect(factoryChoice.configured).toBe(true);
-    });
-
-    it('should mark GitHub Copilot as already configured during extend mode', async () => {
-      queueSelections('github-copilot', DONE, 'github-copilot', DONE);
-      await initCommand.execute(testDir);
-      await initCommand.execute(testDir);
-
-      const secondRunArgs = mockPrompt.mock.calls[1][0];
-      const githubCopilotChoice = secondRunArgs.choices.find(
-        (choice: any) => choice.value === 'github-copilot'
-      );
-      expect(githubCopilotChoice.configured).toBe(true);
-    });
-
-    it('should create Amazon Q Developer prompt files with templates', async () => {
-      queueSelections('amazon-q', DONE);
+    it('should work in extend mode (re-running init)', async () => {
+      const initCommand1 = new InitCommand({ tools: 'claude', force: true });
+      await initCommand1.execute(testDir);
 
-      await initCommand.execute(testDir);
+      // Run init again with a different tool
+      const initCommand2 = new InitCommand({ tools: 'cursor', force: true });
+      await initCommand2.execute(testDir);
 
-      const proposalPath = path.join(
-        testDir,
-        '.amazonq/prompts/openspec-proposal.md'
-      );
-      const applyPath = path.join(
-        testDir,
-        '.amazonq/prompts/openspec-apply.md'
-      );
-      const archivePath = path.join(
-        testDir,
-        '.amazonq/prompts/openspec-archive.md'
-      );
+      // Both tools should have skills
+      const claudeSkill = path.join(testDir, '.claude', 'skills', 'openspec-explore', 'SKILL.md');
+      const cursorSkill = path.join(testDir, '.cursor', 'skills', 'openspec-explore', 'SKILL.md');
 
-      expect(await fileExists(proposalPath)).toBe(true);
-      expect(await fileExists(applyPath)).toBe(true);
-      expect(await fileExists(archivePath)).toBe(true);
-
-      const proposalContent = await fs.readFile(proposalPath, 'utf-8');
-      expect(proposalContent).toContain('---');
-      expect(proposalContent).toContain('description: Scaffold a new OpenSpec change and validate strictly.');
-      expect(proposalContent).toContain('$ARGUMENTS');
-      expect(proposalContent).toContain('<!-- OPENSPEC:START -->');
-      expect(proposalContent).toContain('**Guardrails**');
-
-      const applyContent = await fs.readFile(applyPath, 'utf-8');
-      expect(applyContent).toContain('---');
-      expect(applyContent).toContain('description: Implement an approved OpenSpec change and keep tasks in sync.');
-      expect(applyContent).toContain('$ARGUMENTS');
-      expect(applyContent).toContain('<!-- OPENSPEC:START -->');
+      expect(await fileExists(claudeSkill)).toBe(true);
+      expect(await fileExists(cursorSkill)).toBe(true);
     });
 
-    it('should mark Amazon Q Developer as already configured during extend mode', async () => {
-      queueSelections('amazon-q', DONE, 'amazon-q', DONE);
-      await initCommand.execute(testDir);
-      await initCommand.execute(testDir);
+    it('should refresh skills on re-run for the same tool', async () => {
+      const initCommand1 = new InitCommand({ tools: 'claude', force: true });
+      await initCommand1.execute(testDir);
 
-      const secondRunArgs = mockPrompt.mock.calls[1][0];
-      const amazonQChoice = secondRunArgs.choices.find(
-        (choice: any) => choice.value === 'amazon-q'
-      );
-      expect(amazonQChoice.configured).toBe(true);
-    });
+      const skillFile = path.join(testDir, '.claude', 'skills', 'openspec-explore', 'SKILL.md');
+      const originalContent = await fs.readFile(skillFile, 'utf-8');
 
-    it('should create Auggie slash command files with templates', async () => {
-      queueSelections('auggie', DONE);
+      // Modify the file
+      await fs.writeFile(skillFile, '# Modified content\n');
 
-      await initCommand.execute(testDir);
+      // Run init again
+      const initCommand2 = new InitCommand({ tools: 'claude', force: true });
+      await initCommand2.execute(testDir);
 
-      const auggieProposal = path.join(
-        testDir,
-        '.augment/commands/openspec-proposal.md'
-      );
-      const auggieApply = path.join(
-        testDir,
-        '.augment/commands/openspec-apply.md'
-      );
-      const auggieArchive = path.join(
-        testDir,
-        '.augment/commands/openspec-archive.md'
-      );
-
-      expect(await fileExists(auggieProposal)).toBe(true);
-      expect(await fileExists(auggieApply)).toBe(true);
-      expect(await fileExists(auggieArchive)).toBe(true);
-
-      const proposalContent = await fs.readFile(auggieProposal, 'utf-8');
-      expect(proposalContent).toContain('---');
-      expect(proposalContent).toContain('description: Scaffold a new OpenSpec change and validate strictly.');
-      expect(proposalContent).toContain('argument-hint: feature description or request');
-      expect(proposalContent).toContain('<!-- OPENSPEC:START -->');
-      expect(proposalContent).toContain('**Guardrails**');
-
-      const applyContent = await fs.readFile(auggieApply, 'utf-8');
-      expect(applyContent).toContain('---');
-      expect(applyContent).toContain('description: Implement an approved OpenSpec change and keep tasks in sync.');
-      expect(applyContent).toContain('argument-hint: change-id');
-      expect(applyContent).toContain('Work through tasks sequentially');
-
-      const archiveContent = await fs.readFile(auggieArchive, 'utf-8');
-      expect(archiveContent).toContain('---');
-      expect(archiveContent).toContain('description: Archive a deployed OpenSpec change and update specs.');
-      expect(archiveContent).toContain('argument-hint: change-id');
-      expect(archiveContent).toContain('openspec archive <id> --yes');
+      const newContent = await fs.readFile(skillFile, 'utf-8');
+      expect(newContent).toBe(originalContent);
     });
+  });
 
-    it('should mark Auggie as already configured during extend mode', async () => {
-      queueSelections('auggie', DONE, 'auggie', DONE);
-      await initCommand.execute(testDir);
-      await initCommand.execute(testDir);
-
-      const secondRunArgs = mockPrompt.mock.calls[1][0];
-      const auggieChoice = secondRunArgs.choices.find(
-        (choice: any) => choice.value === 'auggie'
-      );
-      expect(auggieChoice.configured).toBe(true);
-    });
-
-    it('should create CodeBuddy slash command files with templates', async () => {
-      queueSelections('codebuddy', DONE);
-
-      await initCommand.execute(testDir);
-
-      const codeBuddyProposal = path.join(
-        testDir,
-        '.codebuddy/commands/openspec/proposal.md'
-      );
-      const codeBuddyApply = path.join(
-        testDir,
-        '.codebuddy/commands/openspec/apply.md'
-      );
-      const codeBuddyArchive = path.join(
-        testDir,
-        '.codebuddy/commands/openspec/archive.md'
-      );
-
-      expect(await fileExists(codeBuddyProposal)).toBe(true);
-      expect(await fileExists(codeBuddyApply)).toBe(true);
-      expect(await fileExists(codeBuddyArchive)).toBe(true);
-
-      const proposalContent = await fs.readFile(codeBuddyProposal, 'utf-8');
-      expect(proposalContent).toContain('---');
-      expect(proposalContent).toContain('name: OpenSpec: Proposal');
-      expect(proposalContent).toContain('description: "Scaffold a new OpenSpec change and validate strictly."');
-      expect(proposalContent).toContain('argument-hint: "[feature description or request]"');
-      expect(proposalContent).toContain('<!-- OPENSPEC:START -->');
-      expect(proposalContent).toContain('**Guardrails**');
-
-      const applyContent = await fs.readFile(codeBuddyApply, 'utf-8');
-      expect(applyContent).toContain('---');
-      expect(applyContent).toContain('name: OpenSpec: Apply');
-      expect(applyContent).toContain('description: "Implement an approved OpenSpec change and keep tasks in sync."');
-      expect(applyContent).toContain('Work through tasks sequentially');
-
-      const archiveContent = await fs.readFile(codeBuddyArchive, 'utf-8');
-      expect(archiveContent).toContain('---');
-      expect(archiveContent).toContain('name: OpenSpec: Archive');
-      expect(archiveContent).toContain('description: "Archive a deployed OpenSpec change and update specs."');
-      expect(archiveContent).toContain('openspec archive <id> --yes');
-    });
-
-    it('should mark CodeBuddy as already configured during extend mode', async () => {
-      queueSelections('codebuddy', DONE, 'codebuddy', DONE);
-      await initCommand.execute(testDir);
-      await initCommand.execute(testDir);
-
-      const secondRunArgs = mockPrompt.mock.calls[1][0];
-      const codeBuddyChoice = secondRunArgs.choices.find(
-        (choice: any) => choice.value === 'codebuddy'
-      );
-      expect(codeBuddyChoice.configured).toBe(true);
-    });
-
-    it('should create Continue slash command files with templates', async () => {
-      queueSelections('continue', DONE);
-
-      await initCommand.execute(testDir);
-
-      const continueProposal = path.join(
-        testDir,
-        '.continue/prompts/openspec-proposal.prompt'
-      );
-      const continueApply = path.join(
-        testDir,
-        '.continue/prompts/openspec-apply.prompt'
-      );
-      const continueArchive = path.join(
-        testDir,
-        '.continue/prompts/openspec-archive.prompt'
-      );
-
-      expect(await fileExists(continueProposal)).toBe(true);
-      expect(await fileExists(continueApply)).toBe(true);
-      expect(await fileExists(continueArchive)).toBe(true);
-
-      const proposalContent = await fs.readFile(continueProposal, 'utf-8');
-      expect(proposalContent).toContain('---');
-      expect(proposalContent).toContain('name: openspec-proposal');
-      expect(proposalContent).toContain('invokable: true');
-      expect(proposalContent).toContain('<!-- OPENSPEC:START -->');
-
-      const applyContent = await fs.readFile(continueApply, 'utf-8');
-      expect(applyContent).toContain('---');
-      expect(applyContent).toContain('name: openspec-apply');
-      expect(applyContent).toContain('description: Implement an approved OpenSpec change and keep tasks in sync.');
-      expect(applyContent).toContain('invokable: true');
-      expect(applyContent).toContain('Work through tasks sequentially');
-
-      const archiveContent = await fs.readFile(continueArchive, 'utf-8');
-      expect(archiveContent).toContain('---');
-      expect(archiveContent).toContain('name: openspec-archive');
-      expect(archiveContent).toContain('description: Archive a deployed OpenSpec change and update specs.');
-      expect(archiveContent).toContain('invokable: true');
-      expect(archiveContent).toContain('openspec archive <id> --yes');
-    });
-
-    it('should mark Continue as already configured during extend mode', async () => {
-      queueSelections('continue', DONE, 'continue', DONE);
-      await initCommand.execute(testDir);
-      await initCommand.execute(testDir);
-
-      const secondRunArgs = mockPrompt.mock.calls[1][0];
-      const continueChoice = secondRunArgs.choices.find(
-        (choice: any) => choice.value === 'continue'
-      );
-      expect(continueChoice.configured).toBe(true);
-    });
-
-    it('should create CODEBUDDY.md when CodeBuddy is selected', async () => {
-      queueSelections('codebuddy', DONE);
-
-      await initCommand.execute(testDir);
-
-      const codeBuddyPath = path.join(testDir, 'CODEBUDDY.md');
-      expect(await fileExists(codeBuddyPath)).toBe(true);
-
-      const content = await fs.readFile(codeBuddyPath, 'utf-8');
-      expect(content).toContain('<!-- OPENSPEC:START -->');
-      expect(content).toContain("@/openspec/AGENTS.md");
-      expect(content).toContain('openspec update');
-      expect(content).toContain('<!-- OPENSPEC:END -->');
-    });
-
-    it('should update existing CODEBUDDY.md with markers', async () => {
-      queueSelections('codebuddy', DONE);
-
-      const codeBuddyPath = path.join(testDir, 'CODEBUDDY.md');
-      const existingContent =
-        '# My CodeBuddy Instructions\nCustom instructions here';
-      await fs.writeFile(codeBuddyPath, existingContent);
-
-      await initCommand.execute(testDir);
-
-      const updatedContent = await fs.readFile(codeBuddyPath, 'utf-8');
-      expect(updatedContent).toContain('<!-- OPENSPEC:START -->');
-      expect(updatedContent).toContain("@/openspec/AGENTS.md");
-      expect(updatedContent).toContain('openspec update');
-      expect(updatedContent).toContain('<!-- OPENSPEC:END -->');
-      expect(updatedContent).toContain('Custom instructions here');
-    });
-
-    it('should create Crush slash command files with templates', async () => {
-      queueSelections('crush', DONE);
-
+  describe('skill content validation', () => {
+    it('should generate valid SKILL.md with YAML frontmatter', async () => {
+      const initCommand = new InitCommand({ tools: 'claude', force: true });
       await initCommand.execute(testDir);
 
-      const crushProposal = path.join(
-        testDir,
-        '.crush/commands/openspec/proposal.md'
-      );
-      const crushApply = path.join(
-        testDir,
-        '.crush/commands/openspec/apply.md'
-      );
-      const crushArchive = path.join(
-        testDir,
-        '.crush/commands/openspec/archive.md'
-      );
-
-      expect(await fileExists(crushProposal)).toBe(true);
-      expect(await fileExists(crushApply)).toBe(true);
-      expect(await fileExists(crushArchive)).toBe(true);
-
-      const proposalContent = await fs.readFile(crushProposal, 'utf-8');
-      expect(proposalContent).toContain('---');
-      expect(proposalContent).toContain('name: OpenSpec: Proposal');
-      expect(proposalContent).toContain('description: Scaffold a new OpenSpec change and validate strictly.');
-      expect(proposalContent).toContain('category: OpenSpec');
-      expect(proposalContent).toContain('tags: [openspec, change]');
-      expect(proposalContent).toContain('<!-- OPENSPEC:START -->');
-      expect(proposalContent).toContain('**Guardrails**');
-
-      const applyContent = await fs.readFile(crushApply, 'utf-8');
-      expect(applyContent).toContain('---');
-      expect(applyContent).toContain('name: OpenSpec: Apply');
-      expect(applyContent).toContain('description: Implement an approved OpenSpec change and keep tasks in sync.');
-      expect(applyContent).toContain('category: OpenSpec');
-      expect(applyContent).toContain('tags: [openspec, apply]');
-      expect(applyContent).toContain('Work through tasks sequentially');
-
-      const archiveContent = await fs.readFile(crushArchive, 'utf-8');
-      expect(archiveContent).toContain('---');
-      expect(archiveContent).toContain('name: OpenSpec: Archive');
-      expect(archiveContent).toContain('description: Archive a deployed OpenSpec change and update specs.');
-      expect(archiveContent).toContain('category: OpenSpec');
-      expect(archiveContent).toContain('tags: [openspec, archive]');
-      expect(archiveContent).toContain('openspec archive <id> --yes');
-    });
+      const skillFile = path.join(testDir, '.claude', 'skills', 'openspec-explore', 'SKILL.md');
+      const content = await fs.readFile(skillFile, 'utf-8');
 
-    it('should mark Crush as already configured during extend mode', async () => {
-      queueSelections('crush', DONE, 'crush', DONE);
-      await initCommand.execute(testDir);
-      await initCommand.execute(testDir);
-
-      const secondRunArgs = mockPrompt.mock.calls[1][0];
-      const crushChoice = secondRunArgs.choices.find(
-        (choice: any) => choice.value === 'crush'
-      );
-      expect(crushChoice.configured).toBe(true);
+      // Should have YAML frontmatter
+      expect(content).toMatch(/^---\n/);
+      expect(content).toContain('name: openspec-explore');
+      expect(content).toContain('description:');
+      expect(content).toContain('license:');
+      expect(content).toContain('compatibility:');
+      expect(content).toContain('metadata:');
+      expect(content).toMatch(/---\n\n/); // End of frontmatter
     });
 
-    it('should create CoStrict slash command files with templates', async () => {
-      queueSelections('costrict', DONE);
-
+    it('should include explore mode instructions', async () => {
+      const initCommand = new InitCommand({ tools: 'claude', force: true });
       await initCommand.execute(testDir);
 
-      const costrictProposal = path.join(
-        testDir,
-        '.cospec/openspec/commands/openspec-proposal.md'
-      );
-      const costrictApply = path.join(
-        testDir,
-        '.cospec/openspec/commands/openspec-apply.md'
-      );
-      const costrictArchive = path.join(
-        testDir,
-        '.cospec/openspec/commands/openspec-archive.md'
-      );
-
-      expect(await fileExists(costrictProposal)).toBe(true);
-      expect(await fileExists(costrictApply)).toBe(true);
-      expect(await fileExists(costrictArchive)).toBe(true);
-
-      const proposalContent = await fs.readFile(costrictProposal, 'utf-8');
-      expect(proposalContent).toContain('---');
-      expect(proposalContent).toContain('description: "Scaffold a new OpenSpec change and validate strictly."');
-      expect(proposalContent).toContain('argument-hint: feature description or request');
-      expect(proposalContent).toContain('<!-- OPENSPEC:START -->');
-      expect(proposalContent).toContain('**Guardrails**');
-
-      const applyContent = await fs.readFile(costrictApply, 'utf-8');
-      expect(applyContent).toContain('---');
-      expect(applyContent).toContain('description: "Implement an approved OpenSpec change and keep tasks in sync."');
-      expect(applyContent).toContain('argument-hint: change-id');
-      expect(applyContent).toContain('Work through tasks sequentially');
-
-      const archiveContent = await fs.readFile(costrictArchive, 'utf-8');
-      expect(archiveContent).toContain('---');
-      expect(archiveContent).toContain('description: "Archive a deployed OpenSpec change and update specs."');
-      expect(archiveContent).toContain('argument-hint: change-id');
-      expect(archiveContent).toContain('openspec archive <id> --yes');
-    });
-
-    it('should mark CoStrict as already configured during extend mode', async () => {
-      queueSelections('costrict', DONE, 'costrict', DONE);
-      await initCommand.execute(testDir);
-      await initCommand.execute(testDir);
+      const skillFile = path.join(testDir, '.claude', 'skills', 'openspec-explore', 'SKILL.md');
+      const content = await fs.readFile(skillFile, 'utf-8');
 
-      const secondRunArgs = mockPrompt.mock.calls[1][0];
-      const costrictChoice = secondRunArgs.choices.find(
-        (choice: any) => choice.value === 'costrict'
-      );
-      expect(costrictChoice.configured).toBe(true);
+      expect(content).toContain('Enter explore mode');
+      expect(content).toContain('thinking partner');
     });
 
-    it('should create RooCode slash command files with templates', async () => {
-      queueSelections('roocode', DONE);
-
+    it('should include new-change skill instructions', async () => {
+      const initCommand = new InitCommand({ tools: 'claude', force: true });
       await initCommand.execute(testDir);
 
-      const rooProposal = path.join(
-        testDir,
-        '.roo/commands/openspec-proposal.md'
-      );
-      const rooApply = path.join(
-        testDir,
-        '.roo/commands/openspec-apply.md'
-      );
-      const rooArchive = path.join(
-        testDir,
-        '.roo/commands/openspec-archive.md'
-      );
-
-      expect(await fileExists(rooProposal)).toBe(true);
-      expect(await fileExists(rooApply)).toBe(true);
-      expect(await fileExists(rooArchive)).toBe(true);
-
-      const proposalContent = await fs.readFile(rooProposal, 'utf-8');
-      expect(proposalContent).toContain('# OpenSpec: Proposal');
-      expect(proposalContent).toContain('**Guardrails**');
+      const skillFile = path.join(testDir, '.claude', 'skills', 'openspec-new-change', 'SKILL.md');
+      const content = await fs.readFile(skillFile, 'utf-8');
 
-      const applyContent = await fs.readFile(rooApply, 'utf-8');
-      expect(applyContent).toContain('# OpenSpec: Apply');
-      expect(applyContent).toContain('Work through tasks sequentially');
-
-      const archiveContent = await fs.readFile(rooArchive, 'utf-8');
-      expect(archiveContent).toContain('# OpenSpec: Archive');
-      expect(archiveContent).toContain('openspec archive <id> --yes');
+      expect(content).toContain('name: openspec-new-change');
     });
 
-    it('should mark RooCode as already configured during extend mode', async () => {
-      queueSelections('roocode', DONE, 'roocode', DONE);
-      await initCommand.execute(testDir);
+    it('should include apply-change skill instructions', async () => {
+      const initCommand = new InitCommand({ tools: 'claude', force: true });
       await initCommand.execute(testDir);
 
-      const secondRunArgs = mockPrompt.mock.calls[1][0];
-      const rooChoice = secondRunArgs.choices.find(
-        (choice: any) => choice.value === 'roocode'
-      );
-      expect(rooChoice.configured).toBe(true);
-    });
+      const skillFile = path.join(testDir, '.claude', 'skills', 'openspec-apply-change', 'SKILL.md');
+      const content = await fs.readFile(skillFile, 'utf-8');
 
-    it('should create Qoder slash command files with templates', async () => {
-      queueSelections('qoder', DONE);
-
-      await initCommand.execute(testDir);
-
-      const qoderProposal = path.join(
-        testDir,
-        '.qoder/commands/openspec/proposal.md'
-      );
-      const qoderApply = path.join(
-        testDir,
-        '.qoder/commands/openspec/apply.md'
-      );
-      const qoderArchive = path.join(
-        testDir,
-        '.qoder/commands/openspec/archive.md'
-      );
-
-      expect(await fileExists(qoderProposal)).toBe(true);
-      expect(await fileExists(qoderApply)).toBe(true);
-      expect(await fileExists(qoderArchive)).toBe(true);
-
-      const proposalContent = await fs.readFile(qoderProposal, 'utf-8');
-      expect(proposalContent).toContain('---');
-      expect(proposalContent).toContain('name: OpenSpec: Proposal');
-      expect(proposalContent).toContain('description: Scaffold a new OpenSpec change and validate strictly.');
-      expect(proposalContent).toContain('category: OpenSpec');
-      expect(proposalContent).toContain('<!-- OPENSPEC:START -->');
-      expect(proposalContent).toContain('**Guardrails**');
-
-      const applyContent = await fs.readFile(qoderApply, 'utf-8');
-      expect(applyContent).toContain('---');
-      expect(applyContent).toContain('name: OpenSpec: Apply');
-      expect(applyContent).toContain('description: Implement an approved OpenSpec change and keep tasks in sync.');
-      expect(applyContent).toContain('Work through tasks sequentially');
-
-      const archiveContent = await fs.readFile(qoderArchive, 'utf-8');
-      expect(archiveContent).toContain('---');
-      expect(archiveContent).toContain('name: OpenSpec: Archive');
-      expect(archiveContent).toContain('description: Archive a deployed OpenSpec change and update specs.');
-      expect(archiveContent).toContain('openspec archive <id> --yes');
+      expect(content).toContain('name: openspec-apply-change');
     });
 
-    it('should mark Qoder as already configured during extend mode', async () => {
-      queueSelections('qoder', DONE, 'qoder', DONE);
-      await initCommand.execute(testDir);
+    it('should embed generatedBy version in skill files', async () => {
+      const initCommand = new InitCommand({ tools: 'claude', force: true });
       await initCommand.execute(testDir);
 
-      const secondRunArgs = mockPrompt.mock.calls[1][0];
-      const qoderChoice = secondRunArgs.choices.find(
-        (choice: any) => choice.value === 'qoder'
-      );
-      expect(qoderChoice.configured).toBe(true);
-    });
-
-    it('should create COSTRICT.md when CoStrict is selected', async () => {
-      queueSelections('costrict', DONE);
-
-      await initCommand.execute(testDir);
+      const skillFile = path.join(testDir, '.claude', 'skills', 'openspec-explore', 'SKILL.md');
+      const content = await fs.readFile(skillFile, 'utf-8');
 
-      const costrictPath = path.join(testDir, 'COSTRICT.md');
-      expect(await fileExists(costrictPath)).toBe(true);
-
-      const content = await fs.readFile(costrictPath, 'utf-8');
-      expect(content).toContain('<!-- OPENSPEC:START -->');
-      expect(content).toContain("@/openspec/AGENTS.md");
-      expect(content).toContain('openspec update');
-      expect(content).toContain('<!-- OPENSPEC:END -->');
+      // Should contain generatedBy field with a version string
+      expect(content).toMatch(/generatedBy:\s*["']?\d+\.\d+\.\d+["']?/);
     });
+  });
 
-    it('should create QODER.md when Qoder is selected', async () => {
-      queueSelections('qoder', DONE);
-
+  describe('command generation', () => {
+    it('should generate Claude Code commands with correct format', async () => {
+      const initCommand = new InitCommand({ tools: 'claude', force: true });
       await initCommand.execute(testDir);
 
-      const qoderPath = path.join(testDir, 'QODER.md');
-      expect(await fileExists(qoderPath)).toBe(true);
+      const cmdFile = path.join(testDir, '.claude', 'commands', 'opsx', 'explore.md');
+      const content = await fs.readFile(cmdFile, 'utf-8');
 
-      const content = await fs.readFile(qoderPath, 'utf-8');
-      expect(content).toContain('<!-- OPENSPEC:START -->');
-      expect(content).toContain("@/openspec/AGENTS.md");
-      expect(content).toContain('openspec update');
-      expect(content).toContain('<!-- OPENSPEC:END -->');
+      // Claude commands use YAML frontmatter
+      expect(content).toMatch(/^---\n/);
+      expect(content).toContain('name:');
+      expect(content).toContain('description:');
     });
-    it('should update existing COSTRICT.md with markers', async () => {
-      queueSelections('costrict', DONE);
-
-      const costrictPath = path.join(testDir, 'COSTRICT.md');
-      const existingContent =
-        '# My CoStrict Instructions\nCustom instructions here';
-      await fs.writeFile(costrictPath, existingContent);
 
+    it('should generate Cursor commands with correct format', async () => {
+      const initCommand = new InitCommand({ tools: 'cursor', force: true });
       await initCommand.execute(testDir);
 
-      const updatedContent = await fs.readFile(costrictPath, 'utf-8');
-      expect(updatedContent).toContain('<!-- OPENSPEC:START -->');
-      expect(updatedContent).toContain('# My CoStrict Instructions');
-      expect(updatedContent).toContain('Custom instructions here');
-    });
-
-    it('should update existing QODER.md with markers', async () => {
-      queueSelections('qoder', DONE);
-
-      const qoderPath = path.join(testDir, 'QODER.md');
-      const existingContent =
-        '# My Qoder Instructions\nCustom instructions here';
-      await fs.writeFile(qoderPath, existingContent);
+      const cmdFile = path.join(testDir, '.cursor', 'commands', 'opsx-explore.md');
+      expect(await fileExists(cmdFile)).toBe(true);
 
-      await initCommand.execute(testDir);
-
-      const updatedContent = await fs.readFile(qoderPath, 'utf-8');
-      expect(updatedContent).toContain('<!-- OPENSPEC:START -->');
-      expect(updatedContent).toContain("@/openspec/AGENTS.md");
-      expect(updatedContent).toContain('openspec update');
-      expect(updatedContent).toContain('<!-- OPENSPEC:END -->');
-      expect(updatedContent).toContain('Custom instructions here');
+      const content = await fs.readFile(cmdFile, 'utf-8');
+      expect(content).toMatch(/^---\n/);
     });
   });
 
-  describe('non-interactive mode', () => {
-    it('should select all available tools with --tools all option', async () => {
-      const nonInteractiveCommand = new InitCommand({ tools: 'all' });
-
-      await nonInteractiveCommand.execute(testDir);
-
-      // Should create configurations for all available tools
-      const claudePath = path.join(testDir, 'CLAUDE.md');
-      const cursorProposal = path.join(
-        testDir,
-        '.cursor/commands/openspec-proposal.md'
-      );
-      const windsurfProposal = path.join(
-        testDir,
-        '.windsurf/workflows/openspec-proposal.md'
-      );
-
-      expect(await fileExists(claudePath)).toBe(true);
-      expect(await fileExists(cursorProposal)).toBe(true);
-      expect(await fileExists(windsurfProposal)).toBe(true);
-    });
-
-    it('should select specific tools with --tools option', async () => {
-      const nonInteractiveCommand = new InitCommand({ tools: 'claude,cursor' });
-
-      await nonInteractiveCommand.execute(testDir);
-
-      const claudePath = path.join(testDir, 'CLAUDE.md');
-      const cursorProposal = path.join(
-        testDir,
-        '.cursor/commands/openspec-proposal.md'
-      );
-      const windsurfProposal = path.join(
-        testDir,
-        '.windsurf/workflows/openspec-proposal.md'
-      );
-
-      expect(await fileExists(claudePath)).toBe(true);
-      expect(await fileExists(cursorProposal)).toBe(true);
-      expect(await fileExists(windsurfProposal)).toBe(false); // Not selected
-    });
-
-    it('should skip tool configuration with --tools none option', async () => {
-      const nonInteractiveCommand = new InitCommand({ tools: 'none' });
-
-      await nonInteractiveCommand.execute(testDir);
-
-      const claudePath = path.join(testDir, 'CLAUDE.md');
-      const cursorProposal = path.join(
-        testDir,
-        '.cursor/commands/openspec-proposal.md'
-      );
-
-      // Should still create AGENTS.md but no tool-specific files
-      const rootAgentsPath = path.join(testDir, 'AGENTS.md');
-      expect(await fileExists(rootAgentsPath)).toBe(true);
-      expect(await fileExists(claudePath)).toBe(false);
-      expect(await fileExists(cursorProposal)).toBe(false);
-    });
-
-    it('should throw error for invalid tool names', async () => {
-      const nonInteractiveCommand = new InitCommand({ tools: 'invalid-tool' });
-
-      await expect(nonInteractiveCommand.execute(testDir)).rejects.toThrow(
-        /Invalid tool\(s\): invalid-tool\. Available values: /
-      );
-    });
-
-    it('should handle comma-separated tool names with spaces', async () => {
-      const nonInteractiveCommand = new InitCommand({ tools: 'claude, cursor' });
-
-      await nonInteractiveCommand.execute(testDir);
+  describe('error handling', () => {
+    it('should provide helpful error for insufficient permissions', async () => {
+      // Mock the permission check to fail
+      const readOnlyDir = path.join(testDir, 'readonly');
+      await fs.mkdir(readOnlyDir);
 
-      const claudePath = path.join(testDir, 'CLAUDE.md');
-      const cursorProposal = path.join(
-        testDir,
-        '.cursor/commands/openspec-proposal.md'
+      const originalWriteFile = fs.writeFile;
+      vi.spyOn(fs, 'writeFile').mockImplementation(
+        async (filePath: any, ...args: any[]) => {
+          if (
+            typeof filePath === 'string' &&
+            filePath.includes('.openspec-test-')
+          ) {
+            throw new Error('EACCES: permission denied');
+          }
+          return originalWriteFile.call(fs, filePath, ...args);
+        }
       );
 
-      expect(await fileExists(claudePath)).toBe(true);
-      expect(await fileExists(cursorProposal)).toBe(true);
+      const initCommand = new InitCommand({ tools: 'claude', force: true });
+      await expect(initCommand.execute(readOnlyDir)).rejects.toThrow(/Insufficient permissions/);
     });
 
-    it('should reject combining reserved keywords with explicit tool ids', async () => {
-      const nonInteractiveCommand = new InitCommand({ tools: 'all,claude' });
+    it('should throw error in non-interactive mode without --tools flag', async () => {
+      const initCommand = new InitCommand({ interactive: false });
 
-      await expect(nonInteractiveCommand.execute(testDir)).rejects.toThrow(
-        /Cannot combine reserved values "all" or "none" with specific tool IDs/
-      );
+      await expect(initCommand.execute(testDir)).rejects.toThrow(/Missing required option --tools/);
     });
   });
 
-  describe('already configured detection', () => {
-    it('should NOT show tools as already configured in fresh project with existing CLAUDE.md', async () => {
-      // Simulate user having their own CLAUDE.md before running openspec init
-      const claudePath = path.join(testDir, 'CLAUDE.md');
-      await fs.writeFile(claudePath, '# My Custom Claude Instructions\n');
-
-      queueSelections('claude', DONE);
-
+  describe('tool-specific adapters', () => {
+    it('should generate Gemini CLI commands as TOML files', async () => {
+      const initCommand = new InitCommand({ tools: 'gemini', force: true });
       await initCommand.execute(testDir);
 
-      // In the first run (non-interactive mode via queueSelections),
-      // the prompt is called with configured: false for claude
-      const firstCallArgs = mockPrompt.mock.calls[0][0];
-      const claudeChoice = firstCallArgs.choices.find(
-        (choice: any) => choice.value === 'claude'
-      );
+      const cmdFile = path.join(testDir, '.gemini', 'commands', 'opsx', 'explore.toml');
+      expect(await fileExists(cmdFile)).toBe(true);
 
-      expect(claudeChoice.configured).toBe(false);
+      const content = await fs.readFile(cmdFile, 'utf-8');
+      expect(content).toContain('description =');
+      expect(content).toContain('prompt =');
     });
 
-    it('should NOT show tools as already configured in fresh project with existing slash commands', async () => {
-      // Simulate user having their own custom slash commands
-      const customCommandDir = path.join(testDir, '.claude/commands/custom');
-      await fs.mkdir(customCommandDir, { recursive: true });
-      await fs.writeFile(
-        path.join(customCommandDir, 'mycommand.md'),
-        '# My Custom Command\n'
-      );
-
-      queueSelections('claude', DONE);
-
+    it('should generate Windsurf commands', async () => {
+      const initCommand = new InitCommand({ tools: 'windsurf', force: true });
       await initCommand.execute(testDir);
 
-      const firstCallArgs = mockPrompt.mock.calls[0][0];
-      const claudeChoice = firstCallArgs.choices.find(
-        (choice: any) => choice.value === 'claude'
-      );
-
-      expect(claudeChoice.configured).toBe(false);
+      const cmdFile = path.join(testDir, '.windsurf', 'commands', 'opsx', 'explore.md');
+      expect(await fileExists(cmdFile)).toBe(true);
     });
 
-    it('should show tools as already configured in extend mode', async () => {
-      // First initialization
-      queueSelections('claude', DONE);
-      await initCommand.execute(testDir);
-
-      // Second initialization (extend mode)
-      queueSelections('cursor', DONE);
+    it('should generate Continue prompt files', async () => {
+      const initCommand = new InitCommand({ tools: 'continue', force: true });
       await initCommand.execute(testDir);
 
-      const secondCallArgs = mockPrompt.mock.calls[1][0];
-      const claudeChoice = secondCallArgs.choices.find(
-        (choice: any) => choice.value === 'claude'
-      );
+      const cmdFile = path.join(testDir, '.continue', 'prompts', 'opsx-explore.prompt');
+      expect(await fileExists(cmdFile)).toBe(true);
 
-      expect(claudeChoice.configured).toBe(true);
+      const content = await fs.readFile(cmdFile, 'utf-8');
+      expect(content).toContain('name: opsx-explore');
+      expect(content).toContain('invokable: true');
     });
 
-    it('should NOT show already configured for Codex in fresh init even with global prompts', async () => {
-      // Create global Codex prompts (simulating previous installation)
-      const codexPromptsDir = path.join(testDir, '.codex/prompts');
-      await fs.mkdir(codexPromptsDir, { recursive: true });
-      await fs.writeFile(
-        path.join(codexPromptsDir, 'openspec-proposal.md'),
-        '# Existing prompt\n'
-      );
-
-      queueSelections('claude', DONE);
-
+    it('should generate Cline workflow files', async () => {
+      const initCommand = new InitCommand({ tools: 'cline', force: true });
       await initCommand.execute(testDir);
 
-      const firstCallArgs = mockPrompt.mock.calls[0][0];
-      const codexChoice = firstCallArgs.choices.find(
-        (choice: any) => choice.value === 'codex'
-      );
-
-      // In fresh init, even global tools should not show as configured
-      expect(codexChoice.configured).toBe(false);
+      const cmdFile = path.join(testDir, '.clinerules', 'workflows', 'opsx-explore.md');
+      expect(await fileExists(cmdFile)).toBe(true);
     });
-  });
-
-  describe('error handling', () => {
-    it('should provide helpful error for insufficient permissions', async () => {
-      // This is tricky to test cross-platform, but we can test the error message
-      const readOnlyDir = path.join(testDir, 'readonly');
-      await fs.mkdir(readOnlyDir);
 
-      // Mock the permission check to fail
-      const originalCheck = fs.writeFile;
-      vi.spyOn(fs, 'writeFile').mockImplementation(
-        async (filePath: any, ...args: any[]) => {
-          if (
-            typeof filePath === 'string' &&
-            filePath.includes('.openspec-test-')
-          ) {
-            throw new Error('EACCES: permission denied');
-          }
-          return originalCheck.call(fs, filePath, ...args);
-        }
-      );
+    it('should generate GitHub Copilot prompt files', async () => {
+      const initCommand = new InitCommand({ tools: 'github-copilot', force: true });
+      await initCommand.execute(testDir);
 
-      queueSelections('claude', DONE);
-      await expect(initCommand.execute(readOnlyDir)).rejects.toThrow(
-        /Insufficient permissions/
-      );
+      const cmdFile = path.join(testDir, '.github', 'prompts', 'opsx-explore.prompt.md');
+      expect(await fileExists(cmdFile)).toBe(true);
     });
   });
 });
 
-async function testFileRecreationInExtendMode(
-  testDir: string,
-  initCommand: InitCommand,
-  relativePath: string,
-  expectedContent: string
-): Promise<void> {
-  queueSelections('claude', DONE, DONE);
-
-  // First init
-  await initCommand.execute(testDir);
-
-  const filePath = path.join(testDir, relativePath);
-  expect(await fileExists(filePath)).toBe(true);
-
-  // Delete the file
-  await fs.unlink(filePath);
-  expect(await fileExists(filePath)).toBe(false);
-
-  // Run init again - should recreate the file
-  await initCommand.execute(testDir);
-  expect(await fileExists(filePath)).toBe(true);
-
-  const content = await fs.readFile(filePath, 'utf-8');
-  expect(content).toContain(expectedContent);
-}
-
 async function fileExists(filePath: string): Promise<boolean> {
   try {
     await fs.access(filePath);
diff --git a/test/core/legacy-cleanup.test.ts b/test/core/legacy-cleanup.test.ts
new file mode 100644
index 0000000..4f6a693
--- /dev/null
+++ b/test/core/legacy-cleanup.test.ts
@@ -0,0 +1,1079 @@
+import { describe, it, expect, beforeEach, afterEach } from 'vitest';
+import { promises as fs } from 'fs';
+import path from 'path';
+import os from 'os';
+import { randomUUID } from 'crypto';
+import {
+  detectLegacyArtifacts,
+  detectLegacyConfigFiles,
+  detectLegacySlashCommands,
+  detectLegacyStructureFiles,
+  hasOpenSpecMarkers,
+  isOnlyOpenSpecContent,
+  removeMarkerBlock,
+  cleanupLegacyArtifacts,
+  formatCleanupSummary,
+  formatDetectionSummary,
+  formatProjectMdMigrationHint,
+  getToolsFromLegacyArtifacts,
+  LEGACY_CONFIG_FILES,
+  LEGACY_SLASH_COMMAND_PATHS,
+} from '../../src/core/legacy-cleanup.js';
+import { OPENSPEC_MARKERS } from '../../src/core/config.js';
+import { CommandAdapterRegistry } from '../../src/core/command-generation/registry.js';
+
+describe('legacy-cleanup', () => {
+  let testDir: string;
+
+  beforeEach(async () => {
+    testDir = path.join(os.tmpdir(), `openspec-legacy-test-${randomUUID()}`);
+    await fs.mkdir(testDir, { recursive: true });
+    // Create openspec directory structure
+    await fs.mkdir(path.join(testDir, 'openspec'), { recursive: true });
+  });
+
+  afterEach(async () => {
+    await fs.rm(testDir, { recursive: true, force: true });
+  });
+
+  describe('hasOpenSpecMarkers', () => {
+    it('should return true when both markers are present', () => {
+      const content = `Some content
+${OPENSPEC_MARKERS.start}
+OpenSpec content
+${OPENSPEC_MARKERS.end}
+More content`;
+      expect(hasOpenSpecMarkers(content)).toBe(true);
+    });
+
+    it('should return false when start marker is missing', () => {
+      const content = `Some content
+OpenSpec content
+${OPENSPEC_MARKERS.end}`;
+      expect(hasOpenSpecMarkers(content)).toBe(false);
+    });
+
+    it('should return false when end marker is missing', () => {
+      const content = `${OPENSPEC_MARKERS.start}
+OpenSpec content
+Some content`;
+      expect(hasOpenSpecMarkers(content)).toBe(false);
+    });
+
+    it('should return false when no markers are present', () => {
+      const content = 'Plain content without markers';
+      expect(hasOpenSpecMarkers(content)).toBe(false);
+    });
+  });
+
+  describe('isOnlyOpenSpecContent', () => {
+    it('should return true when content is only markers and whitespace outside', () => {
+      const content = `${OPENSPEC_MARKERS.start}
+OpenSpec content here
+${OPENSPEC_MARKERS.end}`;
+      expect(isOnlyOpenSpecContent(content)).toBe(true);
+    });
+
+    it('should return true with whitespace before and after markers', () => {
+      const content = `
+
+${OPENSPEC_MARKERS.start}
+OpenSpec content
+${OPENSPEC_MARKERS.end}
+
+`;
+      expect(isOnlyOpenSpecContent(content)).toBe(true);
+    });
+
+    it('should return false when content exists before markers', () => {
+      const content = `User content here
+${OPENSPEC_MARKERS.start}
+OpenSpec content
+${OPENSPEC_MARKERS.end}`;
+      expect(isOnlyOpenSpecContent(content)).toBe(false);
+    });
+
+    it('should return false when content exists after markers', () => {
+      const content = `${OPENSPEC_MARKERS.start}
+OpenSpec content
+${OPENSPEC_MARKERS.end}
+User content here`;
+      expect(isOnlyOpenSpecContent(content)).toBe(false);
+    });
+
+    it('should return false when markers are missing', () => {
+      const content = 'Plain content without markers';
+      expect(isOnlyOpenSpecContent(content)).toBe(false);
+    });
+
+    it('should return false when end marker comes before start marker', () => {
+      const content = `${OPENSPEC_MARKERS.end}
+Content
+${OPENSPEC_MARKERS.start}`;
+      expect(isOnlyOpenSpecContent(content)).toBe(false);
+    });
+  });
+
+  describe('removeMarkerBlock', () => {
+    it('should remove marker block and preserve content before', () => {
+      const content = `User content before
+${OPENSPEC_MARKERS.start}
+OpenSpec content
+${OPENSPEC_MARKERS.end}`;
+      const result = removeMarkerBlock(content);
+      expect(result).toBe('User content before\n');
+      expect(result).not.toContain(OPENSPEC_MARKERS.start);
+      expect(result).not.toContain(OPENSPEC_MARKERS.end);
+    });
+
+    it('should remove marker block and preserve content after', () => {
+      const content = `${OPENSPEC_MARKERS.start}
+OpenSpec content
+${OPENSPEC_MARKERS.end}
+User content after`;
+      const result = removeMarkerBlock(content);
+      expect(result).toBe('User content after\n');
+    });
+
+    it('should remove marker block and preserve content before and after', () => {
+      const content = `User content before
+${OPENSPEC_MARKERS.start}
+OpenSpec content
+${OPENSPEC_MARKERS.end}
+User content after`;
+      const result = removeMarkerBlock(content);
+      expect(result).toContain('User content before');
+      expect(result).toContain('User content after');
+      expect(result).not.toContain(OPENSPEC_MARKERS.start);
+    });
+
+    it('should clean up double blank lines', () => {
+      const content = `Line 1
+
+
+${OPENSPEC_MARKERS.start}
+OpenSpec content
+${OPENSPEC_MARKERS.end}
+
+
+Line 2`;
+      const result = removeMarkerBlock(content);
+      expect(result).not.toMatch(/\n{3,}/);
+    });
+
+    it('should return empty string when only markers remain', () => {
+      const content = `${OPENSPEC_MARKERS.start}
+OpenSpec content
+${OPENSPEC_MARKERS.end}`;
+      const result = removeMarkerBlock(content);
+      expect(result).toBe('');
+    });
+
+    it('should return original content when markers are missing', () => {
+      const content = 'Plain content without markers';
+      const result = removeMarkerBlock(content);
+      // When no markers found, content is returned trimmed (no trailing newline added)
+      expect(result).toBe('Plain content without markers');
+    });
+
+    it('should return original content when markers are in wrong order', () => {
+      const content = `${OPENSPEC_MARKERS.end}
+Content
+${OPENSPEC_MARKERS.start}`;
+      const result = removeMarkerBlock(content);
+      expect(result).toContain(OPENSPEC_MARKERS.end);
+      expect(result).toContain(OPENSPEC_MARKERS.start);
+    });
+
+    it('should ignore inline mentions of markers and only remove actual block', () => {
+      const content = `Intro referencing ${OPENSPEC_MARKERS.start} and ${OPENSPEC_MARKERS.end} inline.
+
+${OPENSPEC_MARKERS.start}
+Managed content here
+${OPENSPEC_MARKERS.end}
+After content`;
+      const result = removeMarkerBlock(content);
+      // Inline mentions preserved
+      expect(result).toContain('Intro referencing');
+      expect(result).toContain(OPENSPEC_MARKERS.start);
+      expect(result).toContain(OPENSPEC_MARKERS.end);
+      // Managed content removed
+      expect(result).not.toContain('Managed content here');
+      expect(result).toContain('After content');
+    });
+  });
+
+  describe('detectLegacyConfigFiles', () => {
+    it('should detect CLAUDE.md with OpenSpec markers and put in update list', async () => {
+      const claudePath = path.join(testDir, 'CLAUDE.md');
+      await fs.writeFile(claudePath, `${OPENSPEC_MARKERS.start}
+OpenSpec content
+${OPENSPEC_MARKERS.end}`);
+
+      const result = await detectLegacyConfigFiles(testDir);
+      expect(result.allFiles).toContain('CLAUDE.md');
+      // Config files are NEVER deleted, always updated (markers removed)
+      expect(result.filesToUpdate).toContain('CLAUDE.md');
+    });
+
+    it('should detect files with mixed content and put in update list', async () => {
+      const claudePath = path.join(testDir, 'CLAUDE.md');
+      await fs.writeFile(claudePath, `User instructions here
+${OPENSPEC_MARKERS.start}
+OpenSpec content
+${OPENSPEC_MARKERS.end}`);
+
+      const result = await detectLegacyConfigFiles(testDir);
+      expect(result.allFiles).toContain('CLAUDE.md');
+      expect(result.filesToUpdate).toContain('CLAUDE.md');
+    });
+
+    it('should not detect files without OpenSpec markers', async () => {
+      const claudePath = path.join(testDir, 'CLAUDE.md');
+      await fs.writeFile(claudePath, 'Plain instructions without markers');
+
+      const result = await detectLegacyConfigFiles(testDir);
+      expect(result.allFiles).not.toContain('CLAUDE.md');
+    });
+
+    it('should detect multiple config files', async () => {
+      // Create multiple config files with markers
+      await fs.writeFile(path.join(testDir, 'CLAUDE.md'), `${OPENSPEC_MARKERS.start}\nContent\n${OPENSPEC_MARKERS.end}`);
+      await fs.writeFile(path.join(testDir, 'CLINE.md'), `${OPENSPEC_MARKERS.start}\nContent\n${OPENSPEC_MARKERS.end}`);
+      await fs.writeFile(path.join(testDir, 'QODER.md'), `${OPENSPEC_MARKERS.start}\nContent\n${OPENSPEC_MARKERS.end}`);
+
+      const result = await detectLegacyConfigFiles(testDir);
+      expect(result.allFiles).toHaveLength(3);
+      expect(result.allFiles).toContain('CLAUDE.md');
+      expect(result.allFiles).toContain('CLINE.md');
+      expect(result.allFiles).toContain('QODER.md');
+      // All should be in update list, none deleted
+      expect(result.filesToUpdate).toHaveLength(3);
+    });
+
+    it('should handle non-existent files gracefully', async () => {
+      const result = await detectLegacyConfigFiles(testDir);
+      expect(result.allFiles).toHaveLength(0);
+      expect(result.filesToUpdate).toHaveLength(0);
+    });
+  });
+
+  describe('detectLegacySlashCommands', () => {
+    it('should detect legacy Claude slash command directory', async () => {
+      const dirPath = path.join(testDir, '.claude', 'commands', 'openspec');
+      await fs.mkdir(dirPath, { recursive: true });
+      await fs.writeFile(path.join(dirPath, 'proposal.md'), 'content');
+
+      const result = await detectLegacySlashCommands(testDir);
+      expect(result.directories).toContain('.claude/commands/openspec');
+    });
+
+    it('should detect legacy Cursor slash command files', async () => {
+      const dirPath = path.join(testDir, '.cursor', 'commands');
+      await fs.mkdir(dirPath, { recursive: true });
+      await fs.writeFile(path.join(dirPath, 'openspec-proposal.md'), 'content');
+      await fs.writeFile(path.join(dirPath, 'openspec-apply.md'), 'content');
+
+      const result = await detectLegacySlashCommands(testDir);
+      expect(result.files).toContain('.cursor/commands/openspec-proposal.md');
+      expect(result.files).toContain('.cursor/commands/openspec-apply.md');
+    });
+
+    it('should detect legacy Windsurf workflow files', async () => {
+      const dirPath = path.join(testDir, '.windsurf', 'workflows');
+      await fs.mkdir(dirPath, { recursive: true });
+      await fs.writeFile(path.join(dirPath, 'openspec-archive.md'), 'content');
+
+      const result = await detectLegacySlashCommands(testDir);
+      expect(result.files).toContain('.windsurf/workflows/openspec-archive.md');
+    });
+
+    it('should detect multiple tool directories and files', async () => {
+      // Create directory-based
+      await fs.mkdir(path.join(testDir, '.claude', 'commands', 'openspec'), { recursive: true });
+      await fs.mkdir(path.join(testDir, '.qoder', 'commands', 'openspec'), { recursive: true });
+
+      // Create file-based
+      await fs.mkdir(path.join(testDir, '.cursor', 'commands'), { recursive: true });
+      await fs.writeFile(path.join(testDir, '.cursor', 'commands', 'openspec-proposal.md'), 'content');
+
+      const result = await detectLegacySlashCommands(testDir);
+      expect(result.directories).toContain('.claude/commands/openspec');
+      expect(result.directories).toContain('.qoder/commands/openspec');
+      expect(result.files).toContain('.cursor/commands/openspec-proposal.md');
+    });
+
+    it('should not detect non-openspec files', async () => {
+      const dirPath = path.join(testDir, '.cursor', 'commands');
+      await fs.mkdir(dirPath, { recursive: true });
+      await fs.writeFile(path.join(dirPath, 'other-command.md'), 'content');
+
+      const result = await detectLegacySlashCommands(testDir);
+      expect(result.files).not.toContain('.cursor/commands/other-command.md');
+    });
+
+    it('should handle non-existent directories gracefully', async () => {
+      const result = await detectLegacySlashCommands(testDir);
+      expect(result.directories).toHaveLength(0);
+      expect(result.files).toHaveLength(0);
+    });
+
+    it('should detect TOML-based slash commands for Qwen', async () => {
+      const dirPath = path.join(testDir, '.qwen', 'commands');
+      await fs.mkdir(dirPath, { recursive: true });
+      await fs.writeFile(path.join(dirPath, 'openspec-proposal.toml'), 'content');
+
+      const result = await detectLegacySlashCommands(testDir);
+      expect(result.files).toContain('.qwen/commands/openspec-proposal.toml');
+    });
+
+    it('should detect Continue prompt files', async () => {
+      const dirPath = path.join(testDir, '.continue', 'prompts');
+      await fs.mkdir(dirPath, { recursive: true });
+      await fs.writeFile(path.join(dirPath, 'openspec-apply.prompt'), 'content');
+
+      const result = await detectLegacySlashCommands(testDir);
+      expect(result.files).toContain('.continue/prompts/openspec-apply.prompt');
+    });
+  });
+
+  describe('detectLegacyStructureFiles', () => {
+    it('should detect openspec/AGENTS.md', async () => {
+      const agentsPath = path.join(testDir, 'openspec', 'AGENTS.md');
+      await fs.writeFile(agentsPath, '# AGENTS.md content');
+
+      const result = await detectLegacyStructureFiles(testDir);
+      expect(result.hasOpenspecAgents).toBe(true);
+    });
+
+    it('should detect openspec/project.md', async () => {
+      const projectPath = path.join(testDir, 'openspec', 'project.md');
+      await fs.writeFile(projectPath, '# Project content');
+
+      const result = await detectLegacyStructureFiles(testDir);
+      expect(result.hasProjectMd).toBe(true);
+    });
+
+    it('should detect root AGENTS.md with OpenSpec markers', async () => {
+      const agentsPath = path.join(testDir, 'AGENTS.md');
+      await fs.writeFile(agentsPath, `${OPENSPEC_MARKERS.start}
+OpenSpec content
+${OPENSPEC_MARKERS.end}`);
+
+      const result = await detectLegacyStructureFiles(testDir);
+      expect(result.hasRootAgentsWithMarkers).toBe(true);
+    });
+
+    it('should not detect root AGENTS.md without markers', async () => {
+      const agentsPath = path.join(testDir, 'AGENTS.md');
+      await fs.writeFile(agentsPath, 'Plain content without markers');
+
+      const result = await detectLegacyStructureFiles(testDir);
+      expect(result.hasRootAgentsWithMarkers).toBe(false);
+    });
+
+    it('should handle non-existent files gracefully', async () => {
+      const result = await detectLegacyStructureFiles(testDir);
+      expect(result.hasOpenspecAgents).toBe(false);
+      expect(result.hasProjectMd).toBe(false);
+      expect(result.hasRootAgentsWithMarkers).toBe(false);
+    });
+  });
+
+  describe('detectLegacyArtifacts', () => {
+    it('should return hasLegacyArtifacts: false when nothing is found', async () => {
+      const result = await detectLegacyArtifacts(testDir);
+      expect(result.hasLegacyArtifacts).toBe(false);
+    });
+
+    it('should return hasLegacyArtifacts: true when config files are found', async () => {
+      await fs.writeFile(path.join(testDir, 'CLAUDE.md'), `${OPENSPEC_MARKERS.start}\nContent\n${OPENSPEC_MARKERS.end}`);
+
+      const result = await detectLegacyArtifacts(testDir);
+      expect(result.hasLegacyArtifacts).toBe(true);
+      expect(result.configFiles).toContain('CLAUDE.md');
+    });
+
+    it('should return hasLegacyArtifacts: true when slash commands are found', async () => {
+      await fs.mkdir(path.join(testDir, '.claude', 'commands', 'openspec'), { recursive: true });
+
+      const result = await detectLegacyArtifacts(testDir);
+      expect(result.hasLegacyArtifacts).toBe(true);
+      expect(result.slashCommandDirs).toContain('.claude/commands/openspec');
+    });
+
+    it('should return hasLegacyArtifacts: true when openspec/AGENTS.md is found', async () => {
+      await fs.writeFile(path.join(testDir, 'openspec', 'AGENTS.md'), 'content');
+
+      const result = await detectLegacyArtifacts(testDir);
+      expect(result.hasLegacyArtifacts).toBe(true);
+      expect(result.hasOpenspecAgents).toBe(true);
+    });
+
+    it('should detect project.md for migration hint (it is preserved, not deleted)', async () => {
+      await fs.writeFile(path.join(testDir, 'openspec', 'project.md'), 'content');
+
+      const result = await detectLegacyArtifacts(testDir);
+      // project.md triggers hasLegacyArtifacts to show migration hint
+      expect(result.hasLegacyArtifacts).toBe(true);
+      expect(result.hasProjectMd).toBe(true);
+    });
+
+    it('should combine all detection results', async () => {
+      // Create various legacy artifacts
+      await fs.writeFile(path.join(testDir, 'CLAUDE.md'), `${OPENSPEC_MARKERS.start}\nContent\n${OPENSPEC_MARKERS.end}`);
+      await fs.mkdir(path.join(testDir, '.claude', 'commands', 'openspec'), { recursive: true });
+      await fs.writeFile(path.join(testDir, 'openspec', 'AGENTS.md'), 'content');
+      await fs.writeFile(path.join(testDir, 'openspec', 'project.md'), 'content');
+
+      const result = await detectLegacyArtifacts(testDir);
+      expect(result.hasLegacyArtifacts).toBe(true);
+      expect(result.configFiles).toContain('CLAUDE.md');
+      expect(result.slashCommandDirs).toContain('.claude/commands/openspec');
+      expect(result.hasOpenspecAgents).toBe(true);
+      expect(result.hasProjectMd).toBe(true);
+    });
+  });
+
+  describe('cleanupLegacyArtifacts', () => {
+    it('should remove markers from config files that have only OpenSpec content (never delete)', async () => {
+      const claudePath = path.join(testDir, 'CLAUDE.md');
+      await fs.writeFile(claudePath, `${OPENSPEC_MARKERS.start}\nContent\n${OPENSPEC_MARKERS.end}`);
+
+      const detection = await detectLegacyArtifacts(testDir);
+      const result = await cleanupLegacyArtifacts(testDir, detection);
+
+      // Config files should NEVER be deleted, only have markers removed
+      expect(result.deletedFiles).not.toContain('CLAUDE.md');
+      expect(result.modifiedFiles).toContain('CLAUDE.md');
+      // File should still exist
+      await expect(fs.access(claudePath)).resolves.not.toThrow();
+      // File should be empty or have markers removed
+      const content = await fs.readFile(claudePath, 'utf-8');
+      expect(content).not.toContain(OPENSPEC_MARKERS.start);
+      expect(content).not.toContain(OPENSPEC_MARKERS.end);
+    });
+
+    it('should remove marker block from files with mixed content', async () => {
+      const claudePath = path.join(testDir, 'CLAUDE.md');
+      await fs.writeFile(claudePath, `User instructions
+${OPENSPEC_MARKERS.start}
+OpenSpec content
+${OPENSPEC_MARKERS.end}`);
+
+      const detection = await detectLegacyArtifacts(testDir);
+      const result = await cleanupLegacyArtifacts(testDir, detection);
+
+      expect(result.modifiedFiles).toContain('CLAUDE.md');
+      const content = await fs.readFile(claudePath, 'utf-8');
+      expect(content).toContain('User instructions');
+      expect(content).not.toContain(OPENSPEC_MARKERS.start);
+    });
+
+    it('should delete legacy slash command directories', async () => {
+      const dirPath = path.join(testDir, '.claude', 'commands', 'openspec');
+      await fs.mkdir(dirPath, { recursive: true });
+      await fs.writeFile(path.join(dirPath, 'proposal.md'), 'content');
+
+      const detection = await detectLegacyArtifacts(testDir);
+      const result = await cleanupLegacyArtifacts(testDir, detection);
+
+      expect(result.deletedDirs).toContain('.claude/commands/openspec');
+      await expect(fs.access(dirPath)).rejects.toThrow();
+      // Parent directory should still exist
+      await expect(fs.access(path.join(testDir, '.claude', 'commands'))).resolves.not.toThrow();
+    });
+
+    it('should delete legacy slash command files', async () => {
+      const dirPath = path.join(testDir, '.cursor', 'commands');
+      await fs.mkdir(dirPath, { recursive: true });
+      const filePath = path.join(dirPath, 'openspec-proposal.md');
+      await fs.writeFile(filePath, 'content');
+
+      const detection = await detectLegacyArtifacts(testDir);
+      const result = await cleanupLegacyArtifacts(testDir, detection);
+
+      expect(result.deletedFiles).toContain('.cursor/commands/openspec-proposal.md');
+      await expect(fs.access(filePath)).rejects.toThrow();
+    });
+
+    it('should delete openspec/AGENTS.md', async () => {
+      const agentsPath = path.join(testDir, 'openspec', 'AGENTS.md');
+      await fs.writeFile(agentsPath, 'content');
+
+      const detection = await detectLegacyArtifacts(testDir);
+      const result = await cleanupLegacyArtifacts(testDir, detection);
+
+      expect(result.deletedFiles).toContain('openspec/AGENTS.md');
+      await expect(fs.access(agentsPath)).rejects.toThrow();
+      // openspec directory should still exist
+      await expect(fs.access(path.join(testDir, 'openspec'))).resolves.not.toThrow();
+    });
+
+    it('should NOT delete openspec/project.md', async () => {
+      const projectPath = path.join(testDir, 'openspec', 'project.md');
+      await fs.writeFile(projectPath, 'User project content');
+
+      const detection = await detectLegacyArtifacts(testDir);
+      const result = await cleanupLegacyArtifacts(testDir, detection);
+
+      expect(result.projectMdNeedsMigration).toBe(true);
+      expect(result.deletedFiles).not.toContain('openspec/project.md');
+      await expect(fs.access(projectPath)).resolves.not.toThrow();
+    });
+
+    it('should handle root AGENTS.md with mixed content', async () => {
+      const agentsPath = path.join(testDir, 'AGENTS.md');
+      await fs.writeFile(agentsPath, `User content
+${OPENSPEC_MARKERS.start}
+OpenSpec content
+${OPENSPEC_MARKERS.end}`);
+
+      const detection = await detectLegacyArtifacts(testDir);
+      const result = await cleanupLegacyArtifacts(testDir, detection);
+
+      expect(result.modifiedFiles).toContain('AGENTS.md');
+      const content = await fs.readFile(agentsPath, 'utf-8');
+      expect(content).toContain('User content');
+      expect(content).not.toContain(OPENSPEC_MARKERS.start);
+    });
+
+    it('should remove markers from root AGENTS.md even when only OpenSpec content (never delete)', async () => {
+      const agentsPath = path.join(testDir, 'AGENTS.md');
+      await fs.writeFile(agentsPath, `${OPENSPEC_MARKERS.start}\nOpenSpec content\n${OPENSPEC_MARKERS.end}`);
+
+      const detection = await detectLegacyArtifacts(testDir);
+      const result = await cleanupLegacyArtifacts(testDir, detection);
+
+      // Root AGENTS.md should NEVER be deleted, only have markers removed
+      expect(result.deletedFiles).not.toContain('AGENTS.md');
+      expect(result.modifiedFiles).toContain('AGENTS.md');
+      // File should still exist
+      await expect(fs.access(agentsPath)).resolves.not.toThrow();
+    });
+
+    it('should report errors without stopping cleanup', async () => {
+      // Create a valid detection result with a non-existent file to simulate error
+      const detection = {
+        configFiles: ['NON_EXISTENT.md'],
+        configFilesToUpdate: ['NON_EXISTENT.md'],
+        slashCommandDirs: [],
+        slashCommandFiles: [],
+        hasOpenspecAgents: false,
+        hasProjectMd: false,
+        hasRootAgentsWithMarkers: false,
+        hasLegacyArtifacts: true,
+      };
+
+      const result = await cleanupLegacyArtifacts(testDir, detection);
+
+      // Should not throw, but should record the error
+      expect(result.errors.length).toBeGreaterThan(0);
+      expect(result.errors[0]).toContain('NON_EXISTENT.md');
+    });
+  });
+
+  describe('formatCleanupSummary', () => {
+    it('should format deleted files', () => {
+      const result = {
+        deletedFiles: ['CLAUDE.md', 'CLINE.md'],
+        modifiedFiles: [],
+        deletedDirs: [],
+        projectMdNeedsMigration: false,
+        errors: [],
+      };
+
+      const summary = formatCleanupSummary(result);
+      expect(summary).toContain('Cleaned up legacy files:');
+      expect(summary).toContain('âœ“ Removed CLAUDE.md');
+      expect(summary).toContain('âœ“ Removed CLINE.md');
+    });
+
+    it('should format deleted directories', () => {
+      const result = {
+        deletedFiles: [],
+        modifiedFiles: [],
+        deletedDirs: ['.claude/commands/openspec'],
+        projectMdNeedsMigration: false,
+        errors: [],
+      };
+
+      const summary = formatCleanupSummary(result);
+      expect(summary).toContain('âœ“ Removed .claude/commands/openspec/ (replaced by /opsx:*)');
+    });
+
+    it('should format modified files', () => {
+      const result = {
+        deletedFiles: [],
+        modifiedFiles: ['AGENTS.md'],
+        deletedDirs: [],
+        projectMdNeedsMigration: false,
+        errors: [],
+      };
+
+      const summary = formatCleanupSummary(result);
+      expect(summary).toContain('âœ“ Removed OpenSpec markers from AGENTS.md');
+    });
+
+    it('should include migration hint for project.md', () => {
+      const result = {
+        deletedFiles: [],
+        modifiedFiles: [],
+        deletedDirs: [],
+        projectMdNeedsMigration: true,
+        errors: [],
+      };
+
+      const summary = formatCleanupSummary(result);
+      expect(summary).toContain('Needs your attention');
+      expect(summary).toContain('openspec/project.md');
+      expect(summary).toContain('config.yaml');
+    });
+
+    it('should include errors', () => {
+      const result = {
+        deletedFiles: [],
+        modifiedFiles: [],
+        deletedDirs: [],
+        projectMdNeedsMigration: false,
+        errors: ['Failed to delete CLAUDE.md: Permission denied'],
+      };
+
+      const summary = formatCleanupSummary(result);
+      expect(summary).toContain('Errors during cleanup:');
+      expect(summary).toContain('Failed to delete CLAUDE.md');
+    });
+
+    it('should return empty string when nothing to report', () => {
+      const result = {
+        deletedFiles: [],
+        modifiedFiles: [],
+        deletedDirs: [],
+        projectMdNeedsMigration: false,
+        errors: [],
+      };
+
+      const summary = formatCleanupSummary(result);
+      expect(summary).toBe('');
+    });
+  });
+
+  describe('formatDetectionSummary', () => {
+    it('should include welcoming upgrade header and explanation', () => {
+      const detection = {
+        configFiles: ['CLAUDE.md'],
+        configFilesToUpdate: ['CLAUDE.md'],
+        slashCommandDirs: [],
+        slashCommandFiles: [],
+        hasOpenspecAgents: false,
+        hasProjectMd: false,
+        hasRootAgentsWithMarkers: false,
+        hasLegacyArtifacts: true,
+      };
+
+      const summary = formatDetectionSummary(detection);
+      expect(summary).toContain('Upgrading to the new OpenSpec');
+      expect(summary).toContain('agent skills');
+      expect(summary).toContain('keeping everything working');
+    });
+
+    it('should format config files as files to update (never remove)', () => {
+      const detection = {
+        configFiles: ['CLAUDE.md'],
+        configFilesToUpdate: ['CLAUDE.md'],
+        slashCommandDirs: [],
+        slashCommandFiles: [],
+        hasOpenspecAgents: false,
+        hasProjectMd: false,
+        hasRootAgentsWithMarkers: false,
+        hasLegacyArtifacts: true,
+      };
+
+      const summary = formatDetectionSummary(detection);
+      // Config files should be in "Files to update", not "Files to remove"
+      expect(summary).toContain('Files to update');
+      expect(summary).toContain('â€¢ CLAUDE.md');
+      // Should NOT be in removals
+      expect(summary).not.toContain('No user content to preserve');
+    });
+
+    it('should format files to be updated', () => {
+      const detection = {
+        configFiles: ['CLINE.md'],
+        configFilesToUpdate: ['CLINE.md'],
+        slashCommandDirs: [],
+        slashCommandFiles: [],
+        hasOpenspecAgents: false,
+        hasProjectMd: false,
+        hasRootAgentsWithMarkers: false,
+        hasLegacyArtifacts: true,
+      };
+
+      const summary = formatDetectionSummary(detection);
+      expect(summary).toContain('Files to update');
+      expect(summary).toContain('markers will be removed');
+      expect(summary).toContain('your content preserved');
+      expect(summary).toContain('â€¢ CLINE.md');
+    });
+
+    it('should format slash command directories', () => {
+      const detection = {
+        configFiles: [],
+        configFilesToUpdate: [],
+        slashCommandDirs: ['.claude/commands/openspec'],
+        slashCommandFiles: [],
+        hasOpenspecAgents: false,
+        hasProjectMd: false,
+        hasRootAgentsWithMarkers: false,
+        hasLegacyArtifacts: true,
+      };
+
+      const summary = formatDetectionSummary(detection);
+      expect(summary).toContain('Files to remove');
+      expect(summary).toContain('â€¢ .claude/commands/openspec/');
+    });
+
+    it('should format slash command files', () => {
+      const detection = {
+        configFiles: [],
+        configFilesToUpdate: [],
+        slashCommandDirs: [],
+        slashCommandFiles: ['.cursor/commands/openspec-proposal.md'],
+        hasOpenspecAgents: false,
+        hasProjectMd: false,
+        hasRootAgentsWithMarkers: false,
+        hasLegacyArtifacts: true,
+      };
+
+      const summary = formatDetectionSummary(detection);
+      expect(summary).toContain('Files to remove');
+      expect(summary).toContain('â€¢ .cursor/commands/openspec-proposal.md');
+    });
+
+    it('should format openspec/AGENTS.md', () => {
+      const detection = {
+        configFiles: [],
+        configFilesToUpdate: [],
+        slashCommandDirs: [],
+        slashCommandFiles: [],
+        hasOpenspecAgents: true,
+        hasProjectMd: false,
+        hasRootAgentsWithMarkers: false,
+        hasLegacyArtifacts: true,
+      };
+
+      const summary = formatDetectionSummary(detection);
+      expect(summary).toContain('Files to remove');
+      expect(summary).toContain('â€¢ openspec/AGENTS.md');
+    });
+
+    it('should include attention section for project.md', () => {
+      const detection = {
+        configFiles: [],
+        configFilesToUpdate: [],
+        slashCommandDirs: [],
+        slashCommandFiles: [],
+        hasOpenspecAgents: false,
+        hasProjectMd: true,
+        hasRootAgentsWithMarkers: false,
+        hasLegacyArtifacts: false,
+      };
+
+      const summary = formatDetectionSummary(detection);
+      expect(summary).toContain('Needs your attention');
+      expect(summary).toContain('â€¢ openspec/project.md');
+      expect(summary).toContain('won\'t delete this file');
+      expect(summary).toContain('config.yaml');
+      expect(summary).toContain('"context:"');
+    });
+
+    it('should include attention section with other legacy artifacts', () => {
+      const detection = {
+        configFiles: ['CLAUDE.md'],
+        configFilesToUpdate: ['CLAUDE.md'],
+        slashCommandDirs: [],
+        slashCommandFiles: [],
+        hasOpenspecAgents: false,
+        hasProjectMd: true,
+        hasRootAgentsWithMarkers: false,
+        hasLegacyArtifacts: true,
+      };
+
+      const summary = formatDetectionSummary(detection);
+      // Config files now in "Files to update", not "Files to remove"
+      expect(summary).toContain('Files to update');
+      expect(summary).toContain('CLAUDE.md');
+      expect(summary).toContain('Needs your attention');
+      expect(summary).toContain('openspec/project.md');
+    });
+
+    it('should group both removals and updates correctly', () => {
+      const detection = {
+        configFiles: ['CLAUDE.md', 'CLINE.md'],
+        configFilesToUpdate: ['CLAUDE.md', 'CLINE.md'],
+        slashCommandDirs: ['.claude/commands/openspec'],
+        slashCommandFiles: [],
+        hasOpenspecAgents: true,
+        hasProjectMd: false,
+        hasRootAgentsWithMarkers: false,
+        hasLegacyArtifacts: true,
+      };
+
+      const summary = formatDetectionSummary(detection);
+      // Check both sections exist
+      expect(summary).toContain('Files to remove');
+      expect(summary).toContain('Files to update');
+      // Check removals (only slash commands and openspec/AGENTS.md)
+      expect(summary).toContain('â€¢ .claude/commands/openspec/');
+      expect(summary).toContain('â€¢ openspec/AGENTS.md');
+      // Check updates (all config files)
+      expect(summary).toContain('â€¢ CLAUDE.md');
+      expect(summary).toContain('â€¢ CLINE.md');
+    });
+
+    it('should return empty string when nothing is detected', () => {
+      const detection = {
+        configFiles: [],
+        configFilesToUpdate: [],
+        slashCommandDirs: [],
+        slashCommandFiles: [],
+        hasOpenspecAgents: false,
+        hasProjectMd: false,
+        hasRootAgentsWithMarkers: false,
+        hasLegacyArtifacts: false,
+      };
+
+      const summary = formatDetectionSummary(detection);
+      expect(summary).toBe('');
+    });
+  });
+
+  describe('formatProjectMdMigrationHint', () => {
+    it('should return migration hint message', () => {
+      const hint = formatProjectMdMigrationHint();
+      expect(hint).toContain('Needs your attention');
+      expect(hint).toContain('openspec/project.md');
+      expect(hint).toContain('won\'t delete this file');
+      expect(hint).toContain('config.yaml');
+      expect(hint).toContain('"context:"');
+    });
+
+    it('should include actionable instructions', () => {
+      const hint = formatProjectMdMigrationHint();
+      expect(hint).toContain('move any useful content');
+      expect(hint).toContain('delete the file when ready');
+    });
+
+    it('should explain the new context section benefits', () => {
+      const hint = formatProjectMdMigrationHint();
+      expect(hint).toContain('included in every OpenSpec request');
+      expect(hint).toContain('reliably');
+    });
+  });
+
+  describe('LEGACY_CONFIG_FILES', () => {
+    it('should include expected config file names', () => {
+      expect(LEGACY_CONFIG_FILES).toContain('CLAUDE.md');
+      expect(LEGACY_CONFIG_FILES).toContain('CLINE.md');
+      expect(LEGACY_CONFIG_FILES).toContain('CODEBUDDY.md');
+      expect(LEGACY_CONFIG_FILES).toContain('COSTRICT.md');
+      expect(LEGACY_CONFIG_FILES).toContain('QODER.md');
+      expect(LEGACY_CONFIG_FILES).toContain('IFLOW.md');
+      expect(LEGACY_CONFIG_FILES).toContain('AGENTS.md');
+      expect(LEGACY_CONFIG_FILES).toContain('QWEN.md');
+    });
+  });
+
+  describe('LEGACY_SLASH_COMMAND_PATHS', () => {
+    it('should include expected tool patterns', () => {
+      expect(LEGACY_SLASH_COMMAND_PATHS['claude']).toEqual({
+        type: 'directory',
+        path: '.claude/commands/openspec',
+      });
+
+      expect(LEGACY_SLASH_COMMAND_PATHS['cursor']).toEqual({
+        type: 'files',
+        pattern: '.cursor/commands/openspec-*.md',
+      });
+
+      expect(LEGACY_SLASH_COMMAND_PATHS['windsurf']).toEqual({
+        type: 'files',
+        pattern: '.windsurf/workflows/openspec-*.md',
+      });
+    });
+
+    it('should cover all tools from the CommandAdapterRegistry', () => {
+      const expectedTools = CommandAdapterRegistry.getAll().map(adapter => adapter.toolId);
+
+      // Verify all adapters have legacy paths
+      for (const tool of expectedTools) {
+        expect(LEGACY_SLASH_COMMAND_PATHS).toHaveProperty(tool);
+      }
+
+      // Verify counts match
+      expect(expectedTools.length).toBe(Object.keys(LEGACY_SLASH_COMMAND_PATHS).length);
+    });
+  });
+
+  describe('getToolsFromLegacyArtifacts', () => {
+    it('should extract claude from directory-based legacy artifacts', () => {
+      const detection = {
+        configFiles: [],
+        configFilesToUpdate: [],
+        slashCommandDirs: ['.claude/commands/openspec'],
+        slashCommandFiles: [],
+        hasOpenspecAgents: false,
+        hasProjectMd: false,
+        hasRootAgentsWithMarkers: false,
+        hasLegacyArtifacts: true,
+      };
+
+      const tools = getToolsFromLegacyArtifacts(detection);
+      expect(tools).toContain('claude');
+      expect(tools).toHaveLength(1);
+    });
+
+    it('should extract cursor from file-based legacy artifacts', () => {
+      const detection = {
+        configFiles: [],
+        configFilesToUpdate: [],
+        slashCommandDirs: [],
+        slashCommandFiles: ['.cursor/commands/openspec-proposal.md'],
+        hasOpenspecAgents: false,
+        hasProjectMd: false,
+        hasRootAgentsWithMarkers: false,
+        hasLegacyArtifacts: true,
+      };
+
+      const tools = getToolsFromLegacyArtifacts(detection);
+      expect(tools).toContain('cursor');
+      expect(tools).toHaveLength(1);
+    });
+
+    it('should extract multiple tools from mixed legacy artifacts', () => {
+      const detection = {
+        configFiles: [],
+        configFilesToUpdate: [],
+        slashCommandDirs: ['.claude/commands/openspec', '.qoder/commands/openspec'],
+        slashCommandFiles: ['.cursor/commands/openspec-apply.md', '.windsurf/workflows/openspec-archive.md'],
+        hasOpenspecAgents: false,
+        hasProjectMd: false,
+        hasRootAgentsWithMarkers: false,
+        hasLegacyArtifacts: true,
+      };
+
+      const tools = getToolsFromLegacyArtifacts(detection);
+      expect(tools).toContain('claude');
+      expect(tools).toContain('qoder');
+      expect(tools).toContain('cursor');
+      expect(tools).toContain('windsurf');
+      expect(tools).toHaveLength(4);
+    });
+
+    it('should deduplicate tools when multiple files match same tool', () => {
+      const detection = {
+        configFiles: [],
+        configFilesToUpdate: [],
+        slashCommandDirs: [],
+        slashCommandFiles: [
+          '.cursor/commands/openspec-proposal.md',
+          '.cursor/commands/openspec-apply.md',
+          '.cursor/commands/openspec-archive.md',
+        ],
+        hasOpenspecAgents: false,
+        hasProjectMd: false,
+        hasRootAgentsWithMarkers: false,
+        hasLegacyArtifacts: true,
+      };
+
+      const tools = getToolsFromLegacyArtifacts(detection);
+      expect(tools).toContain('cursor');
+      expect(tools).toHaveLength(1);
+    });
+
+    it('should return empty array when no legacy artifacts', () => {
+      const detection = {
+        configFiles: [],
+        configFilesToUpdate: [],
+        slashCommandDirs: [],
+        slashCommandFiles: [],
+        hasOpenspecAgents: false,
+        hasProjectMd: false,
+        hasRootAgentsWithMarkers: false,
+        hasLegacyArtifacts: false,
+      };
+
+      const tools = getToolsFromLegacyArtifacts(detection);
+      expect(tools).toHaveLength(0);
+    });
+
+    it('should handle qwen TOML-based legacy files', () => {
+      const detection = {
+        configFiles: [],
+        configFilesToUpdate: [],
+        slashCommandDirs: [],
+        slashCommandFiles: ['.qwen/commands/openspec-proposal.toml'],
+        hasOpenspecAgents: false,
+        hasProjectMd: false,
+        hasRootAgentsWithMarkers: false,
+        hasLegacyArtifacts: true,
+      };
+
+      const tools = getToolsFromLegacyArtifacts(detection);
+      expect(tools).toContain('qwen');
+      expect(tools).toHaveLength(1);
+    });
+
+    it('should handle continue prompt files', () => {
+      const detection = {
+        configFiles: [],
+        configFilesToUpdate: [],
+        slashCommandDirs: [],
+        slashCommandFiles: ['.continue/prompts/openspec-apply.prompt'],
+        hasOpenspecAgents: false,
+        hasProjectMd: false,
+        hasRootAgentsWithMarkers: false,
+        hasLegacyArtifacts: true,
+      };
+
+      const tools = getToolsFromLegacyArtifacts(detection);
+      expect(tools).toContain('continue');
+      expect(tools).toHaveLength(1);
+    });
+
+    it('should handle github-copilot prompt files', () => {
+      const detection = {
+        configFiles: [],
+        configFilesToUpdate: [],
+        slashCommandDirs: [],
+        slashCommandFiles: ['.github/prompts/openspec-apply.prompt.md'],
+        hasOpenspecAgents: false,
+        hasProjectMd: false,
+        hasRootAgentsWithMarkers: false,
+        hasLegacyArtifacts: true,
+      };
+
+      const tools = getToolsFromLegacyArtifacts(detection);
+      expect(tools).toContain('github-copilot');
+      expect(tools).toHaveLength(1);
+    });
+
+    it('should not extract tools from config files only', () => {
+      // Config files don't indicate which tools were configured
+      // Only slash command dirs/files tell us which tools to upgrade
+      const detection = {
+        configFiles: ['CLAUDE.md'],
+        configFilesToUpdate: ['CLAUDE.md'],
+        slashCommandDirs: [],
+        slashCommandFiles: [],
+        hasOpenspecAgents: true,
+        hasProjectMd: false,
+        hasRootAgentsWithMarkers: false,
+        hasLegacyArtifacts: true,
+      };
+
+      const tools = getToolsFromLegacyArtifacts(detection);
+      expect(tools).toHaveLength(0);
+    });
+  });
+});
diff --git a/test/core/project-config.test.ts b/test/core/project-config.test.ts
index abfd2a3..8894465 100644
--- a/test/core/project-config.test.ts
+++ b/test/core/project-config.test.ts
@@ -374,7 +374,7 @@ context: |
         );
         fs.writeFileSync(
           path.join(configDir, 'config.yml'),
-          'schema: tdd\ncontext: from yml\n'
+          'schema: custom-schema\ncontext: from yml\n'
         );
 
         const config = readProjectConfig(tempDir);
@@ -388,12 +388,12 @@ context: |
         fs.mkdirSync(configDir, { recursive: true });
         fs.writeFileSync(
           path.join(configDir, 'config.yml'),
-          'schema: tdd\ncontext: from yml\n'
+          'schema: custom-schema\ncontext: from yml\n'
         );
 
         const config = readProjectConfig(tempDir);
 
-        expect(config?.schema).toBe('tdd');
+        expect(config?.schema).toBe('custom-schema');
         expect(config?.context).toBe('from yml');
       });
 
@@ -538,7 +538,6 @@ rules:
   describe('suggestSchemas', () => {
     const availableSchemas = [
       { name: 'spec-driven', isBuiltIn: true },
-      { name: 'tdd', isBuiltIn: true },
       { name: 'custom-workflow', isBuiltIn: false },
       { name: 'team-process', isBuiltIn: false },
     ];
@@ -551,29 +550,28 @@ rules:
       expect(message).toContain('spec-driven (built-in)');
     });
 
-    it('should suggest tdd for tdd typo', () => {
-      const message = suggestSchemas('td', availableSchemas);
+    it('should suggest custom-workflow for workflow typo', () => {
+      const message = suggestSchemas('custom-workflo', availableSchemas);
 
       expect(message).toContain('Did you mean one of these?');
-      expect(message).toContain('tdd (built-in)');
+      expect(message).toContain('custom-workflow');
     });
 
     it('should list all available schemas', () => {
       const message = suggestSchemas('nonexistent', availableSchemas);
 
       expect(message).toContain('Available schemas:');
-      expect(message).toContain('Built-in: spec-driven, tdd');
+      expect(message).toContain('Built-in: spec-driven');
       expect(message).toContain('Project-local: custom-workflow, team-process');
     });
 
     it('should handle case when no project-local schemas exist', () => {
       const builtInOnly = [
         { name: 'spec-driven', isBuiltIn: true },
-        { name: 'tdd', isBuiltIn: true },
       ];
       const message = suggestSchemas('invalid', builtInOnly);
 
-      expect(message).toContain('Built-in: spec-driven, tdd');
+      expect(message).toContain('Built-in: spec-driven');
       expect(message).toContain('Project-local: (none found)');
     });
 
diff --git a/test/core/shared/skill-generation.test.ts b/test/core/shared/skill-generation.test.ts
new file mode 100644
index 0000000..df6d2e3
--- /dev/null
+++ b/test/core/shared/skill-generation.test.ts
@@ -0,0 +1,181 @@
+import { describe, it, expect } from 'vitest';
+import {
+  getSkillTemplates,
+  getCommandTemplates,
+  getCommandContents,
+  generateSkillContent,
+} from '../../../src/core/shared/skill-generation.js';
+
+describe('skill-generation', () => {
+  describe('getSkillTemplates', () => {
+    it('should return all 10 skill templates', () => {
+      const templates = getSkillTemplates();
+      expect(templates).toHaveLength(10);
+    });
+
+    it('should have unique directory names', () => {
+      const templates = getSkillTemplates();
+      const dirNames = templates.map(t => t.dirName);
+      const uniqueDirNames = new Set(dirNames);
+      expect(uniqueDirNames.size).toBe(templates.length);
+    });
+
+    it('should include all expected skills', () => {
+      const templates = getSkillTemplates();
+      const dirNames = templates.map(t => t.dirName);
+
+      expect(dirNames).toContain('openspec-explore');
+      expect(dirNames).toContain('openspec-new-change');
+      expect(dirNames).toContain('openspec-continue-change');
+      expect(dirNames).toContain('openspec-apply-change');
+      expect(dirNames).toContain('openspec-ff-change');
+      expect(dirNames).toContain('openspec-sync-specs');
+      expect(dirNames).toContain('openspec-archive-change');
+      expect(dirNames).toContain('openspec-bulk-archive-change');
+      expect(dirNames).toContain('openspec-verify-change');
+      expect(dirNames).toContain('openspec-onboard');
+    });
+
+    it('should have valid template structure', () => {
+      const templates = getSkillTemplates();
+
+      for (const { template, dirName } of templates) {
+        expect(template.name).toBeTruthy();
+        expect(template.description).toBeTruthy();
+        expect(template.instructions).toBeTruthy();
+        expect(dirName).toBeTruthy();
+      }
+    });
+  });
+
+  describe('getCommandTemplates', () => {
+    it('should return all 10 command templates', () => {
+      const templates = getCommandTemplates();
+      expect(templates).toHaveLength(10);
+    });
+
+    it('should have unique IDs', () => {
+      const templates = getCommandTemplates();
+      const ids = templates.map(t => t.id);
+      const uniqueIds = new Set(ids);
+      expect(uniqueIds.size).toBe(templates.length);
+    });
+
+    it('should include all expected commands', () => {
+      const templates = getCommandTemplates();
+      const ids = templates.map(t => t.id);
+
+      expect(ids).toContain('explore');
+      expect(ids).toContain('new');
+      expect(ids).toContain('continue');
+      expect(ids).toContain('apply');
+      expect(ids).toContain('ff');
+      expect(ids).toContain('sync');
+      expect(ids).toContain('archive');
+      expect(ids).toContain('bulk-archive');
+      expect(ids).toContain('verify');
+      expect(ids).toContain('onboard');
+    });
+  });
+
+  describe('getCommandContents', () => {
+    it('should return all 10 command contents', () => {
+      const contents = getCommandContents();
+      expect(contents).toHaveLength(10);
+    });
+
+    it('should have valid content structure', () => {
+      const contents = getCommandContents();
+
+      for (const content of contents) {
+        expect(content.id).toBeTruthy();
+        expect(content.name).toBeTruthy();
+        expect(content.description).toBeTruthy();
+        expect(content.body).toBeTruthy();
+      }
+    });
+
+    it('should have matching IDs with command templates', () => {
+      const templates = getCommandTemplates();
+      const contents = getCommandContents();
+
+      const templateIds = templates.map(t => t.id).sort();
+      const contentIds = contents.map(c => c.id).sort();
+
+      expect(contentIds).toEqual(templateIds);
+    });
+  });
+
+  describe('generateSkillContent', () => {
+    it('should generate valid YAML frontmatter', () => {
+      const template = {
+        name: 'test-skill',
+        description: 'Test description',
+        instructions: 'Test instructions',
+        license: 'MIT',
+        compatibility: 'Test compatibility',
+        metadata: {
+          author: 'test-author',
+          version: '2.0',
+        },
+      };
+
+      const content = generateSkillContent(template, '0.23.0');
+
+      expect(content).toMatch(/^---\n/);
+      expect(content).toContain('name: test-skill');
+      expect(content).toContain('description: Test description');
+      expect(content).toContain('license: MIT');
+      expect(content).toContain('compatibility: Test compatibility');
+      expect(content).toContain('author: test-author');
+      expect(content).toContain('version: "2.0"');
+      expect(content).toContain('generatedBy: "0.23.0"');
+      expect(content).toContain('Test instructions');
+    });
+
+    it('should use default values for optional fields', () => {
+      const template = {
+        name: 'minimal-skill',
+        description: 'Minimal description',
+        instructions: 'Minimal instructions',
+      };
+
+      const content = generateSkillContent(template, '0.24.0');
+
+      expect(content).toContain('license: MIT');
+      expect(content).toContain('compatibility: Requires openspec CLI.');
+      expect(content).toContain('author: openspec');
+      expect(content).toContain('version: "1.0"');
+      expect(content).toContain('generatedBy: "0.24.0"');
+    });
+
+    it('should embed the provided version in generatedBy field', () => {
+      const template = {
+        name: 'version-test',
+        description: 'Test version embedding',
+        instructions: 'Instructions',
+      };
+
+      const content1 = generateSkillContent(template, '0.23.0');
+      expect(content1).toContain('generatedBy: "0.23.0"');
+
+      const content2 = generateSkillContent(template, '1.0.0');
+      expect(content2).toContain('generatedBy: "1.0.0"');
+
+      const content3 = generateSkillContent(template, '0.24.0-beta.1');
+      expect(content3).toContain('generatedBy: "0.24.0-beta.1"');
+    });
+
+    it('should end frontmatter with separator and blank line', () => {
+      const template = {
+        name: 'test',
+        description: 'Test',
+        instructions: 'Body content',
+      };
+
+      const content = generateSkillContent(template, '0.23.0');
+
+      expect(content).toMatch(/---\n\nBody content\n$/);
+    });
+  });
+});
diff --git a/test/core/shared/tool-detection.test.ts b/test/core/shared/tool-detection.test.ts
new file mode 100644
index 0000000..d11e0da
--- /dev/null
+++ b/test/core/shared/tool-detection.test.ts
@@ -0,0 +1,331 @@
+import { describe, it, expect, beforeEach, afterEach } from 'vitest';
+import { promises as fs } from 'fs';
+import path from 'path';
+import os from 'os';
+import { randomUUID } from 'crypto';
+import {
+  SKILL_NAMES,
+  getToolsWithSkillsDir,
+  getToolSkillStatus,
+  getToolStates,
+  extractGeneratedByVersion,
+  getToolVersionStatus,
+  getConfiguredTools,
+  getAllToolVersionStatus,
+} from '../../../src/core/shared/tool-detection.js';
+
+describe('tool-detection', () => {
+  let testDir: string;
+
+  beforeEach(async () => {
+    testDir = path.join(os.tmpdir(), `openspec-test-${randomUUID()}`);
+    await fs.mkdir(testDir, { recursive: true });
+  });
+
+  afterEach(async () => {
+    await fs.rm(testDir, { recursive: true, force: true });
+  });
+
+  describe('SKILL_NAMES', () => {
+    it('should contain all 9 skill names', () => {
+      expect(SKILL_NAMES).toHaveLength(9);
+      expect(SKILL_NAMES).toContain('openspec-explore');
+      expect(SKILL_NAMES).toContain('openspec-new-change');
+      expect(SKILL_NAMES).toContain('openspec-continue-change');
+      expect(SKILL_NAMES).toContain('openspec-apply-change');
+      expect(SKILL_NAMES).toContain('openspec-ff-change');
+      expect(SKILL_NAMES).toContain('openspec-sync-specs');
+      expect(SKILL_NAMES).toContain('openspec-archive-change');
+      expect(SKILL_NAMES).toContain('openspec-bulk-archive-change');
+      expect(SKILL_NAMES).toContain('openspec-verify-change');
+    });
+  });
+
+  describe('getToolsWithSkillsDir', () => {
+    it('should return tools that have skillsDir configured', () => {
+      const tools = getToolsWithSkillsDir();
+      expect(tools).toContain('claude');
+      expect(tools).toContain('cursor');
+      expect(tools).toContain('windsurf');
+      expect(tools.length).toBeGreaterThan(0);
+    });
+  });
+
+  describe('getToolSkillStatus', () => {
+    it('should return not configured for unknown tool', () => {
+      const status = getToolSkillStatus(testDir, 'unknown-tool');
+      expect(status.configured).toBe(false);
+      expect(status.fullyConfigured).toBe(false);
+      expect(status.skillCount).toBe(0);
+    });
+
+    it('should return not configured when no skills exist', () => {
+      const status = getToolSkillStatus(testDir, 'claude');
+      expect(status.configured).toBe(false);
+      expect(status.fullyConfigured).toBe(false);
+      expect(status.skillCount).toBe(0);
+    });
+
+    it('should detect when one skill exists', async () => {
+      const skillDir = path.join(testDir, '.claude', 'skills', 'openspec-explore');
+      await fs.mkdir(skillDir, { recursive: true });
+      await fs.writeFile(path.join(skillDir, 'SKILL.md'), 'test content');
+
+      const status = getToolSkillStatus(testDir, 'claude');
+      expect(status.configured).toBe(true);
+      expect(status.fullyConfigured).toBe(false);
+      expect(status.skillCount).toBe(1);
+    });
+
+    it('should detect when all skills exist', async () => {
+      for (const skillName of SKILL_NAMES) {
+        const skillDir = path.join(testDir, '.claude', 'skills', skillName);
+        await fs.mkdir(skillDir, { recursive: true });
+        await fs.writeFile(path.join(skillDir, 'SKILL.md'), 'test content');
+      }
+
+      const status = getToolSkillStatus(testDir, 'claude');
+      expect(status.configured).toBe(true);
+      expect(status.fullyConfigured).toBe(true);
+      expect(status.skillCount).toBe(9);
+    });
+  });
+
+  describe('getToolStates', () => {
+    it('should return status for all tools with skillsDir', () => {
+      const states = getToolStates(testDir);
+      expect(states.has('claude')).toBe(true);
+      expect(states.has('cursor')).toBe(true);
+
+      const claudeStatus = states.get('claude');
+      expect(claudeStatus?.configured).toBe(false);
+    });
+
+    it('should detect configured tools', async () => {
+      const skillDir = path.join(testDir, '.claude', 'skills', 'openspec-explore');
+      await fs.mkdir(skillDir, { recursive: true });
+      await fs.writeFile(path.join(skillDir, 'SKILL.md'), 'test content');
+
+      const states = getToolStates(testDir);
+      expect(states.get('claude')?.configured).toBe(true);
+      expect(states.get('cursor')?.configured).toBe(false);
+    });
+  });
+
+  describe('extractGeneratedByVersion', () => {
+    it('should return null for non-existent file', () => {
+      const version = extractGeneratedByVersion(path.join(testDir, 'missing.md'));
+      expect(version).toBeNull();
+    });
+
+    it('should return null when generatedBy is not present', async () => {
+      const filePath = path.join(testDir, 'skill.md');
+      await fs.writeFile(filePath, `---
+name: openspec-explore
+metadata:
+  author: openspec
+  version: "1.0"
+---
+
+Content here
+`);
+
+      const version = extractGeneratedByVersion(filePath);
+      expect(version).toBeNull();
+    });
+
+    it('should extract generatedBy version with double quotes', async () => {
+      const filePath = path.join(testDir, 'skill.md');
+      await fs.writeFile(filePath, `---
+name: openspec-explore
+metadata:
+  author: openspec
+  version: "1.0"
+  generatedBy: "0.23.0"
+---
+
+Content here
+`);
+
+      const version = extractGeneratedByVersion(filePath);
+      expect(version).toBe('0.23.0');
+    });
+
+    it('should extract generatedBy version with single quotes', async () => {
+      const filePath = path.join(testDir, 'skill.md');
+      await fs.writeFile(filePath, `---
+name: openspec-explore
+metadata:
+  generatedBy: '0.24.0'
+---
+
+Content here
+`);
+
+      const version = extractGeneratedByVersion(filePath);
+      expect(version).toBe('0.24.0');
+    });
+
+    it('should extract generatedBy version without quotes', async () => {
+      const filePath = path.join(testDir, 'skill.md');
+      await fs.writeFile(filePath, `---
+name: openspec-explore
+metadata:
+  generatedBy: 0.25.0
+---
+
+Content here
+`);
+
+      const version = extractGeneratedByVersion(filePath);
+      expect(version).toBe('0.25.0');
+    });
+  });
+
+  describe('getToolVersionStatus', () => {
+    it('should return not configured for unknown tool', () => {
+      const status = getToolVersionStatus(testDir, 'unknown-tool', '0.23.0');
+      expect(status.configured).toBe(false);
+      expect(status.generatedByVersion).toBeNull();
+      expect(status.needsUpdate).toBe(false);
+    });
+
+    it('should return not configured when no skills exist', () => {
+      const status = getToolVersionStatus(testDir, 'claude', '0.23.0');
+      expect(status.configured).toBe(false);
+      expect(status.generatedByVersion).toBeNull();
+      expect(status.needsUpdate).toBe(false);
+    });
+
+    it('should detect needsUpdate when generatedBy is missing', async () => {
+      const skillDir = path.join(testDir, '.claude', 'skills', 'openspec-explore');
+      await fs.mkdir(skillDir, { recursive: true });
+      await fs.writeFile(path.join(skillDir, 'SKILL.md'), `---
+name: openspec-explore
+metadata:
+  author: openspec
+  version: "1.0"
+---
+
+Content here
+`);
+
+      const status = getToolVersionStatus(testDir, 'claude', '0.23.0');
+      expect(status.configured).toBe(true);
+      expect(status.generatedByVersion).toBeNull();
+      expect(status.needsUpdate).toBe(true);
+    });
+
+    it('should detect needsUpdate when version differs', async () => {
+      const skillDir = path.join(testDir, '.claude', 'skills', 'openspec-explore');
+      await fs.mkdir(skillDir, { recursive: true });
+      await fs.writeFile(path.join(skillDir, 'SKILL.md'), `---
+name: openspec-explore
+metadata:
+  author: openspec
+  version: "1.0"
+  generatedBy: "0.22.0"
+---
+
+Content here
+`);
+
+      const status = getToolVersionStatus(testDir, 'claude', '0.23.0');
+      expect(status.configured).toBe(true);
+      expect(status.generatedByVersion).toBe('0.22.0');
+      expect(status.needsUpdate).toBe(true);
+    });
+
+    it('should not need update when version matches', async () => {
+      const skillDir = path.join(testDir, '.claude', 'skills', 'openspec-explore');
+      await fs.mkdir(skillDir, { recursive: true });
+      await fs.writeFile(path.join(skillDir, 'SKILL.md'), `---
+name: openspec-explore
+metadata:
+  author: openspec
+  version: "1.0"
+  generatedBy: "0.23.0"
+---
+
+Content here
+`);
+
+      const status = getToolVersionStatus(testDir, 'claude', '0.23.0');
+      expect(status.configured).toBe(true);
+      expect(status.generatedByVersion).toBe('0.23.0');
+      expect(status.needsUpdate).toBe(false);
+    });
+
+    it('should include tool name in status', async () => {
+      const skillDir = path.join(testDir, '.claude', 'skills', 'openspec-explore');
+      await fs.mkdir(skillDir, { recursive: true });
+      await fs.writeFile(path.join(skillDir, 'SKILL.md'), 'content');
+
+      const status = getToolVersionStatus(testDir, 'claude', '0.23.0');
+      expect(status.toolId).toBe('claude');
+      expect(status.toolName).toBe('Claude Code');
+    });
+  });
+
+  describe('getConfiguredTools', () => {
+    it('should return empty array when no tools are configured', () => {
+      const tools = getConfiguredTools(testDir);
+      expect(tools).toEqual([]);
+    });
+
+    it('should return configured tools', async () => {
+      // Setup Claude
+      const claudeSkillDir = path.join(testDir, '.claude', 'skills', 'openspec-explore');
+      await fs.mkdir(claudeSkillDir, { recursive: true });
+      await fs.writeFile(path.join(claudeSkillDir, 'SKILL.md'), 'content');
+
+      // Setup Cursor
+      const cursorSkillDir = path.join(testDir, '.cursor', 'skills', 'openspec-explore');
+      await fs.mkdir(cursorSkillDir, { recursive: true });
+      await fs.writeFile(path.join(cursorSkillDir, 'SKILL.md'), 'content');
+
+      const tools = getConfiguredTools(testDir);
+      expect(tools).toContain('claude');
+      expect(tools).toContain('cursor');
+      expect(tools).toHaveLength(2);
+    });
+  });
+
+  describe('getAllToolVersionStatus', () => {
+    it('should return empty array when no tools are configured', () => {
+      const statuses = getAllToolVersionStatus(testDir, '0.23.0');
+      expect(statuses).toEqual([]);
+    });
+
+    it('should return version status for all configured tools', async () => {
+      // Setup Claude with old version
+      const claudeSkillDir = path.join(testDir, '.claude', 'skills', 'openspec-explore');
+      await fs.mkdir(claudeSkillDir, { recursive: true });
+      await fs.writeFile(path.join(claudeSkillDir, 'SKILL.md'), `---
+metadata:
+  generatedBy: "0.22.0"
+---
+`);
+
+      // Setup Cursor with current version
+      const cursorSkillDir = path.join(testDir, '.cursor', 'skills', 'openspec-explore');
+      await fs.mkdir(cursorSkillDir, { recursive: true });
+      await fs.writeFile(path.join(cursorSkillDir, 'SKILL.md'), `---
+metadata:
+  generatedBy: "0.23.0"
+---
+`);
+
+      const statuses = getAllToolVersionStatus(testDir, '0.23.0');
+      expect(statuses).toHaveLength(2);
+
+      const claudeStatus = statuses.find(s => s.toolId === 'claude');
+      expect(claudeStatus?.generatedByVersion).toBe('0.22.0');
+      expect(claudeStatus?.needsUpdate).toBe(true);
+
+      const cursorStatus = statuses.find(s => s.toolId === 'cursor');
+      expect(cursorStatus?.generatedByVersion).toBe('0.23.0');
+      expect(cursorStatus?.needsUpdate).toBe(false);
+    });
+  });
+});
diff --git a/test/core/update.test.ts b/test/core/update.test.ts
index f41cdbe..ce2b343 100644
--- a/test/core/update.test.ts
+++ b/test/core/update.test.ts
@@ -1,7 +1,7 @@
 import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
 import { UpdateCommand } from '../../src/core/update.js';
 import { FileSystemUtils } from '../../src/utils/file-system.js';
-import { ToolRegistry } from '../../src/core/configurators/registry.js';
+import { OPENSPEC_MARKERS } from '../../src/core/config.js';
 import path from 'path';
 import fs from 'fs/promises';
 import os from 'os';
@@ -10,7 +10,6 @@ import { randomUUID } from 'crypto';
 describe('UpdateCommand', () => {
   let testDir: string;
   let updateCommand: UpdateCommand;
-  let prevCodexHome: string | undefined;
 
   beforeEach(async () => {
     // Create a temporary test directory
@@ -23,1694 +22,1328 @@ describe('UpdateCommand', () => {
 
     updateCommand = new UpdateCommand();
 
-    // Route Codex global directory into the test sandbox
-    prevCodexHome = process.env.CODEX_HOME;
-    process.env.CODEX_HOME = path.join(testDir, '.codex');
+    // Clear all mocks before each test
+    vi.restoreAllMocks();
   });
 
   afterEach(async () => {
+    // Restore all mocks after each test
+    vi.restoreAllMocks();
+
     // Clean up test directory
     await fs.rm(testDir, { recursive: true, force: true });
-    if (prevCodexHome === undefined) delete process.env.CODEX_HOME;
-    else process.env.CODEX_HOME = prevCodexHome;
   });
 
-  it('should update only existing CLAUDE.md file', async () => {
-    // Create CLAUDE.md file with initial content
-    const claudePath = path.join(testDir, 'CLAUDE.md');
-    const initialContent = `# Project Instructions
-
-Some existing content here.
-
-<!-- OPENSPEC:START -->
-Old OpenSpec content
-<!-- OPENSPEC:END -->
-
-More content after.`;
-    await fs.writeFile(claudePath, initialContent);
-
-    const consoleSpy = vi.spyOn(console, 'log');
-
-    // Execute update command
-    await updateCommand.execute(testDir);
-
-    // Check that CLAUDE.md was updated
-    const updatedContent = await fs.readFile(claudePath, 'utf-8');
-    expect(updatedContent).toContain('<!-- OPENSPEC:START -->');
-    expect(updatedContent).toContain('<!-- OPENSPEC:END -->');
-    expect(updatedContent).toContain("@/openspec/AGENTS.md");
-    expect(updatedContent).toContain('openspec update');
-    expect(updatedContent).toContain('Some existing content here');
-    expect(updatedContent).toContain('More content after');
-
-    // Check console output
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated OpenSpec instructions (openspec/AGENTS.md'
-    );
-    expect(logMessage).toContain('AGENTS.md (created)');
-    expect(logMessage).toContain('Updated AI tool files: CLAUDE.md');
-    consoleSpy.mockRestore();
-  });
+  describe('basic validation', () => {
+    it('should throw error if openspec directory does not exist', async () => {
+      // Remove openspec directory
+      await fs.rm(path.join(testDir, 'openspec'), {
+        recursive: true,
+        force: true,
+      });
 
-  it('should update only existing QWEN.md file', async () => {
-    const qwenPath = path.join(testDir, 'QWEN.md');
-    const initialContent = `# Qwen Instructions
+      await expect(updateCommand.execute(testDir)).rejects.toThrow(
+        "No OpenSpec directory found. Run 'openspec init' first."
+      );
+    });
 
-Some existing content.
+    it('should report no configured tools when none exist', async () => {
+      const consoleSpy = vi.spyOn(console, 'log');
 
-<!-- OPENSPEC:START -->
-Old OpenSpec content
-<!-- OPENSPEC:END -->
+      await updateCommand.execute(testDir);
 
-More notes here.`;
-    await fs.writeFile(qwenPath, initialContent);
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('No configured tools found')
+      );
 
-    const consoleSpy = vi.spyOn(console, 'log');
+      consoleSpy.mockRestore();
+    });
+  });
 
-    await updateCommand.execute(testDir);
+  describe('skill updates', () => {
+    it('should update skill files for configured Claude tool', async () => {
+      // Set up a configured Claude tool by creating skill directories
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      const exploreSkillDir = path.join(skillsDir, 'openspec-explore');
+      await fs.mkdir(exploreSkillDir, { recursive: true });
 
-    const updatedContent = await fs.readFile(qwenPath, 'utf-8');
-    expect(updatedContent).toContain('<!-- OPENSPEC:START -->');
-    expect(updatedContent).toContain('<!-- OPENSPEC:END -->');
-    expect(updatedContent).toContain("@/openspec/AGENTS.md");
-    expect(updatedContent).toContain('openspec update');
-    expect(updatedContent).toContain('Some existing content.');
-    expect(updatedContent).toContain('More notes here.');
+      // Create an existing skill file
+      const oldSkillContent = `---
+name: openspec-explore (old)
+description: Old description
+license: MIT
+compatibility: Requires openspec CLI.
+metadata:
+  author: openspec
+  version: "0.9"
+---
 
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated OpenSpec instructions (openspec/AGENTS.md'
-    );
-    expect(logMessage).toContain('AGENTS.md (created)');
-    expect(logMessage).toContain('Updated AI tool files: QWEN.md');
+Old instructions content
+`;
+      await fs.writeFile(
+        path.join(exploreSkillDir, 'SKILL.md'),
+        oldSkillContent
+      );
+
+      const consoleSpy = vi.spyOn(console, 'log');
+
+      await updateCommand.execute(testDir);
+
+      // Check skill file was updated
+      const updatedSkill = await fs.readFile(
+        path.join(exploreSkillDir, 'SKILL.md'),
+        'utf-8'
+      );
+      expect(updatedSkill).toContain('name: openspec-explore');
+      expect(updatedSkill).not.toContain('Old instructions content');
+      expect(updatedSkill).toContain('license: MIT');
+
+      // Check console output
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Updating 1 tool(s): claude')
+      );
+
+      consoleSpy.mockRestore();
+    });
 
-    consoleSpy.mockRestore();
+    it('should update all 9 skill files when tool is configured', async () => {
+      // Set up a configured tool with all skill directories
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      const skillNames = [
+        'openspec-explore',
+        'openspec-new-change',
+        'openspec-continue-change',
+        'openspec-apply-change',
+        'openspec-ff-change',
+        'openspec-sync-specs',
+        'openspec-archive-change',
+        'openspec-bulk-archive-change',
+        'openspec-verify-change',
+      ];
+
+      // Create at least one skill to mark tool as configured
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        'old content'
+      );
+
+      await updateCommand.execute(testDir);
+
+      // Verify all skill files were created/updated
+      for (const skillName of skillNames) {
+        const skillFile = path.join(skillsDir, skillName, 'SKILL.md');
+        const exists = await FileSystemUtils.fileExists(skillFile);
+        expect(exists).toBe(true);
+
+        const content = await fs.readFile(skillFile, 'utf-8');
+        expect(content).toContain('---');
+        expect(content).toContain('name:');
+        expect(content).toContain('description:');
+      }
+    });
   });
 
-  it('should refresh existing Claude slash command files', async () => {
-    const proposalPath = path.join(
-      testDir,
-      '.claude/commands/openspec/proposal.md'
-    );
-    await fs.mkdir(path.dirname(proposalPath), { recursive: true });
-    const initialContent = `---
-name: OpenSpec - Proposal
-description: Old description
-category: OpenSpec
-tags: [openspec, change]
----
-<!-- OPENSPEC:START -->
-Old slash content
-<!-- OPENSPEC:END -->`;
-    await fs.writeFile(proposalPath, initialContent);
-
-    const consoleSpy = vi.spyOn(console, 'log');
-
-    await updateCommand.execute(testDir);
-
-    const updated = await fs.readFile(proposalPath, 'utf-8');
-    expect(updated).toContain('name: OpenSpec - Proposal');
-    expect(updated).toContain('**Guardrails**');
-    expect(updated).toContain(
-      'Validate with `openspec validate <id> --strict --no-interactive`'
-    );
-    expect(updated).not.toContain('Old slash content');
-
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated OpenSpec instructions (openspec/AGENTS.md'
-    );
-    expect(logMessage).toContain('AGENTS.md (created)');
-    expect(logMessage).toContain(
-      'Updated slash commands: .claude/commands/openspec/proposal.md'
-    );
-
-    consoleSpy.mockRestore();
-  });
+  describe('command updates', () => {
+    it('should update opsx commands for configured Claude tool', async () => {
+      // Set up a configured Claude tool
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        'old content'
+      );
+
+      await updateCommand.execute(testDir);
+
+      // Check opsx command files were created
+      const commandsDir = path.join(testDir, '.claude', 'commands', 'opsx');
+      const exploreCmd = path.join(commandsDir, 'explore.md');
+      const exists = await FileSystemUtils.fileExists(exploreCmd);
+      expect(exists).toBe(true);
+
+      const content = await fs.readFile(exploreCmd, 'utf-8');
+      expect(content).toContain('---');
+      expect(content).toContain('name:');
+      expect(content).toContain('description:');
+      expect(content).toContain('category:');
+      expect(content).toContain('tags:');
+    });
 
-  it('should refresh existing Qwen slash command files', async () => {
-    const applyPath = path.join(
-      testDir,
-      '.qwen/commands/openspec-apply.toml'
-    );
-    await fs.mkdir(path.dirname(applyPath), { recursive: true });
-    const initialContent = `description = "Implement an approved OpenSpec change and keep tasks in sync."
-
-prompt = """
-<!-- OPENSPEC:START -->
-Old body
-<!-- OPENSPEC:END -->
-"""
-`;
-    await fs.writeFile(applyPath, initialContent);
+    it('should update all 9 opsx commands when tool is configured', async () => {
+      // Set up a configured tool
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        'old content'
+      );
+
+      await updateCommand.execute(testDir);
+
+      const commandIds = [
+        'explore',
+        'new',
+        'continue',
+        'apply',
+        'ff',
+        'sync',
+        'archive',
+        'bulk-archive',
+        'verify',
+      ];
+
+      const commandsDir = path.join(testDir, '.claude', 'commands', 'opsx');
+      for (const cmdId of commandIds) {
+        const cmdFile = path.join(commandsDir, `${cmdId}.md`);
+        const exists = await FileSystemUtils.fileExists(cmdFile);
+        expect(exists).toBe(true);
+      }
+    });
+  });
 
-    const consoleSpy = vi.spyOn(console, 'log');
+  describe('multi-tool support', () => {
+    it('should update multiple configured tools', async () => {
+      // Set up Claude
+      const claudeSkillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(claudeSkillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(claudeSkillsDir, 'openspec-explore', 'SKILL.md'),
+        'old'
+      );
+
+      // Set up Cursor
+      const cursorSkillsDir = path.join(testDir, '.cursor', 'skills');
+      await fs.mkdir(path.join(cursorSkillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(cursorSkillsDir, 'openspec-explore', 'SKILL.md'),
+        'old'
+      );
+
+      const consoleSpy = vi.spyOn(console, 'log');
+
+      await updateCommand.execute(testDir);
+
+      // Both tools should be updated
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Updating 2 tool(s)')
+      );
+
+      // Verify Claude skills updated
+      const claudeSkill = await fs.readFile(
+        path.join(claudeSkillsDir, 'openspec-explore', 'SKILL.md'),
+        'utf-8'
+      );
+      expect(claudeSkill).toContain('name: openspec-explore');
+
+      // Verify Cursor skills updated
+      const cursorSkill = await fs.readFile(
+        path.join(cursorSkillsDir, 'openspec-explore', 'SKILL.md'),
+        'utf-8'
+      );
+      expect(cursorSkill).toContain('name: openspec-explore');
+
+      consoleSpy.mockRestore();
+    });
 
-    await updateCommand.execute(testDir);
+    it('should update Qwen tool with correct command format', async () => {
+      // Set up Qwen
+      const qwenSkillsDir = path.join(testDir, '.qwen', 'skills');
+      await fs.mkdir(path.join(qwenSkillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(qwenSkillsDir, 'openspec-explore', 'SKILL.md'),
+        'old'
+      );
+
+      await updateCommand.execute(testDir);
+
+      // Check Qwen command format (TOML) - Qwen uses flat path structure: opsx-<id>.toml
+      const qwenCmd = path.join(
+        testDir,
+        '.qwen',
+        'commands',
+        'opsx-explore.toml'
+      );
+      const exists = await FileSystemUtils.fileExists(qwenCmd);
+      expect(exists).toBe(true);
+
+      const content = await fs.readFile(qwenCmd, 'utf-8');
+      expect(content).toContain('description =');
+      expect(content).toContain('prompt =');
+    });
 
-    const updated = await fs.readFile(applyPath, 'utf-8');
-    expect(updated).toContain('description = "Implement an approved OpenSpec change and keep tasks in sync."');
-    expect(updated).toContain('prompt = """');
-    expect(updated).toContain('<!-- OPENSPEC:START -->');
-    expect(updated).toContain('Work through tasks sequentially');
-    expect(updated).not.toContain('Old body');
+    it('should update Windsurf tool with correct command format', async () => {
+      // Set up Windsurf
+      const windsurfSkillsDir = path.join(testDir, '.windsurf', 'skills');
+      await fs.mkdir(path.join(windsurfSkillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(windsurfSkillsDir, 'openspec-explore', 'SKILL.md'),
+        'old'
+      );
+
+      await updateCommand.execute(testDir);
+
+      // Check Windsurf command format
+      const windsurfCmd = path.join(
+        testDir,
+        '.windsurf',
+        'commands',
+        'opsx',
+        'explore.md'
+      );
+      const exists = await FileSystemUtils.fileExists(windsurfCmd);
+      expect(exists).toBe(true);
+
+      const content = await fs.readFile(windsurfCmd, 'utf-8');
+      expect(content).toContain('---');
+      expect(content).toContain('name:');
+    });
+  });
 
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated OpenSpec instructions (openspec/AGENTS.md'
-    );
-    expect(logMessage).toContain('AGENTS.md (created)');
-    expect(logMessage).toContain(
-      'Updated slash commands: .qwen/commands/openspec-apply.toml'
-    );
+  describe('error handling', () => {
+    it('should handle tool update failures gracefully', async () => {
+      // Set up a configured tool
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        'old'
+      );
+
+      // Mock writeFile to fail for skills
+      const originalWriteFile = FileSystemUtils.writeFile.bind(FileSystemUtils);
+      const writeSpy = vi
+        .spyOn(FileSystemUtils, 'writeFile')
+        .mockImplementation(async (filePath, content) => {
+          if (filePath.includes('SKILL.md')) {
+            throw new Error('EACCES: permission denied');
+          }
+          return originalWriteFile(filePath, content);
+        });
+
+      const consoleSpy = vi.spyOn(console, 'log');
+
+      // Should not throw
+      await updateCommand.execute(testDir);
+
+      // Should report failure
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Failed')
+      );
+
+      writeSpy.mockRestore();
+      consoleSpy.mockRestore();
+    });
 
-    consoleSpy.mockRestore();
+    it('should continue updating other tools when one fails', async () => {
+      // Set up Claude and Cursor
+      const claudeSkillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(claudeSkillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(claudeSkillsDir, 'openspec-explore', 'SKILL.md'),
+        'old'
+      );
+
+      const cursorSkillsDir = path.join(testDir, '.cursor', 'skills');
+      await fs.mkdir(path.join(cursorSkillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(cursorSkillsDir, 'openspec-explore', 'SKILL.md'),
+        'old'
+      );
+
+      // Mock writeFile to fail only for Claude
+      const originalWriteFile = FileSystemUtils.writeFile.bind(FileSystemUtils);
+      const writeSpy = vi
+        .spyOn(FileSystemUtils, 'writeFile')
+        .mockImplementation(async (filePath, content) => {
+          if (filePath.includes('.claude') && filePath.includes('SKILL.md')) {
+            throw new Error('EACCES: permission denied');
+          }
+          return originalWriteFile(filePath, content);
+        });
+
+      const consoleSpy = vi.spyOn(console, 'log');
+
+      await updateCommand.execute(testDir);
+
+      // Cursor should still be updated - check the actual format from ora spinner
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Updated: Cursor')
+      );
+
+      // Claude should be reported as failed
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Failed')
+      );
+
+      writeSpy.mockRestore();
+      consoleSpy.mockRestore();
+    });
   });
 
-  it('should not create missing Qwen slash command files on update', async () => {
-    const applyPath = path.join(
-      testDir,
-      '.qwen/commands/openspec-apply.toml'
-    );
-
-    await fs.mkdir(path.dirname(applyPath), { recursive: true });
-    await fs.writeFile(
-      applyPath,
-      `description = "Old description"
-
-prompt = """
-<!-- OPENSPEC:START -->
-Old content
-<!-- OPENSPEC:END -->
-"""
-`
-    );
+  describe('tool detection', () => {
+    it('should detect tool as configured only when skill file exists', async () => {
+      // Create skills directory but no skill files
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(skillsDir, { recursive: true });
 
-    await updateCommand.execute(testDir);
+      const consoleSpy = vi.spyOn(console, 'log');
 
-    const updatedApply = await fs.readFile(applyPath, 'utf-8');
-    expect(updatedApply).toContain('Work through tasks sequentially');
-    expect(updatedApply).not.toContain('Old content');
+      await updateCommand.execute(testDir);
 
-    const proposalPath = path.join(
-      testDir,
-      '.qwen/commands/openspec-proposal.toml'
-    );
-    const archivePath = path.join(
-      testDir,
-      '.qwen/commands/openspec-archive.toml'
-    );
+      // Should report no configured tools
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('No configured tools found')
+      );
 
-    await expect(FileSystemUtils.fileExists(proposalPath)).resolves.toBe(false);
-    await expect(FileSystemUtils.fileExists(archivePath)).resolves.toBe(false);
-  });
+      consoleSpy.mockRestore();
+    });
 
-  it('should not create CLAUDE.md if it does not exist', async () => {
-    // Ensure CLAUDE.md does not exist
-    const claudePath = path.join(testDir, 'CLAUDE.md');
+    it('should detect tool when any single skill exists', async () => {
+      // Create only one skill file
+      const skillDir = path.join(
+        testDir,
+        '.claude',
+        'skills',
+        'openspec-archive-change'
+      );
+      await fs.mkdir(skillDir, { recursive: true });
+      await fs.writeFile(path.join(skillDir, 'SKILL.md'), 'old');
 
-    // Execute update command
-    await updateCommand.execute(testDir);
+      const consoleSpy = vi.spyOn(console, 'log');
 
-    // Check that CLAUDE.md was not created
-    const fileExists = await FileSystemUtils.fileExists(claudePath);
-    expect(fileExists).toBe(false);
-  });
+      await updateCommand.execute(testDir);
 
-  it('should not create QWEN.md if it does not exist', async () => {
-    const qwenPath = path.join(testDir, 'QWEN.md');
-    await updateCommand.execute(testDir);
-    await expect(FileSystemUtils.fileExists(qwenPath)).resolves.toBe(false);
-  });
+      // Should detect and update Claude
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Updating 1 tool(s): claude')
+      );
 
-  it('should update only existing CLINE.md file', async () => {
-    // Create CLINE.md file with initial content
-    const clinePath = path.join(testDir, 'CLINE.md');
-    const initialContent = `# Cline Rules
-
-Some existing Cline rules here.
-
-<!-- OPENSPEC:START -->
-Old OpenSpec content
-<!-- OPENSPEC:END -->
-
-More rules after.`;
-    await fs.writeFile(clinePath, initialContent);
-
-    const consoleSpy = vi.spyOn(console, 'log');
-
-    // Execute update command
-    await updateCommand.execute(testDir);
-
-    // Check that CLINE.md was updated
-    const updatedContent = await fs.readFile(clinePath, 'utf-8');
-    expect(updatedContent).toContain('<!-- OPENSPEC:START -->');
-    expect(updatedContent).toContain('<!-- OPENSPEC:END -->');
-    expect(updatedContent).toContain("@/openspec/AGENTS.md");
-    expect(updatedContent).toContain('openspec update');
-    expect(updatedContent).toContain('Some existing Cline rules here');
-    expect(updatedContent).toContain('More rules after');
-
-    // Check console output
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated OpenSpec instructions (openspec/AGENTS.md'
-    );
-    expect(logMessage).toContain('AGENTS.md (created)');
-    expect(logMessage).toContain('Updated AI tool files: CLINE.md');
-    consoleSpy.mockRestore();
+      consoleSpy.mockRestore();
+    });
   });
 
-  it('should not create CLINE.md if it does not exist', async () => {
-    // Ensure CLINE.md does not exist
-    const clinePath = path.join(testDir, 'CLINE.md');
+  describe('skill content validation', () => {
+    it('should generate valid YAML frontmatter in skill files', async () => {
+      // Set up a configured tool
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        'old'
+      );
+
+      await updateCommand.execute(testDir);
+
+      const skillContent = await fs.readFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        'utf-8'
+      );
+
+      // Validate frontmatter structure
+      expect(skillContent).toMatch(/^---\n/);
+      expect(skillContent).toContain('name:');
+      expect(skillContent).toContain('description:');
+      expect(skillContent).toContain('license:');
+      expect(skillContent).toContain('compatibility:');
+      expect(skillContent).toContain('metadata:');
+      expect(skillContent).toContain('author:');
+      expect(skillContent).toContain('version:');
+      expect(skillContent).toMatch(/---\n\n/);
+    });
+
+    it('should include proper instructions in skill files', async () => {
+      // Set up a configured tool
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-apply-change'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-apply-change', 'SKILL.md'),
+        'old'
+      );
 
-    // Execute update command
-    await updateCommand.execute(testDir);
+      await updateCommand.execute(testDir);
 
-    // Check that CLINE.md was not created
-    const fileExists = await FileSystemUtils.fileExists(clinePath);
-    expect(fileExists).toBe(false);
-  });
+      const skillContent = await fs.readFile(
+        path.join(skillsDir, 'openspec-apply-change', 'SKILL.md'),
+        'utf-8'
+      );
 
-  it('should refresh existing Cline workflow files', async () => {
-    const proposalPath = path.join(
-      testDir,
-      '.clinerules/workflows/openspec-proposal.md'
-    );
-    await fs.mkdir(path.dirname(proposalPath), { recursive: true });
-    const initialContent = `# OpenSpec: Proposal
-
-Scaffold a new OpenSpec change and validate strictly.
-
-<!-- OPENSPEC:START -->
-Old slash content
-<!-- OPENSPEC:END -->`;
-    await fs.writeFile(proposalPath, initialContent);
-
-    const consoleSpy = vi.spyOn(console, 'log');
-
-    await updateCommand.execute(testDir);
-
-    const updated = await fs.readFile(proposalPath, 'utf-8');
-    expect(updated).toContain('# OpenSpec: Proposal');
-    expect(updated).toContain('**Guardrails**');
-    expect(updated).toContain(
-      'Validate with `openspec validate <id> --strict --no-interactive`'
-    );
-    expect(updated).not.toContain('Old slash content');
-
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated OpenSpec instructions (openspec/AGENTS.md'
-    );
-    expect(logMessage).toContain('AGENTS.md (created)');
-    expect(logMessage).toContain(
-      'Updated slash commands: .clinerules/workflows/openspec-proposal.md'
-    );
-
-    consoleSpy.mockRestore();
+      // Apply skill should contain implementation instructions
+      expect(skillContent.toLowerCase()).toContain('task');
+    });
   });
 
-  it('should refresh existing Cursor slash command files', async () => {
-    const cursorPath = path.join(testDir, '.cursor/commands/openspec-apply.md');
-    await fs.mkdir(path.dirname(cursorPath), { recursive: true });
-    const initialContent = `---
-name: /openspec-apply
-id: openspec-apply
-category: OpenSpec
-description: Old description
----
-<!-- OPENSPEC:START -->
-Old body
-<!-- OPENSPEC:END -->`;
-    await fs.writeFile(cursorPath, initialContent);
-
-    const consoleSpy = vi.spyOn(console, 'log');
-
-    await updateCommand.execute(testDir);
-
-    const updated = await fs.readFile(cursorPath, 'utf-8');
-    expect(updated).toContain('id: openspec-apply');
-    expect(updated).toContain('Work through tasks sequentially');
-    expect(updated).not.toContain('Old body');
-
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated OpenSpec instructions (openspec/AGENTS.md'
-    );
-    expect(logMessage).toContain('AGENTS.md (created)');
-    expect(logMessage).toContain(
-      'Updated slash commands: .cursor/commands/openspec-apply.md'
-    );
-
-    consoleSpy.mockRestore();
-  });
+  describe('success output', () => {
+    it('should display success message with tool name', async () => {
+      // Set up a configured tool
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        'old'
+      );
 
-  it('should refresh existing Continue prompt files', async () => {
-    const continuePath = path.join(
-      testDir,
-      '.continue/prompts/openspec-apply.prompt'
-    );
-    await fs.mkdir(path.dirname(continuePath), { recursive: true });
-    const initialContent = `---
-name: openspec-apply
-description: Old description
-invokable: true
----
-<!-- OPENSPEC:START -->
-Old body
-<!-- OPENSPEC:END -->`;
-    await fs.writeFile(continuePath, initialContent);
-
-    const consoleSpy = vi.spyOn(console, 'log');
-
-    await updateCommand.execute(testDir);
-
-    const updated = await fs.readFile(continuePath, 'utf-8');
-    expect(updated).toContain('name: openspec-apply');
-    expect(updated).toContain('invokable: true');
-    expect(updated).toContain('Work through tasks sequentially');
-    expect(updated).not.toContain('Old body');
-
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated OpenSpec instructions (openspec/AGENTS.md'
-    );
-    expect(logMessage).toContain('AGENTS.md (created)');
-    expect(logMessage).toContain(
-      'Updated slash commands: .continue/prompts/openspec-apply.prompt'
-    );
-
-    consoleSpy.mockRestore();
-  });
+      const consoleSpy = vi.spyOn(console, 'log');
 
-  it('should not create missing Continue prompt files on update', async () => {
-    const continueApply = path.join(
-      testDir,
-      '.continue/prompts/openspec-apply.prompt'
-    );
-
-    // Only create apply; leave proposal and archive missing
-    await fs.mkdir(path.dirname(continueApply), { recursive: true });
-    await fs.writeFile(
-      continueApply,
-      `---
-name: openspec-apply
-description: Old description
-invokable: true
----
-<!-- OPENSPEC:START -->
-Old body
-<!-- OPENSPEC:END -->`
-    );
-
-    await updateCommand.execute(testDir);
-
-    const continueProposal = path.join(
-      testDir,
-      '.continue/prompts/openspec-proposal.prompt'
-    );
-    const continueArchive = path.join(
-      testDir,
-      '.continue/prompts/openspec-archive.prompt'
-    );
-
-    // Confirm they weren't created by update
-    await expect(FileSystemUtils.fileExists(continueProposal)).resolves.toBe(false);
-    await expect(FileSystemUtils.fileExists(continueArchive)).resolves.toBe(false);
-  });
+      await updateCommand.execute(testDir);
 
-  it('should refresh existing OpenCode slash command files', async () => {
-    const openCodePath = path.join(
-      testDir,
-      '.opencode/command/openspec-apply.md'
-    );
-    await fs.mkdir(path.dirname(openCodePath), { recursive: true });
-    const initialContent = `---
-name: /openspec-apply
-id: openspec-apply
-category: OpenSpec
-description: Old description
----
-<!-- OPENSPEC:START -->
-Old body
-<!-- OPENSPEC:END -->`;
-    await fs.writeFile(openCodePath, initialContent);
-
-    const consoleSpy = vi.spyOn(console, 'log');
-
-    await updateCommand.execute(testDir);
-
-    const updated = await fs.readFile(openCodePath, 'utf-8');
-    expect(updated).toContain('id: openspec-apply');
-    expect(updated).toContain('Work through tasks sequentially');
-    expect(updated).not.toContain('Old body');
-
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated OpenSpec instructions (openspec/AGENTS.md'
-    );
-    expect(logMessage).toContain('AGENTS.md (created)');
-    expect(logMessage).toContain(
-      'Updated slash commands: .opencode/command/openspec-apply.md'
-    );
-
-    consoleSpy.mockRestore();
-  });
+      // The success output uses "âœ“ Updated: <name>"
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Updated: Claude Code')
+      );
 
-  it('should refresh existing Kilo Code workflows', async () => {
-    const kilocodePath = path.join(
-      testDir,
-      '.kilocode/workflows/openspec-apply.md'
-    );
-    await fs.mkdir(path.dirname(kilocodePath), { recursive: true });
-    const initialContent = `<!-- OPENSPEC:START -->
-Old body
-<!-- OPENSPEC:END -->`;
-    await fs.writeFile(kilocodePath, initialContent);
+      consoleSpy.mockRestore();
+    });
 
-    const consoleSpy = vi.spyOn(console, 'log');
+    it('should suggest IDE restart after update', async () => {
+      // Set up a configured tool
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        'old'
+      );
 
-    await updateCommand.execute(testDir);
+      const consoleSpy = vi.spyOn(console, 'log');
 
-    const updated = await fs.readFile(kilocodePath, 'utf-8');
-    expect(updated).toContain('Work through tasks sequentially');
-    expect(updated).not.toContain('Old body');
-    expect(updated.startsWith('<!-- OPENSPEC:START -->')).toBe(true);
+      await updateCommand.execute(testDir);
 
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated slash commands: .kilocode/workflows/openspec-apply.md'
-    );
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Restart your IDE')
+      );
 
-    consoleSpy.mockRestore();
+      consoleSpy.mockRestore();
+    });
   });
 
-  it('should refresh existing Windsurf workflows', async () => {
-    const wsPath = path.join(
-      testDir,
-      '.windsurf/workflows/openspec-apply.md'
-    );
-    await fs.mkdir(path.dirname(wsPath), { recursive: true });
-    const initialContent = `## OpenSpec: Apply (Windsurf)
-Intro
-<!-- OPENSPEC:START -->
-Old body
-<!-- OPENSPEC:END -->`;
-    await fs.writeFile(wsPath, initialContent);
-
-    const consoleSpy = vi.spyOn(console, 'log');
-
-    await updateCommand.execute(testDir);
-
-    const updated = await fs.readFile(wsPath, 'utf-8');
-    expect(updated).toContain('Work through tasks sequentially');
-    expect(updated).not.toContain('Old body');
-    expect(updated).toContain('## OpenSpec: Apply (Windsurf)');
-
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated slash commands: .windsurf/workflows/openspec-apply.md'
-    );
-    consoleSpy.mockRestore();
-  });
+  describe('smart update detection', () => {
+    it('should show "up to date" message when skills have current version', async () => {
+      // Set up a configured tool with current version
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
 
-  it('should refresh existing Antigravity workflows', async () => {
-    const agPath = path.join(
-      testDir,
-      '.agent/workflows/openspec-apply.md'
-    );
-    await fs.mkdir(path.dirname(agPath), { recursive: true });
-    const initialContent = `---
-description: Implement an approved OpenSpec change and keep tasks in sync.
+      // Use the current package version in generatedBy
+      const { version } = await import('../../package.json');
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        `---
+name: openspec-explore
+metadata:
+  author: openspec
+  version: "1.0"
+  generatedBy: "${version}"
 ---
 
-<!-- OPENSPEC:START -->
-Old body
-<!-- OPENSPEC:END -->`;
-    await fs.writeFile(agPath, initialContent);
-
-    const consoleSpy = vi.spyOn(console, 'log');
-
-    await updateCommand.execute(testDir);
+Content here
+`
+      );
 
-    const updated = await fs.readFile(agPath, 'utf-8');
-    expect(updated).toContain('Work through tasks sequentially');
-    expect(updated).not.toContain('Old body');
-    expect(updated).toContain('description: Implement an approved OpenSpec change and keep tasks in sync.');
-    expect(updated).not.toContain('auto_execution_mode: 3');
+      const consoleSpy = vi.spyOn(console, 'log');
 
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated slash commands: .agent/workflows/openspec-apply.md'
-    );
-    consoleSpy.mockRestore();
-  });
+      await updateCommand.execute(testDir);
 
-  it('should refresh existing Codex prompts', async () => {
-    const codexPath = path.join(
-      testDir,
-      '.codex/prompts/openspec-apply.md'
-    );
-    await fs.mkdir(path.dirname(codexPath), { recursive: true });
-    const initialContent = `---\ndescription: Old description\nargument-hint: old-hint\n---\n\n$ARGUMENTS\n<!-- OPENSPEC:START -->\nOld body\n<!-- OPENSPEC:END -->`;
-    await fs.writeFile(codexPath, initialContent);
-
-    const consoleSpy = vi.spyOn(console, 'log');
-
-    await updateCommand.execute(testDir);
-
-    const updated = await fs.readFile(codexPath, 'utf-8');
-    expect(updated).toContain('description: Implement an approved OpenSpec change and keep tasks in sync.');
-    expect(updated).toContain('argument-hint: change-id');
-    expect(updated).toContain('$ARGUMENTS');
-    expect(updated).toContain('Work through tasks sequentially');
-    expect(updated).not.toContain('Old body');
-    expect(updated).not.toContain('Old description');
-
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated slash commands: .codex/prompts/openspec-apply.md'
-    );
-
-    consoleSpy.mockRestore();
-  });
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('up to date')
+      );
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('--force')
+      );
 
-  it('should not create missing Codex prompts on update', async () => {
-    const codexApply = path.join(
-      testDir,
-      '.codex/prompts/openspec-apply.md'
-    );
-
-    // Only create apply; leave proposal and archive missing
-    await fs.mkdir(path.dirname(codexApply), { recursive: true });
-    await fs.writeFile(
-      codexApply,
-      '---\ndescription: Old\nargument-hint: old\n---\n\n$ARGUMENTS\n<!-- OPENSPEC:START -->\nOld\n<!-- OPENSPEC:END -->'
-    );
-
-    await updateCommand.execute(testDir);
-
-    const codexProposal = path.join(
-      testDir,
-      '.codex/prompts/openspec-proposal.md'
-    );
-    const codexArchive = path.join(
-      testDir,
-      '.codex/prompts/openspec-archive.md'
-    );
-
-    // Confirm they weren't created by update
-    await expect(FileSystemUtils.fileExists(codexProposal)).resolves.toBe(false);
-    await expect(FileSystemUtils.fileExists(codexArchive)).resolves.toBe(false);
-  });
+      consoleSpy.mockRestore();
+    });
 
-  it('should refresh existing GitHub Copilot prompts', async () => {
-    const ghPath = path.join(
-      testDir,
-      '.github/prompts/openspec-apply.prompt.md'
-    );
-    await fs.mkdir(path.dirname(ghPath), { recursive: true });
-    const initialContent = `---
-description: Implement an approved OpenSpec change and keep tasks in sync.
+    it('should detect update needed when generatedBy is missing', async () => {
+      // Set up a configured tool without generatedBy
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        `---
+name: openspec-explore
+metadata:
+  author: openspec
+  version: "1.0"
 ---
 
-$ARGUMENTS
-<!-- OPENSPEC:START -->
-Old body
-<!-- OPENSPEC:END -->`;
-    await fs.writeFile(ghPath, initialContent);
+Legacy content without generatedBy
+`
+      );
 
-    const consoleSpy = vi.spyOn(console, 'log');
+      const consoleSpy = vi.spyOn(console, 'log');
 
-    await updateCommand.execute(testDir);
+      await updateCommand.execute(testDir);
 
-    const updated = await fs.readFile(ghPath, 'utf-8');
-    expect(updated).toContain('description: Implement an approved OpenSpec change and keep tasks in sync.');
-    expect(updated).toContain('$ARGUMENTS');
-    expect(updated).toContain('Work through tasks sequentially');
-    expect(updated).not.toContain('Old body');
+      // Should show "unknown â†’ version" in the update message
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('unknown')
+      );
 
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated slash commands: .github/prompts/openspec-apply.prompt.md'
-    );
+      consoleSpy.mockRestore();
+    });
 
-    consoleSpy.mockRestore();
-  });
+    it('should detect update needed when version differs', async () => {
+      // Set up a configured tool with old version
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        `---
+name: openspec-explore
+metadata:
+  generatedBy: "0.1.0"
+---
 
-  it('should not create missing GitHub Copilot prompts on update', async () => {
-    const ghApply = path.join(
-      testDir,
-      '.github/prompts/openspec-apply.prompt.md'
-    );
-
-    // Only create apply; leave proposal and archive missing
-    await fs.mkdir(path.dirname(ghApply), { recursive: true });
-    await fs.writeFile(
-      ghApply,
-      '---\ndescription: Old\n---\n\n$ARGUMENTS\n<!-- OPENSPEC:START -->\nOld\n<!-- OPENSPEC:END -->'
-    );
-
-    await updateCommand.execute(testDir);
-
-    const ghProposal = path.join(
-      testDir,
-      '.github/prompts/openspec-proposal.prompt.md'
-    );
-    const ghArchive = path.join(
-      testDir,
-      '.github/prompts/openspec-archive.prompt.md'
-    );
-
-    // Confirm they weren't created by update
-    await expect(FileSystemUtils.fileExists(ghProposal)).resolves.toBe(false);
-    await expect(FileSystemUtils.fileExists(ghArchive)).resolves.toBe(false);
-  });
+Old version content
+`
+      );
 
-  it('should refresh existing Gemini CLI TOML files without creating new ones', async () => {
-    const geminiProposal = path.join(
-      testDir,
-      '.gemini/commands/openspec/proposal.toml'
-    );
-    await fs.mkdir(path.dirname(geminiProposal), { recursive: true });
-    const initialContent = `description = "Scaffold a new OpenSpec change and validate strictly."
-
-prompt = """
-<!-- OPENSPEC:START -->
-Old Gemini body
-<!-- OPENSPEC:END -->
-"""
-`;
-    await fs.writeFile(geminiProposal, initialContent);
-
-    const consoleSpy = vi.spyOn(console, 'log');
-
-    await updateCommand.execute(testDir);
-
-    const updated = await fs.readFile(geminiProposal, 'utf-8');
-    expect(updated).toContain('description = "Scaffold a new OpenSpec change and validate strictly."');
-    expect(updated).toContain('prompt = """');
-    expect(updated).toContain('<!-- OPENSPEC:START -->');
-    expect(updated).toContain('**Guardrails**');
-    expect(updated).toContain('<!-- OPENSPEC:END -->');
-    expect(updated).not.toContain('Old Gemini body');
-
-    const geminiApply = path.join(
-      testDir,
-      '.gemini/commands/openspec/apply.toml'
-    );
-    const geminiArchive = path.join(
-      testDir,
-      '.gemini/commands/openspec/archive.toml'
-    );
-
-    await expect(FileSystemUtils.fileExists(geminiApply)).resolves.toBe(false);
-    await expect(FileSystemUtils.fileExists(geminiArchive)).resolves.toBe(false);
-
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated slash commands: .gemini/commands/openspec/proposal.toml'
-    );
-
-    consoleSpy.mockRestore();
-  });
-  
-  it('should refresh existing IFLOW slash commands', async () => {
-    const iflowProposal = path.join(
-      testDir,
-      '.iflow/commands/openspec-proposal.md'
-    );
-    await fs.mkdir(path.dirname(iflowProposal), { recursive: true });
-    const initialContent = `description: Scaffold a new OpenSpec change and validate strictly."
-
-prompt = """
-<!-- OPENSPEC:START -->
-Old IFlow body
-<!-- OPENSPEC:END -->
-"""
-`;
-    await fs.writeFile(iflowProposal, initialContent);
+      const consoleSpy = vi.spyOn(console, 'log');
 
-    const consoleSpy = vi.spyOn(console, 'log');
+      await updateCommand.execute(testDir);
 
-    await updateCommand.execute(testDir);
+      // Should show version transition
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('0.1.0')
+      );
 
-    const updated = await fs.readFile(iflowProposal, 'utf-8');
-    expect(updated).toContain('description: Scaffold a new OpenSpec change and validate strictly.');
-    expect(updated).toContain('<!-- OPENSPEC:START -->');
-    expect(updated).toContain('**Guardrails**');
-    expect(updated).toContain('<!-- OPENSPEC:END -->');
-    expect(updated).not.toContain('Old IFlow body');
+      consoleSpy.mockRestore();
+    });
 
-    const iflowApply = path.join(
-      testDir,
-      '.iflow/commands/openspec-apply.md'
-    );
-    const iflowArchive = path.join(
-      testDir,
-      '.iflow/commands/openspec-archive.md'
-    );
+    it('should embed generatedBy in updated skill files', async () => {
+      // Set up a configured tool without generatedBy
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        'old content without version'
+      );
 
-    await expect(FileSystemUtils.fileExists(iflowApply)).resolves.toBe(false);
-    await expect(FileSystemUtils.fileExists(iflowArchive)).resolves.toBe(false);
+      await updateCommand.execute(testDir);
 
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated slash commands: .iflow/commands/openspec-proposal.md'
-    );
+      const updatedContent = await fs.readFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        'utf-8'
+      );
 
-    consoleSpy.mockRestore();
+      // Should contain generatedBy field
+      expect(updatedContent).toMatch(/generatedBy:\s*["']\d+\.\d+\.\d+["']/);
+    });
   });
 
-  it('should refresh existing Factory slash commands', async () => {
-    const factoryPath = path.join(
-      testDir,
-      '.factory/commands/openspec-proposal.md'
-    );
-    await fs.mkdir(path.dirname(factoryPath), { recursive: true });
-    const initialContent = `---
-description: Scaffold a new OpenSpec change and validate strictly.
-argument-hint: request or feature description
+  describe('--force flag', () => {
+    it('should update when force is true even if up to date', async () => {
+      // Set up a configured tool with current version
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+
+      const { version } = await import('../../package.json');
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        `---
+metadata:
+  generatedBy: "${version}"
 ---
+Content
+`
+      );
 
-<!-- OPENSPEC:START -->
-Old body
-<!-- OPENSPEC:END -->`;
-    await fs.writeFile(factoryPath, initialContent);
+      const consoleSpy = vi.spyOn(console, 'log');
 
-    const consoleSpy = vi.spyOn(console, 'log');
+      // Create update command with force option
+      const forceUpdateCommand = new UpdateCommand({ force: true });
+      await forceUpdateCommand.execute(testDir);
 
-    await updateCommand.execute(testDir);
+      // Should show "Force updating" message
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Force updating')
+      );
 
-    const updated = await fs.readFile(factoryPath, 'utf-8');
-    expect(updated).toContain('description: Scaffold a new OpenSpec change and validate strictly.');
-    expect(updated).toContain('argument-hint: request or feature description');
-    expect(
-      /<!-- OPENSPEC:START -->([\s\S]*?)<!-- OPENSPEC:END -->/u.exec(updated)?.[1]
-    ).toContain('$ARGUMENTS');
-    expect(updated).toContain('**Guardrails**');
-    expect(updated).not.toContain('Old body');
+      // Should show updated message
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Updated: Claude Code')
+      );
 
-    expect(consoleSpy).toHaveBeenCalledWith(
-      expect.stringContaining('.factory/commands/openspec-proposal.md')
-    );
+      consoleSpy.mockRestore();
+    });
 
-    consoleSpy.mockRestore();
-  });
+    it('should not show --force hint when force is used', async () => {
+      // Set up a configured tool
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        'old content'
+      );
 
-  it('should not create missing Factory slash command files on update', async () => {
-    const factoryApply = path.join(
-      testDir,
-      '.factory/commands/openspec-apply.md'
-    );
-
-    await fs.mkdir(path.dirname(factoryApply), { recursive: true });
-    await fs.writeFile(
-      factoryApply,
-      `---
-description: Old
-argument-hint: old
----
+      const consoleSpy = vi.spyOn(console, 'log');
 
-<!-- OPENSPEC:START -->
-Old body
-<!-- OPENSPEC:END -->`
-    );
+      const forceUpdateCommand = new UpdateCommand({ force: true });
+      await forceUpdateCommand.execute(testDir);
 
-    await updateCommand.execute(testDir);
+      // Get all console.log calls as strings
+      const allCalls = consoleSpy.mock.calls.map(call =>
+        call.map(arg => String(arg)).join(' ')
+      );
 
-    const factoryProposal = path.join(
-      testDir,
-      '.factory/commands/openspec-proposal.md'
-    );
-    const factoryArchive = path.join(
-      testDir,
-      '.factory/commands/openspec-archive.md'
-    );
+      // Should not show "Use --force" since force was used
+      const hasForceHint = allCalls.some(call => call.includes('Use --force'));
+      expect(hasForceHint).toBe(false);
 
-    await expect(FileSystemUtils.fileExists(factoryProposal)).resolves.toBe(false);
-    await expect(FileSystemUtils.fileExists(factoryArchive)).resolves.toBe(false);
-  });
+      consoleSpy.mockRestore();
+    });
 
-  it('should refresh existing Amazon Q Developer prompts', async () => {
-    const aqPath = path.join(
-      testDir,
-      '.amazonq/prompts/openspec-apply.md'
-    );
-    await fs.mkdir(path.dirname(aqPath), { recursive: true });
-    const initialContent = `---
-description: Implement an approved OpenSpec change and keep tasks in sync.
+    it('should update all tools when force is used with mixed versions', async () => {
+      // Set up Claude with current version
+      const { version } = await import('../../package.json');
+      const claudeSkillDir = path.join(testDir, '.claude', 'skills', 'openspec-explore');
+      await fs.mkdir(claudeSkillDir, { recursive: true });
+      await fs.writeFile(
+        path.join(claudeSkillDir, 'SKILL.md'),
+        `---
+metadata:
+  generatedBy: "${version}"
 ---
+`
+      );
+
+      // Set up Cursor with old version
+      const cursorSkillDir = path.join(testDir, '.cursor', 'skills', 'openspec-explore');
+      await fs.mkdir(cursorSkillDir, { recursive: true });
+      await fs.writeFile(
+        path.join(cursorSkillDir, 'SKILL.md'),
+        `---
+metadata:
+  generatedBy: "0.1.0"
+---
+`
+      );
 
-The user wants to apply the following change. Use the openspec instructions to implement the approved change.
+      const consoleSpy = vi.spyOn(console, 'log');
 
-<ChangeId>
-  $ARGUMENTS
-</ChangeId>
-<!-- OPENSPEC:START -->
-Old body
-<!-- OPENSPEC:END -->`;
-    await fs.writeFile(aqPath, initialContent);
+      const forceUpdateCommand = new UpdateCommand({ force: true });
+      await forceUpdateCommand.execute(testDir);
 
-    const consoleSpy = vi.spyOn(console, 'log');
+      // Should show both tools being force updated
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Force updating 2 tool(s)')
+      );
 
-    await updateCommand.execute(testDir);
+      consoleSpy.mockRestore();
+    });
+  });
 
-    const updatedContent = await fs.readFile(aqPath, 'utf-8');
-    expect(updatedContent).toContain('**Guardrails**');
-    expect(updatedContent).toContain('<!-- OPENSPEC:START -->');
-    expect(updatedContent).toContain('<!-- OPENSPEC:END -->');
-    expect(updatedContent).not.toContain('Old body');
+  describe('version tracking', () => {
+    it('should show version in success message', async () => {
+      // Set up a configured tool
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        'old'
+      );
 
-    expect(consoleSpy).toHaveBeenCalledWith(
-      expect.stringContaining('.amazonq/prompts/openspec-apply.md')
-    );
+      const consoleSpy = vi.spyOn(console, 'log');
 
-    consoleSpy.mockRestore();
-  });
+      await updateCommand.execute(testDir);
 
-  it('should not create missing Amazon Q Developer prompts on update', async () => {
-    const aqApply = path.join(
-      testDir,
-      '.amazonq/prompts/openspec-apply.md'
-    );
-
-    // Only create apply; leave proposal and archive missing
-    await fs.mkdir(path.dirname(aqApply), { recursive: true });
-    await fs.writeFile(
-      aqApply,
-      '---\ndescription: Old\n---\n\nThe user wants to apply the following change.\n\n<ChangeId>\n  $ARGUMENTS\n</ChangeId>\n<!-- OPENSPEC:START -->\nOld\n<!-- OPENSPEC:END -->'
-    );
-
-    await updateCommand.execute(testDir);
-
-    const aqProposal = path.join(
-      testDir,
-      '.amazonq/prompts/openspec-proposal.md'
-    );
-    const aqArchive = path.join(
-      testDir,
-      '.amazonq/prompts/openspec-archive.md'
-    );
-
-    // Confirm they weren't created by update
-    await expect(FileSystemUtils.fileExists(aqProposal)).resolves.toBe(false);
-    await expect(FileSystemUtils.fileExists(aqArchive)).resolves.toBe(false);
-  });
+      // Should show version in success message
+      const { version } = await import('../../package.json');
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining(`(v${version})`)
+      );
 
-  it('should refresh existing Auggie slash command files', async () => {
-    const auggiePath = path.join(
-      testDir,
-      '.augment/commands/openspec-apply.md'
-    );
-    await fs.mkdir(path.dirname(auggiePath), { recursive: true });
-    const initialContent = `---
-description: Implement an approved OpenSpec change and keep tasks in sync.
-argument-hint: change-id
+      consoleSpy.mockRestore();
+    });
+
+    it('should only update tools that need updating', async () => {
+      // Set up Claude with old version (needs update)
+      const claudeSkillDir = path.join(testDir, '.claude', 'skills', 'openspec-explore');
+      await fs.mkdir(claudeSkillDir, { recursive: true });
+      await fs.writeFile(
+        path.join(claudeSkillDir, 'SKILL.md'),
+        `---
+metadata:
+  generatedBy: "0.1.0"
+---
+`
+      );
+
+      // Set up Cursor with current version (up to date)
+      const { version } = await import('../../package.json');
+      const cursorSkillDir = path.join(testDir, '.cursor', 'skills', 'openspec-explore');
+      await fs.mkdir(cursorSkillDir, { recursive: true });
+      await fs.writeFile(
+        path.join(cursorSkillDir, 'SKILL.md'),
+        `---
+metadata:
+  generatedBy: "${version}"
 ---
-<!-- OPENSPEC:START -->
-Old body
-<!-- OPENSPEC:END -->`;
-    await fs.writeFile(auggiePath, initialContent);
+`
+      );
 
-    const consoleSpy = vi.spyOn(console, 'log');
+      const consoleSpy = vi.spyOn(console, 'log');
 
-    await updateCommand.execute(testDir);
+      await updateCommand.execute(testDir);
 
-    const updatedContent = await fs.readFile(auggiePath, 'utf-8');
-    expect(updatedContent).toContain('**Guardrails**');
-    expect(updatedContent).toContain('<!-- OPENSPEC:START -->');
-    expect(updatedContent).toContain('<!-- OPENSPEC:END -->');
-    expect(updatedContent).not.toContain('Old body');
+      // Should show only Claude being updated
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Updating 1 tool(s)')
+      );
 
-    expect(consoleSpy).toHaveBeenCalledWith(
-      expect.stringContaining('.augment/commands/openspec-apply.md')
-    );
+      // Should mention Cursor is already up to date
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Already up to date: cursor')
+      );
 
-    consoleSpy.mockRestore();
+      consoleSpy.mockRestore();
+    });
   });
 
-  it('should not create missing Auggie slash command files on update', async () => {
-    const auggieApply = path.join(
-      testDir,
-      '.augment/commands/openspec-apply.md'
-    );
-
-    // Only create apply; leave proposal and archive missing
-    await fs.mkdir(path.dirname(auggieApply), { recursive: true });
-    await fs.writeFile(
-      auggieApply,
-      '---\ndescription: Old\nargument-hint: old\n---\n<!-- OPENSPEC:START -->\nOld\n<!-- OPENSPEC:END -->'
-    );
-
-    await updateCommand.execute(testDir);
-
-    const auggieProposal = path.join(
-      testDir,
-      '.augment/commands/openspec-proposal.md'
-    );
-    const auggieArchive = path.join(
-      testDir,
-      '.augment/commands/openspec-archive.md'
-    );
-
-    // Confirm they weren't created by update
-    await expect(FileSystemUtils.fileExists(auggieProposal)).resolves.toBe(false);
-    await expect(FileSystemUtils.fileExists(auggieArchive)).resolves.toBe(false);
-  });
+  describe('legacy cleanup', () => {
+    it('should detect and auto-cleanup legacy files with --force flag', async () => {
+      // Set up a configured tool
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        'old'
+      );
 
-  it('should refresh existing CodeBuddy slash command files', async () => {
-    const codeBuddyPath = path.join(
-      testDir,
-      '.codebuddy/commands/openspec/proposal.md'
-    );
-    await fs.mkdir(path.dirname(codeBuddyPath), { recursive: true });
-    const initialContent = `---
-name: OpenSpec - Proposal
-description: Old description
-category: OpenSpec
-tags: [openspec, change]
----
-<!-- OPENSPEC:START -->
-Old slash content
-<!-- OPENSPEC:END -->`;
-    await fs.writeFile(codeBuddyPath, initialContent);
-
-    const consoleSpy = vi.spyOn(console, 'log');
-
-    await updateCommand.execute(testDir);
-
-    const updated = await fs.readFile(codeBuddyPath, 'utf-8');
-    expect(updated).toContain('name: OpenSpec - Proposal');
-    expect(updated).toContain('**Guardrails**');
-    expect(updated).toContain(
-      'Validate with `openspec validate <id> --strict --no-interactive`'
-    );
-    expect(updated).not.toContain('Old slash content');
-
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated OpenSpec instructions (openspec/AGENTS.md'
-    );
-    expect(logMessage).toContain('AGENTS.md (created)');
-    expect(logMessage).toContain(
-      'Updated slash commands: .codebuddy/commands/openspec/proposal.md'
-    );
-
-    consoleSpy.mockRestore();
-  });
+      // Create legacy CLAUDE.md with OpenSpec markers
+      const legacyContent = `${OPENSPEC_MARKERS.start}
+# OpenSpec Instructions
 
-  it('should not create missing CodeBuddy slash command files on update', async () => {
-    const codeBuddyApply = path.join(
-      testDir,
-      '.codebuddy/commands/openspec/apply.md'
-    );
-
-    // Only create apply; leave proposal and archive missing
-    await fs.mkdir(path.dirname(codeBuddyApply), { recursive: true });
-    await fs.writeFile(
-      codeBuddyApply,
-      `---
-name: OpenSpec - Apply
-description: Old description
-category: OpenSpec
-tags: [openspec, apply]
----
-<!-- OPENSPEC:START -->
-Old body
-<!-- OPENSPEC:END -->`
-    );
-
-    await updateCommand.execute(testDir);
-
-    const codeBuddyProposal = path.join(
-      testDir,
-      '.codebuddy/commands/openspec/proposal.md'
-    );
-    const codeBuddyArchive = path.join(
-      testDir,
-      '.codebuddy/commands/openspec/archive.md'
-    );
-
-    // Confirm they weren't created by update
-    await expect(FileSystemUtils.fileExists(codeBuddyProposal)).resolves.toBe(false);
-    await expect(FileSystemUtils.fileExists(codeBuddyArchive)).resolves.toBe(false);
-  });
+These instructions are for AI assistants.
+${OPENSPEC_MARKERS.end}
+`;
+      await fs.writeFile(path.join(testDir, 'CLAUDE.md'), legacyContent);
 
-  it('should refresh existing Crush slash command files', async () => {
-    const crushPath = path.join(
-      testDir,
-      '.crush/commands/openspec/proposal.md'
-    );
-    await fs.mkdir(path.dirname(crushPath), { recursive: true });
-    const initialContent = `---
-name: OpenSpec - Proposal
-description: Old description
-category: OpenSpec
-tags: [openspec, change]
----
-<!-- OPENSPEC:START -->
-Old slash content
-<!-- OPENSPEC:END -->`;
-    await fs.writeFile(crushPath, initialContent);
-
-    const consoleSpy = vi.spyOn(console, 'log');
-
-    await updateCommand.execute(testDir);
-
-    const updated = await fs.readFile(crushPath, 'utf-8');
-    expect(updated).toContain('name: OpenSpec - Proposal');
-    expect(updated).toContain('**Guardrails**');
-    expect(updated).toContain(
-      'Validate with `openspec validate <id> --strict --no-interactive`'
-    );
-    expect(updated).not.toContain('Old slash content');
-
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated OpenSpec instructions (openspec/AGENTS.md'
-    );
-    expect(logMessage).toContain('AGENTS.md (created)');
-    expect(logMessage).toContain(
-      'Updated slash commands: .crush/commands/openspec/proposal.md'
-    );
-
-    consoleSpy.mockRestore();
-  });
+      const consoleSpy = vi.spyOn(console, 'log');
 
-  it('should not create missing Crush slash command files on update', async () => {
-    const crushApply = path.join(
-      testDir,
-      '.crush/commands/openspec-apply.md'
-    );
-
-    // Only create apply; leave proposal and archive missing
-    await fs.mkdir(path.dirname(crushApply), { recursive: true });
-    await fs.writeFile(
-      crushApply,
-      `---
-name: OpenSpec - Apply
-description: Old description
-category: OpenSpec
-tags: [openspec, apply]
----
-<!-- OPENSPEC:START -->
-Old body
-<!-- OPENSPEC:END -->`
-    );
-
-    await updateCommand.execute(testDir);
-
-    const crushProposal = path.join(
-      testDir,
-      '.crush/commands/openspec-proposal.md'
-    );
-    const crushArchive = path.join(
-      testDir,
-      '.crush/commands/openspec-archive.md'
-    );
-
-    // Confirm they weren't created by update
-    await expect(FileSystemUtils.fileExists(crushProposal)).resolves.toBe(false);
-    await expect(FileSystemUtils.fileExists(crushArchive)).resolves.toBe(false);
-  });
+      // Create update command with force option
+      const forceUpdateCommand = new UpdateCommand({ force: true });
+      await forceUpdateCommand.execute(testDir);
 
-  it('should refresh existing CoStrict slash command files', async () => {
-    const costrictPath = path.join(
-      testDir,
-      '.cospec/openspec/commands/openspec-proposal.md'
-    );
-    await fs.mkdir(path.dirname(costrictPath), { recursive: true });
-    const initialContent = `---
-description: "Old description"
-argument-hint: old-hint
----
-<!-- OPENSPEC:START -->
-Old body
-<!-- OPENSPEC:END -->`;
-    await fs.writeFile(costrictPath, initialContent);
-
-    const consoleSpy = vi.spyOn(console, 'log');
-
-    await updateCommand.execute(testDir);
-
-    const updated = await fs.readFile(costrictPath, 'utf-8');
-    // For slash commands, only the content between OpenSpec markers is updated
-    expect(updated).toContain('description: "Old description"');
-    expect(updated).toContain('argument-hint: old-hint');
-    expect(updated).toContain('**Guardrails**');
-    expect(updated).toContain(
-      'Validate with `openspec validate <id> --strict --no-interactive`'
-    );
-    expect(updated).not.toContain('Old body');
-
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated OpenSpec instructions (openspec/AGENTS.md'
-    );
-    expect(logMessage).toContain('AGENTS.md (created)');
-    expect(logMessage).toContain(
-      'Updated slash commands: .cospec/openspec/commands/openspec-proposal.md'
-    );
-
-    consoleSpy.mockRestore();
-  });
+      // Should show v1 upgrade message
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Upgrading to the new OpenSpec')
+      );
 
-  it('should refresh existing Qoder slash command files', async () => {
-    const qoderPath = path.join(
-      testDir,
-      '.qoder/commands/openspec/proposal.md'
-    );
-    await fs.mkdir(path.dirname(qoderPath), { recursive: true });
-    const initialContent = `---
-name: OpenSpec - Proposal
-description: Old description
-category: OpenSpec
-tags: [openspec, change]
----
-<!-- OPENSPEC:START -->
-Old slash content
-<!-- OPENSPEC:END -->`;
-    await fs.writeFile(qoderPath, initialContent);
-
-    const consoleSpy = vi.spyOn(console, 'log');
-
-    await updateCommand.execute(testDir);
-
-    const updated = await fs.readFile(qoderPath, 'utf-8');
-    expect(updated).toContain('name: OpenSpec - Proposal');
-    expect(updated).toContain('**Guardrails**');
-    expect(updated).toContain(
-      'Validate with `openspec validate <id> --strict --no-interactive`'
-    );
-    expect(updated).not.toContain('Old slash content');
-
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated OpenSpec instructions (openspec/AGENTS.md'
-    );
-    expect(logMessage).toContain('AGENTS.md (created)');
-    expect(logMessage).toContain(
-      'Updated slash commands: .qoder/commands/openspec/proposal.md'
-    );
-
-    consoleSpy.mockRestore();
-  });
+      // Should show marker removal message (config files are never deleted, only have markers removed)
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Removed OpenSpec markers from CLAUDE.md')
+      );
 
-  it('should refresh existing RooCode slash command files', async () => {
-    const rooPath = path.join(
-      testDir,
-      '.roo/commands/openspec-proposal.md'
-    );
-    await fs.mkdir(path.dirname(rooPath), { recursive: true });
-    const initialContent = `# OpenSpec: Proposal
-
-Old description
-
-<!-- OPENSPEC:START -->
-Old body
-<!-- OPENSPEC:END -->`;
-    await fs.writeFile(rooPath, initialContent);
-
-    const consoleSpy = vi.spyOn(console, 'log');
-
-    await updateCommand.execute(testDir);
-
-    const updated = await fs.readFile(rooPath, 'utf-8');
-    // For RooCode, the header is Markdown, preserve it and update only managed block
-    expect(updated).toContain('# OpenSpec: Proposal');
-    expect(updated).toContain('**Guardrails**');
-    expect(updated).toContain(
-      'Validate with `openspec validate <id> --strict --no-interactive`'
-    );
-    expect(updated).not.toContain('Old body');
-
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated OpenSpec instructions (openspec/AGENTS.md'
-    );
-    expect(logMessage).toContain('AGENTS.md (created)');
-    expect(logMessage).toContain(
-      'Updated slash commands: .roo/commands/openspec-proposal.md'
-    );
-
-    consoleSpy.mockRestore();
-  });
+      // Config file should still exist (never deleted)
+      const legacyExists = await FileSystemUtils.fileExists(
+        path.join(testDir, 'CLAUDE.md')
+      );
+      expect(legacyExists).toBe(true);
 
-  it('should not create missing RooCode slash command files on update', async () => {
-    const rooApply = path.join(
-      testDir,
-      '.roo/commands/openspec-apply.md'
-    );
-
-    // Only create apply; leave proposal and archive missing
-    await fs.mkdir(path.dirname(rooApply), { recursive: true });
-    await fs.writeFile(
-      rooApply,
-      `# OpenSpec: Apply
-
-<!-- OPENSPEC:START -->
-Old body
-<!-- OPENSPEC:END -->`
-    );
-
-    await updateCommand.execute(testDir);
-
-    const rooProposal = path.join(
-      testDir,
-      '.roo/commands/openspec-proposal.md'
-    );
-    const rooArchive = path.join(
-      testDir,
-      '.roo/commands/openspec-archive.md'
-    );
-
-    // Confirm they weren't created by update
-    await expect(FileSystemUtils.fileExists(rooProposal)).resolves.toBe(false);
-    await expect(FileSystemUtils.fileExists(rooArchive)).resolves.toBe(false);
-  });
+      // File should have markers removed
+      const content = await fs.readFile(path.join(testDir, 'CLAUDE.md'), 'utf-8');
+      expect(content).not.toContain(OPENSPEC_MARKERS.start);
+      expect(content).not.toContain(OPENSPEC_MARKERS.end);
 
-  it('should not create missing CoStrict slash command files on update', async () => {
-    const costrictApply = path.join(
-      testDir,
-      '.cospec/openspec/commands/openspec-apply.md'
-    );
-
-    // Only create apply; leave proposal and archive missing
-    await fs.mkdir(path.dirname(costrictApply), { recursive: true });
-    await fs.writeFile(
-      costrictApply,
-      `---
-description: "Old"
-argument-hint: old
----
-<!-- OPENSPEC:START -->
-Old
-<!-- OPENSPEC:END -->`
-    );
-
-    await updateCommand.execute(testDir);
-
-    const costrictProposal = path.join(
-      testDir,
-      '.cospec/openspec/commands/openspec-proposal.md'
-    );
-    const costrictArchive = path.join(
-      testDir,
-      '.cospec/openspec/commands/openspec-archive.md'
-    );
-
-    // Confirm they weren't created by update
-    await expect(FileSystemUtils.fileExists(costrictProposal)).resolves.toBe(false);
-    await expect(FileSystemUtils.fileExists(costrictArchive)).resolves.toBe(false);
-  });
+      consoleSpy.mockRestore();
+    });
 
-  it('should not create missing Qoder slash command files on update', async () => {
-    const qoderApply = path.join(
-      testDir,
-      '.qoder/commands/openspec/apply.md'
-    );
-
-    // Only create apply; leave proposal and archive missing
-    await fs.mkdir(path.dirname(qoderApply), { recursive: true });
-    await fs.writeFile(
-      qoderApply,
-      `---
-name: OpenSpec - Apply
-description: Old description
-category: OpenSpec
-tags: [openspec, apply]
----
-<!-- OPENSPEC:START -->
-Old body
-<!-- OPENSPEC:END -->`
-    );
-
-    await updateCommand.execute(testDir);
-
-    const qoderProposal = path.join(
-      testDir,
-      '.qoder/commands/openspec/proposal.md'
-    );
-    const qoderArchive = path.join(
-      testDir,
-      '.qoder/commands/openspec/archive.md'
-    );
-
-    // Confirm they weren't created by update
-    await expect(FileSystemUtils.fileExists(qoderProposal)).resolves.toBe(false);
-    await expect(FileSystemUtils.fileExists(qoderArchive)).resolves.toBe(false);
-  });
+    it('should warn but continue with update when legacy files found in non-interactive mode', async () => {
+      // Set up a configured tool
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        'old'
+      );
+
+      // Create legacy CLAUDE.md with OpenSpec markers
+      const legacyContent = `${OPENSPEC_MARKERS.start}
+# OpenSpec Instructions
+${OPENSPEC_MARKERS.end}
+`;
+      await fs.writeFile(path.join(testDir, 'CLAUDE.md'), legacyContent);
 
-  it('should update only existing COSTRICT.md file', async () => {
-    // Create COSTRICT.md file with initial content
-    const costrictPath = path.join(testDir, 'COSTRICT.md');
-    const initialContent = `# CoStrict Instructions
-
-Some existing CoStrict instructions here.
-
-<!-- OPENSPEC:START -->
-Old OpenSpec content
-<!-- OPENSPEC:END -->
-
-More instructions after.`;
-    await fs.writeFile(costrictPath, initialContent);
-
-    const consoleSpy = vi.spyOn(console, 'log');
-
-    // Execute update command
-    await updateCommand.execute(testDir);
-
-    // Check that COSTRICT.md was updated
-    const updatedContent = await fs.readFile(costrictPath, 'utf-8');
-    expect(updatedContent).toContain('<!-- OPENSPEC:START -->');
-    expect(updatedContent).toContain('<!-- OPENSPEC:END -->');
-    expect(updatedContent).toContain("@/openspec/AGENTS.md");
-    expect(updatedContent).toContain('openspec update');
-    expect(updatedContent).toContain('Some existing CoStrict instructions here');
-    expect(updatedContent).toContain('More instructions after');
-
-    // Check console output
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated OpenSpec instructions (openspec/AGENTS.md'
-    );
-    expect(logMessage).toContain('AGENTS.md (created)');
-    expect(logMessage).toContain('Updated AI tool files: COSTRICT.md');
-    consoleSpy.mockRestore();
-  });
+      const consoleSpy = vi.spyOn(console, 'log');
 
+      // Run without --force in non-interactive mode (CI environment)
+      await updateCommand.execute(testDir);
 
-  it('should not create COSTRICT.md if it does not exist', async () => {
-    // Ensure COSTRICT.md does not exist
-    const costrictPath = path.join(testDir, 'COSTRICT.md');
+      // Should show v1 upgrade message
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Upgrading to the new OpenSpec')
+      );
 
-    // Execute update command
-    await updateCommand.execute(testDir);
+      // Should show warning about --force
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Run with --force to auto-cleanup')
+      );
 
-    // Check that COSTRICT.md was not created
-    const fileExists = await FileSystemUtils.fileExists(costrictPath);
-    expect(fileExists).toBe(false);
-  });
+      // Should continue with update
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Updated: Claude Code')
+      );
 
-  it('should preserve CoStrict content outside markers during update', async () => {
-    const costrictPath = path.join(
-      testDir,
-      '.cospec/openspec/commands/openspec-proposal.md'
-    );
-    await fs.mkdir(path.dirname(costrictPath), { recursive: true });
-    const initialContent = `## Custom Intro Title\nSome intro text\n<!-- OPENSPEC:START -->\nOld body\n<!-- OPENSPEC:END -->\n\nFooter stays`;
-    await fs.writeFile(costrictPath, initialContent);
-
-    await updateCommand.execute(testDir);
-
-    const updated = await fs.readFile(costrictPath, 'utf-8');
-    expect(updated).toContain('## Custom Intro Title');
-    expect(updated).toContain('Footer stays');
-    expect(updated).not.toContain('Old body');
-    expect(updated).toContain('Validate with `openspec validate <id> --strict --no-interactive`');
-  });
+      // Legacy file should still exist (not cleaned up)
+      const legacyExists = await FileSystemUtils.fileExists(
+        path.join(testDir, 'CLAUDE.md')
+      );
+      expect(legacyExists).toBe(true);
 
-  it('should handle configurator errors gracefully for CoStrict', async () => {
-    // Create COSTRICT.md file but make it read-only to cause an error
-    const costrictPath = path.join(testDir, 'COSTRICT.md');
-    await fs.writeFile(
-      costrictPath,
-      '<!-- OPENSPEC:START -->\nOld\n<!-- OPENSPEC:END -->'
-    );
-
-    const consoleSpy = vi.spyOn(console, 'log');
-    const errorSpy = vi.spyOn(console, 'error');
-    const originalWriteFile = FileSystemUtils.writeFile.bind(FileSystemUtils);
-    const writeSpy = vi
-      .spyOn(FileSystemUtils, 'writeFile')
-      .mockImplementation(async (filePath, content) => {
-        if (filePath.endsWith('COSTRICT.md')) {
-          throw new Error('EACCES: permission denied, open');
-        }
-
-        return originalWriteFile(filePath, content);
+      consoleSpy.mockRestore();
+    });
+
+    it('should cleanup legacy slash command directories with --force', async () => {
+      // Set up a configured tool
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), {
+        recursive: true,
       });
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        'old'
+      );
+
+      // Create legacy slash command directory
+      const legacyCommandDir = path.join(testDir, '.claude', 'commands', 'openspec');
+      await fs.mkdir(legacyCommandDir, { recursive: true });
+      await fs.writeFile(
+        path.join(legacyCommandDir, 'old-command.md'),
+        'old command'
+      );
+
+      const consoleSpy = vi.spyOn(console, 'log');
+
+      // Create update command with force option
+      const forceUpdateCommand = new UpdateCommand({ force: true });
+      await forceUpdateCommand.execute(testDir);
+
+      // Should show cleanup message for directory
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Removed .claude/commands/openspec/')
+      );
+
+      // Legacy directory should be deleted
+      const legacyDirExists = await FileSystemUtils.directoryExists(legacyCommandDir);
+      expect(legacyDirExists).toBe(false);
+
+      consoleSpy.mockRestore();
+    });
 
-    // Execute update command - should not throw
-    await updateCommand.execute(testDir);
-
-    // Should report the failure
-    expect(errorSpy).toHaveBeenCalled();
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated OpenSpec instructions (openspec/AGENTS.md'
-    );
-    expect(logMessage).toContain('AGENTS.md (created)');
-    expect(logMessage).toContain('Failed to update: COSTRICT.md');
-
-    consoleSpy.mockRestore();
-    errorSpy.mockRestore();
-    writeSpy.mockRestore();
-  });
+    it('should cleanup legacy openspec/AGENTS.md with --force', async () => {
+      // Set up a configured tool
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        'old'
+      );
+
+      // Create legacy openspec/AGENTS.md
+      await fs.writeFile(
+        path.join(testDir, 'openspec', 'AGENTS.md'),
+        '# Old AGENTS.md content'
+      );
+
+      const consoleSpy = vi.spyOn(console, 'log');
+
+      // Create update command with force option
+      const forceUpdateCommand = new UpdateCommand({ force: true });
+      await forceUpdateCommand.execute(testDir);
+
+      // Should show cleanup message
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Removed openspec/AGENTS.md')
+      );
+
+      // Legacy file should be deleted
+      const legacyExists = await FileSystemUtils.fileExists(
+        path.join(testDir, 'openspec', 'AGENTS.md')
+      );
+      expect(legacyExists).toBe(false);
+
+      consoleSpy.mockRestore();
+    });
 
-  it('should preserve Windsurf content outside markers during update', async () => {
-    const wsPath = path.join(
-      testDir,
-      '.windsurf/workflows/openspec-proposal.md'
-    );
-    await fs.mkdir(path.dirname(wsPath), { recursive: true });
-    const initialContent = `## Custom Intro Title\nSome intro text\n<!-- OPENSPEC:START -->\nOld body\n<!-- OPENSPEC:END -->\n\nFooter stays`;
-    await fs.writeFile(wsPath, initialContent);
-
-    await updateCommand.execute(testDir);
-
-    const updated = await fs.readFile(wsPath, 'utf-8');
-    expect(updated).toContain('## Custom Intro Title');
-    expect(updated).toContain('Footer stays');
-    expect(updated).not.toContain('Old body');
-    expect(updated).toContain('Validate with `openspec validate <id> --strict --no-interactive`');
-  });
+    it('should not show legacy cleanup messages when no legacy files exist', async () => {
+      // Set up a configured tool with no legacy files
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        'old'
+      );
 
-  it('should not create missing Windsurf workflows on update', async () => {
-    const wsApply = path.join(
-      testDir,
-      '.windsurf/workflows/openspec-apply.md'
-    );
-    // Only create apply; leave proposal and archive missing
-    await fs.mkdir(path.dirname(wsApply), { recursive: true });
-    await fs.writeFile(
-      wsApply,
-      '<!-- OPENSPEC:START -->\nOld\n<!-- OPENSPEC:END -->'
-    );
-
-    await updateCommand.execute(testDir);
-
-    const wsProposal = path.join(
-      testDir,
-      '.windsurf/workflows/openspec-proposal.md'
-    );
-    const wsArchive = path.join(
-      testDir,
-      '.windsurf/workflows/openspec-archive.md'
-    );
-
-    // Confirm they weren't created by update
-    await expect(FileSystemUtils.fileExists(wsProposal)).resolves.toBe(false);
-    await expect(FileSystemUtils.fileExists(wsArchive)).resolves.toBe(false);
-  });
+      const consoleSpy = vi.spyOn(console, 'log');
 
-  it('should handle no AI tool files present', async () => {
-    // Execute update command with no AI tool files
-    const consoleSpy = vi.spyOn(console, 'log');
-    await updateCommand.execute(testDir);
-
-    // Should only update OpenSpec instructions
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated OpenSpec instructions (openspec/AGENTS.md'
-    );
-    expect(logMessage).toContain('AGENTS.md (created)');
-    consoleSpy.mockRestore();
-  });
+      await updateCommand.execute(testDir);
 
-  it('should update multiple AI tool files if present', async () => {
-    // TODO: When additional configurators are added (Cursor, Aider, etc.),
-    // enhance this test to create multiple AI tool files and verify
-    // that all existing files are updated in a single operation.
-    // For now, we test with just CLAUDE.md.
-    const claudePath = path.join(testDir, 'CLAUDE.md');
-    await fs.mkdir(path.dirname(claudePath), { recursive: true });
-    await fs.writeFile(
-      claudePath,
-      '<!-- OPENSPEC:START -->\nOld\n<!-- OPENSPEC:END -->'
-    );
-
-    const consoleSpy = vi.spyOn(console, 'log');
-    await updateCommand.execute(testDir);
-
-    // Should report updating with new format
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated OpenSpec instructions (openspec/AGENTS.md'
-    );
-    expect(logMessage).toContain('AGENTS.md (created)');
-    expect(logMessage).toContain('Updated AI tool files: CLAUDE.md');
-    consoleSpy.mockRestore();
-  });
+      // Should not show v1 upgrade message (no legacy files)
+      const calls = consoleSpy.mock.calls.map(call =>
+        call.map(arg => String(arg)).join(' ')
+      );
+      const hasLegacyMessage = calls.some(call =>
+        call.includes('Upgrading to the new OpenSpec')
+      );
+      expect(hasLegacyMessage).toBe(false);
 
-  it('should skip creating missing slash commands during update', async () => {
-    const proposalPath = path.join(
-      testDir,
-      '.claude/commands/openspec/proposal.md'
-    );
-    await fs.mkdir(path.dirname(proposalPath), { recursive: true });
-    await fs.writeFile(
-      proposalPath,
-      `---
-name: OpenSpec - Proposal
-description: Existing file
-category: OpenSpec
-tags: [openspec, change]
----
-<!-- OPENSPEC:START -->
-Old content
-<!-- OPENSPEC:END -->`
-    );
-
-    await updateCommand.execute(testDir);
-
-    const applyExists = await FileSystemUtils.fileExists(
-      path.join(testDir, '.claude/commands/openspec/apply.md')
-    );
-    const archiveExists = await FileSystemUtils.fileExists(
-      path.join(testDir, '.claude/commands/openspec/archive.md')
-    );
-
-    expect(applyExists).toBe(false);
-    expect(archiveExists).toBe(false);
-  });
+      consoleSpy.mockRestore();
+    });
 
-  it('should never create new AI tool files', async () => {
-    // Get all configurators
-    const configurators = ToolRegistry.getAll();
-
-    // Execute update command
-    await updateCommand.execute(testDir);
-
-    // Check that no new AI tool files were created
-    for (const configurator of configurators) {
-      const configPath = path.join(testDir, configurator.configFileName);
-      const fileExists = await FileSystemUtils.fileExists(configPath);
-      if (configurator.configFileName === 'AGENTS.md') {
-        expect(fileExists).toBe(true);
-      } else {
-        expect(fileExists).toBe(false);
-      }
-    }
-  });
+    it('should remove OpenSpec marker block from mixed content files', async () => {
+      // Set up a configured tool
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), {
+        recursive: true,
+      });
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        'old'
+      );
 
-  it('should update AGENTS.md in openspec directory', async () => {
-    // Execute update command
-    await updateCommand.execute(testDir);
+      // Create CLAUDE.md with mixed content (user content + OpenSpec markers)
+      const mixedContent = `# My Project
 
-    // Check that AGENTS.md was created/updated
-    const agentsPath = path.join(testDir, 'openspec', 'AGENTS.md');
-    const fileExists = await FileSystemUtils.fileExists(agentsPath);
-    expect(fileExists).toBe(true);
+Some user-defined instructions here.
 
-    const content = await fs.readFile(agentsPath, 'utf-8');
-    expect(content).toContain('# OpenSpec Instructions');
+${OPENSPEC_MARKERS.start}
+# OpenSpec Instructions
+
+These instructions are for AI assistants.
+${OPENSPEC_MARKERS.end}
+
+More user content after markers.
+`;
+      await fs.writeFile(path.join(testDir, 'CLAUDE.md'), mixedContent);
+
+      const consoleSpy = vi.spyOn(console, 'log');
+
+      // Create update command with force option
+      const forceUpdateCommand = new UpdateCommand({ force: true });
+      await forceUpdateCommand.execute(testDir);
+
+      // Should show marker removal message
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Removed OpenSpec markers from CLAUDE.md')
+      );
+
+      // File should still exist
+      const fileExists = await FileSystemUtils.fileExists(
+        path.join(testDir, 'CLAUDE.md')
+      );
+      expect(fileExists).toBe(true);
+
+      // File should have markers removed but preserve user content
+      const updatedContent = await fs.readFile(
+        path.join(testDir, 'CLAUDE.md'),
+        'utf-8'
+      );
+      expect(updatedContent).toContain('# My Project');
+      expect(updatedContent).toContain('Some user-defined instructions here');
+      expect(updatedContent).toContain('More user content after markers');
+      expect(updatedContent).not.toContain(OPENSPEC_MARKERS.start);
+      expect(updatedContent).not.toContain(OPENSPEC_MARKERS.end);
+
+      consoleSpy.mockRestore();
+    });
   });
 
-  it('should create root AGENTS.md with managed block when missing', async () => {
-    await updateCommand.execute(testDir);
+  describe('legacy tool upgrade', () => {
+    it('should upgrade legacy tools to new skills with --force', async () => {
+      // Create legacy slash command directory (no skills exist yet)
+      const legacyCommandDir = path.join(testDir, '.claude', 'commands', 'openspec');
+      await fs.mkdir(legacyCommandDir, { recursive: true });
+      await fs.writeFile(
+        path.join(legacyCommandDir, 'proposal.md'),
+        'old command content'
+      );
+
+      const consoleSpy = vi.spyOn(console, 'log');
+
+      // Create update command with force option
+      const forceUpdateCommand = new UpdateCommand({ force: true });
+      await forceUpdateCommand.execute(testDir);
+
+      // Should show detected tools message
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Tools detected from legacy artifacts')
+      );
+
+      // Should show Claude Code being set up
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Claude Code')
+      );
+
+      // Should show getting started message for newly configured tools
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Getting started')
+      );
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('/opsx:new')
+      );
+
+      // Skills should be created
+      const skillFile = path.join(testDir, '.claude', 'skills', 'openspec-explore', 'SKILL.md');
+      const skillExists = await FileSystemUtils.fileExists(skillFile);
+      expect(skillExists).toBe(true);
+
+      // Legacy directory should be deleted
+      const legacyDirExists = await FileSystemUtils.directoryExists(legacyCommandDir);
+      expect(legacyDirExists).toBe(false);
+
+      consoleSpy.mockRestore();
+    });
+
+    it('should upgrade multiple legacy tools with --force', async () => {
+      // Create legacy command directories for Claude and Cursor
+      await fs.mkdir(path.join(testDir, '.claude', 'commands', 'openspec'), { recursive: true });
+      await fs.writeFile(
+        path.join(testDir, '.claude', 'commands', 'openspec', 'proposal.md'),
+        'content'
+      );
 
-    const rootAgentsPath = path.join(testDir, 'AGENTS.md');
-    const exists = await FileSystemUtils.fileExists(rootAgentsPath);
-    expect(exists).toBe(true);
+      await fs.mkdir(path.join(testDir, '.cursor', 'commands'), { recursive: true });
+      await fs.writeFile(
+        path.join(testDir, '.cursor', 'commands', 'openspec-proposal.md'),
+        'content'
+      );
 
-    const content = await fs.readFile(rootAgentsPath, 'utf-8');
-    expect(content).toContain('<!-- OPENSPEC:START -->');
-    expect(content).toContain("@/openspec/AGENTS.md");
-    expect(content).toContain('openspec update');
-    expect(content).toContain('<!-- OPENSPEC:END -->');
-  });
+      const consoleSpy = vi.spyOn(console, 'log');
 
-  it('should refresh root AGENTS.md while preserving surrounding content', async () => {
-    const rootAgentsPath = path.join(testDir, 'AGENTS.md');
-    const original = `# Custom intro\n\n<!-- OPENSPEC:START -->\nOld content\n<!-- OPENSPEC:END -->\n\n# Footnotes`;
-    await fs.writeFile(rootAgentsPath, original);
+      // Create update command with force option
+      const forceUpdateCommand = new UpdateCommand({ force: true });
+      await forceUpdateCommand.execute(testDir);
 
-    const consoleSpy = vi.spyOn(console, 'log');
+      // Should detect both tools
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Tools detected from legacy artifacts')
+      );
 
-    await updateCommand.execute(testDir);
+      // Both tools should have skills created
+      const claudeSkillFile = path.join(testDir, '.claude', 'skills', 'openspec-explore', 'SKILL.md');
+      const cursorSkillFile = path.join(testDir, '.cursor', 'skills', 'openspec-explore', 'SKILL.md');
 
-    const updated = await fs.readFile(rootAgentsPath, 'utf-8');
-    expect(updated).toContain('# Custom intro');
-    expect(updated).toContain('# Footnotes');
-    expect(updated).toContain("@/openspec/AGENTS.md");
-    expect(updated).toContain('openspec update');
-    expect(updated).not.toContain('Old content');
+      expect(await FileSystemUtils.fileExists(claudeSkillFile)).toBe(true);
+      expect(await FileSystemUtils.fileExists(cursorSkillFile)).toBe(true);
 
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated OpenSpec instructions (openspec/AGENTS.md, AGENTS.md)'
-    );
-    expect(logMessage).not.toContain('AGENTS.md (created)');
+      consoleSpy.mockRestore();
+    });
 
-    consoleSpy.mockRestore();
-  });
+    it('should not upgrade legacy tools already configured', async () => {
+      // Set up a configured Claude tool with skills
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), { recursive: true });
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        'existing skill'
+      );
+
+      // Also create legacy directory (simulating partial upgrade)
+      const legacyCommandDir = path.join(testDir, '.claude', 'commands', 'openspec');
+      await fs.mkdir(legacyCommandDir, { recursive: true });
+      await fs.writeFile(
+        path.join(legacyCommandDir, 'proposal.md'),
+        'old command'
+      );
+
+      const consoleSpy = vi.spyOn(console, 'log');
+
+      // Create update command with force option
+      const forceUpdateCommand = new UpdateCommand({ force: true });
+      await forceUpdateCommand.execute(testDir);
+
+      // Legacy cleanup should happen
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Removed .claude/commands/openspec/')
+      );
+
+      // Should NOT show "Tools detected from legacy artifacts" because claude is already configured
+      const calls = consoleSpy.mock.calls.map(call =>
+        call.map(arg => String(arg)).join(' ')
+      );
+      const hasDetectedMessage = calls.some(call =>
+        call.includes('Tools detected from legacy artifacts')
+      );
+      expect(hasDetectedMessage).toBe(false);
+
+      // Should update existing skills (not "Getting started" for newly configured)
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Updated: Claude Code')
+      );
+
+      consoleSpy.mockRestore();
+    });
 
-  it('should throw error if openspec directory does not exist', async () => {
-    // Remove openspec directory
-    await fs.rm(path.join(testDir, 'openspec'), {
-      recursive: true,
-      force: true,
+    it('should upgrade only unconfigured legacy tools when mixed', async () => {
+      // Set up configured Claude tool with skills
+      const claudeSkillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(claudeSkillsDir, 'openspec-explore'), { recursive: true });
+      await fs.writeFile(
+        path.join(claudeSkillsDir, 'openspec-explore', 'SKILL.md'),
+        'existing skill'
+      );
+
+      // Create legacy commands for both Claude (configured) and Cursor (not configured)
+      await fs.mkdir(path.join(testDir, '.claude', 'commands', 'openspec'), { recursive: true });
+      await fs.writeFile(
+        path.join(testDir, '.claude', 'commands', 'openspec', 'proposal.md'),
+        'content'
+      );
+
+      await fs.mkdir(path.join(testDir, '.cursor', 'commands'), { recursive: true });
+      await fs.writeFile(
+        path.join(testDir, '.cursor', 'commands', 'openspec-proposal.md'),
+        'content'
+      );
+
+      const consoleSpy = vi.spyOn(console, 'log');
+
+      // Create update command with force option
+      const forceUpdateCommand = new UpdateCommand({ force: true });
+      await forceUpdateCommand.execute(testDir);
+
+      // Should detect Cursor as a legacy tool to upgrade (but not Claude)
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Tools detected from legacy artifacts')
+      );
+
+      // Cursor skills should be created
+      const cursorSkillFile = path.join(testDir, '.cursor', 'skills', 'openspec-explore', 'SKILL.md');
+      expect(await FileSystemUtils.fileExists(cursorSkillFile)).toBe(true);
+
+      // Should show "Getting started" for newly configured Cursor
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Getting started')
+      );
+
+      consoleSpy.mockRestore();
     });
 
-    // Execute update command and expect error
-    await expect(updateCommand.execute(testDir)).rejects.toThrow(
-      "No OpenSpec directory found. Run 'openspec init' first."
-    );
-  });
+    it('should not show getting started message when no new tools configured', async () => {
+      // Set up a configured tool (no legacy artifacts)
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      await fs.mkdir(path.join(skillsDir, 'openspec-explore'), { recursive: true });
+      await fs.writeFile(
+        path.join(skillsDir, 'openspec-explore', 'SKILL.md'),
+        'old skill'
+      );
+
+      const consoleSpy = vi.spyOn(console, 'log');
+
+      await updateCommand.execute(testDir);
+
+      // Should NOT show "Getting started" message
+      const calls = consoleSpy.mock.calls.map(call =>
+        call.map(arg => String(arg)).join(' ')
+      );
+      const hasGettingStarted = calls.some(call =>
+        call.includes('Getting started')
+      );
+      expect(hasGettingStarted).toBe(false);
+
+      consoleSpy.mockRestore();
+    });
 
-  it('should handle configurator errors gracefully', async () => {
-    // Create CLAUDE.md file but make it read-only to cause an error
-    const claudePath = path.join(testDir, 'CLAUDE.md');
-    await fs.writeFile(
-      claudePath,
-      '<!-- OPENSPEC:START -->\nOld\n<!-- OPENSPEC:END -->'
-    );
-    await fs.chmod(claudePath, 0o444); // Read-only
-
-    const consoleSpy = vi.spyOn(console, 'log');
-    const errorSpy = vi.spyOn(console, 'error');
-    const originalWriteFile = FileSystemUtils.writeFile.bind(FileSystemUtils);
-    const writeSpy = vi
-      .spyOn(FileSystemUtils, 'writeFile')
-      .mockImplementation(async (filePath, content) => {
-        if (filePath.endsWith('CLAUDE.md')) {
-          throw new Error('EACCES: permission denied, open');
-        }
-
-        return originalWriteFile(filePath, content);
-      });
+    it('should create all 9 skills when upgrading legacy tools', async () => {
+      // Create legacy command directory
+      await fs.mkdir(path.join(testDir, '.claude', 'commands', 'openspec'), { recursive: true });
+      await fs.writeFile(
+        path.join(testDir, '.claude', 'commands', 'openspec', 'proposal.md'),
+        'content'
+      );
+
+      // Create update command with force option
+      const forceUpdateCommand = new UpdateCommand({ force: true });
+      await forceUpdateCommand.execute(testDir);
+
+      // Verify all 9 skill directories were created
+      const skillNames = [
+        'openspec-explore',
+        'openspec-new-change',
+        'openspec-continue-change',
+        'openspec-apply-change',
+        'openspec-ff-change',
+        'openspec-sync-specs',
+        'openspec-archive-change',
+        'openspec-bulk-archive-change',
+        'openspec-verify-change',
+      ];
+
+      const skillsDir = path.join(testDir, '.claude', 'skills');
+      for (const skillName of skillNames) {
+        const skillFile = path.join(skillsDir, skillName, 'SKILL.md');
+        const exists = await FileSystemUtils.fileExists(skillFile);
+        expect(exists).toBe(true);
+      }
+    });
 
-    // Execute update command - should not throw
-    await updateCommand.execute(testDir);
-
-    // Should report the failure
-    expect(errorSpy).toHaveBeenCalled();
-    const [logMessage] = consoleSpy.mock.calls[0];
-    expect(logMessage).toContain(
-      'Updated OpenSpec instructions (openspec/AGENTS.md'
-    );
-    expect(logMessage).toContain('AGENTS.md (created)');
-    expect(logMessage).toContain('Failed to update: CLAUDE.md');
-
-    // Restore permissions for cleanup
-    await fs.chmod(claudePath, 0o644);
-    consoleSpy.mockRestore();
-    errorSpy.mockRestore();
-    writeSpy.mockRestore();
+    it('should create commands when upgrading legacy tools', async () => {
+      // Create legacy command directory
+      await fs.mkdir(path.join(testDir, '.claude', 'commands', 'openspec'), { recursive: true });
+      await fs.writeFile(
+        path.join(testDir, '.claude', 'commands', 'openspec', 'proposal.md'),
+        'content'
+      );
+
+      // Create update command with force option
+      const forceUpdateCommand = new UpdateCommand({ force: true });
+      await forceUpdateCommand.execute(testDir);
+
+      // New opsx commands should be created
+      const commandsDir = path.join(testDir, '.claude', 'commands', 'opsx');
+      const exploreCmd = path.join(commandsDir, 'explore.md');
+      const exists = await FileSystemUtils.fileExists(exploreCmd);
+      expect(exists).toBe(true);
+    });
   });
 });
diff --git a/test/utils/change-metadata.test.ts b/test/utils/change-metadata.test.ts
index 2102c98..a8c1238 100644
--- a/test/utils/change-metadata.test.ts
+++ b/test/utils/change-metadata.test.ts
@@ -28,11 +28,11 @@ describe('ChangeMetadataSchema', () => {
 
     it('should accept valid schema without created date', () => {
       const result = ChangeMetadataSchema.safeParse({
-        schema: 'tdd',
+        schema: 'custom-schema',
       });
       expect(result.success).toBe(true);
       if (result.success) {
-        expect(result.data.schema).toBe('tdd');
+        expect(result.data.schema).toBe('custom-schema');
         expect(result.data.created).toBeUndefined();
       }
     });
@@ -183,8 +183,8 @@ describe('resolveSchemaForChange', () => {
     const metaPath = path.join(changeDir, '.openspec.yaml');
     await fs.writeFile(metaPath, 'schema: spec-driven\n', 'utf-8');
 
-    const result = resolveSchemaForChange(changeDir, 'tdd');
-    expect(result).toBe('tdd');
+    const result = resolveSchemaForChange(changeDir, 'custom-schema');
+    expect(result).toBe('custom-schema');
   });
 
   it('should return schema from metadata when no explicit schema', async () => {
@@ -216,12 +216,12 @@ describe('resolveSchemaForChange', () => {
     await fs.mkdir(configDir, { recursive: true });
     await fs.writeFile(
       path.join(configDir, 'config.yaml'),
-      'schema: tdd\n',
+      'schema: custom-schema\n',
       'utf-8'
     );
 
     const result = resolveSchemaForChange(changeDir);
-    expect(result).toBe('tdd');
+    expect(result).toBe('custom-schema');
   });
 
   it('should prefer change metadata over project config', async () => {
@@ -230,7 +230,7 @@ describe('resolveSchemaForChange', () => {
     await fs.mkdir(configDir, { recursive: true });
     await fs.writeFile(
       path.join(configDir, 'config.yaml'),
-      'schema: tdd\n',
+      'schema: custom-schema\n',
       'utf-8'
     );
 
@@ -248,7 +248,7 @@ describe('resolveSchemaForChange', () => {
     await fs.mkdir(configDir, { recursive: true });
     await fs.writeFile(
       path.join(configDir, 'config.yaml'),
-      'schema: tdd\n',
+      'schema: custom-schema\n',
       'utf-8'
     );
 
@@ -257,8 +257,8 @@ describe('resolveSchemaForChange', () => {
     await fs.writeFile(metaPath, 'schema: spec-driven\n', 'utf-8');
 
     // Explicit schema should win
-    const result = resolveSchemaForChange(changeDir, 'tdd');
-    expect(result).toBe('tdd');
+    const result = resolveSchemaForChange(changeDir, 'custom-schema');
+    expect(result).toBe('custom-schema');
   });
 
   it('should test full precedence order: CLI > metadata > config > default', async () => {
@@ -267,7 +267,7 @@ describe('resolveSchemaForChange', () => {
     await fs.mkdir(configDir, { recursive: true });
     await fs.writeFile(
       path.join(configDir, 'config.yaml'),
-      'schema: tdd\n',
+      'schema: custom-schema\n',
       'utf-8'
     );
 
@@ -275,12 +275,12 @@ describe('resolveSchemaForChange', () => {
     await fs.writeFile(metaPath, 'schema: spec-driven\n', 'utf-8');
 
     // Test each level
-    expect(resolveSchemaForChange(changeDir, 'tdd')).toBe('tdd'); // CLI wins
+    expect(resolveSchemaForChange(changeDir, 'custom-schema')).toBe('custom-schema'); // CLI wins
     expect(resolveSchemaForChange(changeDir)).toBe('spec-driven'); // Metadata wins when no CLI
 
     // Remove metadata, config should win
     await fs.unlink(metaPath);
-    expect(resolveSchemaForChange(changeDir)).toBe('tdd'); // Config wins
+    expect(resolveSchemaForChange(changeDir)).toBe('custom-schema'); // Config wins
 
     // Remove config, default should win
     await fs.unlink(path.join(configDir, 'config.yaml'));
diff --git a/test/utils/change-utils.test.ts b/test/utils/change-utils.test.ts
index 8e94260..090b21b 100644
--- a/test/utils/change-utils.test.ts
+++ b/test/utils/change-utils.test.ts
@@ -139,11 +139,11 @@ describe('createChange', () => {
     });
 
     it('should create .openspec.yaml with custom schema', async () => {
-      await createChange(testDir, 'add-auth', { schema: 'tdd' });
+      await createChange(testDir, 'add-auth', { schema: 'spec-driven' });
 
       const metaPath = path.join(testDir, 'openspec', 'changes', 'add-auth', '.openspec.yaml');
       const content = await fs.readFile(metaPath, 'utf-8');
-      expect(content).toContain('schema: tdd');
+      expect(content).toContain('schema: spec-driven');
     });
   });
 
diff --git a/test/utils/marker-updates.test.ts b/test/utils/marker-updates.test.ts
index b3cec84..da9a06b 100644
--- a/test/utils/marker-updates.test.ts
+++ b/test/utils/marker-updates.test.ts
@@ -2,7 +2,7 @@ import { describe, it, expect, beforeEach, afterEach } from 'vitest';
 import { promises as fs } from 'fs';
 import path from 'path';
 import os from 'os';
-import { FileSystemUtils } from '../../src/utils/file-system.js';
+import { FileSystemUtils, removeMarkerBlock } from '../../src/utils/file-system.js';
 
 describe('FileSystemUtils.updateFileWithMarkers', () => {
   let testDir: string;
@@ -285,3 +285,164 @@ ${END_MARKER}
     });
   });
 });
+
+describe('removeMarkerBlock', () => {
+  const START_MARKER = '<!-- OPENSPEC:START -->';
+  const END_MARKER = '<!-- OPENSPEC:END -->';
+
+  describe('basic removal', () => {
+    it('should remove marker block and preserve content before', () => {
+      const content = `User content before
+${START_MARKER}
+OpenSpec content
+${END_MARKER}`;
+      const result = removeMarkerBlock(content, START_MARKER, END_MARKER);
+      expect(result).toBe('User content before\n');
+      expect(result).not.toContain(START_MARKER);
+      expect(result).not.toContain(END_MARKER);
+    });
+
+    it('should remove marker block and preserve content after', () => {
+      const content = `${START_MARKER}
+OpenSpec content
+${END_MARKER}
+User content after`;
+      const result = removeMarkerBlock(content, START_MARKER, END_MARKER);
+      expect(result).toBe('User content after\n');
+    });
+
+    it('should remove marker block and preserve content before and after', () => {
+      const content = `User content before
+${START_MARKER}
+OpenSpec content
+${END_MARKER}
+User content after`;
+      const result = removeMarkerBlock(content, START_MARKER, END_MARKER);
+      expect(result).toContain('User content before');
+      expect(result).toContain('User content after');
+      expect(result).not.toContain(START_MARKER);
+    });
+
+    it('should return empty string when only markers remain', () => {
+      const content = `${START_MARKER}
+OpenSpec content
+${END_MARKER}`;
+      const result = removeMarkerBlock(content, START_MARKER, END_MARKER);
+      expect(result).toBe('');
+    });
+  });
+
+  describe('invalid states', () => {
+    it('should return original content when markers are missing', () => {
+      const content = 'Plain content without markers';
+      const result = removeMarkerBlock(content, START_MARKER, END_MARKER);
+      expect(result).toBe('Plain content without markers');
+    });
+
+    it('should return original content when only start marker exists', () => {
+      const content = `${START_MARKER}
+Content without end marker`;
+      const result = removeMarkerBlock(content, START_MARKER, END_MARKER);
+      expect(result).toContain(START_MARKER);
+    });
+
+    it('should return original content when only end marker exists', () => {
+      const content = `Content without start marker
+${END_MARKER}`;
+      const result = removeMarkerBlock(content, START_MARKER, END_MARKER);
+      expect(result).toContain(END_MARKER);
+    });
+
+    it('should return original content when markers are in wrong order', () => {
+      const content = `${END_MARKER}
+Content
+${START_MARKER}`;
+      const result = removeMarkerBlock(content, START_MARKER, END_MARKER);
+      expect(result).toContain(END_MARKER);
+      expect(result).toContain(START_MARKER);
+    });
+  });
+
+  describe('whitespace handling', () => {
+    it('should clean up double blank lines', () => {
+      const content = `Line 1
+
+
+${START_MARKER}
+OpenSpec content
+${END_MARKER}
+
+
+Line 2`;
+      const result = removeMarkerBlock(content, START_MARKER, END_MARKER);
+      expect(result).not.toMatch(/\n{3,}/);
+    });
+
+    it('should handle markers with whitespace on same line', () => {
+      const content = `User content
+  ${START_MARKER}
+OpenSpec content
+  ${END_MARKER}
+More content`;
+      const result = removeMarkerBlock(content, START_MARKER, END_MARKER);
+      expect(result).toContain('User content');
+      expect(result).toContain('More content');
+      expect(result).not.toContain(START_MARKER);
+    });
+  });
+
+  describe('inline marker mentions', () => {
+    it('should ignore inline mentions and only remove actual marker block', () => {
+      const content = `Intro referencing markers like ${START_MARKER} and ${END_MARKER} inside text.
+
+${START_MARKER}
+Original content
+${END_MARKER}
+`;
+      const result = removeMarkerBlock(content, START_MARKER, END_MARKER);
+      // Inline mentions should be preserved
+      expect(result).toContain('Intro referencing markers like');
+      expect(result).toContain(`${START_MARKER} and ${END_MARKER} inside text`);
+      // Original content between markers should be removed
+      expect(result).not.toContain('Original content');
+    });
+
+    it('should handle multiple inline mentions before actual block', () => {
+      const content = `The ${START_MARKER} marker starts a block.
+The ${END_MARKER} marker ends it.
+Here is the actual block:
+${START_MARKER}
+Managed content
+${END_MARKER}
+After block content`;
+      const result = removeMarkerBlock(content, START_MARKER, END_MARKER);
+      expect(result).toContain(`The ${START_MARKER} marker starts a block`);
+      expect(result).toContain(`The ${END_MARKER} marker ends it`);
+      expect(result).toContain('After block content');
+      expect(result).not.toContain('Managed content');
+    });
+  });
+
+  describe('shell markers', () => {
+    const SHELL_START = '# OPENSPEC:START';
+    const SHELL_END = '# OPENSPEC:END';
+
+    it('should work with shell-style markers', () => {
+      const content = `# User config
+export PATH="/usr/local/bin:$PATH"
+
+${SHELL_START}
+# OpenSpec managed
+alias openspec="npx openspec"
+${SHELL_END}
+
+# More user config
+export EDITOR="vim"`;
+      const result = removeMarkerBlock(content, SHELL_START, SHELL_END);
+      expect(result).toContain('export PATH');
+      expect(result).toContain('export EDITOR');
+      expect(result).not.toContain('alias openspec');
+      expect(result).not.toContain(SHELL_START);
+    });
+  });
+});

diff --git a/.gitignore b/.gitignore
index eec37bb..5ecf229 100644
--- a/.gitignore
+++ b/.gitignore
@@ -140,8 +140,6 @@ dist/
 vite.config.js.timestamp-*
 vite.config.ts.timestamp-*
 
-# Internal Docs
-docs/
 
 # Claude
 .claude/
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 44abebb..bb9eae5 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,36 @@
 # @fission-ai/openspec
 
+## 0.18.0
+
+### Minor Changes
+
+- 8dfd824: Add OPSX experimental workflow commands and enhanced artifact system
+
+  **New Commands:**
+
+  - `/opsx:ff` - Fast-forward through artifact creation, generating all needed artifacts in one go
+  - `/opsx:sync` - Sync delta specs from a change to main specs
+  - `/opsx:archive` - Archive completed changes with smart sync check
+
+  **Artifact Workflow Enhancements:**
+
+  - Schema-aware apply instructions with inline guidance and XML output
+  - Agent schema selection for experimental artifact workflow
+  - Per-change schema metadata via `.openspec.yaml` files
+  - Agent Skills for experimental artifact workflow
+  - Instruction loader for template loading and change context
+  - Restructured schemas as directories with templates
+
+  **Improvements:**
+
+  - Enhanced list command with last modified timestamps and sorting
+  - Change creation utilities for better workflow support
+
+  **Fixes:**
+
+  - Normalize paths for cross-platform glob compatibility
+  - Allow REMOVED requirements when creating new spec files
+
 ## 0.17.2
 
 ### Patch Changes
diff --git a/docs/artifact_poc.md b/docs/artifact_poc.md
new file mode 100644
index 0000000..01dd009
--- /dev/null
+++ b/docs/artifact_poc.md
@@ -0,0 +1,597 @@
+# POC-OpenSpec-Core Analysis
+
+---
+
+## Design Decisions & Terminology
+
+### Philosophy: Not a Workflow System
+
+This system is **not** a workflow engine. It's an **artifact tracker with dependency awareness**.
+
+| What it's NOT | What it IS |
+|---------------|------------|
+| Linear step-by-step progression | Exploratory, iterative planning |
+| Bureaucratic checkpoints | Enablers that unlock possibilities |
+| "You must complete step 1 first" | "Here's what you could create now" |
+| Form-filling | Fluid document creation |
+
+**Key insight:** Dependencies are *enablers*, not *gates*. You can't meaningfully write a design document if there's no proposal to design from - that's not bureaucracy, it's logic.
+
+### Terminology
+
+| Term | Definition | Example |
+|------|------------|---------|
+| **Change** | A unit of work being planned (feature, refactor, migration) | `openspec/changes/add-auth/` |
+| **Schema** | An artifact graph definition (what artifacts exist, their dependencies) | `spec-driven.yaml` |
+| **Artifact** | A node in the graph (a document to create) | `proposal`, `design`, `specs` |
+| **Template** | Instructions/guidance for creating an artifact | `templates/proposal.md` |
+
+### Hierarchy
+
+```
+Schema (defines) â”€â”€â†’ Artifacts (guided by) â”€â”€â†’ Templates
+```
+
+- **Schema** = the artifact graph (what exists, dependencies)
+- **Artifact** = a document to produce
+- **Template** = instructions for creating that artifact
+
+### Schema Variations
+
+Schemas can vary across multiple dimensions:
+
+| Dimension | Examples |
+|-----------|----------|
+| Philosophy | `spec-driven`, `tdd`, `prototype-first` |
+| Version | `v1`, `v2`, `v3` |
+| Language | `en`, `zh`, `es` |
+| Custom | `team-alpha`, `experimental` |
+
+### Schema Resolution (XDG Standard)
+
+Schemas follow the XDG Base Directory Specification with a 2-level resolution:
+
+```
+1. ${XDG_DATA_HOME}/openspec/schemas/<name>/schema.yaml   # Global user override
+2. <package>/schemas/<name>/schema.yaml                    # Built-in defaults
+```
+
+**Platform-specific paths:**
+- Unix/macOS: `~/.local/share/openspec/schemas/`
+- Windows: `%LOCALAPPDATA%/openspec/schemas/`
+- All platforms: `$XDG_DATA_HOME/openspec/schemas/` (when set)
+
+**Why XDG?**
+- Schemas are workflow definitions (data), not user preferences (config)
+- Built-ins baked into package, never auto-copied
+- Users customize by creating files in global data dir
+- Consistent with modern CLI tooling standards
+
+### Template Inheritance (2 Levels Max)
+
+Templates are co-located with schemas in a `templates/` subdirectory:
+
+```
+1. ${XDG_DATA_HOME}/openspec/schemas/<schema>/templates/<artifact>.md  # User override
+2. <package>/schemas/<schema>/templates/<artifact>.md                   # Built-in
+```
+
+**Rules:**
+- User overrides take precedence over package built-ins
+- A CLI command shows resolved paths (no guessing)
+- No inheritance between schemas (copy if you need to diverge)
+- Templates are always co-located with their schema
+
+**Why this matters:**
+- Avoids "where does this come from?" debugging
+- No implicit magic that works until it doesn't
+- Schema + templates form a cohesive unit
+
+---
+
+## Executive Summary
+
+This is an **artifact tracker with dependency awareness** that guides iterative development through a structured artifact pipeline. The core innovation is using the **filesystem as a database** - artifact completion is detected by file existence, making the system stateless and version-control friendly.
+
+The system answers:
+- "What artifacts exist for this change?"
+- "What could I create next?" (not "what must I create")
+- "What's blocking X?" (informational, not prescriptive)
+
+---
+
+## Core Components
+
+### 1. ArtifactGraph (Slice 1 - COMPLETE)
+
+The dependency graph engine with XDG-compliant schema resolution.
+
+| Responsibility | Approach |
+|----------------|----------|
+| Model artifacts as a DAG | Artifact with `requires: string[]` |
+| Track completion state | `Set<string>` for completed artifacts |
+| Calculate build order | Kahn's algorithm (topological sort) |
+| Find ready artifacts | Check if all dependencies are in `completed` set |
+| Resolve schemas | XDG global â†’ package built-ins |
+
+**Key Data Structures (Zod-validated):**
+
+```typescript
+// Zod schemas define types + validation
+const ArtifactSchema = z.object({
+  id: z.string().min(1),
+  generates: z.string().min(1),      // e.g., "proposal.md" or "specs/*.md"
+  description: z.string(),
+  template: z.string(),              // path to template file
+  requires: z.array(z.string()).default([]),
+});
+
+const SchemaYamlSchema = z.object({
+  name: z.string().min(1),
+  version: z.number().int().positive(),
+  description: z.string().optional(),
+  artifacts: z.array(ArtifactSchema).min(1),
+});
+
+// Derived types
+type Artifact = z.infer<typeof ArtifactSchema>;
+type SchemaYaml = z.infer<typeof SchemaYamlSchema>;
+```
+
+**Key Methods:**
+- `resolveSchema(name)` - Load schema with XDG fallback
+- `ArtifactGraph.fromSchema(schema)` - Build graph from schema
+- `detectState(graph, changeDir)` - Scan filesystem for completion
+- `getNextArtifacts(graph, completed)` - Find artifacts ready to create
+- `getBuildOrder(graph)` - Topological sort of all artifacts
+- `getBlocked(graph, completed)` - Artifacts with unmet dependencies
+
+---
+
+### 2. Change Utilities (Slice 2)
+
+Simple utility functions for programmatic change creation. No class, no abstraction layer.
+
+| Responsibility | Approach |
+|----------------|----------|
+| Create changes | Create dirs under `openspec/changes/<name>/` with README |
+| Name validation | Enforce kebab-case naming |
+
+**Key Paths:**
+
+```
+openspec/changes/<name>/   â†’ Change instances with artifacts (project-level)
+```
+
+**Key Functions** (`src/utils/change-utils.ts`):
+- `createChange(projectRoot, name, description?)` - Create new change directory + README
+- `validateChangeName(name)` - Validate kebab-case naming, returns `{ valid, error? }`
+
+**Note:** Existing CLI commands (`ListCommand`, `ChangeCommand`) already handle listing, path resolution, and existence checks. No need to extract that logic - it works fine as-is.
+
+---
+
+### 3. InstructionLoader (Slice 3)
+
+Template resolution and instruction enrichment.
+
+| Responsibility | Approach |
+|----------------|----------|
+| Resolve templates | XDG 2-level fallback (schema-specific â†’ shared â†’ built-in) |
+| Build dynamic context | Gather dependency status, change info |
+| Enrich templates | Inject context into base templates |
+| Generate status reports | Formatted markdown with progress |
+
+**Key Class - ChangeState:**
+
+```
+ChangeState {
+  changeName: string
+  changeDir: string
+  graph: ArtifactGraph
+  completed: Set<string>
+
+  // Methods
+  getNextSteps(): string[]
+  getStatus(artifactId): ArtifactStatus
+  isComplete(): boolean
+}
+```
+
+**Key Functions:**
+- `getTemplatePath(artifactId, schemaName?)` - Resolve with 2-level fallback
+- `getEnrichedInstructions(artifactId, projectRoot, changeName?)` - Main entry point
+- `getChangeStatus(projectRoot, changeName?)` - Formatted status report
+
+---
+
+### 4. CLI (Slice 4)
+
+User interface layer. **All commands are deterministic** - require explicit `--change` parameter.
+
+| Command | Function | Status |
+|---------|----------|--------|
+| `status --change <id>` | Show change progress (artifact graph) | **NEW** |
+| `next --change <id>` | Show artifacts ready to create | **NEW** |
+| `instructions <artifact> --change <id>` | Get enriched instructions for artifact | **NEW** |
+| `list` | List all changes | EXISTS (`openspec change list`) |
+| `new <name>` | Create change | **NEW** (uses `createChange()`) |
+| `init` | Initialize structure | EXISTS (`openspec init`) |
+| `templates --change <id>` | Show resolved template paths | **NEW** |
+
+**Note:** Commands that operate on a change require `--change`. Missing parameter â†’ error with list of available changes. Agent infers the change from conversation and passes it explicitly.
+
+**Existing CLI commands** (not part of this slice):
+- `openspec change list` / `openspec change show <id>` / `openspec change validate <id>`
+- `openspec list --changes` / `openspec list --specs`
+- `openspec view` (dashboard)
+- `openspec init` / `openspec archive <change>`
+
+---
+
+### 5. Claude Commands
+
+Integration layer for Claude Code. **Operational commands only** - artifact creation via natural language.
+
+| Command | Purpose |
+|---------|---------|
+| `/status` | Show change progress |
+| `/next` | Show what's ready to create |
+| `/run [artifact]` | Execute a specific step (power users) |
+| `/list` | List all changes |
+| `/new <name>` | Create a new change |
+| `/init` | Initialize structure |
+
+**Artifact creation:** Users say "create the proposal" or "write the tests" in natural language. The agent:
+1. Infers change from conversation (confirms if uncertain)
+2. Infers artifact from request
+3. Calls CLI with explicit `--change` parameter
+4. Creates artifact following instructions
+
+This works for ANY artifact in ANY schema - no new slash commands needed when schemas change.
+
+**Note:** Legacy commands (`/openspec-proposal`, `/openspec-apply`, `/openspec-archive`) exist in the main project for backward compatibility but are separate from this architecture.
+
+---
+
+## Component Dependency Graph
+
+```
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚                     PRESENTATION LAYER                       â”‚
+â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
+â”‚  â”‚     CLI      â”‚ â†â”€shell execâ”€â”€â”€â”€â”€â”€â”€â”‚ Claude Commands    â”‚ â”‚
+â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+          â”‚ imports
+          â–¼
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚                    ORCHESTRATION LAYER                       â”‚
+â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
+â”‚  â”‚ InstructionLoader  â”‚        â”‚  change-utils (Slice 2)  â”‚ â”‚
+â”‚  â”‚    (Slice 3)       â”‚        â”‚  createChange()          â”‚ â”‚
+â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚  validateChangeName()    â”‚ â”‚
+â”‚            â”‚                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+             â”‚ uses
+             â–¼
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚                      CORE LAYER                              â”‚
+â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
+â”‚  â”‚               ArtifactGraph (Slice 1)                â”‚   â”‚
+â”‚  â”‚                                                      â”‚   â”‚
+â”‚  â”‚  Schema Resolution (XDG) â”€â”€â†’ Graph â”€â”€â†’ State Detectionâ”‚   â”‚
+â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+             â–²
+             â”‚ reads from
+             â–¼
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚                   PERSISTENCE LAYER                          â”‚
+â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
+â”‚  â”‚  XDG Schemas     â”‚   â”‚  Project Artifacts             â”‚  â”‚
+â”‚  â”‚  ~/.local/share/ â”‚   â”‚  openspec/changes/<name>/      â”‚  â”‚
+â”‚  â”‚  openspec/       â”‚   â”‚  - proposal.md, design.md      â”‚  â”‚
+â”‚  â”‚  schemas/        â”‚   â”‚  - specs/*.md, tasks.md        â”‚  â”‚
+â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+```
+
+---
+
+## Key Design Patterns
+
+### 1. Filesystem as Database
+
+No SQLite, no JSON state files. The existence of `proposal.md` means proposal is complete.
+
+```
+// State detection is just file existence checking
+if (exists(artifactPath)) {
+  completed.add(artifactId)
+}
+```
+
+### 2. Deterministic CLI, Inferring Agent
+
+**CLI layer:** Always deterministic - requires explicit `--change` parameter.
+
+```
+openspec status --change add-auth     # explicit, works
+openspec status                        # error: "No change specified"
+```
+
+**Agent layer:** Infers from conversation, confirms if uncertain, passes explicit `--change`.
+
+This separation means:
+- CLI is pure, testable, no state to corrupt
+- Agent handles all "smartness"
+- No config.yaml tracking of "active change"
+
+### 3. XDG-Compliant Schema Resolution
+
+```
+${XDG_DATA_HOME}/openspec/schemas/<name>/schema.yaml   # User override
+    â†“ (not found)
+<package>/schemas/<name>/schema.yaml                    # Built-in
+    â†“ (not found)
+Error (schema not found)
+```
+
+### 4. Two-Level Template Fallback
+
+```
+${XDG_DATA_HOME}/openspec/schemas/<schema>/templates/<artifact>.md  # User override
+    â†“ (not found)
+<package>/schemas/<schema>/templates/<artifact>.md                   # Built-in
+    â†“ (not found)
+Error (no silent fallback to avoid confusion)
+```
+
+### 5. Glob Pattern Support
+
+`specs/*.md` allows multiple files to satisfy a single artifact:
+
+```
+if (artifact.generates.includes("*")) {
+  const parentDir = changeDir / patternParts[0]
+  if (exists(parentDir) && hasFiles(parentDir)) {
+    completed.add(artifactId)
+  }
+}
+```
+
+### 6. Stateless State Detection
+
+Every command re-scans the filesystem. No cached state to corrupt.
+
+---
+
+## Artifact Pipeline (Default Schema)
+
+The default `spec-driven` schema:
+
+```
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚ proposal â”‚  (no dependencies)
+â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
+     â”‚
+     â–¼
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚  specs   â”‚  (requires: proposal)
+â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
+     â”‚
+     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+     â–¼              â–¼
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚  design  â”‚   â”‚          â”‚
+â”‚          â”‚â—„â”€â”€â”¤ proposal â”‚
+â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+     â”‚         (requires: proposal, specs)
+     â–¼
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚  tasks   â”‚  (requires: design)
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+```
+
+Other schemas (TDD, prototype-first) would have different graphs.
+
+---
+
+## Implementation Order
+
+Structured as **vertical slices** - each slice is independently testable.
+
+---
+
+### Slice 1: "What's Ready?" (Core Query) âœ… COMPLETE
+
+**Delivers:** Types + Graph + State Detection + Schema Resolution
+
+**Implementation:** `src/core/artifact-graph/`
+- `types.ts` - Zod schemas and derived TypeScript types
+- `schema.ts` - YAML parsing with Zod validation
+- `graph.ts` - ArtifactGraph class with topological sort
+- `state.ts` - Filesystem-based state detection
+- `resolver.ts` - XDG-compliant schema resolution
+- `builtin-schemas.ts` - Package-bundled default schemas
+
+**Key decisions made:**
+- Zod for schema validation (consistent with project)
+- XDG for global schema overrides
+- `Set<string>` for completion state (immutable, functional)
+- `inProgress` and `failed` states deferred (require external tracking)
+
+---
+
+### Slice 2: "Change Creation Utilities"
+
+**Delivers:** Utility functions for programmatic change creation
+
+**Scope:**
+- `createChange(projectRoot, name, description?)` â†’ creates directory + README
+- `validateChangeName(name)` â†’ kebab-case pattern enforcement
+
+**Not in scope (already exists in CLI commands):**
+- `listChanges()` â†’ exists in `ListCommand` and `ChangeCommand.getActiveChanges()`
+- `getChangePath()` â†’ simple `path.join()` inline
+- `changeExists()` â†’ simple `fs.access()` inline
+- `isInitialized()` â†’ simple directory check inline
+
+**Why simplified:** Extracting existing CLI logic into a class would require similar refactoring of `SpecCommand` for consistency. The existing code works fine (~15 lines each). Only truly new functionality is `createChange()` + name validation.
+
+---
+
+### Slice 3: "Get Instructions" (Enrichment)
+
+**Delivers:** Template resolution + context injection
+
+**Testable behaviors:**
+- Template fallback: schema-specific â†’ shared â†’ built-in â†’ error
+- Context injection: completed deps show âœ“, missing show âœ—
+- Output path shown correctly based on change directory
+
+---
+
+### Slice 4: "CLI + Integration"
+
+**Delivers:** New artifact graph commands (builds on existing CLI)
+
+**New commands:**
+- `status --change <id>` - Show artifact completion state
+- `next --change <id>` - Show ready-to-create artifacts
+- `instructions <artifact> --change <id>` - Get enriched template
+- `templates --change <id>` - Show resolved paths
+- `new <name>` - Create change (wrapper for `createChange()`)
+
+**Already exists (not in scope):**
+- `openspec change list/show/validate` - change management
+- `openspec list --changes/--specs` - listing
+- `openspec view` - dashboard
+- `openspec init` - initialization
+
+**Testable behaviors:**
+- Each new command produces expected output
+- Commands compose correctly (status â†’ next â†’ instructions flow)
+- Error handling for missing changes, invalid artifacts, etc.
+
+---
+
+## Directory Structure
+
+```
+# Global (XDG paths - user overrides)
+~/.local/share/openspec/           # Unix/macOS ($XDG_DATA_HOME/openspec/)
+%LOCALAPPDATA%/openspec/           # Windows
+â””â”€â”€ schemas/                       # Schema overrides
+    â””â”€â”€ custom-workflow/           # User-defined schema directory
+        â”œâ”€â”€ schema.yaml            # Schema definition
+        â””â”€â”€ templates/             # Co-located templates
+            â””â”€â”€ proposal.md
+
+# Package (built-in defaults)
+<package>/
+â””â”€â”€ schemas/                       # Built-in schema definitions
+    â”œâ”€â”€ spec-driven/               # Default: proposal â†’ specs â†’ design â†’ tasks
+    â”‚   â”œâ”€â”€ schema.yaml
+    â”‚   â””â”€â”€ templates/
+    â”‚       â”œâ”€â”€ proposal.md
+    â”‚       â”œâ”€â”€ design.md
+    â”‚       â”œâ”€â”€ spec.md
+    â”‚       â””â”€â”€ tasks.md
+    â””â”€â”€ tdd/                       # TDD: tests â†’ implementation â†’ docs
+        â”œâ”€â”€ schema.yaml
+        â””â”€â”€ templates/
+            â”œâ”€â”€ test.md
+            â”œâ”€â”€ implementation.md
+            â”œâ”€â”€ spec.md
+            â””â”€â”€ docs.md
+
+# Project (change instances)
+openspec/
+â””â”€â”€ changes/                       # Change instances
+    â”œâ”€â”€ add-auth/
+    â”‚   â”œâ”€â”€ README.md              # Auto-generated on creation
+    â”‚   â”œâ”€â”€ proposal.md            # Created artifacts
+    â”‚   â”œâ”€â”€ design.md
+    â”‚   â””â”€â”€ specs/
+    â”‚       â””â”€â”€ *.md
+    â”œâ”€â”€ refactor-db/
+    â”‚   â””â”€â”€ ...
+    â””â”€â”€ archive/                   # Completed changes
+        â””â”€â”€ 2025-01-01-add-auth/
+
+.claude/
+â”œâ”€â”€ settings.local.json            # Permissions
+â””â”€â”€ commands/                      # Slash commands
+    â””â”€â”€ *.md
+```
+
+---
+
+## Schema YAML Format
+
+```yaml
+# Built-in: <package>/schemas/spec-driven/schema.yaml
+# Or user override: ~/.local/share/openspec/schemas/spec-driven/schema.yaml
+name: spec-driven
+version: 1
+description: Specification-driven development
+
+artifacts:
+  - id: proposal
+    generates: "proposal.md"
+    description: "Create project proposal document"
+    template: "proposal.md"          # resolves from co-located templates/ directory
+    requires: []
+
+  - id: specs
+    generates: "specs/*.md"          # glob pattern
+    description: "Create technical specification documents"
+    template: "specs.md"
+    requires:
+      - proposal
+
+  - id: design
+    generates: "design.md"
+    description: "Create design document"
+    template: "design.md"
+    requires:
+      - proposal
+      - specs
+
+  - id: tasks
+    generates: "tasks.md"
+    description: "Create tasks breakdown document"
+    template: "tasks.md"
+    requires:
+      - design
+```
+
+---
+
+## Summary
+
+| Layer | Component | Responsibility | Status |
+|-------|-----------|----------------|--------|
+| Core | ArtifactGraph | Pure dependency logic + XDG schema resolution | âœ… Slice 1 COMPLETE |
+| Utils | change-utils | Change creation + name validation only | Slice 2 (new functionality only) |
+| Core | InstructionLoader | Template resolution + enrichment | Slice 3 (all new) |
+| Presentation | CLI | New artifact graph commands | Slice 4 (new commands only) |
+| Integration | Claude Commands | AI assistant glue | Slice 4 |
+
+**What already exists (not in this proposal):**
+- `getActiveChangeIds()` in `src/utils/item-discovery.ts` - list changes
+- `ChangeCommand.list/show/validate()` in `src/commands/change.ts`
+- `ListCommand.execute()` in `src/core/list.ts`
+- `ViewCommand.execute()` in `src/core/view.ts` - dashboard
+- `src/core/init.ts` - initialization
+- `src/core/archive.ts` - archiving
+
+**Key Principles:**
+- **Filesystem IS the database** - stateless, version-control friendly
+- **Dependencies are enablers** - show what's possible, don't force order
+- **Deterministic CLI, inferring agent** - CLI requires explicit `--change`, agent infers from context
+- **XDG-compliant paths** - schemas and templates use standard user data directories
+- **2-level inheritance** - user override â†’ package built-in (no deeper)
+- **Schemas are versioned** - support variations by philosophy, version, language
diff --git a/docs/experimental-release-plan.md b/docs/experimental-release-plan.md
new file mode 100644
index 0000000..387b48c
--- /dev/null
+++ b/docs/experimental-release-plan.md
@@ -0,0 +1,926 @@
+# OpenSpec Experimental Release Plan
+
+This document outlines the plan to release the experimental artifact workflow system for user testing.
+
+## Overview
+
+The goal is to allow users to test the new artifact-driven workflow system alongside the existing OpenSpec commands. This experimental system (`opsx`) provides a more granular, step-by-step approach to creating change artifacts.
+
+## Three Workflow Modes
+
+### 1. Old Workflow (Current Production)
+- **Commands**: `/openspec:proposal`, `/openspec:apply`, `/openspec:archive`
+- **Behavior**: Hardcoded slash commands that generate all artifacts in one command
+- **Status**: Production, unchanged
+
+### 2. New Artifact System - Batch Mode (Future)
+- **Commands**: Refactored `/openspec:proposal` using schemas
+- **Behavior**: Schema-driven but generates all artifacts at once (like legacy)
+- **Status**: Not in scope for this experimental release
+- **Note**: This is a future refactor to unify the old system with schemas
+
+### 3. New Artifact System - Granular Mode (Experimental)
+- **Commands**: `/opsx:new`, `/opsx:continue`
+- **Behavior**: One artifact at a time, dependency-driven, iterative
+- **Status**: Target for this experimental release
+
+---
+
+## Work Items
+
+### 1. Rename AWF to OPSX
+
+**Current State:**
+- Commands: `/awf:start`, `/awf:continue`
+- Files: `.claude/commands/awf/start.md`, `.claude/commands/awf/continue.md`
+
+**Target State:**
+- Commands: `/opsx:new`, `/opsx:continue`
+- Files: `.claude/commands/opsx/new.md`, `.claude/commands/opsx/continue.md`
+
+**Tasks:**
+- [x] Create `.claude/commands/opsx/` directory
+- [x] Rename `start.md` â†’ `new.md` and update content
+- [x] Copy `continue.md` with updated references
+- [x] Update all references from "awf" to "opsx" in command content
+- [x] Update frontmatter (name, description) to use "opsx" naming
+- [x] Remove `.claude/commands/awf/` directory
+
+**CLI Commands:**
+The underlying CLI commands (`openspec status`, `openspec instructions`, etc.) remain unchanged. Only the slash command names change.
+
+---
+
+### 2. Remove WF Skill Files
+
+**Current State:**
+- `.claude/commands/wf/start.md` - References non-existent `openspec wf` commands
+- `.claude/commands/wf/continue.md` - References non-existent `openspec wf` commands
+
+**Target State:**
+- Directory and files removed
+
+**Tasks:**
+- [x] Delete `.claude/commands/wf/start.md`
+- [x] Delete `.claude/commands/wf/continue.md`
+- [x] Delete `.claude/commands/wf/` directory
+
+---
+
+### 3. Add Agent Skills for Experimental Workflow
+
+**Purpose:**
+Generate experimental workflow skills using the [Agent Skills](https://agentskills.io/specification) open standard.
+
+**Why Skills Instead of Slash Commands:**
+- **Cross-editor compatibility**: Skills work in Claude Code, Cursor, Windsurf, and other compatible editors automatically
+- **Simpler implementation**: Single directory (`.claude/skills/`) instead of 18+ editor-specific configurators
+- **Standard format**: Open standard with simple YAML frontmatter + markdown
+- **User invocation**: Users explicitly invoke skills when they want to use them
+
+**Behavior:**
+1. Create `.claude/skills/` directory if it doesn't exist
+2. Generate two skills using the Agent Skills specification:
+   - `openspec-new-change/SKILL.md` - Start a new change with artifact workflow
+   - `openspec-continue-change/SKILL.md` - Continue working on a change (create next artifact)
+3. Skills are added **alongside** existing `/openspec:*` commands (not replacing)
+
+**Supported Editors:**
+- Claude Code (native support)
+- Cursor (native support via Settings â†’ Rules â†’ Import Settings)
+- Windsurf (imports `.claude` configs)
+- Cline, Codex, and other Agent Skills-compatible editors
+
+**Tasks:**
+- [x] Create skill template content for `openspec-new-change` (based on current opsx:new)
+- [x] Create skill template content for `openspec-continue-change` (based on current opsx:continue)
+- [x] Add temporary `artifact-experimental-setup` command to CLI
+- [x] Implement skill file generation (YAML frontmatter + markdown body)
+- [x] Add success message with usage instructions
+
+**Note:** The `artifact-experimental-setup` command is temporary and will be merged into `openspec init` once the experimental workflow is promoted to stable.
+
+**Skill Format:**
+Each skill is a directory with a `SKILL.md` file:
+```
+.claude/skills/
+â”œâ”€â”€ openspec-new-change/
+â”‚   â””â”€â”€ SKILL.md          # name, description, instructions
+â”œâ”€â”€ openspec-continue-change/
+â”‚   â””â”€â”€ SKILL.md          # name, description, instructions
+â””â”€â”€ openspec-apply-change/
+    â””â”€â”€ SKILL.md          # name, description, instructions
+```
+
+**CLI Interface:**
+```bash
+openspec artifact-experimental-setup
+
+# Output:
+# ğŸ§ª Experimental Artifact Workflow Skills Created
+#
+#   âœ“ .claude/skills/openspec-new-change/SKILL.md
+#   âœ“ .claude/skills/openspec-continue-change/SKILL.md
+#   âœ“ .claude/skills/openspec-apply-change/SKILL.md
+#
+# ğŸ“– Usage:
+#
+#   Skills work automatically in compatible editors:
+#   â€¢ Claude Code - Auto-detected, ready to use
+#   â€¢ Cursor - Enable in Settings â†’ Rules â†’ Import Settings
+#   â€¢ Windsurf - Auto-imports from .claude directory
+#
+#   Ask Claude naturally:
+#   â€¢ "I want to start a new OpenSpec change to add <feature>"
+#   â€¢ "Continue working on this change"
+#
+#   Claude will automatically use the appropriate skill.
+#
+# ğŸ’¡ This is an experimental feature.
+#    Feedback welcome at: https://github.com/Fission-AI/OpenSpec/issues
+```
+
+**Implementation Notes:**
+- Simple file writing: Create directories and write templated `SKILL.md` files (no complex logic)
+- Use existing `FileSystemUtils.writeFile()` pattern like slash command configurators
+- Template structure: YAML frontmatter + markdown body
+- Keep existing `/opsx:*` slash commands for now (manual cleanup later)
+- Skills use invocation model (user explicitly asks Claude to use them)
+- Skill `description` field guides when Claude suggests using the skill
+- Each `SKILL.md` has required fields: `name` (matches directory) and `description`
+
+---
+
+### 4. Update `/opsx:new` Command Content
+
+**Current Behavior (awf:start):**
+1. Ask user what they want to build (if no input)
+2. Create change directory
+3. Show artifact status
+4. Show what's ready
+5. Get instructions for proposal
+6. STOP and wait
+
+**New Behavior (opsx:new):**
+Same flow but with updated naming:
+- References to "awf" â†’ "opsx"
+- References to `/awf:continue` â†’ `/opsx:continue`
+- Update frontmatter name/description
+
+**Tasks:**
+- [x] Update all "awf" references to "opsx"
+- [x] Update command references in prompt text
+- [x] Verify CLI commands still work (they use `openspec`, not `awf`)
+
+---
+
+### 5. Update `/opsx:continue` Command Content
+
+**Current Behavior (awf:continue):**
+1. Prompt for change selection (if not provided)
+2. Check current status
+3. Create ONE artifact based on what's ready
+4. Show progress and what's unlocked
+5. STOP
+
+**New Behavior (opsx:continue):**
+Same flow with updated naming.
+
+**Tasks:**
+- [x] Update all "awf" references to "opsx"
+- [x] Update command references in prompt text
+
+---
+
+### 6. End-to-End Testing
+
+**Objective:**
+Run through a complete workflow with Claude using the new skills to create a real feature, validating the entire flow works.
+
+**Test Scenario:**
+Use a real OpenSpec feature as the test case (dog-fooding).
+
+**Test Flow:**
+1. Run `openspec artifact-experimental-setup` to create skills
+2. Verify `.claude/skills/openspec-new-change/SKILL.md` created
+3. Verify `.claude/skills/openspec-continue-change/SKILL.md` created
+4. Verify `.claude/skills/openspec-apply-change/SKILL.md` created
+5. Ask Claude: "I want to start a new OpenSpec change to add feature X"
+6. Verify Claude invokes the `openspec-new-change` skill
+7. Verify change directory created at `openspec/changes/add-feature-x/`
+8. Verify proposal template shown
+9. Ask Claude: "Continue working on this change"
+10. Verify Claude invokes the `openspec-continue-change` skill
+11. Verify `proposal.md` created with content
+12. Ask Claude: "Continue" (create specs)
+13. Verify `specs/*.md` created
+14. Ask Claude: "Continue" (create design)
+15. Verify `design.md` created
+16. Ask Claude: "Continue" (create tasks)
+17. Verify `tasks.md` created
+18. Verify status shows 4/4 complete
+19. Implement the feature based on tasks
+20. Run `/openspec:archive` to archive the change
+
+**Validation Checklist:**
+- [ ] `openspec artifact-experimental-setup` creates correct directory structure
+- [ ] Skills are auto-detected in Claude Code
+- [ ] Skill descriptions trigger appropriate invocations
+- [ ] Skills create change directory and show proposal template
+- [ ] Skills correctly identify ready artifacts
+- [ ] Skills create artifacts with meaningful content
+- [ ] Dependency detection works (specs requires proposal, etc.)
+- [ ] Progress tracking is accurate
+- [ ] Template content is useful and well-structured
+- [ ] Error handling works (invalid names, missing changes, etc.)
+- [ ] Works with different schemas (spec-driven, tdd)
+- [ ] Test in Cursor (Settings â†’ Rules â†’ Import Settings)
+
+**Document Results:**
+- Create test log documenting what worked and what didn't
+- Note any friction points or confusing UX
+- Identify bugs or improvements needed before user release
+
+---
+
+### 7. Documentation for Users
+
+**Create user-facing documentation explaining:**
+
+1. **What is the experimental workflow?**
+   - A new way to create OpenSpec changes step-by-step using Agent Skills
+   - One artifact at a time with dependency tracking
+   - More interactive and iterative than the batch approach
+   - Works across Claude Code, Cursor, Windsurf, and other compatible editors
+
+2. **How to set up experimental workflow**
+   ```bash
+   openspec artifact-experimental-setup
+   ```
+
+   Note: This is a temporary command that will be integrated into `openspec init` once promoted to stable.
+
+3. **Available skills**
+   - `openspec-new-change` - Start a new change with artifact workflow
+   - `openspec-continue-change` - Continue working (create next artifact)
+
+4. **How to use**
+   - **Claude Code**: Skills are auto-detected, just ask Claude naturally
+     - "I want to start a new OpenSpec change to add X"
+     - "Continue working on this change"
+   - **Cursor**: Enable in Settings â†’ Rules â†’ Import Settings
+   - **Windsurf**: Auto-imports `.claude` directory
+
+5. **Example workflow**
+   - Step-by-step walkthrough with natural language interactions
+   - Show how Claude invokes skills based on user requests
+
+6. **Feedback mechanism**
+   - GitHub issue template for feedback
+   - What to report (bugs, UX issues, suggestions)
+
+**Tasks:**
+- [ ] Create `docs/experimental-workflow.md` user guide
+- [ ] Add GitHub issue template for experimental feedback
+- [ ] Update README with mention of experimental features
+
+---
+
+## Dependency Graph
+
+```
+1. Remove WF skill files
+   â””â”€â”€ (no dependencies)
+
+2. Rename AWF to OPSX
+   â””â”€â”€ (no dependencies)
+
+3. Add Agent Skills
+   â””â”€â”€ Depends on: Rename AWF to OPSX (uses opsx content as templates)
+
+4. Update opsx:new content
+   â””â”€â”€ Depends on: Rename AWF to OPSX
+
+5. Update opsx:continue content
+   â””â”€â”€ Depends on: Rename AWF to OPSX
+
+6. E2E Testing
+   â””â”€â”€ Depends on: Add Agent Skills (tests the skills workflow)
+
+7. User Documentation
+   â””â”€â”€ Depends on: E2E Testing (need to know final behavior)
+```
+
+---
+
+## Out of Scope
+
+The following are explicitly NOT part of this experimental release:
+
+1. **Batch mode refactor** - Making legacy `/openspec:proposal` use schemas
+2. **New schemas** - Only shipping with existing `spec-driven` and `tdd`
+3. **Schema customization UI** - No `openspec schema list` or similar
+4. **Multiple editor support in CLI** - Skills work cross-editor automatically via `.claude/skills/`
+5. **Replacing existing commands** - Skills are additive, not replacing `/openspec:*` or `/opsx:*`
+
+---
+
+## Success Criteria
+
+The experimental release is ready when:
+
+1. `openspec-new-change`, `openspec-continue-change`, and `openspec-apply-change` skills work end-to-end
+2. `openspec artifact-experimental-setup` creates skills in `.claude/skills/`
+3. Skills work in Claude Code and are compatible with Cursor/Windsurf
+4. At least one complete workflow has been tested manually
+5. User documentation exists explaining how to generate and use skills
+6. Feedback mechanism is in place
+7. WF skill files are removed
+8. No references to "awf" remain in user-facing content
+
+---
+
+## Open Questions
+
+1. **Schema selection** - Should `opsx:new` allow selecting a schema, or always use `spec-driven`?
+   - Current: Always uses `spec-driven` as default
+   - Consider: Add `--schema tdd` option or prompt
+
+2. **Namespace in CLI** - Should experimental CLI commands be namespaced?
+   - Current: `openspec status`, `openspec instructions` (no namespace)
+   - Alternative: `openspec opsx status` (explicit experimental namespace)
+   - Recommendation: Keep current, less typing for users
+
+3. **Deprecation path** - If opsx becomes the default, how do we migrate?
+   - Not needed for experimental release
+   - Document that command names may change
+
+---
+
+## Estimated Work Breakdown
+
+| Item | Complexity | Notes |
+|------|------------|-------|
+| Remove WF files | Trivial | Just delete 2 files + directory |
+| Rename AWF â†’ OPSX | Low | File renames + content updates |
+| Add Agent Skills | **Low** | **Simple: 3-4 files, single output directory, standard format** |
+| Update opsx:new content | Low | Text replacements |
+| Update opsx:continue content | Low | Text replacements |
+| E2E Testing | Medium | Manual testing, documenting results |
+| User Documentation | Medium | New docs, issue template |
+
+**Key Improvement:** Switching to Agent Skills reduces complexity significantly:
+- **Before:** 20+ files (type definitions, 18+ editor configurators, editor selection UI)
+- **After:** 3-4 files (skill templates, simple CLI command)
+- **Cross-editor:** Works automatically in Claude Code, Cursor, Windsurf without extra code
+
+---
+
+## User Feedback from E2E Testing
+
+### What Worked Well
+
+1. **Clear dependency graph** â­ HIGH PRIORITY - KEEP
+   - The status command showing blocked/unblocked artifacts was intuitive:
+     ```
+     [x] proposal
+     [ ] design
+     [-] tasks (blocked by: design, specs)
+     ```
+   - Users always knew what they could work on next
+   - **Relevance**: Core UX strength to preserve
+
+2. **Structured instructions output** â­ HIGH PRIORITY - KEEP
+   - `openspec instructions <artifact>` gave templates, output paths, and context in one call
+   - Very helpful for understanding what to create
+   - **Relevance**: Essential for agent-driven workflow
+
+3. **Simple scaffolding** âœ… WORKS WELL
+   - `openspec new change "name"` just worked - created directory structure without fuss
+   - **Relevance**: Good baseline, room for improvement (see pain points)
+
+---
+
+### Pain Points & Confusion
+
+1. **Redundant CLI calls** âš ï¸ MEDIUM PRIORITY
+   - Users called both `status` AND `next` every time, but they overlap significantly
+   - `status` already shows what's blocked
+   - **Recommendation**: Consider merging or making `next` give actionable guidance beyond just listing names
+   - **Relevance**: Reduces friction in iterative workflow
+
+2. **Specs directory structure was ambiguous** ğŸ”¥ HIGH PRIORITY - FIX
+   - Instructions said: `Write to: .../specs/**/*.md`
+   - Users had to guess: `specs/spec.md`? `specs/game/spec.md`? `specs/tic-tac-toe/spec.md`?
+   - Users ended up doing manual `mkdir -p .../specs/tic-tac-toe` then writing `spec.md` inside
+   - **Recommendation**: CLI should scaffold this directory structure automatically
+   - **Relevance**: Critical agent UX - ambiguous paths cause workflow friction
+
+3. **Repetitive --change flag** âš ï¸ MEDIUM PRIORITY
+   - Every command needed `--change "tic-tac-toe-game"`
+   - After 10+ calls, this felt verbose
+   - **Recommendation**: `openspec use "tic-tac-toe-game"` to set context, then subsequent commands assume that change
+   - **Relevance**: Quality of life improvement for iterative sessions
+
+4. **No validation feedback** ğŸ”¥ HIGH PRIORITY - ADD
+   - After writing each artifact, users just ran `status` hoping it would show `[x]`
+   - Questions raised:
+     - How did it know the artifact was "done"? File existence?
+     - What if spec format was wrong (e.g., wrong heading levels)?
+   - **Recommendation**: Add `openspec validate --change "name"` to check content quality
+   - **Relevance**: Critical for user confidence and catching errors early
+
+5. **Query-heavy, action-light CLI** ğŸ”¥ HIGH PRIORITY - ENHANCE
+   - Most commands retrieve info. The only "action" is `new change`
+   - Artifact creation is manual Write to guessed paths
+   - **Recommendation**: `openspec create proposal --change "name"` could scaffold the file with template pre-filled, then user just edits
+   - **Relevance**: Directly impacts agent productivity - reduce manual file writing
+
+6. **Instructions output was verbose** âš ï¸ LOW PRIORITY
+   - XML-style output (`<artifact>`, `<template>`, `<instruction>`) was parseable but long
+   - Key info (output path, template) was buried in ~50 lines
+   - **Recommendation**: Add compact mode or structured JSON output for agents
+   - **Relevance**: Nice-to-have for agent parsing efficiency
+
+---
+
+### Workflow Friction
+
+1. **Mandatory "STOP and wait" after showing proposal template** âš ï¸ MEDIUM PRIORITY
+   - The skill said "STOP and wait" after showing the proposal template
+   - This felt overly cautious when user had already provided enough context (e.g., "tic tac toe, single player vs AI, minimal aesthetics")
+   - **Recommendation**: Make the pause optional or conditional based on context clarity
+   - **Relevance**: Reduces unnecessary round-trips in agent conversations
+
+2. **No connection to implementation** ğŸ”¥ HIGH PRIORITY - ROADMAP ITEM
+   - After 4/4 artifacts complete, then what? The workflow ends at planning
+   - No `openspec apply` or guidance on how to execute the tasks
+   - User asked "would you like me to implement?" but that's outside OpenSpec's scope currently
+   - **Recommendation**: Add implementation bridge - either:
+     - `openspec apply` command to start execution phase
+     - Clear handoff to existing `/openspec:apply` workflow
+     - Documentation on next steps after planning completes
+   - **Relevance**: Critical missing piece - users expect end-to-end workflow
+
+---
+
+### Priority Summary
+
+**MUST FIX (High Priority):**
+1. Specs directory structure ambiguity (#2)
+2. Add validation feedback (#4)
+3. Make CLI more action-oriented (#5)
+4. Bridge to implementation phase (#2 in Workflow Friction)
+5. Keep clear dependency graph (#1 in What Worked)
+6. Keep structured instructions (#2 in What Worked)
+
+**SHOULD FIX (Medium Priority):**
+1. Reduce redundant CLI calls (#1)
+2. Repetitive `--change` flag (#3)
+3. Mandatory STOP behavior (#1 in Workflow Friction)
+
+**NICE TO HAVE (Low Priority):**
+1. Compact instructions output mode (#6)
+
+---
+
+## Design Decisions (from E2E Testing Feedback)
+
+Based on dev testing and analysis of agent workflow friction, we identified three blockers for experimental release and made the following decisions.
+
+### Blockers Identified
+
+From the pain points in E2E testing, three issues are blocking the experimental release:
+
+1. **Specs directory ambiguity** - Agents don't know where to write spec files or how to name capabilities
+2. **CLI is query-heavy** - Most commands retrieve info, artifact creation is manual
+3. **Apply integration missing** - After 4/4 artifacts complete, no guidance on implementation phase
+
+### Decision 1: Capability Discovery in Proposal (RESOLVED)
+
+**Problem:** The specs artifact instruction says "Create one spec file per capability in `specs/<name>/spec.md`" but:
+- Agent doesn't know what `<name>` should be
+- Capability identification requires research (existing specs, codebase)
+- Proposal template asks for "Affected specs" but doesn't structure it
+- Research happens implicitly, output isn't captured
+
+**Decision:** Enrich the proposal template to explicitly capture capability discovery.
+
+**Current proposal template:**
+```markdown
+## Why
+## What Changes
+## Impact
+- Affected specs: List capabilities...  â† vague, easy to skip
+- Affected code: ...
+```
+
+**New proposal template:**
+```markdown
+## Why
+## What Changes
+## Capabilities
+
+### New Capabilities
+<!-- Capabilities being introduced (will create new specs/<name>/spec.md) -->
+- `<name>`: <brief description of what this capability covers>
+
+### Modified Capabilities
+<!-- Existing capabilities being changed (will update existing specs) -->
+- `<existing-name>`: <what's changing>
+
+## Impact
+<!-- Affected code, APIs, dependencies, systems -->
+```
+
+**Rationale:**
+- Proposal already asks for capabilities (just poorly) - this makes it explicit
+- Captured output is reviewable (vs implicit research that can't be verified)
+- Creates clear contract between proposal and specs phases
+- Distinguishes NEW vs MODIFIED upfront (critical for specs phase)
+- Agent can't skip research - it's part of the deliverable
+
+**Implementation:**
+- Update `schemas/spec-driven/templates/proposal.md`
+- Update proposal instruction in `schemas/spec-driven/schema.yaml`
+- Update skill instructions to guide capability discovery
+
+### Decision 2: CLI Action Commands (IN PROGRESS)
+
+**Problem:** CLI is mostly query-oriented. Agents run `openspec status`, `openspec next`, `openspec instructions` but then must manually write files.
+
+#### Decision 2a: Remove `openspec next` command (RESOLVED)
+
+**Problem:** The `next` command is redundant. It only shows which artifacts are ready, but `status` already shows this information (artifacts with status "ready" vs "blocked" vs "done").
+
+**Current behavior:**
+```bash
+openspec status --change "X"  # Shows: proposal (done), specs (ready), design (blocked), tasks (blocked)
+openspec next --change "X"    # Shows: ["specs"]  â† redundant
+```
+
+**Decision:** Remove the `next` command. Agents should use `status` which provides the same info plus more context.
+
+**Implementation:**
+- Remove `next` command from CLI
+- Update skill instructions to use `status` instead of `next`
+- Update AGENTS.md references
+
+#### Decision 2b: CLI Scaffolding (RESOLVED - NO)
+
+**Problem:** After getting instructions, agents manually write files. Should CLI scaffold artifacts instead?
+
+**Options considered:**
+- Add `openspec create <artifact>` commands that scaffold files with templates
+- Keep current approach where agent writes files directly from instructions
+- Hybrid: CLI can scaffold, agent can also write directly
+
+**Decision:** Keep current flow. No scaffolding commands.
+
+**Rationale (from agent ergonomics perspective):**
+- One Write is better than multiple Edits - agent composes full content atomically
+- `instructions` already provides template in context - scaffolding just moves it to a file
+- Fewer tool calls: `instructions` + Write (2) vs `create` + `instructions` + Read + EditÃ—N (4+)
+- Scaffolding doesn't solve the real problem (not knowing WHAT to write)
+- Real problem solved by proposal template change (capability discovery)
+
+**For multi-file artifacts (specs):** Scaffolding can't help because CLI doesn't know capability names until proposal is complete. The capability discovery in proposal solves this.
+
+### Decision 3: Apply Integration (RESOLVED)
+
+**Original problem:** After planning completes (4/4 artifacts), the experimental workflow ends. No guidance on implementation.
+
+**Key insight: No phases, just actions.**
+
+Through discussion, we realized phases (planning â†’ implementation â†’ archive) are an artificial constraint. Work is fluid:
+- You might start implementing, realize the design is wrong â†’ update design.md
+- You're halfway through tasks, discover a new requirement â†’ update specs
+- You bounce between "planning" and "implementing" constantly
+
+**The better model: Actions on a Change**
+
+A change is a thing (with artifacts). Actions are verbs you perform on a change. Actions aren't phases - they're fluid operations you can perform anytime.
+
+| Action | What it does | Skill | CLI Command |
+|--------|--------------|-------|-------------|
+| `new` | Create a change (scaffold directory) | `opsx:new` | `openspec new change` |
+| `continue` | Create next artifact (dependency-aware) | `opsx:continue` | `openspec instructions` |
+| `apply` | Implement tasks (execute, check off) | `opsx:apply` (NEW) | TBD |
+| `update` | Refresh/update artifacts based on learnings | `opsx:update` (NEW) | TBD |
+| `explore` | Research, ask questions, understand | `opsx:explore` (NEW) | TBD |
+| `validate` | Check artifacts are correct/complete | TBD | `openspec validate` |
+| `archive` | Finalize and move to archive | existing | `openspec archive` |
+
+**Key principles:**
+- Actions are modeled as skills (primary interface for agents)
+- Some skills have matching CLI commands for convenience
+- Skills and CLI commands are decoupled - not everything needs both
+- Actions can be performed in any order (with soft prerequisites)
+- No linear phase gates
+
+**What the schema defines:**
+- Artifacts (what they are, where they go)
+- Dependencies (what must exist first)
+- Required vs optional
+- Templates + instructions
+
+**What the schema does NOT define:**
+- Phases
+- When you can modify things
+- Linear workflow
+
+**Progress tracking:**
+- tasks.md checkboxes = implementation progress
+- Artifact existence = planning progress
+- Archive readiness = user decides (or all tasks done)
+
+**For experimental release:**
+- Create `opsx:apply` skill (guidance for implementing tasks)
+- Document the "actions on a change" model
+- Other actions (update, explore) can come later
+
+---
+
+### Design: `openspec-apply-change` Skill
+
+#### Overview
+
+The apply skill guides agents through implementing tasks from a completed (or in-progress) change. Unlike the old `/openspec:apply` command, this skill:
+- Is **fluid** - can be invoked anytime, not just after all artifacts are done
+- Allows **artifact updates** - if implementation reveals issues, update design/specs
+- Works **until done** - keeps going through tasks until complete or blocked
+- Tracks **progress via checkboxes** - tasks.md is the source of truth
+
+#### Skill Metadata
+
+```yaml
+name: openspec-apply-change
+description: Implement tasks from an OpenSpec change. Use when the user wants to start implementing, continue implementation, or work through tasks.
+```
+
+#### When to Invoke
+
+The skill should be invoked when:
+- User says "implement this change" or "start implementing"
+- User says "work on the tasks" or "do the next task"
+- User says "apply this change"
+- All artifacts are complete and user wants to proceed
+- User wants to continue implementation after a break
+
+#### Input
+
+- Optionally: change name
+- Optionally: specific task number to work on
+- If omitted: prompt for change selection (same pattern as continue-change)
+
+#### Steps
+
+```markdown
+**Steps**
+
+1. **If no change name provided, prompt for selection**
+
+   Run `openspec list --json` to get available changes. Use **AskUserQuestion** to let user select.
+
+   Show changes that have tasks.md (implementation-ready).
+   Mark changes with incomplete tasks as "(In Progress)".
+
+2. **Get apply instructions**
+
+   ```bash
+   openspec instructions apply --change "<name>" --json
+   ```
+
+   This returns:
+   - Context file paths (proposal, specs, design, tasks)
+   - Progress (total, complete, remaining)
+   - Task list with status
+   - Dynamic instruction based on current state
+
+   **Handle states:**
+   - If blocked (missing artifacts): show message, suggest `openspec-continue-change`
+   - If all done: congratulate, suggest archive
+   - Otherwise: proceed to implementation
+
+3. **Read context files**
+
+   Read the files listed in the instructions:
+   - `proposal.md` - why and what
+   - `specs/*.md` - requirements and scenarios
+   - `design.md` - technical approach (if exists)
+   - `tasks.md` - the implementation checklist
+
+4. **Show current progress**
+
+   Display:
+   - Progress: "N/M tasks complete"
+   - Remaining tasks overview
+   - Dynamic instruction from CLI
+
+5. **Implement tasks (loop until done or blocked)**
+
+   For each pending task:
+   - Show which task is being worked on
+   - Make the code changes required
+   - Keep changes minimal and focused
+   - Mark task complete in tasks.md: `- [ ]` â†’ `- [x]`
+   - Continue to next task
+
+   **Pause if:**
+   - Task is unclear â†’ ask for clarification
+   - Implementation reveals a design issue â†’ suggest updating artifacts
+   - Error or blocker encountered â†’ report and wait for guidance
+   - User interrupts
+
+6. **On completion or pause, show status**
+
+   Display:
+   - Tasks completed this session
+   - Overall progress: "N/M tasks complete"
+   - If all done: suggest archive
+   - If paused: explain why and wait for guidance
+```
+
+#### Output Format
+
+**During implementation:**
+```
+## Implementing: add-user-auth
+
+Working on task 3/7: Create UserAuth service class
+[...implementation happening...]
+âœ“ Task complete
+
+Working on task 4/7: Add login endpoint to AuthController
+[...implementation happening...]
+âœ“ Task complete
+
+Working on task 5/7: Add JWT token generation
+[...implementation happening...]
+```
+
+**On completion:**
+```
+## Implementation Complete
+
+**Change:** add-user-auth
+**Progress:** 7/7 tasks complete âœ“
+
+### Completed This Session
+- [x] Create UserAuth service class
+- [x] Add login endpoint to AuthController
+- [x] Add JWT token generation
+- [x] Add logout endpoint
+- [x] Add auth middleware
+- [x] Write unit tests
+- [x] Update API documentation
+
+All tasks complete! Ready to archive this change.
+```
+
+**On pause (issue encountered):**
+```
+## Implementation Paused
+
+**Change:** add-user-auth
+**Progress:** 4/7 tasks complete
+
+### Issue Encountered
+Task 5 "Add JWT token generation" - the design specifies using RS256 but
+the existing auth library only supports HS256.
+
+**Options:**
+1. Update design.md to use HS256 instead
+2. Add a new JWT library that supports RS256
+3. Other approach
+
+What would you like to do?
+```
+
+#### Guardrails
+
+- Keep going through tasks until done or blocked
+- Always read context before starting (specs, design)
+- If task is ambiguous, pause and ask before implementing
+- If implementation reveals issues, pause and suggest artifact updates
+- Keep code changes minimal and scoped to each task
+- Update task checkbox immediately after completing each task
+- Pause on errors, blockers, or unclear requirements - don't guess
+
+#### Fluid Workflow Integration
+
+The apply skill supports the "actions on a change" model:
+
+**Can be invoked anytime:**
+- Before all artifacts are done (if tasks.md exists)
+- After partial implementation
+- Interleaved with other actions (update, continue)
+
+**Allows artifact updates:**
+- If implementation reveals design issues â†’ suggest `opsx:update` or manual edit
+- If requirements need clarification â†’ suggest updating specs
+- Not phase-locked - work fluidly
+
+**Example fluid workflow:**
+```
+User: "Implement add-user-auth"
+â†’ openspec-apply-change: implements tasks 1, 2, 3, 4...
+â†’ Pauses at task 5: "Design says RS256 but library only supports HS256"
+
+User: "Let's use HS256 instead, update the design"
+â†’ User edits design.md (or uses opsx:update in future)
+
+User: "Continue implementing"
+â†’ openspec-apply-change: implements tasks 5, 6, 7
+â†’ "All tasks complete! Ready to archive."
+```
+
+#### CLI Commands Used
+
+```bash
+openspec list --json                        # List changes for selection
+openspec status --change "<name>"           # Check artifact completion
+openspec instructions apply --change "<name>" # Get apply instructions (NEW)
+# File reads via Read tool for proposal, specs, design, tasks
+# File edits via Edit tool for checking off tasks
+```
+
+#### New CLI Command: `openspec instructions apply`
+
+For consistency with artifact instructions.
+
+**Usage:**
+```bash
+openspec instructions apply --change "<name>" [--json]
+```
+
+**Output (Markdown format):**
+```markdown
+## Apply: add-user-auth
+
+### Context Files
+- proposal: openspec/changes/add-user-auth/proposal.md
+- specs: openspec/changes/add-user-auth/specs/**/*.md
+- design: openspec/changes/add-user-auth/design.md
+- tasks: openspec/changes/add-user-auth/tasks.md
+
+### Progress
+2/7 complete
+
+### Tasks
+- [x] Create UserAuth service class
+- [x] Add login endpoint
+- [ ] Add JWT token generation
+- [ ] Add logout endpoint
+- [ ] Add auth middleware
+- [ ] Write unit tests
+- [ ] Update API documentation
+
+### Instruction
+Read context files, work through pending tasks, mark complete as you go.
+Pause if you hit blockers or need clarification.
+```
+
+**Benefits of CLI command:**
+- **Consistency** - same pattern as `openspec instructions <artifact>`
+- **Structured output** - progress, tasks, context paths in one call
+- **Clean format** - markdown is readable and compact (vs verbose XML)
+- **Extensibility** - can add more sections later if needed
+- **JSON option** - `--json` flag available for programmatic use
+
+#### Differences from Old `/openspec:apply`
+
+| Aspect | Old `/openspec:apply` | New `openspec-apply-change` |
+|--------|----------------------|----------------------------|
+| Invocation | After all artifacts done | Anytime (if tasks.md exists) |
+| Granularity | All tasks at once | All tasks, but pauses on issues |
+| Artifact updates | Not mentioned | Encouraged when needed |
+| Progress tracking | Update all at end | Update after each task |
+| Flow control | Push through everything | Pause on blockers, resume after |
+| Context loading | Read once at start | Read context, reference as needed |
+| Issue handling | Not specified | Pause, present options, wait for guidance |
+
+#### Implementation Notes
+
+1. **Add CLI command**: Add `openspec instructions apply` to artifact-workflow.ts
+   - Parse tasks.md for progress (count done/pending)
+   - Return context paths, progress, task list, simple instruction
+2. **Add to skill-templates.ts**: Create `getApplyChangeSkillTemplate()` function
+3. **Update artifact-experimental-setup**: Generate this skill alongside new/continue
+4. **Update skills list**: Add to `.claude/skills/` directory
+5. **Test the flow**: Verify it works with existing changes that have tasks.md
+
+---
+
+## Next Steps
+
+1. ~~Review this plan and confirm scope~~ (Done - blockers identified)
+2. ~~Design decisions~~ (Done - all 3 blockers resolved)
+3. ~~Design apply skill~~ (Done - documented above)
+4. ~~Implement proposal template change (Decision 1 - capability discovery)~~ (Done)
+5. ~~Remove `openspec next` command (Decision 2a)~~ (Done)
+6. ~~Add `openspec instructions apply` CLI command~~ (Done)
+7. ~~Create `openspec-apply-change` skill~~ (Done)
+8. Conduct E2E testing with updated workflow
+9. Write user docs (document "actions on a change" model)
+10. Release to test users
diff --git a/docs/experimental-workflow.md b/docs/experimental-workflow.md
new file mode 100644
index 0000000..10b0b7e
--- /dev/null
+++ b/docs/experimental-workflow.md
@@ -0,0 +1,107 @@
+# Experimental Workflow (OPSX)
+
+> **Status:** Experimental. Things might break. Feedback welcome on [Discord](https://discord.gg/BYjPaKbqMt).
+>
+> **Compatibility:** Claude Code only (for now)
+
+## What Is It?
+
+OPSX is a new way to work with OpenSpec changes. Instead of one big proposal, you build **artifacts** step-by-step:
+
+```
+proposal â†’ specs â†’ design â†’ tasks â†’ implementation â†’ archive
+```
+
+Each artifact has dependencies. Can't write tasks until you have specs. Can't implement until you have tasks. The system tracks what's ready and what's blocked.
+
+## Setup
+
+```bash
+# 1. Make sure you have openspec installed and initialized
+openspec init
+
+# 2. Generate the experimental skills
+openspec artifact-experimental-setup
+```
+
+This creates skills in `.claude/skills/` that Claude Code auto-detects.
+
+## Commands
+
+| Command | What it does |
+|---------|--------------|
+| `/opsx:new` | Start a new change |
+| `/opsx:continue` | Create the next artifact |
+| `/opsx:ff` | Fast-forward (create all artifacts at once) |
+| `/opsx:apply` | Implement the tasks |
+| `/opsx:sync` | Sync delta specs to main specs |
+| `/opsx:archive` | Archive when done |
+
+## Usage
+
+### Start a new change
+```
+/opsx:new
+```
+You'll be asked what you want to build and which workflow schema to use.
+
+### Build artifacts step-by-step
+```
+/opsx:continue
+```
+Creates one artifact at a time. Good for reviewing each step.
+
+### Or fast-forward
+```
+/opsx:ff add-dark-mode
+```
+Creates all artifacts in one go. Good when you know what you want.
+
+### Implement
+```
+/opsx:apply
+```
+Works through tasks, checking them off as you go.
+
+### Sync specs and archive
+```
+/opsx:sync      # Update main specs with your delta specs
+/opsx:archive   # Move to archive when done
+```
+
+## What's Different?
+
+**Standard workflow** (`/openspec:proposal`):
+- One big proposal document
+- Linear phases: plan â†’ implement â†’ archive
+- All-or-nothing artifact creation
+
+**Experimental workflow** (`/opsx:*`):
+- Discrete artifacts with dependencies
+- Fluid actions (not phases) - update artifacts anytime
+- Step-by-step or fast-forward
+- Schema-driven (can customize the workflow)
+
+The key insight: work isn't linear. You implement, realize the design is wrong, update it, continue. OPSX supports this.
+
+## Schemas
+
+Schemas define what artifacts exist and their dependencies. Currently available:
+
+- **spec-driven** (default): proposal â†’ specs â†’ design â†’ tasks
+- **tdd**: tests â†’ implementation â†’ docs
+
+Run `openspec schemas` to see available schemas.
+
+## Tips
+
+- Use `/opsx:ff` when you have a clear idea, `/opsx:continue` when exploring
+- Tasks track progress via checkboxes in `tasks.md`
+- Delta specs (in `specs/`) get synced to main specs with `/opsx:sync`
+- If you get stuck, the status command shows what's blocked: `openspec status --change "name"`
+
+## Feedback
+
+This is rough. That's intentional - we're learning what works.
+
+Found a bug? Have ideas? Join us on [Discord](https://discord.gg/BYjPaKbqMt) or open an issue on [GitHub](https://github.com/Fission-AI/openspec/issues).
diff --git a/docs/schema-customization.md b/docs/schema-customization.md
new file mode 100644
index 0000000..d4cc3f2
--- /dev/null
+++ b/docs/schema-customization.md
@@ -0,0 +1,211 @@
+# Schema Customization
+
+This document describes how users can customize OpenSpec schemas and templates, the current manual process, and the gap that needs to be addressed.
+
+---
+
+## Overview
+
+OpenSpec uses a 2-level schema resolution system following the XDG Base Directory Specification:
+
+1. **User override**: `${XDG_DATA_HOME}/openspec/schemas/<name>/`
+2. **Package built-in**: `<npm-package>/schemas/<name>/`
+
+When a schema is requested (e.g., `spec-driven`), the resolver checks the user directory first. If found, that entire schema directory is used. Otherwise, it falls back to the package's built-in schema.
+
+---
+
+## Current Manual Process
+
+To override the default `spec-driven` schema, a user must:
+
+### 1. Determine the correct directory path
+
+| Platform | Path |
+|----------|------|
+| macOS/Linux | `~/.local/share/openspec/schemas/` |
+| Windows | `%LOCALAPPDATA%\openspec\schemas\` |
+| All (if set) | `$XDG_DATA_HOME/openspec/schemas/` |
+
+### 2. Create the directory structure
+
+```bash
+# macOS/Linux example
+mkdir -p ~/.local/share/openspec/schemas/spec-driven/templates
+```
+
+### 3. Find and copy the default schema files
+
+The user must locate the installed npm package to copy the defaults:
+
+```bash
+# Find the package location (varies by install method)
+npm list -g openspec --parseable
+# or
+which openspec && readlink -f $(which openspec)
+
+# Copy files from the package's schemas/ directory
+cp <package-path>/schemas/spec-driven/schema.yaml ~/.local/share/openspec/schemas/spec-driven/
+cp <package-path>/schemas/spec-driven/templates/*.md ~/.local/share/openspec/schemas/spec-driven/templates/
+```
+
+### 4. Modify the copied files
+
+Edit `schema.yaml` to change the workflow structure:
+
+```yaml
+name: spec-driven
+version: 1
+description: My custom workflow
+artifacts:
+  - id: proposal
+    generates: proposal.md
+    description: Initial proposal
+    template: proposal.md
+    requires: []
+  # Add, remove, or modify artifacts...
+```
+
+Edit templates in `templates/` to customize the content guidance.
+
+### 5. Verify the override is active
+
+Currently there's no command to verify which schema is being used. Users must trust that the file exists in the right location.
+
+---
+
+## Gap Analysis
+
+The current process has several friction points:
+
+| Issue | Impact |
+|-------|--------|
+| **Path discovery** | Users must know XDG conventions and platform-specific paths |
+| **Package location** | Finding the npm package path varies by install method (global, local, pnpm, yarn, volta, etc.) |
+| **No scaffolding** | Users must manually create directories and copy files |
+| **No verification** | No way to confirm which schema is actually being resolved |
+| **No diffing** | When upgrading openspec, users can't see what changed in built-in templates |
+| **Full copy required** | Must copy entire schema even to change one template |
+
+### User Stories Not Currently Supported
+
+1. *"I want to add a `research` artifact before `proposal`"* â€” requires manual copy and edit
+2. *"I want to customize just the proposal template"* â€” must copy entire schema
+3. *"I want to see what the default schema looks like"* â€” must find package path
+4. *"I want to revert to defaults"* â€” must delete files and hope paths are correct
+5. *"I upgraded openspec, did the templates change?"* â€” no way to diff
+
+---
+
+## Proposed Solution: Schema Configurator
+
+A CLI command (or set of commands) that handles path resolution and file operations for users.
+
+### Option A: Single `openspec schema` command
+
+```bash
+# List available schemas (built-in and user overrides)
+openspec schema list
+
+# Show where a schema resolves from
+openspec schema which spec-driven
+# Output: /Users/me/.local/share/openspec/schemas/spec-driven/ (user override)
+# Output: /usr/local/lib/node_modules/openspec/schemas/spec-driven/ (built-in)
+
+# Copy a built-in schema to user directory for customization
+openspec schema copy spec-driven
+# Creates ~/.local/share/openspec/schemas/spec-driven/ with all files
+
+# Show diff between user override and built-in
+openspec schema diff spec-driven
+
+# Remove user override (revert to built-in)
+openspec schema reset spec-driven
+
+# Validate a schema
+openspec schema validate spec-driven
+```
+
+### Option B: Dedicated `openspec customize` command
+
+```bash
+# Interactive schema customization
+openspec customize
+# Prompts: Which schema? What do you want to change? etc.
+
+# Copy and open for editing
+openspec customize spec-driven
+# Copies to user dir, prints path, optionally opens in $EDITOR
+```
+
+### Option C: Init-time schema selection
+
+```bash
+# During project init, offer schema customization
+openspec init
+# ? Select a workflow schema:
+#   > spec-driven (default)
+#     tdd
+#     minimal
+#     custom (copy and edit)
+```
+
+### Recommended Approach
+
+**Option A** provides the most flexibility and follows Unix conventions (subcommands for discrete operations). Key commands in priority order:
+
+1. `openspec schema list` â€” see what's available
+2. `openspec schema which <name>` â€” debug resolution
+3. `openspec schema copy <name>` â€” scaffold customization
+4. `openspec schema diff <name>` â€” compare with built-in
+5. `openspec schema reset <name>` â€” revert to defaults
+
+---
+
+## Implementation Considerations
+
+### Path Resolution
+
+The resolver already exists in `src/core/artifact-graph/resolver.ts`:
+
+```typescript
+export function getPackageSchemasDir(): string { ... }
+export function getUserSchemasDir(): string { ... }
+export function getSchemaDir(name: string): string | null { ... }
+export function listSchemas(): string[] { ... }
+```
+
+New commands would leverage these existing functions.
+
+### File Operations
+
+- Copy should preserve file permissions
+- Copy should not overwrite existing user files without `--force`
+- Reset should prompt for confirmation
+
+### Template-Only Overrides
+
+A future enhancement could support overriding individual templates without copying the entire schema. This would require changes to the resolution logic:
+
+```
+Current: schema dir (user) OR schema dir (built-in)
+Future:  schema.yaml from user OR built-in
+         + each template from user OR built-in (independent fallback)
+```
+
+This adds complexity but enables the "I just want to change one template" use case.
+
+---
+
+## Related Documents
+
+- [Schema Workflow Gaps](./schema-workflow-gaps.md) â€” End-to-end workflow analysis and phased implementation plan
+
+## Related Files
+
+| File | Purpose |
+|------|---------|
+| `src/core/artifact-graph/resolver.ts` | Schema resolution logic |
+| `src/core/artifact-graph/instruction-loader.ts` | Template loading |
+| `src/core/global-config.ts` | XDG path helpers |
+| `schemas/spec-driven/` | Default schema and templates |
diff --git a/docs/schema-workflow-gaps.md b/docs/schema-workflow-gaps.md
new file mode 100644
index 0000000..d32778b
--- /dev/null
+++ b/docs/schema-workflow-gaps.md
@@ -0,0 +1,378 @@
+# Schema Workflow: End-to-End Analysis
+
+This document analyzes the complete user journey for working with schemas in OpenSpec, identifies gaps, and proposes a phased solution.
+
+---
+
+## Current State
+
+### What Exists
+
+| Component | Status |
+|-----------|--------|
+| Schema resolution (XDG) | 2-level: user override â†’ package built-in |
+| Built-in schemas | `spec-driven`, `tdd` |
+| Artifact workflow commands | `status`, `next`, `instructions`, `templates` with `--schema` flag |
+| Change creation | `openspec new change <name>` â€” no schema binding |
+
+### What's Missing
+
+| Component | Status |
+|-----------|--------|
+| Schema bound to change | Not stored â€” must pass `--schema` every time |
+| Project-local schemas | Not supported â€” can't version control with repo |
+| Schema management CLI | None â€” manual path discovery required |
+| Project default schema | None â€” hardcoded to `spec-driven` |
+
+---
+
+## User Journey Analysis
+
+### Scenario 1: Using a Non-Default Schema
+
+**Goal:** User wants to use TDD workflow for a new feature.
+
+**Today's experience:**
+```bash
+openspec new change add-auth
+# Creates directory, no schema info stored
+
+openspec status --change add-auth
+# Shows spec-driven artifacts (WRONG - user wanted TDD)
+
+# User realizes mistake...
+openspec status --change add-auth --schema tdd
+# Correct, but must remember --schema every time
+
+# 6 months later...
+openspec status --change add-auth
+# Wrong again - nobody remembers this was TDD
+```
+
+**Problems:**
+- Schema is a runtime argument, not persisted
+- Easy to forget `--schema` and get wrong results
+- No record of intended schema for future reference
+
+---
+
+### Scenario 2: Customizing a Schema
+
+**Goal:** User wants to add a "research" artifact before "proposal".
+
+**Today's experience:**
+```bash
+# Step 1: Figure out where to put overrides
+# Must know XDG conventions:
+#   macOS/Linux: ~/.local/share/openspec/schemas/
+#   Windows: %LOCALAPPDATA%\openspec\schemas/
+
+# Step 2: Create directory structure
+mkdir -p ~/.local/share/openspec/schemas/my-workflow/templates
+
+# Step 3: Find the npm package to copy defaults
+npm list -g openspec --parseable
+# Output varies by package manager:
+#   npm: /usr/local/lib/node_modules/openspec
+#   pnpm: ~/.local/share/pnpm/global/5/node_modules/openspec
+#   volta: ~/.volta/tools/image/packages/openspec/...
+#   yarn: ~/.config/yarn/global/node_modules/openspec
+
+# Step 4: Copy files
+cp -r <package-path>/schemas/spec-driven/* \
+      ~/.local/share/openspec/schemas/my-workflow/
+
+# Step 5: Edit schema.yaml and templates
+# No way to verify override is active
+# No way to diff against original
+```
+
+**Problems:**
+- Must know XDG path conventions
+- Finding npm package path varies by install method
+- No tooling to scaffold or verify
+- No diff capability when upgrading openspec
+
+---
+
+### Scenario 3: Team Sharing Custom Workflow
+
+**Goal:** Team wants everyone to use the same custom schema.
+
+**Today's options:**
+1. Everyone manually sets up XDG override â€” error-prone, drift risk
+2. Document setup in README â€” still manual, easy to miss
+3. Publish separate npm package â€” overkill for most teams
+4. Check schema into repo â€” **not supported** (no project-local resolution)
+
+**Problems:**
+- No project-local schema resolution
+- Can't version control custom schemas with the codebase
+- No single source of truth for team workflow
+
+---
+
+## Gap Summary
+
+| Gap | Impact | Workaround |
+|-----|--------|------------|
+| Schema not bound to change | Wrong results, forgotten context | Remember to pass `--schema` |
+| No project-local schemas | Can't share via repo | Manual XDG setup per machine |
+| No schema management CLI | Manual path hunting | Know XDG + find npm package |
+| No project default schema | Must specify every time | Always pass `--schema` |
+| No init-time schema selection | Missed setup opportunity | Manual config |
+
+---
+
+## Proposed Architecture
+
+### New File Structure
+
+```
+openspec/
+â”œâ”€â”€ config.yaml                 # Project config (NEW)
+â”œâ”€â”€ schemas/                    # Project-local schemas (NEW)
+â”‚   â””â”€â”€ my-workflow/
+â”‚       â”œâ”€â”€ schema.yaml
+â”‚       â””â”€â”€ templates/
+â”‚           â”œâ”€â”€ research.md
+â”‚           â”œâ”€â”€ proposal.md
+â”‚           â””â”€â”€ ...
+â””â”€â”€ changes/
+    â””â”€â”€ add-auth/
+        â”œâ”€â”€ change.yaml         # Change metadata (NEW)
+        â”œâ”€â”€ proposal.md
+        â””â”€â”€ ...
+```
+
+### config.yaml (Project Config)
+
+```yaml
+# openspec/config.yaml
+defaultSchema: spec-driven
+```
+
+Sets the project-wide default schema. Used when:
+- Creating new changes without `--schema`
+- Running commands on changes without `change.yaml`
+
+### change.yaml (Change Metadata)
+
+```yaml
+# openspec/changes/add-auth/change.yaml
+schema: tdd
+created: 2025-01-15T10:30:00Z
+description: Add user authentication system
+```
+
+Binds a specific schema to a change. Created automatically by `openspec new change`.
+
+### Schema Resolution Order
+
+```
+1. ./openspec/schemas/<name>/                    # Project-local
+2. ~/.local/share/openspec/schemas/<name>/       # User global (XDG)
+3. <npm-package>/schemas/<name>/                 # Built-in
+```
+
+Project-local takes priority, enabling version-controlled custom schemas.
+
+### Schema Selection Order (Per Command)
+
+```
+1. --schema CLI flag                    # Explicit override
+2. change.yaml in change directory      # Change-specific binding
+3. openspec/config.yaml defaultSchema   # Project default
+4. "spec-driven"                        # Hardcoded fallback
+```
+
+---
+
+## Ideal User Experience
+
+### Creating a Change
+
+```bash
+# Uses project default (from config.yaml, or spec-driven)
+openspec new change add-auth
+# Creates openspec/changes/add-auth/change.yaml:
+#   schema: spec-driven
+#   created: 2025-01-15T10:30:00Z
+
+# Explicit schema for this change
+openspec new change add-auth --schema tdd
+# Creates change.yaml with schema: tdd
+```
+
+### Working with Changes
+
+```bash
+# Auto-reads schema from change.yaml â€” no --schema needed
+openspec status --change add-auth
+# Output: "Change: add-auth (schema: tdd)"
+# Shows which artifacts are ready/blocked/done
+
+# Explicit override still works (with informational message)
+openspec status --change add-auth --schema spec-driven
+# "Note: change.yaml specifies 'tdd', using 'spec-driven' per --schema flag"
+```
+
+### Customizing Schemas
+
+```bash
+# See what's available
+openspec schema list
+# Built-in:
+#   spec-driven    proposal â†’ specs â†’ design â†’ tasks
+#   tdd            spec â†’ tests â†’ implementation â†’ docs
+# Project: (none)
+# User: (none)
+
+# Copy to project for customization
+openspec schema copy spec-driven my-workflow
+# Created ./openspec/schemas/my-workflow/
+# Edit schema.yaml and templates/ to customize
+
+# Copy to global (user-level override)
+openspec schema copy spec-driven --global
+# Created ~/.local/share/openspec/schemas/spec-driven/
+
+# See where a schema resolves from
+openspec schema which spec-driven
+# ./openspec/schemas/spec-driven/ (project)
+# or: ~/.local/share/openspec/schemas/spec-driven/ (user)
+# or: /usr/local/lib/node_modules/openspec/schemas/spec-driven/ (built-in)
+
+# Compare override with built-in
+openspec schema diff spec-driven
+# Shows diff between user/project version and package built-in
+
+# Remove override, revert to built-in
+openspec schema reset spec-driven
+# Removes ./openspec/schemas/spec-driven/ (or --global for user dir)
+```
+
+### Project Setup
+
+```bash
+openspec init
+# ? Select default workflow schema:
+#   > spec-driven (proposal â†’ specs â†’ design â†’ tasks)
+#     tdd (spec â†’ tests â†’ implementation â†’ docs)
+#     (custom schemas if detected)
+#
+# Writes to openspec/config.yaml:
+#   defaultSchema: spec-driven
+```
+
+---
+
+## Implementation Phases
+
+### Phase 1: Change Metadata (change.yaml)
+
+**Priority:** High
+**Solves:** "Forgot --schema", lost context, wrong results
+
+**Scope:**
+- Create `change.yaml` when running `openspec new change`
+- Store `schema`, `created` timestamp
+- Modify workflow commands to read schema from `change.yaml`
+- `--schema` flag overrides (with informational message)
+- Backwards compatible: missing `change.yaml` â†’ use default
+
+**change.yaml format:**
+```yaml
+schema: tdd
+created: 2025-01-15T10:30:00Z
+```
+
+**Migration:**
+- Existing changes without `change.yaml` continue to work
+- Default to `spec-driven` (current behavior)
+- Optional: `openspec migrate` to add `change.yaml` to existing changes
+
+---
+
+### Phase 2: Project-Local Schemas
+
+**Priority:** High
+**Solves:** Team sharing, version control, no XDG knowledge needed
+
+**Scope:**
+- Add `./openspec/schemas/` to resolution order (first priority)
+- `openspec schema copy <name> [new-name]` creates in project by default
+- `--global` flag for user-level XDG directory
+- Teams can commit `openspec/schemas/` to repo
+
+**Resolution order:**
+```
+1. ./openspec/schemas/<name>/           # Project-local (NEW)
+2. ~/.local/share/openspec/schemas/<name>/  # User global
+3. <npm-package>/schemas/<name>/        # Built-in
+```
+
+---
+
+### Phase 3: Schema Management CLI
+
+**Priority:** Medium
+**Solves:** Path discovery, scaffolding, debugging
+
+**Commands:**
+```bash
+openspec schema list              # Show available schemas with sources
+openspec schema which <name>      # Show resolution path
+openspec schema copy <name> [to]  # Copy for customization
+openspec schema diff <name>       # Compare with built-in
+openspec schema reset <name>      # Remove override
+openspec schema validate <name>   # Validate schema.yaml structure
+```
+
+---
+
+### Phase 4: Project Config + Init Enhancement
+
+**Priority:** Low
+**Solves:** Project-wide defaults, streamlined setup
+
+**Scope:**
+- Add `openspec/config.yaml` with `defaultSchema` field
+- `openspec init` prompts for schema selection
+- Store selection in `config.yaml`
+- Commands use as fallback when no `change.yaml` exists
+
+**config.yaml format:**
+```yaml
+defaultSchema: spec-driven
+```
+
+---
+
+## Backwards Compatibility
+
+| Scenario | Behavior |
+|----------|----------|
+| Existing change without `change.yaml` | Uses `--schema` flag or project default or `spec-driven` |
+| Existing project without `config.yaml` | Falls back to `spec-driven` |
+| `--schema` flag provided | Overrides `change.yaml` (with info message) |
+| No project-local schemas dir | Skipped in resolution, checks user/built-in |
+
+All existing functionality continues to work. New features are additive.
+
+---
+
+## Related Documents
+
+- [Schema Customization](./schema-customization.md) â€” Details on manual override process and CLI gaps
+- [Artifact POC](./artifact_poc.md) â€” Core artifact graph architecture
+
+## Related Code
+
+| File | Purpose |
+|------|---------|
+| `src/core/artifact-graph/resolver.ts` | Schema resolution logic |
+| `src/core/artifact-graph/instruction-loader.ts` | Template loading |
+| `src/core/global-config.ts` | XDG path helpers |
+| `src/commands/artifact-workflow.ts` | CLI commands |
+| `src/utils/change-utils.ts` | Change creation utilities |
diff --git a/openspec/changes/add-antigravity-support/specs/cli-init/spec.md b/openspec/changes/add-antigravity-support/specs/cli-init/spec.md
deleted file mode 100644
index 5b61baf..0000000
--- a/openspec/changes/add-antigravity-support/specs/cli-init/spec.md
+++ /dev/null
@@ -1,9 +0,0 @@
-## MODIFIED Requirements
-### Requirement: Slash Command Configuration
-The init command SHALL generate slash command files for supported editors using shared templates.
-
-#### Scenario: Generating slash commands for Antigravity
-- **WHEN** the user selects Antigravity during initialization
-- **THEN** create `.agent/workflows/openspec-proposal.md`, `.agent/workflows/openspec-apply.md`, and `.agent/workflows/openspec-archive.md`
-- **AND** ensure each file begins with YAML frontmatter that contains only a `description: <stage summary>` field followed by the shared OpenSpec workflow instructions wrapped in managed markers
-- **AND** populate the workflow body with the same proposal/apply/archive guidance used for other tools so Antigravity behaves like Windsurf while pointing to the `.agent/workflows/` directory
diff --git a/openspec/changes/add-antigravity-support/specs/cli-update/spec.md b/openspec/changes/add-antigravity-support/specs/cli-update/spec.md
deleted file mode 100644
index 8a2eebe..0000000
--- a/openspec/changes/add-antigravity-support/specs/cli-update/spec.md
+++ /dev/null
@@ -1,8 +0,0 @@
-## MODIFIED Requirements
-### Requirement: Slash Command Updates
-The update command SHALL refresh existing slash command files for configured tools without creating new ones, and ensure the OpenCode archive command accepts change ID arguments.
-
-#### Scenario: Updating slash commands for Antigravity
-- **WHEN** `.agent/workflows/` contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
-- **THEN** refresh the OpenSpec-managed portion of each file so the workflow copy matches other tools while preserving the existing single-field `description` frontmatter
-- **AND** skip creating any missing workflow files during update, mirroring the behavior for Windsurf and other IDEs
diff --git a/openspec/changes/add-scaffold-command/proposal.md b/openspec/changes/add-scaffold-command/proposal.md
deleted file mode 100644
index c97a1d5..0000000
--- a/openspec/changes/add-scaffold-command/proposal.md
+++ /dev/null
@@ -1,11 +0,0 @@
-## Why
-Manual setup for new changes leads to formatting mistakes in spec deltas and slows agents who must recreate the same file skeletons for every proposal. A built-in scaffold command will generate compliant templates so assistants can focus on the change content instead of structure.
-
-## What Changes
-- Add an `openspec scaffold <change-id>` CLI command that creates a change directory (if it does not already exist) with validated `proposal.md`, `tasks.md`, and spec delta templates.
-- Update CLI documentation and quick-reference guidance so agents discover the scaffold workflow before drafting files manually, including reminders on when to create spec deltas.
-- Add automated coverage (unit/integ tests) to ensure the command respects naming rules, copies templates correctly, fails for existing directories, and produces output that passes `openspec validate --strict` untouched.
-
-## Impact
-- Affected specs: `specs/cli-scaffold`
-- Affected code: `src/cli/index.ts`, `src/commands`, `docs/`
diff --git a/openspec/changes/add-scaffold-command/specs/cli-scaffold/spec.md b/openspec/changes/add-scaffold-command/specs/cli-scaffold/spec.md
deleted file mode 100644
index 572dc2f..0000000
--- a/openspec/changes/add-scaffold-command/specs/cli-scaffold/spec.md
+++ /dev/null
@@ -1,36 +0,0 @@
-## ADDED Requirements
-### Requirement: Scaffolding Command Registration
-The CLI SHALL expose an `openspec scaffold <change-id>` command that validates the change identifier before generating files.
-
-#### Scenario: Registering scaffold command
-- **WHEN** a user runs `openspec scaffold add-user-notifications`
-- **THEN** the CLI SHALL reject invalid identifiers (non kebab-case) before proceeding
-- **AND** display usage documentation via `openspec scaffold --help`
-- **AND** exit with code 0 after successful scaffolding
-
-### Requirement: Change Directory Structure
-The scaffold command SHALL create the standard change workspace (if it does not already exist) with proposal, tasks, optional design, and `specs/` directories laid out according to OpenSpec conventions.
-
-#### Scenario: Generating change workspace
-- **WHEN** scaffolding a new change with id `add-user-notifications`
-- **THEN** create `openspec/changes/add-user-notifications/` if it does not exist
-- **AND** copy the default template bundle (proposal, tasks, design placeholders) into that directory in a single operation
-- **AND** create an empty `openspec/changes/add-user-notifications/specs/` directory ready for capability-specific deltas that will be authored later
-
-### Requirement: Template Content Guidance
-The scaffold command SHALL populate generated Markdown files with OpenSpec-compliant templates so authors can copy, edit, and pass validation without reformatting.
-
-#### Scenario: Populating proposal and tasks templates
-- **WHEN** the scaffold command writes `proposal.md`
-- **THEN** include the `## Why`, `## What Changes`, and `## Impact` headings with placeholder guidance text
-- **AND** ensure `tasks.md` starts with `## 1. Implementation` and numbered checklist items using `- [ ]` syntax
-- **AND** annotate optional sections (like `design.md`) with inline TODO comments so users understand when to keep or delete them
-- **AND** include a short reminder inside `specs/README.md` (or similar) instructing authors to add deltas once they know the affected capability
-
-### Requirement: Idempotent Execution
-The scaffold command SHALL be safe to rerun, preserving user edits while filling in any missing managed sections.
-
-#### Scenario: Rerunning scaffold on existing change
-- **WHEN** the command is executed again for an existing change directory containing user-edited files
-- **THEN** leave existing content untouched except for managed placeholder regions or missing files that need creation
-- **AND** update the filesystem summary to highlight which files were skipped, created, or refreshed
diff --git a/openspec/changes/add-scaffold-command/tasks.md b/openspec/changes/add-scaffold-command/tasks.md
deleted file mode 100644
index 0f631a9..0000000
--- a/openspec/changes/add-scaffold-command/tasks.md
+++ /dev/null
@@ -1,12 +0,0 @@
-## 1. CLI scaffolding command
-- [ ] 1.1 Register an `openspec scaffold` command in the CLI entrypoint with `change-id` argument validation.
-- [ ] 1.2 Implement generator logic that copies the default change template bundle (`proposal.md`, `tasks.md`, optional `design.md`, `specs/README.md`) into `openspec/changes/<id>/`, creating the directory tree in a single pass.
-- [ ] 1.3 Detect when `openspec/changes/<id>/` already exists and exit with a clear error instead of overwriting user files.
-
-## 2. Templates and documentation
-- [ ] 2.1 Update `openspec/AGENTS.md` quick reference so agents see `openspec scaffold` before drafting files manually.
-- [ ] 2.2 Refresh CLI docs/README/help text to mention the scaffold workflow, template bundle contents, and when to add spec deltas manually.
-
-## 3. Test coverage
-- [ ] 3.1 Add unit tests covering name validation, template copying, and existing-directory failures.
-- [ ] 3.2 Add integration coverage ensuring a freshly scaffolded change (without deltas) passes `openspec validate --strict` until the author customizes it.
diff --git a/openspec/changes/archive/2025-12-24-add-artifact-graph-core/design.md b/openspec/changes/archive/2025-12-24-add-artifact-graph-core/design.md
new file mode 100644
index 0000000..0c1d49a
--- /dev/null
+++ b/openspec/changes/archive/2025-12-24-add-artifact-graph-core/design.md
@@ -0,0 +1,197 @@
+## Context
+
+This implements "Slice 1: What's Ready?" from the artifact POC analysis. The core insight is using the filesystem as a database - artifact completion is detected by file existence, making the system stateless and version-control friendly.
+
+This module will coexist with the current OpenSpec system as a parallel capability, potentially enabling future migration or integration.
+
+## Goals / Non-Goals
+
+**Goals:**
+- Pure dependency graph logic with no side effects
+- Stateless state detection (rescan filesystem each query)
+- Support glob patterns for multi-file artifacts (e.g., `specs/*.md`)
+- Load artifact definitions from YAML schemas
+- Calculate topological build order
+- Determine "ready" artifacts based on dependency completion
+
+**Non-Goals:**
+- CLI commands (Slice 4)
+- Multi-change management (Slice 2)
+- Template resolution and enrichment (Slice 3)
+- Agent integration or Claude commands
+- Replacing existing OpenSpec functionality
+
+## Decisions
+
+### Decision: Filesystem as Database
+Use file existence for state detection rather than a separate state file.
+
+**Rationale:**
+- Stateless - no state corruption possible
+- Git-friendly - state derived from committed files
+- Simple - no sync issues between state file and actual files
+
+**Alternatives considered:**
+- JSON/SQLite state file: More complex, sync issues, not git-friendly
+- Git metadata: Too coupled to git, complex implementation
+
+### Decision: Kahn's Algorithm for Topological Sort
+Use Kahn's algorithm for computing build order.
+
+**Rationale:**
+- Well-understood, O(V+E) complexity
+- Naturally detects cycles during execution
+- Produces a stable, deterministic order
+
+### Decision: Glob Pattern Support
+Support glob patterns like `specs/*.md` in artifact `generates` field.
+
+**Rationale:**
+- Allows multiple files to satisfy a single artifact requirement
+- Common pattern for spec directories with multiple files
+- Uses standard glob syntax
+
+### Decision: Immutable Completed Set
+Represent completion state as an immutable Set of completed artifact IDs.
+
+**Rationale:**
+- Functional style, easier to reason about
+- State derived fresh each query, no mutation needed
+- Clear separation between graph structure and runtime state
+- Filesystem can only detect binary existence (complete vs not complete)
+
+**Note:** `inProgress` and `failed` states are deferred to future slices. They would require external state tracking (e.g., a status file) since file existence alone cannot distinguish these states.
+
+### Decision: Zod for Schema Validation
+Use Zod for validating YAML schema structure and deriving TypeScript types.
+
+**Rationale:**
+- Already a project dependency (v4.0.17) used in `src/core/schemas/`
+- Type inference via `z.infer<>` - single source of truth for types
+- Runtime validation with detailed error messages
+- Consistent with existing project patterns (`base.schema.ts`, `config-schema.ts`)
+
+**Alternatives considered:**
+- Manual validation: More code, error-prone, no type inference
+- JSON Schema: Would require additional dependency, less TypeScript integration
+- io-ts: Not already in project, steeper learning curve
+
+### Decision: Two-Level Schema Resolution
+Schemas resolve from global user data directory, falling back to package built-ins.
+
+**Resolution order:**
+1. `${XDG_DATA_HOME:-~/.local/share}/openspec/schemas/<name>.yaml` - Global user override
+2. `<package>/schemas/<name>.yaml` - Built-in defaults
+
+**Rationale:**
+- Follows XDG Base Directory Specification (schemas are data, not config)
+- Mirrors existing `getGlobalConfigDir()` pattern in `src/core/global-paths.ts`
+- Built-ins baked into package, never auto-copied
+- Users customize by creating files in global data dir
+- Simple - no project-level overrides (can add later if needed)
+
+**XDG compliance:**
+- Uses `XDG_DATA_HOME` env var when set (all platforms)
+- Unix/macOS fallback: `~/.local/share/openspec/`
+- Windows fallback: `%LOCALAPPDATA%/openspec/`
+
+**Alternatives considered:**
+- Project-level overrides: Added complexity, not needed initially
+- Auto-copy to user space: Creates drift, harder to update defaults
+- Config directory (`XDG_CONFIG_HOME`): Schemas are workflow definitions (data), not user preferences (config)
+
+### Decision: Template Field Parsed But Not Resolved
+The `template` field is required in schema YAML for completeness, but template resolution is deferred to Slice 3.
+
+**Rationale:**
+- Slice 1 focuses on "What's Ready?" - dependency and completion queries only
+- Template paths are validated syntactically (non-empty string) but not resolved
+- Keeps Slice 1 focused and independently testable
+
+### Decision: Cycle Error Format
+Cycle errors list all artifact IDs in the cycle for easy debugging.
+
+**Format:** `"Cyclic dependency detected: A â†’ B â†’ C â†’ A"`
+
+**Rationale:**
+- Shows the full cycle path, not just that a cycle exists
+- Actionable - developer can see exactly which artifacts to fix
+- Consistent with Kahn's algorithm which naturally identifies cycle participants
+
+## Data Structures
+
+**Zod Schemas (source of truth):**
+
+```typescript
+import { z } from 'zod';
+
+// Artifact definition schema
+export const ArtifactSchema = z.object({
+  id: z.string().min(1, 'Artifact ID is required'),
+  generates: z.string().min(1),      // e.g., "proposal.md" or "specs/*.md"
+  description: z.string(),
+  template: z.string(),              // path to template file
+  requires: z.array(z.string()).default([]),
+});
+
+// Full schema YAML structure
+export const SchemaYamlSchema = z.object({
+  name: z.string().min(1, 'Schema name is required'),
+  version: z.number().int().positive(),
+  description: z.string().optional(),
+  artifacts: z.array(ArtifactSchema).min(1, 'At least one artifact required'),
+});
+
+// Derived TypeScript types
+export type Artifact = z.infer<typeof ArtifactSchema>;
+export type SchemaYaml = z.infer<typeof SchemaYamlSchema>;
+```
+
+**Runtime State (not Zod - internal only):**
+
+```typescript
+// Slice 1: Simple completion tracking via filesystem
+type CompletedSet = Set<string>;
+
+// Return type for blocked query
+interface BlockedArtifacts {
+  [artifactId: string]: string[];  // artifact â†’ list of unmet dependencies
+}
+
+interface ArtifactGraphResult {
+  completed: string[];
+  ready: string[];
+  blocked: BlockedArtifacts;
+  buildOrder: string[];
+}
+```
+
+## File Structure
+
+```
+src/core/artifact-graph/
+â”œâ”€â”€ index.ts           # Public exports
+â”œâ”€â”€ types.ts           # Zod schemas and type definitions
+â”œâ”€â”€ graph.ts           # ArtifactGraph class
+â”œâ”€â”€ state.ts           # State detection logic
+â”œâ”€â”€ resolver.ts        # Schema resolution (global â†’ built-in)
+â””â”€â”€ schemas/           # Built-in schema definitions (package level)
+    â”œâ”€â”€ spec-driven.yaml   # Default: proposal â†’ specs â†’ design â†’ tasks
+    â””â”€â”€ tdd.yaml           # Alternative: tests â†’ implementation â†’ docs
+```
+
+**Schema Resolution Paths:**
+- Global user override: `${XDG_DATA_HOME:-~/.local/share}/openspec/schemas/<name>.yaml`
+- Package built-in: `src/core/artifact-graph/schemas/<name>.yaml` (bundled with package)
+
+## Risks / Trade-offs
+
+| Risk | Mitigation |
+|------|------------|
+| Glob pattern edge cases | Use well-tested glob library (fast-glob or similar) |
+| Cycle detection | Kahn's algorithm naturally fails on cycles; provide clear error |
+| Schema evolution | Version field in schema, validate on load |
+
+## Open Questions
+
+None - all questions resolved in Decisions section.
diff --git a/openspec/changes/archive/2025-12-24-add-artifact-graph-core/proposal.md b/openspec/changes/archive/2025-12-24-add-artifact-graph-core/proposal.md
new file mode 100644
index 0000000..393d331
--- /dev/null
+++ b/openspec/changes/archive/2025-12-24-add-artifact-graph-core/proposal.md
@@ -0,0 +1,18 @@
+## Why
+
+The current OpenSpec system relies on conventions and AI inference for artifact ordering. A formal artifact graph with dependency awareness would enable deterministic "what's ready?" queries, making the system more predictable and enabling future features like automated pipeline execution.
+
+## What Changes
+
+- Add `ArtifactGraph` class to model artifacts as a DAG with dependency relationships
+- Add `ArtifactState` type to track completion status (completed, in_progress, failed)
+- Add filesystem-based state detection using file existence and glob patterns
+- Add schema YAML parser to load artifact definitions
+- Implement topological sort (Kahn's algorithm) for build order calculation
+- Add `getNextArtifacts()` to find artifacts ready for creation
+
+## Impact
+
+- Affected specs: New `artifact-graph` capability
+- Affected code: `src/core/artifact-graph/` (new directory)
+- No changes to existing functionality - this is a parallel module
diff --git a/openspec/changes/archive/2025-12-24-add-artifact-graph-core/specs/artifact-graph/spec.md b/openspec/changes/archive/2025-12-24-add-artifact-graph-core/specs/artifact-graph/spec.md
new file mode 100644
index 0000000..bc5898f
--- /dev/null
+++ b/openspec/changes/archive/2025-12-24-add-artifact-graph-core/specs/artifact-graph/spec.md
@@ -0,0 +1,103 @@
+## ADDED Requirements
+
+### Requirement: Schema Loading
+The system SHALL load artifact graph definitions from YAML schema files.
+
+#### Scenario: Valid schema loaded
+- **WHEN** a valid schema YAML file is provided
+- **THEN** the system returns an ArtifactGraph with all artifacts and dependencies
+
+#### Scenario: Invalid schema rejected
+- **WHEN** a schema YAML file is missing required fields
+- **THEN** the system throws an error with a descriptive message
+
+#### Scenario: Cyclic dependencies detected
+- **WHEN** a schema contains cyclic artifact dependencies
+- **THEN** the system throws an error listing the artifact IDs in the cycle
+
+#### Scenario: Invalid dependency reference
+- **WHEN** an artifact's `requires` array references a non-existent artifact ID
+- **THEN** the system throws an error identifying the invalid reference
+
+#### Scenario: Duplicate artifact IDs rejected
+- **WHEN** a schema contains multiple artifacts with the same ID
+- **THEN** the system throws an error identifying the duplicate
+
+### Requirement: Build Order Calculation
+The system SHALL compute a valid topological build order for artifacts.
+
+#### Scenario: Linear dependency chain
+- **WHEN** artifacts form a linear chain (A â†’ B â†’ C)
+- **THEN** getBuildOrder() returns [A, B, C]
+
+#### Scenario: Diamond dependency
+- **WHEN** artifacts form a diamond (A â†’ B, A â†’ C, B â†’ D, C â†’ D)
+- **THEN** getBuildOrder() returns A before B and C, and D last
+
+#### Scenario: Independent artifacts
+- **WHEN** artifacts have no dependencies
+- **THEN** getBuildOrder() returns them in a stable order
+
+### Requirement: State Detection
+The system SHALL detect artifact completion state by scanning the filesystem.
+
+#### Scenario: Simple file exists
+- **WHEN** an artifact generates "proposal.md" and the file exists
+- **THEN** the artifact is marked as completed
+
+#### Scenario: Simple file missing
+- **WHEN** an artifact generates "proposal.md" and the file does not exist
+- **THEN** the artifact is not marked as completed
+
+#### Scenario: Glob pattern with files
+- **WHEN** an artifact generates "specs/*.md" and the specs/ directory contains .md files
+- **THEN** the artifact is marked as completed
+
+#### Scenario: Glob pattern empty
+- **WHEN** an artifact generates "specs/*.md" and the specs/ directory is empty or missing
+- **THEN** the artifact is not marked as completed
+
+#### Scenario: Missing change directory
+- **WHEN** the change directory does not exist
+- **THEN** all artifacts are marked as not completed (empty state)
+
+### Requirement: Ready Artifact Query
+The system SHALL identify which artifacts are ready to be created based on dependency completion.
+
+#### Scenario: Root artifacts ready initially
+- **WHEN** no artifacts are completed
+- **THEN** getNextArtifacts() returns artifacts with no dependencies
+
+#### Scenario: Dependent artifact becomes ready
+- **WHEN** an artifact's dependencies are all completed
+- **THEN** getNextArtifacts() includes that artifact
+
+#### Scenario: Blocked artifacts excluded
+- **WHEN** an artifact has uncompleted dependencies
+- **THEN** getNextArtifacts() does not include that artifact
+
+### Requirement: Completion Check
+The system SHALL determine when all artifacts in a graph are complete.
+
+#### Scenario: All complete
+- **WHEN** all artifacts in the graph are in the completed set
+- **THEN** isComplete() returns true
+
+#### Scenario: Partially complete
+- **WHEN** some artifacts in the graph are not completed
+- **THEN** isComplete() returns false
+
+### Requirement: Blocked Query
+The system SHALL identify which artifacts are blocked and return all their unmet dependencies.
+
+#### Scenario: Artifact blocked by single dependency
+- **WHEN** artifact B requires artifact A and A is not complete
+- **THEN** getBlocked() returns `{ B: ['A'] }`
+
+#### Scenario: Artifact blocked by multiple dependencies
+- **WHEN** artifact C requires A and B, and only A is complete
+- **THEN** getBlocked() returns `{ C: ['B'] }`
+
+#### Scenario: Artifact blocked by all dependencies
+- **WHEN** artifact C requires A and B, and neither is complete
+- **THEN** getBlocked() returns `{ C: ['A', 'B'] }`
diff --git a/openspec/changes/archive/2025-12-24-add-artifact-graph-core/tasks.md b/openspec/changes/archive/2025-12-24-add-artifact-graph-core/tasks.md
new file mode 100644
index 0000000..125f186
--- /dev/null
+++ b/openspec/changes/archive/2025-12-24-add-artifact-graph-core/tasks.md
@@ -0,0 +1,61 @@
+## 1. Type Definitions
+- [x] 1.1 Create `src/core/artifact-graph/types.ts` with Zod schemas (`ArtifactSchema`, `SchemaYamlSchema`) and inferred types via `z.infer<>`
+- [x] 1.2 Define `CompletedSet` (Set<string>), `BlockedArtifacts`, and `ArtifactGraphResult` types for runtime state
+
+## 2. Schema Parser
+- [x] 2.1 Create `src/core/artifact-graph/schema.ts` with YAML loading and Zod validation via `.safeParse()`
+- [x] 2.2 Implement dependency reference validation (ensure `requires` references valid artifact IDs)
+- [x] 2.3 Implement duplicate artifact ID detection
+- [x] 2.4 Add cycle detection during schema load (error format: "Cyclic dependency detected: A â†’ B â†’ C â†’ A")
+
+## 3. Artifact Graph Core
+- [x] 3.1 Create `src/core/artifact-graph/graph.ts` with ArtifactGraph class
+- [x] 3.2 Implement `fromYaml(path)` - load graph from schema file
+- [x] 3.3 Implement `getBuildOrder()` - topological sort via Kahn's algorithm
+- [x] 3.4 Implement `getArtifact(id)` - retrieve single artifact definition
+- [x] 3.5 Implement `getAllArtifacts()` - list all artifacts
+
+## 4. State Detection
+- [x] 4.1 Create `src/core/artifact-graph/state.ts` with state detection logic
+- [x] 4.2 Implement file existence checking for simple paths
+- [x] 4.3 Implement glob pattern matching for multi-file artifacts
+- [x] 4.4 Implement `detectCompleted(graph, changeDir)` - scan filesystem and return CompletedSet
+- [x] 4.5 Handle missing changeDir gracefully (return empty CompletedSet)
+
+## 5. Ready Calculation
+- [x] 5.1 Implement `getNextArtifacts(graph, completed)` - find artifacts with all deps completed
+- [x] 5.2 Implement `isComplete(graph, completed)` - check if all artifacts done
+- [x] 5.3 Implement `getBlocked(graph, completed)` - return BlockedArtifacts map (artifact â†’ unmet deps)
+
+## 6. Schema Resolution
+- [x] 6.1 Create `src/core/artifact-graph/resolver.ts` with schema resolution logic
+- [x] 6.2 Add `getGlobalDataDir()` to `src/core/global-config.ts` (XDG_DATA_HOME with platform fallbacks)
+- [x] 6.3 Implement `resolveSchema(name)` - global (`${XDG_DATA_HOME}/openspec/schemas/`) â†’ built-in fallback
+
+## 7. Built-in Schemas
+- [x] 7.1 Create `src/core/artifact-graph/schemas/spec-driven.yaml` (default: proposal â†’ specs â†’ design â†’ tasks)
+- [x] 7.2 Create `src/core/artifact-graph/schemas/tdd.yaml` (alternative: tests â†’ implementation â†’ docs)
+
+## 8. Integration
+- [x] 8.1 Create `src/core/artifact-graph/index.ts` with public exports
+
+## 9. Testing
+- [x] 9.1 Test: Parse valid schema YAML returns correct artifact graph
+- [x] 9.2 Test: Parse invalid schema (missing fields) throws descriptive error
+- [x] 9.3 Test: Duplicate artifact IDs throws error
+- [x] 9.4 Test: Invalid `requires` reference throws error identifying the invalid ID
+- [x] 9.5 Test: Cycle in schema throws error listing cycle path (e.g., "A â†’ B â†’ C â†’ A")
+- [x] 9.6 Test: Compute build order returns correct topological ordering (linear chain)
+- [x] 9.7 Test: Compute build order handles diamond dependencies correctly
+- [x] 9.8 Test: Independent artifacts return in stable order
+- [x] 9.9 Test: Empty/missing changeDir returns empty CompletedSet
+- [x] 9.10 Test: File existence marks artifact as completed
+- [x] 9.11 Test: Glob pattern specs/*.md detected as complete when files exist
+- [x] 9.12 Test: Glob pattern with empty directory not marked complete
+- [x] 9.13 Test: getNextArtifacts returns only root artifacts when nothing completed
+- [x] 9.14 Test: getNextArtifacts includes artifact when all deps completed
+- [x] 9.15 Test: getBlocked returns artifact with all unmet dependencies listed
+- [x] 9.16 Test: isComplete() returns true when all artifacts completed
+- [x] 9.17 Test: isComplete() returns false when some artifacts incomplete
+- [x] 9.18 Test: Schema resolution finds global override before built-in
+- [x] 9.19 Test: Schema resolution falls back to built-in when no global
diff --git a/openspec/changes/archive/2025-12-25-add-change-manager/design.md b/openspec/changes/archive/2025-12-25-add-change-manager/design.md
new file mode 100644
index 0000000..12e8351
--- /dev/null
+++ b/openspec/changes/archive/2025-12-25-add-change-manager/design.md
@@ -0,0 +1,74 @@
+## Context
+
+This is Slice 2 of the artifact tracker POC. The goal is to provide utilities for creating change directories programmatically.
+
+**Current state:** No programmatic way to create changes. Users must manually create directories.
+
+**Proposed state:** Utility functions for change creation with name validation.
+
+## Goals / Non-Goals
+
+### Goals
+- **Add** `createChange()` function to create change directories
+- **Add** `validateChangeName()` function for kebab-case validation
+- **Enable** automation (Claude commands, scripts) to create changes
+
+### Non-Goals
+- Refactor existing CLI commands (they work fine)
+- Create abstraction layers or manager classes
+- Change how `ListCommand` or `ChangeCommand` work
+
+## Decisions
+
+### Decision 1: Simple Utility Functions
+
+**Choice**: Add functions to `src/utils/change-utils.ts` - no class.
+
+```typescript
+// src/utils/change-utils.ts
+
+export function validateChangeName(name: string): { valid: boolean; error?: string }
+
+export async function createChange(
+  projectRoot: string,
+  name: string
+): Promise<void>
+```
+
+**Why**:
+- Simple, no abstraction overhead
+- Easy to test
+- Easy to import where needed
+- Matches existing utility patterns in `src/utils/`
+
+**Alternatives considered**:
+- ChangeManager class: Rejected - over-engineered for 2 functions
+- Add to existing command: Rejected - mixes CLI with reusable logic
+
+### Decision 2: Kebab-Case Validation Pattern
+
+**Choice**: Validate names with `^[a-z][a-z0-9]*(-[a-z0-9]+)*$`
+
+Valid: `add-auth`, `refactor-db`, `add-feature-2`, `refactor`
+Invalid: `Add-Auth`, `add auth`, `add_auth`, `-add-auth`, `add-auth-`, `add--auth`
+
+**Why**:
+- Filesystem-safe (no special characters)
+- URL-safe (for future web UI)
+- Consistent with existing change naming in repo
+
+## File Changes
+
+### New Files
+- `src/utils/change-utils.ts` - Utility functions
+- `src/utils/change-utils.test.ts` - Unit tests
+
+### Modified Files
+- None
+
+## Risks / Trade-offs
+
+| Risk | Mitigation |
+|------|------------|
+| Function might not cover all use cases | Start simple, extend if needed |
+| Naming conflicts with future work | Using clear, specific function names |
diff --git a/openspec/changes/archive/2025-12-25-add-change-manager/proposal.md b/openspec/changes/archive/2025-12-25-add-change-manager/proposal.md
new file mode 100644
index 0000000..047d46d
--- /dev/null
+++ b/openspec/changes/archive/2025-12-25-add-change-manager/proposal.md
@@ -0,0 +1,45 @@
+## Why
+
+There's no programmatic way to create a new change directory. Users must manually:
+1. Create `openspec/changes/<name>/` directory
+2. Create a `proposal.md` file
+3. Hope they got the naming right
+
+This is error-prone and blocks automation (e.g., Claude commands, scripts).
+
+**This proposal adds:**
+1. `createChange(projectRoot, name)` - Create change directories programmatically
+2. `validateChangeName(name)` - Enforce kebab-case naming conventions
+
+## What Changes
+
+### New Utilities
+
+| Function | Description |
+|----------|-------------|
+| `createChange(projectRoot, name)` | Creates `openspec/changes/<name>/` directory |
+| `validateChangeName(name)` | Returns `{ valid: boolean; error?: string }` |
+
+### Name Validation Rules
+
+Pattern: `^[a-z][a-z0-9]*(-[a-z0-9]+)*$`
+
+| Valid | Invalid |
+|-------|---------|
+| `add-auth` | `Add-Auth` (uppercase) |
+| `refactor-db` | `add auth` (spaces) |
+| `add-feature-2` | `add_auth` (underscores) |
+| `refactor` | `-add-auth` (leading hyphen) |
+
+### Location
+
+New file: `src/utils/change-utils.ts`
+
+Simple utility functions - no class, no abstraction layer.
+
+## Impact
+
+- **Affected specs**: None
+- **Affected code**: None (new utilities only)
+- **New files**: `src/utils/change-utils.ts`
+- **Breaking changes**: None
diff --git a/openspec/changes/archive/2025-12-25-add-change-manager/specs/change-creation/spec.md b/openspec/changes/archive/2025-12-25-add-change-manager/specs/change-creation/spec.md
new file mode 100644
index 0000000..447bf78
--- /dev/null
+++ b/openspec/changes/archive/2025-12-25-add-change-manager/specs/change-creation/spec.md
@@ -0,0 +1,63 @@
+## ADDED Requirements
+
+### Requirement: Change Creation
+The system SHALL provide a function to create new change directories programmatically.
+
+#### Scenario: Create change
+- **WHEN** `createChange(projectRoot, 'add-auth')` is called
+- **THEN** the system creates `openspec/changes/add-auth/` directory
+
+#### Scenario: Duplicate change rejected
+- **WHEN** `createChange(projectRoot, 'add-auth')` is called and `openspec/changes/add-auth/` already exists
+- **THEN** the system throws an error indicating the change already exists
+
+#### Scenario: Creates parent directories if needed
+- **WHEN** `createChange(projectRoot, 'add-auth')` is called and `openspec/changes/` does not exist
+- **THEN** the system creates the full path including parent directories
+
+#### Scenario: Invalid change name rejected
+- **WHEN** `createChange(projectRoot, 'Add Auth')` is called with an invalid name
+- **THEN** the system throws a validation error
+
+### Requirement: Change Name Validation
+The system SHALL validate change names follow kebab-case conventions.
+
+#### Scenario: Valid kebab-case name accepted
+- **WHEN** a change name like `add-user-auth` is validated
+- **THEN** validation returns `{ valid: true }`
+
+#### Scenario: Numeric suffixes accepted
+- **WHEN** a change name like `add-feature-2` is validated
+- **THEN** validation returns `{ valid: true }`
+
+#### Scenario: Single word accepted
+- **WHEN** a change name like `refactor` is validated
+- **THEN** validation returns `{ valid: true }`
+
+#### Scenario: Uppercase characters rejected
+- **WHEN** a change name like `Add-Auth` is validated
+- **THEN** validation returns `{ valid: false, error: "..." }`
+
+#### Scenario: Spaces rejected
+- **WHEN** a change name like `add auth` is validated
+- **THEN** validation returns `{ valid: false, error: "..." }`
+
+#### Scenario: Underscores rejected
+- **WHEN** a change name like `add_auth` is validated
+- **THEN** validation returns `{ valid: false, error: "..." }`
+
+#### Scenario: Special characters rejected
+- **WHEN** a change name like `add-auth!` is validated
+- **THEN** validation returns `{ valid: false, error: "..." }`
+
+#### Scenario: Leading hyphen rejected
+- **WHEN** a change name like `-add-auth` is validated
+- **THEN** validation returns `{ valid: false, error: "..." }`
+
+#### Scenario: Trailing hyphen rejected
+- **WHEN** a change name like `add-auth-` is validated
+- **THEN** validation returns `{ valid: false, error: "..." }`
+
+#### Scenario: Consecutive hyphens rejected
+- **WHEN** a change name like `add--auth` is validated
+- **THEN** validation returns `{ valid: false, error: "..." }`
diff --git a/openspec/changes/archive/2025-12-25-add-change-manager/tasks.md b/openspec/changes/archive/2025-12-25-add-change-manager/tasks.md
new file mode 100644
index 0000000..d07177c
--- /dev/null
+++ b/openspec/changes/archive/2025-12-25-add-change-manager/tasks.md
@@ -0,0 +1,30 @@
+## Phase 1: Implement Name Validation
+
+- [x] 1.1 Create `src/utils/change-utils.ts`
+- [x] 1.2 Implement `validateChangeName()` with kebab-case pattern
+- [x] 1.3 Pattern: `^[a-z][a-z0-9]*(-[a-z0-9]+)*$`
+- [x] 1.4 Return `{ valid: boolean; error?: string }`
+- [x] 1.5 Add test: valid names accepted (`add-auth`, `refactor`, `add-feature-2`)
+- [x] 1.6 Add test: uppercase rejected
+- [x] 1.7 Add test: spaces rejected
+- [x] 1.8 Add test: underscores rejected
+- [x] 1.9 Add test: special characters rejected
+- [x] 1.10 Add test: leading/trailing hyphens rejected
+- [x] 1.11 Add test: consecutive hyphens rejected
+
+## Phase 2: Implement Change Creation
+
+- [x] 2.1 Implement `createChange(projectRoot, name)`
+- [x] 2.2 Validate name before creating
+- [x] 2.3 Create parent directories if needed (`openspec/changes/`)
+- [x] 2.4 Throw if change already exists
+- [x] 2.5 Add test: creates directory
+- [x] 2.6 Add test: duplicate change throws error
+- [x] 2.7 Add test: invalid name throws validation error
+- [x] 2.8 Add test: creates parent directories if needed
+
+## Phase 3: Integration
+
+- [x] 3.1 Export functions from `src/utils/index.ts`
+- [x] 3.2 Add JSDoc comments
+- [x] 3.3 Run all tests to verify no regressions
diff --git a/openspec/changes/archive/2025-12-28-add-artifact-workflow-cli/design.md b/openspec/changes/archive/2025-12-28-add-artifact-workflow-cli/design.md
new file mode 100644
index 0000000..ae7616f
--- /dev/null
+++ b/openspec/changes/archive/2025-12-28-add-artifact-workflow-cli/design.md
@@ -0,0 +1,112 @@
+## Context
+
+Slice 4 of the artifact workflow POC. The core functionality (ArtifactGraph, InstructionLoader, change-utils) is complete. This slice adds CLI commands to expose the artifact workflow to users.
+
+**Key constraint**: This is experimental. Commands must be isolated for easy removal if the feature doesn't work out.
+
+## Goals / Non-Goals
+
+- **Goals:**
+  - Expose artifact workflow status and instructions via CLI
+  - Provide fluid UX with top-level verb commands
+  - Support both human-readable and JSON output
+  - Enable agents to programmatically query workflow state
+  - Keep implementation isolated for easy removal
+
+- **Non-Goals:**
+  - Interactive artifact creation wizards (future work)
+  - Schema management commands (deferred)
+  - Auto-detection of active change (CLI is deterministic, agents infer)
+
+## Decisions
+
+### Command Structure: Top-Level Verbs
+
+Commands are top-level for maximum fluidity:
+
+```
+openspec status --change <id>
+openspec next --change <id>
+openspec instructions <artifact> --change <id>
+openspec templates [--schema <name>]
+openspec new change <name>
+```
+
+**Rationale:**
+- Most fluid UX - fewest keystrokes
+- Commands are unique enough to avoid conflicts
+- Simple mental model for users
+
+**Trade-off accepted:** Slight namespace pollution, but commands are distinct and can be removed cleanly.
+
+### Experimental Isolation
+
+All artifact workflow commands are implemented in a single file:
+
+```
+src/commands/artifact-workflow.ts
+```
+
+**To remove the feature:**
+1. Delete `src/commands/artifact-workflow.ts`
+2. Remove ~5 lines from `src/cli/index.ts`
+
+No other files touched, no risk to stable functionality.
+
+### Deterministic CLI with Explicit `--change`
+
+All change-specific commands require `--change <id>`:
+
+```bash
+openspec status --change add-auth   # explicit, works
+openspec status                      # error: missing --change
+```
+
+**Rationale:**
+- CLI is pure, testable, no hidden state
+- Agents infer change from conversation and pass explicitly
+- No config file tracking "active change"
+- Consistent with POC design philosophy
+
+### New Change Command Structure
+
+Creating changes uses explicit subcommand:
+
+```bash
+openspec new change add-feature
+```
+
+**Rationale:**
+- `openspec new <name>` is ambiguous (new what?)
+- `openspec new change <name>` is clear and extensible
+- Can add `openspec new spec <name>` later if needed
+
+### Output Formats
+
+- **Default**: Human-readable text with visual indicators
+  - Status: `[x]` done, `[ ]` ready, `[-]` blocked
+  - Colors: green (done), yellow (ready), red (blocked)
+- **JSON** (`--json`): Machine-readable for scripts and agents
+
+### Error Handling
+
+- Missing `--change`: Error listing available changes
+- Unknown change: Error with suggestion
+- Unknown artifact: Error listing valid artifacts
+- Missing schema: Error with schema resolution details
+
+## Risks / Trade-offs
+
+| Risk | Mitigation |
+|------|------------|
+| Top-level commands pollute namespace | Commands are distinct; isolated for easy removal |
+| `status` confused with git | Context (`--change`) makes it clear |
+| Feature doesn't work out | Single file deletion removes everything |
+
+## Implementation Notes
+
+- All commands in `src/commands/artifact-workflow.ts`
+- Imports from `src/core/artifact-graph/` for all operations
+- Uses `getActiveChangeIds()` from `item-discovery.ts` for change listing
+- Follows existing CLI patterns (ora spinners, commander.js options)
+- Help text marks commands as "Experimental"
diff --git a/openspec/changes/archive/2025-12-28-add-artifact-workflow-cli/proposal.md b/openspec/changes/archive/2025-12-28-add-artifact-workflow-cli/proposal.md
new file mode 100644
index 0000000..93e5403
--- /dev/null
+++ b/openspec/changes/archive/2025-12-28-add-artifact-workflow-cli/proposal.md
@@ -0,0 +1,33 @@
+## Why
+
+The ArtifactGraph (Slice 1) and InstructionLoader (Slice 3) provide programmatic APIs for artifact-based workflow management. Users currently have no CLI interface to:
+- See artifact completion status for a change
+- Discover what artifacts are ready to create
+- Get enriched instructions for creating artifacts
+- Create new changes with proper validation
+
+This proposal adds CLI commands that expose the artifact workflow functionality to users and agents.
+
+## What Changes
+
+- **NEW**: `openspec status --change <id>` shows artifact completion state
+- **NEW**: `openspec next --change <id>` shows artifacts ready to create
+- **NEW**: `openspec instructions <artifact> --change <id>` outputs enriched template
+- **NEW**: `openspec templates [--schema <name>]` shows resolved template paths
+- **NEW**: `openspec new change <name>` creates a new change directory
+
+All commands are top-level for fluid UX. They integrate with existing core modules:
+- Uses `loadChangeContext()`, `formatChangeStatus()`, `generateInstructions()` from instruction-loader
+- Uses `ArtifactGraph`, `detectCompleted()` from artifact-graph
+- Uses `createChange()`, `validateChangeName()` from change-utils
+
+**Experimental isolation**: All commands are implemented in a single file (`src/commands/artifact-workflow.ts`) for easy removal if the feature doesn't work out. Help text marks them as experimental.
+
+## Impact
+
+- Affected specs: NEW `cli-artifact-workflow` capability
+- Affected code:
+  - `src/cli/index.ts` - register new commands
+  - `src/commands/artifact-workflow.ts` - new command implementations
+- No changes to existing commands or specs
+- Builds on completed Slice 1, 2, and 3 implementations
diff --git a/openspec/changes/archive/2025-12-28-add-artifact-workflow-cli/specs/cli-artifact-workflow/spec.md b/openspec/changes/archive/2025-12-28-add-artifact-workflow-cli/specs/cli-artifact-workflow/spec.md
new file mode 100644
index 0000000..dbf5d3d
--- /dev/null
+++ b/openspec/changes/archive/2025-12-28-add-artifact-workflow-cli/specs/cli-artifact-workflow/spec.md
@@ -0,0 +1,153 @@
+# cli-artifact-workflow Specification
+
+## Purpose
+CLI commands for artifact workflow operations, exposing the artifact graph and instruction loader functionality to users and agents. Commands are top-level for fluid UX and implemented in isolation for easy removal.
+
+## ADDED Requirements
+
+### Requirement: Status Command
+The system SHALL display artifact completion status for a change.
+
+#### Scenario: Show status with all states
+- **WHEN** user runs `openspec status --change <id>`
+- **THEN** the system displays each artifact with status indicator:
+  - `[x]` for completed artifacts
+  - `[ ]` for ready artifacts
+  - `[-]` for blocked artifacts (with missing dependencies listed)
+
+#### Scenario: Status shows completion summary
+- **WHEN** user runs `openspec status --change <id>`
+- **THEN** output includes completion percentage and count (e.g., "2/4 artifacts complete")
+
+#### Scenario: Status JSON output
+- **WHEN** user runs `openspec status --change <id> --json`
+- **THEN** the system outputs JSON with changeName, schemaName, isComplete, and artifacts array
+
+#### Scenario: Missing change parameter
+- **WHEN** user runs `openspec status` without `--change`
+- **THEN** the system displays an error with list of available changes
+
+#### Scenario: Unknown change
+- **WHEN** user runs `openspec status --change unknown-id`
+- **THEN** the system displays an error indicating the change does not exist
+
+### Requirement: Next Command
+The system SHALL show which artifacts are ready to be created.
+
+#### Scenario: Show ready artifacts
+- **WHEN** user runs `openspec next --change <id>`
+- **THEN** the system lists artifacts whose dependencies are all satisfied
+
+#### Scenario: No artifacts ready
+- **WHEN** all artifacts are either completed or blocked
+- **THEN** the system indicates no artifacts are ready (with explanation)
+
+#### Scenario: All artifacts complete
+- **WHEN** all artifacts in the change are completed
+- **THEN** the system indicates the change is complete
+
+#### Scenario: Next JSON output
+- **WHEN** user runs `openspec next --change <id> --json`
+- **THEN** the system outputs JSON array of ready artifact IDs
+
+### Requirement: Instructions Command
+The system SHALL output enriched instructions for creating an artifact.
+
+#### Scenario: Show enriched instructions
+- **WHEN** user runs `openspec instructions <artifact> --change <id>`
+- **THEN** the system outputs:
+  - Artifact metadata (ID, output path, description)
+  - Template content
+  - Dependency status (done/missing)
+  - Unlocked artifacts (what becomes available after completion)
+
+#### Scenario: Instructions JSON output
+- **WHEN** user runs `openspec instructions <artifact> --change <id> --json`
+- **THEN** the system outputs JSON matching ArtifactInstructions interface
+
+#### Scenario: Unknown artifact
+- **WHEN** user runs `openspec instructions unknown-artifact --change <id>`
+- **THEN** the system displays an error listing valid artifact IDs for the schema
+
+#### Scenario: Artifact with unmet dependencies
+- **WHEN** user requests instructions for a blocked artifact
+- **THEN** the system displays instructions with a warning about missing dependencies
+
+### Requirement: Templates Command
+The system SHALL show resolved template paths for all artifacts in a schema.
+
+#### Scenario: List template paths with default schema
+- **WHEN** user runs `openspec templates`
+- **THEN** the system displays each artifact with its resolved template path using the default schema
+
+#### Scenario: List template paths with custom schema
+- **WHEN** user runs `openspec templates --schema tdd`
+- **THEN** the system displays template paths for the specified schema
+
+#### Scenario: Templates JSON output
+- **WHEN** user runs `openspec templates --json`
+- **THEN** the system outputs JSON mapping artifact IDs to template paths
+
+#### Scenario: Template resolution source
+- **WHEN** displaying template paths
+- **THEN** the system indicates whether each template is from user override or package built-in
+
+### Requirement: New Change Command
+The system SHALL create new change directories with validation.
+
+#### Scenario: Create valid change
+- **WHEN** user runs `openspec new change add-feature`
+- **THEN** the system creates `openspec/changes/add-feature/` directory
+
+#### Scenario: Invalid change name
+- **WHEN** user runs `openspec new change "Add Feature"` with invalid name
+- **THEN** the system displays validation error with guidance
+
+#### Scenario: Duplicate change name
+- **WHEN** user runs `openspec new change existing-change` for an existing change
+- **THEN** the system displays an error indicating the change already exists
+
+#### Scenario: Create with description
+- **WHEN** user runs `openspec new change add-feature --description "Add new feature"`
+- **THEN** the system creates the change directory with description in README.md
+
+### Requirement: Schema Selection
+The system SHALL support custom schema selection for workflow commands.
+
+#### Scenario: Default schema
+- **WHEN** user runs workflow commands without `--schema`
+- **THEN** the system uses the "spec-driven" schema
+
+#### Scenario: Custom schema
+- **WHEN** user runs `openspec status --change <id> --schema tdd`
+- **THEN** the system uses the specified schema for artifact graph
+
+#### Scenario: Unknown schema
+- **WHEN** user specifies an unknown schema
+- **THEN** the system displays an error listing available schemas
+
+### Requirement: Output Formatting
+The system SHALL provide consistent output formatting.
+
+#### Scenario: Color output
+- **WHEN** terminal supports colors
+- **THEN** status indicators use colors: green (done), yellow (ready), red (blocked)
+
+#### Scenario: No color output
+- **WHEN** `--no-color` flag is used or NO_COLOR environment variable is set
+- **THEN** output uses text-only indicators without ANSI colors
+
+#### Scenario: Progress indication
+- **WHEN** loading change state takes time
+- **THEN** the system displays a spinner during loading
+
+### Requirement: Experimental Isolation
+The system SHALL implement artifact workflow commands in isolation for easy removal.
+
+#### Scenario: Single file implementation
+- **WHEN** artifact workflow feature is implemented
+- **THEN** all commands are in `src/commands/artifact-workflow.ts`
+
+#### Scenario: Help text marking
+- **WHEN** user runs `--help` on any artifact workflow command
+- **THEN** help text indicates the command is experimental
diff --git a/openspec/changes/archive/2025-12-28-add-artifact-workflow-cli/tasks.md b/openspec/changes/archive/2025-12-28-add-artifact-workflow-cli/tasks.md
new file mode 100644
index 0000000..f1a3d4a
--- /dev/null
+++ b/openspec/changes/archive/2025-12-28-add-artifact-workflow-cli/tasks.md
@@ -0,0 +1,48 @@
+## 1. Core Command Implementation
+
+- [x] 1.1 Create `src/commands/artifact-workflow.ts` with all commands
+- [x] 1.2 Implement `status` command with text output
+- [x] 1.3 Implement `next` command with text output
+- [x] 1.4 Implement `instructions` command with text output
+- [x] 1.5 Implement `templates` command with text output
+- [x] 1.6 Implement `new change` subcommand using createChange()
+
+## 2. CLI Registration
+
+- [x] 2.1 Register `status` command in `src/cli/index.ts`
+- [x] 2.2 Register `next` command in `src/cli/index.ts`
+- [x] 2.3 Register `instructions` command in `src/cli/index.ts`
+- [x] 2.4 Register `templates` command in `src/cli/index.ts`
+- [x] 2.5 Register `new` command group with `change` subcommand
+
+## 3. Output Formatting
+
+- [x] 3.1 Add `--json` flag support to all commands
+- [x] 3.2 Add color-coded status indicators (done/ready/blocked)
+- [x] 3.3 Add progress spinner for loading operations
+- [x] 3.4 Support `--no-color` flag
+
+## 4. Error Handling
+
+- [x] 4.1 Handle missing `--change` parameter with helpful error
+- [x] 4.2 Handle unknown change names with list of available changes
+- [x] 4.3 Handle unknown artifact names with valid options
+- [x] 4.4 Handle schema resolution errors
+
+## 5. Options and Flags
+
+- [x] 5.1 Add `--schema` option for custom schema selection
+- [x] 5.2 Add `--description` option to `new change` command
+- [x] 5.3 Ensure options follow existing CLI patterns
+
+## 6. Testing
+
+- [x] 6.1 Add smoke tests for each command
+- [x] 6.2 Test error cases (missing change, unknown artifact)
+- [x] 6.3 Test JSON output format
+- [x] 6.4 Test with different schemas
+
+## 7. Documentation
+
+- [x] 7.1 Add help text for all commands marked as "Experimental"
+- [ ] 7.2 Update AGENTS.md with new commands (post-archive)
diff --git a/openspec/changes/archive/2025-12-28-add-instruction-loader/design.md b/openspec/changes/archive/2025-12-28-add-instruction-loader/design.md
new file mode 100644
index 0000000..332f2db
--- /dev/null
+++ b/openspec/changes/archive/2025-12-28-add-instruction-loader/design.md
@@ -0,0 +1,149 @@
+## Context
+
+This is Slice 3 of the artifact-graph POC. We have:
+- `ArtifactGraph` class with graph operations (Slice 1)
+- `detectCompleted()` for filesystem-based state detection (Slice 1)
+- `resolveSchema()` for XDG schema resolution (Slice 1)
+- `createChange()` and `validateChangeName()` utilities (Slice 2)
+
+After `restructure-schema-directories` is implemented, schemas will be self-contained directories:
+```
+schemas/<name>/
+â”œâ”€â”€ schema.yaml
+â””â”€â”€ templates/
+    â””â”€â”€ *.md
+```
+
+This proposal adds template loading and instruction enrichment on top of that structure.
+
+## Goals / Non-Goals
+
+**Goals:**
+- Load templates from schema directories
+- Enrich templates with change-specific context (dependency status)
+- Format change status for CLI output
+
+**Non-Goals:**
+- Template authoring UI
+- Dynamic template compilation/execution
+- Caching (keep it stateless like the rest)
+
+## Decisions
+
+### 1. Pure functions over classes
+
+Follow the pattern in `resolver.ts` and `state.ts`. Use a simple `ChangeContext` interface with pure functions:
+
+```typescript
+interface ChangeContext {
+  changeName: string;
+  changeDir: string;
+  schemaName: string;
+  graph: ArtifactGraph;
+  completed: CompletedSet;
+}
+
+function loadChangeContext(projectRoot: string, changeName: string, schemaName?: string): ChangeContext
+function loadTemplate(schemaName: string, templatePath: string): string
+function getInstructions(artifactId: string, context: ChangeContext): string
+function formatStatus(context: ChangeContext): string
+```
+
+**Why:** Matches existing codebase patterns. Easier to test. No hidden state.
+
+### 2. Template resolution from schema directory
+
+Templates are loaded from the schema's `templates/` subdirectory:
+
+```typescript
+function loadTemplate(schemaName: string, templatePath: string): string {
+  const schemaDir = getSchemaDir(schemaName);  // From resolver.ts
+  const fullPath = path.join(schemaDir, 'templates', templatePath);
+  return fs.readFileSync(fullPath, 'utf-8');
+}
+```
+
+Resolution is handled by `getSchemaDir()` which already checks user override â†’ package built-in.
+
+**Why:** Leverages existing schema resolution. Templates are co-located with schemas.
+
+### 3. Template path from artifact definition
+
+The artifact's `template` field is a path relative to the schema's `templates/` directory:
+
+```yaml
+artifacts:
+  - id: proposal
+    template: "proposal.md"  # â†’ schemas/<schema>/templates/proposal.md
+```
+
+**Why:** Explicit, simple, no magic.
+
+### 4. Minimal context injection
+
+Templates are markdown. Injection prepends a header section with context:
+
+```markdown
+---
+change: add-auth
+artifact: proposal
+schema: spec-driven
+output: openspec/changes/add-auth/proposal.md
+---
+
+## Dependencies
+- [x] (none - this is a root artifact)
+
+## Next Steps
+After creating this artifact, you can work on: design, specs
+
+---
+
+[original template content...]
+```
+
+**Why:** Simple string concatenation. No template engine dependency. Clear separation.
+
+### 5. Status output format
+
+```markdown
+## Change: add-auth (spec-driven)
+
+| Artifact | Status | Output |
+|----------|--------|--------|
+| proposal | done | proposal.md |
+| specs | ready | specs/*.md |
+| design | blocked (needs: proposal) | design.md |
+| tasks | blocked (needs: specs, design) | tasks.md |
+```
+
+**Why:** Markdown table is readable in terminal and docs. Matches CLI output style.
+
+## File Structure
+
+```
+src/core/artifact-graph/
+â”œâ”€â”€ index.ts              # Add new exports
+â”œâ”€â”€ template.ts           # NEW: Template loading
+â”œâ”€â”€ context.ts            # NEW: ChangeContext loading
+â””â”€â”€ instructions.ts       # NEW: Enrichment and formatting
+```
+
+## Risks / Trade-offs
+
+**Dependency on restructure-schema-directories:**
+- This proposal requires the schema restructure to be done first
+- Mitigation: Clear dependency documented, implement in order
+
+**No template engine:**
+- Pro: Zero dependencies, simple code
+- Con: Limited expressiveness
+- Mitigation: Current use case only needs static templates + header injection
+
+## Migration Plan
+
+N/A - new capability, no existing code to migrate.
+
+## Open Questions
+
+None.
diff --git a/openspec/changes/archive/2025-12-28-add-instruction-loader/proposal.md b/openspec/changes/archive/2025-12-28-add-instruction-loader/proposal.md
new file mode 100644
index 0000000..0112fb3
--- /dev/null
+++ b/openspec/changes/archive/2025-12-28-add-instruction-loader/proposal.md
@@ -0,0 +1,20 @@
+## Why
+
+Slice 1 (artifact-graph) provides graph operations and state detection. Slice 2 (change-utils) provides change creation. We now need the ability to load templates for artifacts and enrich them with change-specific context so users/agents know what to create next.
+
+## What Changes
+
+- Add template resolution from schema directories (uses structure from `restructure-schema-directories`)
+- Add instruction enrichment that injects change context into templates
+- Add status formatting for CLI output
+- New `instruction-loader` capability
+
+## Dependencies
+
+- Requires `restructure-schema-directories` to be implemented first (schemas as directories with co-located templates)
+
+## Impact
+
+- Affected specs: New `instruction-loader` spec
+- Affected code: `src/core/artifact-graph/` (new files)
+- Builds on: `artifact-graph` (Slice 1), uses `ArtifactGraph`, `detectCompleted`, `resolveSchema`
diff --git a/openspec/changes/archive/2025-12-28-add-instruction-loader/specs/instruction-loader/spec.md b/openspec/changes/archive/2025-12-28-add-instruction-loader/specs/instruction-loader/spec.md
new file mode 100644
index 0000000..7dbe61d
--- /dev/null
+++ b/openspec/changes/archive/2025-12-28-add-instruction-loader/specs/instruction-loader/spec.md
@@ -0,0 +1,70 @@
+# instruction-loader Specification
+
+## Purpose
+Load templates from schema directories and enrich them with change-specific context for guiding artifact creation.
+
+## ADDED Requirements
+
+### Requirement: Template Loading
+The system SHALL load templates from schema directories.
+
+#### Scenario: Load template from schema directory
+- **WHEN** `loadTemplate(schemaName, templatePath)` is called
+- **THEN** the system loads the template from `schemas/<schemaName>/templates/<templatePath>`
+
+#### Scenario: Template file not found
+- **WHEN** a template file does not exist in the schema's templates directory
+- **THEN** the system throws an error with the template path
+
+### Requirement: Change Context Loading
+The system SHALL load change context combining graph and completion state.
+
+#### Scenario: Load context for existing change
+- **WHEN** `loadChangeContext(projectRoot, changeName)` is called for an existing change
+- **THEN** the system returns a context with graph, completed set, schema name, and change info
+
+#### Scenario: Load context with custom schema
+- **WHEN** `loadChangeContext(projectRoot, changeName, schemaName)` is called
+- **THEN** the system uses the specified schema instead of default
+
+#### Scenario: Load context for non-existent change directory
+- **WHEN** `loadChangeContext` is called for a non-existent change directory
+- **THEN** the system returns context with empty completed set
+
+### Requirement: Template Enrichment
+The system SHALL enrich templates with change-specific context.
+
+#### Scenario: Include artifact metadata
+- **WHEN** instructions are generated for an artifact
+- **THEN** the output includes change name, artifact ID, schema name, and output path
+
+#### Scenario: Include dependency status
+- **WHEN** an artifact has dependencies
+- **THEN** the output shows each dependency with completion status (done/missing)
+
+#### Scenario: Include unlocked artifacts
+- **WHEN** instructions are generated
+- **THEN** the output includes which artifacts become available after this one
+
+#### Scenario: Root artifact indicator
+- **WHEN** an artifact has no dependencies
+- **THEN** the dependency section indicates this is a root artifact
+
+### Requirement: Status Formatting
+The system SHALL format change status as readable output.
+
+#### Scenario: All artifacts completed
+- **WHEN** all artifacts are completed
+- **THEN** status shows all artifacts as "done"
+
+#### Scenario: Mixed completion status
+- **WHEN** some artifacts are completed
+- **THEN** status shows completed as "done", ready as "ready", blocked as "blocked"
+
+#### Scenario: Blocked artifact details
+- **WHEN** an artifact is blocked
+- **THEN** status shows which dependencies are missing
+
+#### Scenario: Include output paths
+- **WHEN** status is formatted
+- **THEN** each artifact shows its output path pattern
diff --git a/openspec/changes/archive/2025-12-28-add-instruction-loader/tasks.md b/openspec/changes/archive/2025-12-28-add-instruction-loader/tasks.md
new file mode 100644
index 0000000..a4dbc3a
--- /dev/null
+++ b/openspec/changes/archive/2025-12-28-add-instruction-loader/tasks.md
@@ -0,0 +1,13 @@
+# Tasks
+
+## Implementation Tasks
+
+- [x] Create `instruction-loader` spec in `openspec/specs/instruction-loader/spec.md`
+- [x] Implement `loadTemplate` function to load templates from schema directories
+- [x] Implement `loadChangeContext` function to combine graph and completion state
+- [x] Implement `generateInstructions` function to enrich templates with change context
+- [x] Implement `formatChangeStatus` function for readable status output
+- [x] Export new functions from `src/core/artifact-graph/index.ts`
+- [x] Add comprehensive tests in `test/core/artifact-graph/instruction-loader.test.ts`
+- [x] Verify build passes
+- [x] Verify all tests pass
diff --git a/openspec/changes/archive/2025-12-28-restructure-schema-directories/design.md b/openspec/changes/archive/2025-12-28-restructure-schema-directories/design.md
new file mode 100644
index 0000000..f49cc69
--- /dev/null
+++ b/openspec/changes/archive/2025-12-28-restructure-schema-directories/design.md
@@ -0,0 +1,129 @@
+## Context
+
+Built-in schemas are currently embedded as TypeScript objects:
+
+```typescript
+// src/core/artifact-graph/builtin-schemas.ts
+export const SPEC_DRIVEN_SCHEMA: SchemaYaml = {
+  name: 'spec-driven',
+  version: 1,
+  artifacts: [...]
+};
+```
+
+This doesn't support templates co-located with schemas. The instruction loader (Slice 3) needs templates, and the cleanest approach is self-contained schema directories.
+
+## Goals / Non-Goals
+
+**Goals:**
+- Schemas as self-contained directories (schema.yaml + templates/)
+- User overrides via XDG data directory
+- Simple 2-level resolution (user â†’ package)
+- Templates co-located with their schema
+
+**Non-Goals:**
+- Shared template fallback (intentionally avoiding complexity)
+- Runtime schema compilation
+- Schema inheritance
+
+## Decisions
+
+### 1. Directory structure
+
+Each schema is a directory containing `schema.yaml` and `templates/`:
+
+```
+<package>/schemas/
+â”œâ”€â”€ spec-driven/
+â”‚   â”œâ”€â”€ schema.yaml
+â”‚   â””â”€â”€ templates/
+â”‚       â”œâ”€â”€ proposal.md
+â”‚       â”œâ”€â”€ design.md
+â”‚       â”œâ”€â”€ spec.md
+â”‚       â””â”€â”€ tasks.md
+â””â”€â”€ tdd/
+    â”œâ”€â”€ schema.yaml
+    â””â”€â”€ templates/
+        â”œâ”€â”€ spec.md
+        â”œâ”€â”€ test.md
+        â”œâ”€â”€ implementation.md
+        â””â”€â”€ docs.md
+```
+
+**Why:** Self-contained like Helm charts. No cross-schema dependencies. Each schema owns its templates.
+
+### 2. Resolution order (2 levels)
+
+```
+1. ${XDG_DATA_HOME}/openspec/schemas/<name>/schema.yaml   # User override
+2. <package>/schemas/<name>/schema.yaml                    # Built-in
+3. Error (not found)
+```
+
+**Why:** Simple mental model. User can override entire schema directory or just parts.
+
+### 3. Template path in schema.yaml
+
+The `template` field is relative to the schema's `templates/` directory:
+
+```yaml
+# schemas/spec-driven/schema.yaml
+artifacts:
+  - id: proposal
+    template: "proposal.md"  # â†’ schemas/spec-driven/templates/proposal.md
+```
+
+**Why:** Paths are relative to the schema, not a global templates directory.
+
+### 4. Resolve package directory via import.meta.url
+
+```typescript
+function getPackageSchemasDir(): string {
+  const currentFile = fileURLToPath(import.meta.url);
+  // Navigate from src/core/artifact-graph/ to package root
+  return path.join(path.dirname(currentFile), '..', '..', '..', 'schemas');
+}
+```
+
+**Why:** Works in ESM. No hardcoded paths.
+
+### 5. Keep schema.yaml format unchanged
+
+The YAML format stays the same - only the storage location changes:
+
+```yaml
+name: spec-driven
+version: 1
+description: Specification-driven development
+artifacts:
+  - id: proposal
+    generates: "proposal.md"
+    template: "proposal.md"
+    requires: []
+```
+
+**Why:** No breaking changes to schema format. Just moving from TS to YAML files.
+
+## Migration
+
+1. Create `schemas/` directory at package root
+2. Convert `SPEC_DRIVEN_SCHEMA` to `schemas/spec-driven/schema.yaml`
+3. Convert `TDD_SCHEMA` to `schemas/tdd/schema.yaml`
+4. Update `resolveSchema()` to load from directories
+5. Remove `builtin-schemas.ts`
+6. Update `listSchemas()` to scan directories
+
+## Risks / Trade-offs
+
+**File I/O at runtime:**
+- Previously schemas were in-memory objects
+- Now requires reading YAML files
+- Mitigation: Schemas are small, loaded once per operation
+
+**Package distribution:**
+- Must ensure `schemas/` directory is included in npm package
+- Add to `files` in package.json
+
+## Open Questions
+
+None.
diff --git a/openspec/changes/archive/2025-12-28-restructure-schema-directories/proposal.md b/openspec/changes/archive/2025-12-28-restructure-schema-directories/proposal.md
new file mode 100644
index 0000000..47fe871
--- /dev/null
+++ b/openspec/changes/archive/2025-12-28-restructure-schema-directories/proposal.md
@@ -0,0 +1,20 @@
+## Why
+
+Currently, built-in schemas are embedded as TypeScript objects in `builtin-schemas.ts`. This works for schemas but doesn't support co-located templates. To enable self-contained schema packages (schema + templates together), we need to restructure schemas as directories.
+
+## What Changes
+
+- **BREAKING (internal):** Move built-in schemas from embedded TS objects to actual directory structure
+- Schemas become directories containing `schema.yaml` + `templates/`
+- Update `resolveSchema()` to load from directory structure
+- Remove `builtin-schemas.ts` (replaced by file-based schemas)
+- Update resolution to check user dir â†’ package dir
+
+## Impact
+
+- Affected specs: `artifact-graph` (schema resolution changes)
+- Affected code:
+  - Remove `src/core/artifact-graph/builtin-schemas.ts`
+  - Update `src/core/artifact-graph/resolver.ts`
+  - Add `schemas/` directory at package root
+- No external API changes (resolution still returns `SchemaYaml`)
diff --git a/openspec/changes/archive/2025-12-28-restructure-schema-directories/specs/artifact-graph/spec.md b/openspec/changes/archive/2025-12-28-restructure-schema-directories/specs/artifact-graph/spec.md
new file mode 100644
index 0000000..1568765
--- /dev/null
+++ b/openspec/changes/archive/2025-12-28-restructure-schema-directories/specs/artifact-graph/spec.md
@@ -0,0 +1,49 @@
+## MODIFIED Requirements
+
+### Requirement: Schema Loading
+The system SHALL load artifact graph definitions from YAML schema files within schema directories.
+
+#### Scenario: Valid schema loaded
+- **WHEN** a schema directory contains a valid `schema.yaml` file
+- **THEN** the system returns an ArtifactGraph with all artifacts and dependencies
+
+#### Scenario: Invalid schema rejected
+- **WHEN** a schema YAML file is missing required fields
+- **THEN** the system throws an error with a descriptive message
+
+#### Scenario: Cyclic dependencies detected
+- **WHEN** a schema contains cyclic artifact dependencies
+- **THEN** the system throws an error listing the artifact IDs in the cycle
+
+#### Scenario: Invalid dependency reference
+- **WHEN** an artifact's `requires` array references a non-existent artifact ID
+- **THEN** the system throws an error identifying the invalid reference
+
+#### Scenario: Duplicate artifact IDs rejected
+- **WHEN** a schema contains multiple artifacts with the same ID
+- **THEN** the system throws an error identifying the duplicate
+
+#### Scenario: Schema directory not found
+- **WHEN** resolving a schema name that has no corresponding directory
+- **THEN** the system throws an error listing available schemas
+
+## ADDED Requirements
+
+### Requirement: Schema Directory Structure
+The system SHALL support self-contained schema directories with co-located templates.
+
+#### Scenario: Schema with templates
+- **WHEN** a schema directory contains `schema.yaml` and `templates/` subdirectory
+- **THEN** artifacts can reference templates relative to the schema's templates directory
+
+#### Scenario: User schema override
+- **WHEN** a schema directory exists at `${XDG_DATA_HOME}/openspec/schemas/<name>/`
+- **THEN** the system uses that directory instead of the built-in
+
+#### Scenario: Built-in schema fallback
+- **WHEN** no user override exists for a schema
+- **THEN** the system uses the package built-in schema directory
+
+#### Scenario: List available schemas
+- **WHEN** listing schemas
+- **THEN** the system returns schema names from both user and package directories
diff --git a/openspec/changes/archive/2025-12-28-restructure-schema-directories/tasks.md b/openspec/changes/archive/2025-12-28-restructure-schema-directories/tasks.md
new file mode 100644
index 0000000..dd18908
--- /dev/null
+++ b/openspec/changes/archive/2025-12-28-restructure-schema-directories/tasks.md
@@ -0,0 +1,32 @@
+## 1. Create Schema Directories
+
+- [ ] 1.1 Create `schemas/` directory at package root
+- [ ] 1.2 Create `schemas/spec-driven/schema.yaml` from `SPEC_DRIVEN_SCHEMA`
+- [ ] 1.3 Create `schemas/spec-driven/templates/` with placeholder templates
+- [ ] 1.4 Create `schemas/tdd/schema.yaml` from `TDD_SCHEMA`
+- [ ] 1.5 Create `schemas/tdd/templates/` with placeholder templates
+
+## 2. Update Schema Resolution
+
+- [ ] 2.1 Add `getPackageSchemasDir()` function using `import.meta.url`
+- [ ] 2.2 Add `getSchemaDir(name)` to resolve schema directory path
+- [ ] 2.3 Update `resolveSchema()` to load from directory structure
+- [ ] 2.4 Update `listSchemas()` to scan directories instead of object keys
+- [ ] 2.5 Add tests for user override resolution
+- [ ] 2.6 Add tests for built-in fallback
+
+## 3. Cleanup
+
+- [ ] 3.1 Remove `builtin-schemas.ts`
+- [ ] 3.2 Update `index.ts` exports (remove `BUILTIN_SCHEMAS`, `SPEC_DRIVEN_SCHEMA`, `TDD_SCHEMA`)
+- [ ] 3.3 Update any code that imports removed exports
+
+## 4. Package Distribution
+
+- [ ] 4.1 Add `schemas/` to `files` array in `package.json`
+- [ ] 4.2 Verify schemas are included in built package
+
+## 5. Fix Template Paths
+
+- [ ] 5.1 Update `template` field in schema.yaml files (remove `templates/` prefix)
+- [ ] 5.2 Ensure template paths are relative to schema's templates directory
diff --git a/openspec/changes/archive/2025-12-29-unify-change-state-model/design.md b/openspec/changes/archive/2025-12-29-unify-change-state-model/design.md
new file mode 100644
index 0000000..1ffe3b3
--- /dev/null
+++ b/openspec/changes/archive/2025-12-29-unify-change-state-model/design.md
@@ -0,0 +1,151 @@
+# Design: Unify Change State Model
+
+## Overview
+
+This change fixes two bugs with minimal disruption to the existing system:
+
+1. **View bug**: Empty changes incorrectly shown as "Completed"
+2. **Artifact workflow bug**: Commands fail on scaffolded changes
+
+## Key Design Decision: Two Systems, Two Purposes
+
+The task-based and artifact-based systems serve **different purposes** and should coexist:
+
+| System | Purpose | Used By |
+|--------|---------|---------|
+| **Task Progress** | Track implementation work | `openspec view`, `openspec list` |
+| **Artifact Progress** | Track planning/spec work | `openspec status`, `openspec next` |
+
+We do NOT merge these systems. Instead, we fix each to work correctly in its domain.
+
+## Change 1: Fix View Command
+
+### Current Logic (Buggy)
+
+```typescript
+// view.ts line 90
+if (progress.total === 0 || progress.completed === progress.total) {
+  completed.push({ name: entry.name });
+}
+```
+
+Problem: `total === 0` means "no tasks defined yet", not "all tasks done".
+
+### New Logic
+
+```typescript
+if (progress.total === 0) {
+  draft.push({ name: entry.name });
+} else if (progress.completed === progress.total) {
+  completed.push({ name: entry.name });
+} else {
+  active.push({ name: entry.name, progress });
+}
+```
+
+### View Output Change
+
+**Before:**
+```
+Completed Changes
+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+  âœ“ add-feature        (all tasks done - correct)
+  âœ“ test-workflow      (no tasks - WRONG)
+```
+
+**After:**
+```
+Draft Changes
+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+  â—‹ test-workflow      (no tasks yet)
+
+Active Changes
+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+  â—‰ add-scaffold       [â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘] 3/7 tasks
+
+Completed Changes
+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+  âœ“ add-feature        (all tasks done)
+```
+
+## Change 2: Fix Artifact Workflow Discovery
+
+### Current Logic (Buggy)
+
+```typescript
+// artifact-workflow.ts - validateChangeExists()
+const activeChanges = await getActiveChangeIds(projectRoot);
+if (!activeChanges.includes(changeName)) {
+  throw new Error(`Change '${changeName}' not found...`);
+}
+```
+
+Problem: `getActiveChangeIds()` requires `proposal.md`, but artifact workflow should work on empty directories to help create the first artifact.
+
+### New Logic
+
+```typescript
+async function validateChangeExists(changeName: string, projectRoot: string): Promise<string> {
+  const changePath = path.join(projectRoot, 'openspec', 'changes', changeName);
+
+  // Check directory existence directly, not proposal.md
+  if (!fs.existsSync(changePath) || !fs.statSync(changePath).isDirectory()) {
+    // List available changes for helpful error message
+    const entries = await fs.promises.readdir(
+      path.join(projectRoot, 'openspec', 'changes'),
+      { withFileTypes: true }
+    );
+    const available = entries
+      .filter(e => e.isDirectory() && e.name !== 'archive' && !e.name.startsWith('.'))
+      .map(e => e.name);
+
+    if (available.length === 0) {
+      throw new Error('No changes found. Create one with: openspec new change <name>');
+    }
+    throw new Error(`Change '${changeName}' not found. Available:\n  ${available.join('\n  ')}`);
+  }
+
+  return changeName;
+}
+```
+
+### Behavior Change
+
+```bash
+# Before
+$ openspec new change foo
+$ openspec status --change foo
+Error: Change 'foo' not found.
+
+# After
+$ openspec new change foo
+$ openspec status --change foo
+Change: foo
+Progress: 0/4 artifacts complete
+
+[ ] proposal
+[-] specs (blocked by: proposal)
+[-] design (blocked by: proposal)
+[-] tasks (blocked by: specs, design)
+```
+
+## What Stays the Same
+
+1. **`getActiveChangeIds()`** - Still requires `proposal.md` (used by validate, show)
+2. **`getArchivedChangeIds()`** - Unchanged
+3. **Active/Completed semantics** - Still based on task checkboxes
+4. **Validation** - Still requires `proposal.md` to have something to validate
+
+## File Changes
+
+| File | Change |
+|------|--------|
+| `src/core/view.ts` | Add draft category, fix completion logic |
+| `src/commands/artifact-workflow.ts` | Update `validateChangeExists()` to use directory existence |
+| `test/commands/artifact-workflow.test.ts` | Add tests for scaffolded changes |
+
+## Testing Strategy
+
+1. **Unit test**: `validateChangeExists()` with scaffolded change
+2. **View test**: Verify three categories render correctly
+3. **Manual test**: Full workflow from `new change` â†’ `status` â†’ `view`
diff --git a/openspec/changes/archive/2025-12-29-unify-change-state-model/proposal.md b/openspec/changes/archive/2025-12-29-unify-change-state-model/proposal.md
new file mode 100644
index 0000000..37753ad
--- /dev/null
+++ b/openspec/changes/archive/2025-12-29-unify-change-state-model/proposal.md
@@ -0,0 +1,101 @@
+# Proposal: Unify Change State Model
+
+## Problem Statement
+
+Two bugs create inconsistent behavior when working with changes:
+
+### Bug 1: Empty changes shown as "Completed" in view
+
+```typescript
+// view.ts line 90
+if (progress.total === 0 || progress.completed === progress.total) {
+  completed.push({ name: entry.name });  // BUG: total === 0 â‰  completed
+}
+```
+
+Result: `openspec new change foo && openspec view` shows `foo` as "Completed" when it has no content.
+
+### Bug 2: Artifact workflow commands can't find scaffolded changes
+
+```typescript
+// item-discovery.ts - getActiveChangeIds()
+const proposalPath = path.join(changesPath, entry.name, 'proposal.md');
+await fs.access(proposalPath);  // Only returns changes WITH proposal.md
+```
+
+Result: `openspec status --change foo` says "not found" even though the directory exists.
+
+## Root Cause
+
+The system conflates two different concepts:
+
+| Concept | Question | Source of Truth |
+|---------|----------|-----------------|
+| **Planning Progress** | Are all spec documents created? | File existence (ArtifactGraph) |
+| **Implementation Progress** | Is the coding work done? | Task checkboxes (tasks.md) |
+
+## Proposed Solution
+
+### Fix 1: Add "Draft" state to view command
+
+Keep Active/Completed with their existing meanings, but fix the bug:
+
+| State | Criteria | Meaning |
+|-------|----------|---------|
+| **Draft** | No tasks.md OR `tasks.total === 0` | Still planning |
+| **Active** | `tasks.total > 0` AND `completed < total` | Implementing |
+| **Completed** | `tasks.total > 0` AND `completed === total` | Done |
+
+### Fix 2: Artifact workflow uses directory existence
+
+Update `validateChangeExists()` to check if the directory exists, not if `proposal.md` exists. This allows the artifact workflow to guide users through creating their first artifact.
+
+### Keep existing discovery functions
+
+`getActiveChangeIds()` continues to require `proposal.md` for backward compatibility with validation and other commands.
+
+## What Changes
+
+| Command | Before | After |
+|---------|--------|-------|
+| `openspec view` | Empty = "Completed" | Empty = "Draft" |
+| `openspec status --change X` | Requires proposal.md | Works on any directory |
+| `openspec validate X` | Requires proposal.md | Unchanged (still requires it) |
+
+## Breaking Changes
+
+### Minimal Breaking Change
+
+1. **`openspec view` output**: Empty changes move from "Completed" section to new "Draft" section
+
+### Non-Breaking
+
+- Active/Completed semantics unchanged (still task-based)
+- `getActiveChangeIds()` unchanged
+- `openspec validate` unchanged
+- Archived changes unaffected
+
+## Out of Scope
+
+- Merging task-based and artifact-based progress (they serve different purposes)
+- Changing what "Completed" means (it stays = all tasks done)
+- Adding artifact progress to view command (separate enhancement)
+- Shell tab completions for artifact workflow commands (not yet registered)
+
+## Related Commands Analysis
+
+| Command | Uses `getActiveChangeIds()` | Should include scaffolded? | Change needed? |
+|---------|-----------------------------|-----------------------------|----------------|
+| `openspec view` | No (reads dirs directly) | Yes â†’ Draft section | **Yes** |
+| `openspec list` | No (reads dirs directly) | Yes (shows "No tasks") | No |
+| `openspec status/next/instructions` | Yes | Yes | **Yes** |
+| `openspec validate` | Yes | No (can't validate empty) | No |
+| `openspec show` | Yes | No (nothing to show) | No |
+| Tab completions | Yes | Future enhancement | No |
+
+## Success Criteria
+
+1. `openspec new change foo && openspec view` shows `foo` in "Draft" section
+2. `openspec new change foo && openspec status --change foo` works
+3. Changes with all tasks done still show as "Completed"
+4. All existing tests pass
diff --git a/openspec/changes/archive/2025-12-29-unify-change-state-model/specs/cli-artifact-workflow/spec.md b/openspec/changes/archive/2025-12-29-unify-change-state-model/specs/cli-artifact-workflow/spec.md
new file mode 100644
index 0000000..72270a5
--- /dev/null
+++ b/openspec/changes/archive/2025-12-29-unify-change-state-model/specs/cli-artifact-workflow/spec.md
@@ -0,0 +1,109 @@
+# cli-artifact-workflow Specification Delta
+
+## MODIFIED Requirements
+
+### Requirement: Status Command
+
+The system SHALL display artifact completion status for a change, including scaffolded (empty) changes.
+
+> **Fixes bug**: Previously required `proposal.md` to exist via `getActiveChangeIds()`.
+
+#### Scenario: Show status with all states
+
+- **WHEN** user runs `openspec status --change <id>`
+- **THEN** the system displays each artifact with status indicator:
+  - `[x]` for completed artifacts
+  - `[ ]` for ready artifacts
+  - `[-]` for blocked artifacts (with missing dependencies listed)
+
+#### Scenario: Status shows completion summary
+
+- **WHEN** user runs `openspec status --change <id>`
+- **THEN** output includes completion percentage and count (e.g., "2/4 artifacts complete")
+
+#### Scenario: Status JSON output
+
+- **WHEN** user runs `openspec status --change <id> --json`
+- **THEN** the system outputs JSON with changeName, schemaName, isComplete, and artifacts array
+
+#### Scenario: Status on scaffolded change
+
+- **WHEN** user runs `openspec status --change <id>` on a change with no artifacts
+- **THEN** system displays all artifacts with their status
+- **AND** root artifacts (no dependencies) show as ready `[ ]`
+- **AND** dependent artifacts show as blocked `[-]`
+
+#### Scenario: Missing change parameter
+
+- **WHEN** user runs `openspec status` without `--change`
+- **THEN** the system displays an error with list of available changes
+- **AND** includes scaffolded changes (directories without proposal.md)
+
+#### Scenario: Unknown change
+
+- **WHEN** user runs `openspec status --change unknown-id`
+- **AND** directory `openspec/changes/unknown-id/` does not exist
+- **THEN** the system displays an error listing all available change directories
+
+### Requirement: Next Command
+
+The system SHALL show which artifacts are ready to be created, including for scaffolded changes.
+
+#### Scenario: Show ready artifacts
+
+- **WHEN** user runs `openspec next --change <id>`
+- **THEN** the system lists artifacts whose dependencies are all satisfied
+
+#### Scenario: No artifacts ready
+
+- **WHEN** all artifacts are either completed or blocked
+- **THEN** the system indicates no artifacts are ready (with explanation)
+
+#### Scenario: All artifacts complete
+
+- **WHEN** all artifacts in the change are completed
+- **THEN** the system indicates the change is complete
+
+#### Scenario: Next JSON output
+
+- **WHEN** user runs `openspec next --change <id> --json`
+- **THEN** the system outputs JSON array of ready artifact IDs
+
+#### Scenario: Next on scaffolded change
+
+- **WHEN** user runs `openspec next --change <id>` on a change with no artifacts
+- **THEN** system shows root artifacts (e.g., "proposal") as ready to create
+
+### Requirement: Instructions Command
+
+The system SHALL output enriched instructions for creating an artifact, including for scaffolded changes.
+
+#### Scenario: Show enriched instructions
+
+- **WHEN** user runs `openspec instructions <artifact> --change <id>`
+- **THEN** the system outputs:
+  - Artifact metadata (ID, output path, description)
+  - Template content
+  - Dependency status (done/missing)
+  - Unlocked artifacts (what becomes available after completion)
+
+#### Scenario: Instructions JSON output
+
+- **WHEN** user runs `openspec instructions <artifact> --change <id> --json`
+- **THEN** the system outputs JSON matching ArtifactInstructions interface
+
+#### Scenario: Unknown artifact
+
+- **WHEN** user runs `openspec instructions unknown-artifact --change <id>`
+- **THEN** the system displays an error listing valid artifact IDs for the schema
+
+#### Scenario: Artifact with unmet dependencies
+
+- **WHEN** user requests instructions for a blocked artifact
+- **THEN** the system displays instructions with a warning about missing dependencies
+
+#### Scenario: Instructions on scaffolded change
+
+- **WHEN** user runs `openspec instructions proposal --change <id>` on a scaffolded change
+- **THEN** system outputs template and metadata for creating the proposal
+- **AND** does not require any artifacts to already exist
diff --git a/openspec/changes/archive/2025-12-29-unify-change-state-model/specs/cli-view/spec.md b/openspec/changes/archive/2025-12-29-unify-change-state-model/specs/cli-view/spec.md
new file mode 100644
index 0000000..40f6f7b
--- /dev/null
+++ b/openspec/changes/archive/2025-12-29-unify-change-state-model/specs/cli-view/spec.md
@@ -0,0 +1,60 @@
+# cli-view Specification Delta
+
+## ADDED Requirements
+
+### Requirement: Draft Changes Display
+
+The dashboard SHALL display changes without tasks in a separate "Draft" section.
+
+#### Scenario: Draft changes listing
+
+- **WHEN** there are changes with no tasks.md or zero tasks defined
+- **THEN** system shows them in a "Draft Changes" section
+- **AND** uses a distinct indicator (e.g., `â—‹`) to show draft status
+
+#### Scenario: Draft section ordering
+
+- **WHEN** multiple draft changes exist
+- **THEN** system sorts them alphabetically by name
+
+## MODIFIED Requirements
+
+### Requirement: Completed Changes Display
+
+The dashboard SHALL list completed changes in a separate section, only showing changes with ALL tasks completed.
+
+> **Fixes bug**: Previously, changes with `total === 0` were incorrectly shown as completed.
+
+#### Scenario: Completed changes listing
+
+- **WHEN** there are changes with `tasks.total > 0` AND `tasks.completed === tasks.total`
+- **THEN** system shows them with checkmark indicators in a dedicated section
+
+#### Scenario: Mixed completion states
+
+- **WHEN** some changes are complete and others active
+- **THEN** system separates them into appropriate sections
+
+#### Scenario: Empty changes not completed
+
+- **WHEN** a change has no tasks.md or zero tasks defined
+- **THEN** system does NOT show it in "Completed Changes" section
+- **AND** shows it in "Draft Changes" section instead
+
+### Requirement: Summary Section
+
+The dashboard SHALL display a summary section with key project metrics, including draft change count.
+
+#### Scenario: Complete summary display
+
+- **WHEN** dashboard is rendered with specs and changes
+- **THEN** system shows total number of specifications and requirements
+- **AND** shows number of draft changes
+- **AND** shows number of active changes in progress
+- **AND** shows number of completed changes
+- **AND** shows overall task progress percentage
+
+#### Scenario: Empty project summary
+
+- **WHEN** no specs or changes exist
+- **THEN** summary shows zero counts for all metrics
diff --git a/openspec/changes/archive/2025-12-29-unify-change-state-model/tasks.md b/openspec/changes/archive/2025-12-29-unify-change-state-model/tasks.md
new file mode 100644
index 0000000..d956b98
--- /dev/null
+++ b/openspec/changes/archive/2025-12-29-unify-change-state-model/tasks.md
@@ -0,0 +1,25 @@
+# Tasks: Unify Change State Model
+
+## Phase 1: Fix Artifact Workflow Discovery
+
+- [x] Update `validateChangeExists()` in `artifact-workflow.ts` to check directory existence instead of using `getActiveChangeIds()`
+- [x] Update error message to list all change directories (not just those with proposal.md)
+- [x] Add test for `openspec status --change <scaffolded-change>`
+- [x] Add test for `openspec next --change <scaffolded-change>`
+- [x] Add test for `openspec instructions proposal --change <scaffolded-change>`
+
+## Phase 2: Fix View Command
+
+- [x] Update `getChangesData()` in `view.ts` to return three categories: draft, active, completed
+- [x] Fix completion logic: `total === 0` â†’ draft, not completed
+- [x] Add "Draft Changes" section to dashboard rendering
+- [x] Update summary to include draft count
+- [x] Add test for draft changes appearing correctly in view
+
+## Phase 3: Cleanup and Validation
+
+- [x] Clean up test changes (`test-workflow`, `test-workflow-2`)
+- [x] Run full test suite
+- [x] Manual test: `openspec new change foo && openspec status --change foo`
+- [x] Manual test: `openspec new change foo && openspec view` shows foo in Draft
+- [x] Validate with `openspec validate unify-change-state-model --strict`
diff --git a/openspec/changes/add-antigravity-support/proposal.md b/openspec/changes/archive/2025-12-30-add-antigravity-support/proposal.md
similarity index 100%
rename from openspec/changes/add-antigravity-support/proposal.md
rename to openspec/changes/archive/2025-12-30-add-antigravity-support/proposal.md
diff --git a/openspec/changes/archive/2025-12-30-add-antigravity-support/specs/cli-init/spec.md b/openspec/changes/archive/2025-12-30-add-antigravity-support/specs/cli-init/spec.md
new file mode 100644
index 0000000..5994b8f
--- /dev/null
+++ b/openspec/changes/archive/2025-12-30-add-antigravity-support/specs/cli-init/spec.md
@@ -0,0 +1,105 @@
+# Delta for CLI Init
+
+## MODIFIED Requirements
+### Requirement: Slash Command Configuration
+The init command SHALL generate slash command files for supported editors using shared templates.
+
+#### Scenario: Generating slash commands for Antigravity
+- **WHEN** the user selects Antigravity during initialization
+- **THEN** create `.agent/workflows/openspec-proposal.md`, `.agent/workflows/openspec-apply.md`, and `.agent/workflows/openspec-archive.md`
+- **AND** ensure each file begins with YAML frontmatter that contains only a `description: <stage summary>` field followed by the shared OpenSpec workflow instructions wrapped in managed markers
+- **AND** populate the workflow body with the same proposal/apply/archive guidance used for other tools so Antigravity behaves like Windsurf while pointing to the `.agent/workflows/` directory
+
+#### Scenario: Generating slash commands for Claude Code
+- **WHEN** the user selects Claude Code during initialization
+- **THEN** create `.claude/commands/openspec/proposal.md`, `.claude/commands/openspec/apply.md`, and `.claude/commands/openspec/archive.md`
+- **AND** populate each file from shared templates so command text matches other tools
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
+
+#### Scenario: Generating slash commands for CodeBuddy Code
+- **WHEN** the user selects CodeBuddy Code during initialization
+- **THEN** create `.codebuddy/commands/openspec/proposal.md`, `.codebuddy/commands/openspec/apply.md`, and `.codebuddy/commands/openspec/archive.md`
+- **AND** populate each file from shared templates so command text matches other tools
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
+
+#### Scenario: Generating slash commands for Cline
+- **WHEN** the user selects Cline during initialization
+- **THEN** create `.clinerules/openspec-proposal.md`, `.clinerules/openspec-apply.md`, and `.clinerules/openspec-archive.md`
+- **AND** populate each file from shared templates so command text matches other tools
+- **AND** include Cline-specific Markdown heading frontmatter
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
+
+#### Scenario: Generating slash commands for Crush
+- **WHEN** the user selects Crush during initialization
+- **THEN** create `.crush/commands/openspec/proposal.md`, `.crush/commands/openspec/apply.md`, and `.crush/commands/openspec/archive.md`
+- **AND** populate each file from shared templates so command text matches other tools
+- **AND** include Crush-specific frontmatter with OpenSpec category and tags
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
+
+#### Scenario: Generating slash commands for Cursor
+- **WHEN** the user selects Cursor during initialization
+- **THEN** create `.cursor/commands/openspec-proposal.md`, `.cursor/commands/openspec-apply.md`, and `.cursor/commands/openspec-archive.md`
+- **AND** populate each file from shared templates so command text matches other tools
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
+
+#### Scenario: Generating slash commands for Factory Droid
+- **WHEN** the user selects Factory Droid during initialization
+- **THEN** create `.factory/commands/openspec-proposal.md`, `.factory/commands/openspec-apply.md`, and `.factory/commands/openspec-archive.md`
+- **AND** populate each file from shared templates that include Factory-compatible YAML frontmatter for the `description` and `argument-hint` fields
+- **AND** include the `$ARGUMENTS` placeholder in the template body so droid receives any user-supplied input
+- **AND** wrap the generated content in OpenSpec managed markers so `openspec update` can safely refresh the commands
+
+#### Scenario: Generating slash commands for OpenCode
+- **WHEN** the user selects OpenCode during initialization
+- **THEN** create `.opencode/commands/openspec-proposal.md`, `.opencode/commands/openspec-apply.md`, and `.opencode/commands/openspec-archive.md`
+- **AND** populate each file from shared templates so command text matches other tools
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
+
+#### Scenario: Generating slash commands for Windsurf
+- **WHEN** the user selects Windsurf during initialization
+- **THEN** create `.windsurf/workflows/openspec-proposal.md`, `.windsurf/workflows/openspec-apply.md`, and `.windsurf/workflows/openspec-archive.md`
+- **AND** populate each file from shared templates (wrapped in OpenSpec markers) so workflow text matches other tools
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
+
+#### Scenario: Generating slash commands for Kilo Code
+- **WHEN** the user selects Kilo Code during initialization
+- **THEN** create `.kilocode/workflows/openspec-proposal.md`, `.kilocode/workflows/openspec-apply.md`, and `.kilocode/workflows/openspec-archive.md`
+- **AND** populate each file from shared templates (wrapped in OpenSpec markers) so workflow text matches other tools
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
+
+#### Scenario: Generating slash commands for Codex
+- **WHEN** the user selects Codex during initialization
+- **THEN** create global prompt files at `~/.codex/prompts/openspec-proposal.md`, `~/.codex/prompts/openspec-apply.md`, and `~/.codex/prompts/openspec-archive.md` (or under `$CODEX_HOME/prompts` if set)
+- **AND** populate each file from shared templates that map the first numbered placeholder (`$1`) to the primary user input (e.g., change identifier or question text)
+- **AND** wrap the generated content in OpenSpec markers so `openspec update` can refresh the prompts without touching surrounding custom notes
+
+#### Scenario: Generating slash commands for GitHub Copilot
+- **WHEN** the user selects GitHub Copilot during initialization
+- **THEN** create `.github/prompts/openspec-proposal.prompt.md`, `.github/prompts/openspec-apply.prompt.md`, and `.github/prompts/openspec-archive.prompt.md`
+- **AND** populate each file with YAML frontmatter containing a `description` field that summarizes the workflow stage
+- **AND** include `$ARGUMENTS` placeholder to capture user input
+- **AND** wrap the shared template body with OpenSpec markers so `openspec update` can refresh the content
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
+
+#### Scenario: Generating slash commands for Gemini CLI
+- **WHEN** the user selects Gemini CLI during initialization
+- **THEN** create `.gemini/commands/openspec/proposal.toml`, `.gemini/commands/openspec/apply.toml`, and `.gemini/commands/openspec/archive.toml`
+- **AND** populate each file as TOML that sets a stage-specific `description = "<summary>"` and a multi-line `prompt = """` block with the shared OpenSpec template
+- **AND** wrap the OpenSpec managed markers (`<!-- OPENSPEC:START -->` / `<!-- OPENSPEC:END -->`) inside the `prompt` value so `openspec update` can safely refresh the body between markers without touching the TOML framing
+- **AND** ensure the slash-command copy matches the existing proposal/apply/archive templates used by other tools
+
+#### Scenario: Generating slash commands for iFlow CLI
+- **WHEN** the user selects iFlow CLI during initialization
+- **THEN** create `.iflow/commands/openspec-proposal.md`, `.iflow/commands/openspec-apply.md`, and `.iflow/commands/openspec-archive.md`
+- **AND** populate each file from shared templates so command text matches other tools
+- **AND** include YAML frontmatter with `name`, `id`, `category`, and `description` fields for each command
+- **AND** wrap the generated content in OpenSpec managed markers so `openspec update` can safely refresh the commands
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
+
+#### Scenario: Generating slash commands for RooCode
+- **WHEN** the user selects RooCode during initialization
+- **THEN** create `.roo/commands/openspec-proposal.md`, `.roo/commands/openspec-apply.md`, and `.roo/commands/openspec-archive.md`
+- **AND** populate each file from shared templates so command text matches other tools
+- **AND** include simple Markdown headings (e.g., `# OpenSpec: Proposal`) without YAML frontmatter
+- **AND** wrap the generated content in OpenSpec managed markers where applicable so `openspec update` can safely refresh the commands
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
diff --git a/openspec/changes/archive/2025-12-30-add-antigravity-support/specs/cli-update/spec.md b/openspec/changes/archive/2025-12-30-add-antigravity-support/specs/cli-update/spec.md
new file mode 100644
index 0000000..641688e
--- /dev/null
+++ b/openspec/changes/archive/2025-12-30-add-antigravity-support/specs/cli-update/spec.md
@@ -0,0 +1,92 @@
+# Delta for CLI Update
+
+## MODIFIED Requirements
+### Requirement: Slash Command Updates
+The update command SHALL refresh existing slash command files for configured tools without creating new ones, and ensure the OpenCode archive command accepts change ID arguments.
+
+#### Scenario: Updating slash commands for Antigravity
+- **WHEN** `.agent/workflows/` contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
+- **THEN** refresh the OpenSpec-managed portion of each file so the workflow copy matches other tools while preserving the existing single-field `description` frontmatter
+- **AND** skip creating any missing workflow files during update, mirroring the behavior for Windsurf and other IDEs
+
+#### Scenario: Updating slash commands for Claude Code
+- **WHEN** `.claude/commands/openspec/` contains `proposal.md`, `apply.md`, and `archive.md`
+- **THEN** refresh each file using shared templates
+- **AND** ensure templates include instructions for the relevant workflow stage
+
+#### Scenario: Updating slash commands for CodeBuddy Code
+- **WHEN** `.codebuddy/commands/openspec/` contains `proposal.md`, `apply.md`, and `archive.md`
+- **THEN** refresh each file using shared templates
+- **AND** ensure templates include instructions for the relevant workflow stage
+
+#### Scenario: Updating slash commands for Cline
+- **WHEN** `.clinerules/` contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
+- **THEN** refresh each file using shared templates
+- **AND** include Cline-specific Markdown heading frontmatter
+- **AND** ensure templates include instructions for the relevant workflow stage
+
+#### Scenario: Updating slash commands for Crush
+- **WHEN** `.crush/commands/` contains `openspec/proposal.md`, `openspec/apply.md`, and `openspec/archive.md`
+- **THEN** refresh each file using shared templates
+- **AND** include Crush-specific frontmatter with OpenSpec category and tags
+- **AND** ensure templates include instructions for the relevant workflow stage
+
+#### Scenario: Updating slash commands for Cursor
+- **WHEN** `.cursor/commands/` contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
+- **THEN** refresh each file using shared templates
+- **AND** ensure templates include instructions for the relevant workflow stage
+
+#### Scenario: Updating slash commands for Factory Droid
+- **WHEN** `.factory/commands/` contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
+- **THEN** refresh each file using the shared Factory templates that include YAML frontmatter for the `description` and `argument-hint` fields
+- **AND** ensure the template body retains the `$ARGUMENTS` placeholder so user input keeps flowing into droid
+- **AND** update only the content inside the OpenSpec managed markers, leaving any unmanaged notes untouched
+- **AND** skip creating missing files during update
+
+#### Scenario: Updating slash commands for OpenCode
+- **WHEN** `.opencode/command/` contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
+- **THEN** refresh each file using shared templates
+- **AND** ensure templates include instructions for the relevant workflow stage
+- **AND** ensure the archive command includes `$ARGUMENTS` placeholder in frontmatter for accepting change ID arguments
+
+#### Scenario: Updating slash commands for Windsurf
+- **WHEN** `.windsurf/workflows/` contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
+- **THEN** refresh each file using shared templates wrapped in OpenSpec markers
+- **AND** ensure templates include instructions for the relevant workflow stage
+- **AND** skip creating missing files (the update command only refreshes what already exists)
+
+#### Scenario: Updating slash commands for Kilo Code
+- **WHEN** `.kilocode/workflows/` contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
+- **THEN** refresh each file using shared templates wrapped in OpenSpec markers
+- **AND** ensure templates include instructions for the relevant workflow stage
+- **AND** skip creating missing files (the update command only refreshes what already exists)
+
+#### Scenario: Updating slash commands for Codex
+- **GIVEN** the global Codex prompt directory contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
+- **WHEN** a user runs `openspec update`
+- **THEN** refresh each file using the shared slash-command templates (including placeholder guidance)
+- **AND** preserve any unmanaged content outside the OpenSpec marker block
+- **AND** skip creation when a Codex prompt file is missing
+
+#### Scenario: Updating slash commands for GitHub Copilot
+- **WHEN** `.github/prompts/` contains `openspec-proposal.prompt.md`, `openspec-apply.prompt.md`, and `openspec-archive.prompt.md`
+- **THEN** refresh each file using shared templates while preserving the YAML frontmatter
+- **AND** update only the OpenSpec-managed block between markers
+- **AND** ensure templates include instructions for the relevant workflow stage
+
+#### Scenario: Updating slash commands for Gemini CLI
+- **WHEN** `.gemini/commands/openspec/` contains `proposal.toml`, `apply.toml`, and `archive.toml`
+- **THEN** refresh the body of each file using the shared proposal/apply/archive templates
+- **AND** replace only the content between `<!-- OPENSPEC:START -->` and `<!-- OPENSPEC:END -->` markers inside the `prompt = """` block so the TOML framing (`description`, `prompt`) stays intact
+- **AND** skip creating any missing `.toml` files during update; only pre-existing Gemini commands are refreshed
+
+#### Scenario: Updating slash commands for iFlow CLI
+- **WHEN** `.iflow/commands/` contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
+- **THEN** refresh each file using shared templates
+- **AND** preserve the YAML frontmatter with `name`, `id`, `category`, and `description` fields
+- **AND** update only the OpenSpec-managed block between markers
+- **AND** ensure templates include instructions for the relevant workflow stage
+
+#### Scenario: Missing slash command file
+- **WHEN** a tool lacks a slash command file
+- **THEN** do not create a new file during update
diff --git a/openspec/changes/add-antigravity-support/tasks.md b/openspec/changes/archive/2025-12-30-add-antigravity-support/tasks.md
similarity index 100%
rename from openspec/changes/add-antigravity-support/tasks.md
rename to openspec/changes/archive/2025-12-30-add-antigravity-support/tasks.md
diff --git a/openspec/changes/fix-cline-workflows-implementation/proposal.md b/openspec/changes/archive/2025-12-30-fix-cline-workflows-implementation/proposal.md
similarity index 92%
rename from openspec/changes/fix-cline-workflows-implementation/proposal.md
rename to openspec/changes/archive/2025-12-30-fix-cline-workflows-implementation/proposal.md
index 3737254..1d26b19 100644
--- a/openspec/changes/fix-cline-workflows-implementation/proposal.md
+++ b/openspec/changes/archive/2025-12-30-fix-cline-workflows-implementation/proposal.md
@@ -8,6 +8,6 @@ The Cline implementation was architecturally incorrect. According to Cline's off
 - **BREAKING**: Existing Cline users will need to re-run `openspec init` to get the corrected workflow files
 
 ## Impact
-- Affected specs: cli-init (corrected Cline workflow paths)
+- Affected specs: cli-init, cli-update (corrected Cline workflow paths)
 - Affected code: `src/core/configurators/slash/cline.ts`, test files, README.md
 - Modified files: `.clinerules/workflows/openspec-*.md` (moved from `.clinerules/openspec-*.md`)
diff --git a/openspec/changes/archive/2025-12-30-fix-cline-workflows-implementation/specs/cli-init/spec.md b/openspec/changes/archive/2025-12-30-fix-cline-workflows-implementation/specs/cli-init/spec.md
new file mode 100644
index 0000000..06951ac
--- /dev/null
+++ b/openspec/changes/archive/2025-12-30-fix-cline-workflows-implementation/specs/cli-init/spec.md
@@ -0,0 +1,105 @@
+# Delta for CLI Init
+
+## MODIFIED Requirements
+### Requirement: Slash Command Configuration
+The init command SHALL generate slash command files for supported editors using shared templates.
+
+#### Scenario: Generating slash commands for Antigravity
+- **WHEN** the user selects Antigravity during initialization
+- **THEN** create `.agent/workflows/openspec-proposal.md`, `.agent/workflows/openspec-apply.md`, and `.agent/workflows/openspec-archive.md`
+- **AND** ensure each file begins with YAML frontmatter that contains only a `description: <stage summary>` field followed by the shared OpenSpec workflow instructions wrapped in managed markers
+- **AND** populate the workflow body with the same proposal/apply/archive guidance used for other tools so Antigravity behaves like Windsurf while pointing to the `.agent/workflows/` directory
+
+#### Scenario: Generating slash commands for Claude Code
+- **WHEN** the user selects Claude Code during initialization
+- **THEN** create `.claude/commands/openspec/proposal.md`, `.claude/commands/openspec/apply.md`, and `.claude/commands/openspec/archive.md`
+- **AND** populate each file from shared templates so command text matches other tools
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
+
+#### Scenario: Generating slash commands for CodeBuddy Code
+- **WHEN** the user selects CodeBuddy Code during initialization
+- **THEN** create `.codebuddy/commands/openspec/proposal.md`, `.codebuddy/commands/openspec/apply.md`, and `.codebuddy/commands/openspec/archive.md`
+- **AND** populate each file from shared templates so command text matches other tools
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
+
+#### Scenario: Generating slash commands for Cline
+- **WHEN** the user selects Cline during initialization
+- **THEN** create `.clinerules/workflows/openspec-proposal.md`, `.clinerules/workflows/openspec-apply.md`, and `.clinerules/workflows/openspec-archive.md`
+- **AND** populate each file from shared templates so command text matches other tools
+- **AND** include Cline-specific Markdown heading frontmatter
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
+
+#### Scenario: Generating slash commands for Crush
+- **WHEN** the user selects Crush during initialization
+- **THEN** create `.crush/commands/openspec/proposal.md`, `.crush/commands/openspec/apply.md`, and `.crush/commands/openspec/archive.md`
+- **AND** populate each file from shared templates so command text matches other tools
+- **AND** include Crush-specific frontmatter with OpenSpec category and tags
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
+
+#### Scenario: Generating slash commands for Cursor
+- **WHEN** the user selects Cursor during initialization
+- **THEN** create `.cursor/commands/openspec-proposal.md`, `.cursor/commands/openspec-apply.md`, and `.cursor/commands/openspec-archive.md`
+- **AND** populate each file from shared templates so command text matches other tools
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
+
+#### Scenario: Generating slash commands for Factory Droid
+- **WHEN** the user selects Factory Droid during initialization
+- **THEN** create `.factory/commands/openspec-proposal.md`, `.factory/commands/openspec-apply.md`, and `.factory/commands/openspec-archive.md`
+- **AND** populate each file from shared templates that include Factory-compatible YAML frontmatter for the `description` and `argument-hint` fields
+- **AND** include the `$ARGUMENTS` placeholder in the template body so droid receives any user-supplied input
+- **AND** wrap the generated content in OpenSpec managed markers so `openspec update` can safely refresh the commands
+
+#### Scenario: Generating slash commands for OpenCode
+- **WHEN** the user selects OpenCode during initialization
+- **THEN** create `.opencode/commands/openspec-proposal.md`, `.opencode/commands/openspec-apply.md`, and `.opencode/commands/openspec-archive.md`
+- **AND** populate each file from shared templates so command text matches other tools
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
+
+#### Scenario: Generating slash commands for Windsurf
+- **WHEN** the user selects Windsurf during initialization
+- **THEN** create `.windsurf/workflows/openspec-proposal.md`, `.windsurf/workflows/openspec-apply.md`, and `.windsurf/workflows/openspec-archive.md`
+- **AND** populate each file from shared templates (wrapped in OpenSpec markers) so workflow text matches other tools
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
+
+#### Scenario: Generating slash commands for Kilo Code
+- **WHEN** the user selects Kilo Code during initialization
+- **THEN** create `.kilocode/workflows/openspec-proposal.md`, `.kilocode/workflows/openspec-apply.md`, and `.kilocode/workflows/openspec-archive.md`
+- **AND** populate each file from shared templates (wrapped in OpenSpec markers) so workflow text matches other tools
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
+
+#### Scenario: Generating slash commands for Codex
+- **WHEN** the user selects Codex during initialization
+- **THEN** create global prompt files at `~/.codex/prompts/openspec-proposal.md`, `~/.codex/prompts/openspec-apply.md`, and `~/.codex/prompts/openspec-archive.md` (or under `$CODEX_HOME/prompts` if set)
+- **AND** populate each file from shared templates that map the first numbered placeholder (`$1`) to the primary user input (e.g., change identifier or question text)
+- **AND** wrap the generated content in OpenSpec markers so `openspec update` can refresh the prompts without touching surrounding custom notes
+
+#### Scenario: Generating slash commands for GitHub Copilot
+- **WHEN** the user selects GitHub Copilot during initialization
+- **THEN** create `.github/prompts/openspec-proposal.prompt.md`, `.github/prompts/openspec-apply.prompt.md`, and `.github/prompts/openspec-archive.prompt.md`
+- **AND** populate each file with YAML frontmatter containing a `description` field that summarizes the workflow stage
+- **AND** include `$ARGUMENTS` placeholder to capture user input
+- **AND** wrap the shared template body with OpenSpec markers so `openspec update` can refresh the content
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
+
+#### Scenario: Generating slash commands for Gemini CLI
+- **WHEN** the user selects Gemini CLI during initialization
+- **THEN** create `.gemini/commands/openspec/proposal.toml`, `.gemini/commands/openspec/apply.toml`, and `.gemini/commands/openspec/archive.toml`
+- **AND** populate each file as TOML that sets a stage-specific `description = "<summary>"` and a multi-line `prompt = """` block with the shared OpenSpec template
+- **AND** wrap the OpenSpec managed markers (`<!-- OPENSPEC:START -->` / `<!-- OPENSPEC:END -->`) inside the `prompt` value so `openspec update` can safely refresh the body between markers without touching the TOML framing
+- **AND** ensure the slash-command copy matches the existing proposal/apply/archive templates used by other tools
+
+#### Scenario: Generating slash commands for iFlow CLI
+- **WHEN** the user selects iFlow CLI during initialization
+- **THEN** create `.iflow/commands/openspec-proposal.md`, `.iflow/commands/openspec-apply.md`, and `.iflow/commands/openspec-archive.md`
+- **AND** populate each file from shared templates so command text matches other tools
+- **AND** include YAML frontmatter with `name`, `id`, `category`, and `description` fields for each command
+- **AND** wrap the generated content in OpenSpec managed markers so `openspec update` can safely refresh the commands
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
+
+#### Scenario: Generating slash commands for RooCode
+- **WHEN** the user selects RooCode during initialization
+- **THEN** create `.roo/commands/openspec-proposal.md`, `.roo/commands/openspec-apply.md`, and `.roo/commands/openspec-archive.md`
+- **AND** populate each file from shared templates so command text matches other tools
+- **AND** include simple Markdown headings (e.g., `# OpenSpec: Proposal`) without YAML frontmatter
+- **AND** wrap the generated content in OpenSpec managed markers where applicable so `openspec update` can safely refresh the commands
+- **AND** each template includes instructions for the relevant OpenSpec workflow stage
diff --git a/openspec/changes/archive/2025-12-30-fix-cline-workflows-implementation/specs/cli-update/spec.md b/openspec/changes/archive/2025-12-30-fix-cline-workflows-implementation/specs/cli-update/spec.md
new file mode 100644
index 0000000..2a49df1
--- /dev/null
+++ b/openspec/changes/archive/2025-12-30-fix-cline-workflows-implementation/specs/cli-update/spec.md
@@ -0,0 +1,92 @@
+# Delta for CLI Update
+
+## MODIFIED Requirements
+### Requirement: Slash Command Updates
+The update command SHALL refresh existing slash command files for configured tools without creating new ones, and ensure the OpenCode archive command accepts change ID arguments.
+
+#### Scenario: Updating slash commands for Antigravity
+- **WHEN** `.agent/workflows/` contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
+- **THEN** refresh the OpenSpec-managed portion of each file so the workflow copy matches other tools while preserving the existing single-field `description` frontmatter
+- **AND** skip creating any missing workflow files during update, mirroring the behavior for Windsurf and other IDEs
+
+#### Scenario: Updating slash commands for Claude Code
+- **WHEN** `.claude/commands/openspec/` contains `proposal.md`, `apply.md`, and `archive.md`
+- **THEN** refresh each file using shared templates
+- **AND** ensure templates include instructions for the relevant workflow stage
+
+#### Scenario: Updating slash commands for CodeBuddy Code
+- **WHEN** `.codebuddy/commands/openspec/` contains `proposal.md`, `apply.md`, and `archive.md`
+- **THEN** refresh each file using shared templates
+- **AND** ensure templates include instructions for the relevant workflow stage
+
+#### Scenario: Updating slash commands for Cline
+- **WHEN** `.clinerules/workflows/` contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
+- **THEN** refresh each file using shared templates
+- **AND** include Cline-specific Markdown heading frontmatter
+- **AND** ensure templates include instructions for the relevant workflow stage
+
+#### Scenario: Updating slash commands for Crush
+- **WHEN** `.crush/commands/` contains `openspec/proposal.md`, `openspec/apply.md`, and `openspec/archive.md`
+- **THEN** refresh each file using shared templates
+- **AND** include Crush-specific frontmatter with OpenSpec category and tags
+- **AND** ensure templates include instructions for the relevant workflow stage
+
+#### Scenario: Updating slash commands for Cursor
+- **WHEN** `.cursor/commands/` contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
+- **THEN** refresh each file using shared templates
+- **AND** ensure templates include instructions for the relevant workflow stage
+
+#### Scenario: Updating slash commands for Factory Droid
+- **WHEN** `.factory/commands/` contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
+- **THEN** refresh each file using the shared Factory templates that include YAML frontmatter for the `description` and `argument-hint` fields
+- **AND** ensure the template body retains the `$ARGUMENTS` placeholder so user input keeps flowing into droid
+- **AND** update only the content inside the OpenSpec managed markers, leaving any unmanaged notes untouched
+- **AND** skip creating missing files during update
+
+#### Scenario: Updating slash commands for OpenCode
+- **WHEN** `.opencode/command/` contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
+- **THEN** refresh each file using shared templates
+- **AND** ensure templates include instructions for the relevant workflow stage
+- **AND** ensure the archive command includes `$ARGUMENTS` placeholder in frontmatter for accepting change ID arguments
+
+#### Scenario: Updating slash commands for Windsurf
+- **WHEN** `.windsurf/workflows/` contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
+- **THEN** refresh each file using shared templates wrapped in OpenSpec markers
+- **AND** ensure templates include instructions for the relevant workflow stage
+- **AND** skip creating missing files (the update command only refreshes what already exists)
+
+#### Scenario: Updating slash commands for Kilo Code
+- **WHEN** `.kilocode/workflows/` contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
+- **THEN** refresh each file using shared templates wrapped in OpenSpec markers
+- **AND** ensure templates include instructions for the relevant workflow stage
+- **AND** skip creating missing files (the update command only refreshes what already exists)
+
+#### Scenario: Updating slash commands for Codex
+- **GIVEN** the global Codex prompt directory contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
+- **WHEN** a user runs `openspec update`
+- **THEN** refresh each file using the shared slash-command templates (including placeholder guidance)
+- **AND** preserve any unmanaged content outside the OpenSpec marker block
+- **AND** skip creation when a Codex prompt file is missing
+
+#### Scenario: Updating slash commands for GitHub Copilot
+- **WHEN** `.github/prompts/` contains `openspec-proposal.prompt.md`, `openspec-apply.prompt.md`, and `openspec-archive.prompt.md`
+- **THEN** refresh each file using shared templates while preserving the YAML frontmatter
+- **AND** update only the OpenSpec-managed block between markers
+- **AND** ensure templates include instructions for the relevant workflow stage
+
+#### Scenario: Updating slash commands for Gemini CLI
+- **WHEN** `.gemini/commands/openspec/` contains `proposal.toml`, `apply.toml`, and `archive.toml`
+- **THEN** refresh the body of each file using the shared proposal/apply/archive templates
+- **AND** replace only the content between `<!-- OPENSPEC:START -->` and `<!-- OPENSPEC:END -->` markers inside the `prompt = """` block so the TOML framing (`description`, `prompt`) stays intact
+- **AND** skip creating any missing `.toml` files during update; only pre-existing Gemini commands are refreshed
+
+#### Scenario: Updating slash commands for iFlow CLI
+- **WHEN** `.iflow/commands/` contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
+- **THEN** refresh each file using shared templates
+- **AND** preserve the YAML frontmatter with `name`, `id`, `category`, and `description` fields
+- **AND** update only the OpenSpec-managed block between markers
+- **AND** ensure templates include instructions for the relevant workflow stage
+
+#### Scenario: Missing slash command file
+- **WHEN** a tool lacks a slash command file
+- **THEN** do not create a new file during update
diff --git a/openspec/changes/fix-cline-workflows-implementation/tasks.md b/openspec/changes/archive/2025-12-30-fix-cline-workflows-implementation/tasks.md
similarity index 100%
rename from openspec/changes/fix-cline-workflows-implementation/tasks.md
rename to openspec/changes/archive/2025-12-30-fix-cline-workflows-implementation/tasks.md
diff --git a/openspec/changes/archive/2026-01-06-add-agent-schema-selection/proposal.md b/openspec/changes/archive/2026-01-06-add-agent-schema-selection/proposal.md
new file mode 100644
index 0000000..97a2fe0
--- /dev/null
+++ b/openspec/changes/archive/2026-01-06-add-agent-schema-selection/proposal.md
@@ -0,0 +1,26 @@
+## Why
+
+With per-change schema metadata in place (see `add-per-change-schema-metadata`), agents can now create changes with different workflow schemas. However, the agent skills are still hardcoded to `spec-driven` artifacts and don't offer schema selection to users.
+
+## What Changes
+
+**Scope: Experimental artifact workflow agent skills**
+
+**Depends on:** `add-per-change-schema-metadata` (must be implemented first)
+
+- Update `openspec-new-change` skill to prompt user for schema selection
+- Update `openspec-continue-change` skill to work with any schema's artifacts
+- Update `openspec-apply-change` skill to handle schema-specific task structures
+- Add schema descriptions to help users choose appropriate workflow
+
+## Capabilities
+
+### Modified Capabilities
+- `cli-artifact-workflow`: Agent skills support dynamic schema selection
+
+## Impact
+
+- **Affected code**: `src/core/templates/skill-templates.ts`
+- **User experience**: Users can choose TDD, spec-driven, or future workflows when starting a change
+- **Agent behavior**: Skills read artifact list from schema rather than hardcoding
+- **Backward compatible**: Default remains `spec-driven` if user doesn't choose
diff --git a/openspec/changes/archive/2026-01-06-add-agent-schema-selection/tasks.md b/openspec/changes/archive/2026-01-06-add-agent-schema-selection/tasks.md
new file mode 100644
index 0000000..6ee5eb4
--- /dev/null
+++ b/openspec/changes/archive/2026-01-06-add-agent-schema-selection/tasks.md
@@ -0,0 +1,32 @@
+## Prerequisites
+
+- [x] 0.1 Implement `add-per-change-schema-metadata` change first
+
+## 1. Schema Discovery
+
+- [x] 1.1 Add CLI command or helper to list schemas with descriptions (for agent use)
+- [x] 1.2 Ensure `openspec templates --schema <name>` returns artifact list for any schema
+
+## 2. Update New Change Skill
+
+- [x] 2.1 Add schema selection prompt using AskUserQuestion tool
+- [x] 2.2 Present available schemas with descriptions (spec-driven, tdd, etc.)
+- [x] 2.3 Pass selected schema to `openspec new change --schema <name>`
+- [x] 2.4 Update output to show which schema/workflow was selected
+
+## 3. Update Continue Change Skill
+
+- [x] 3.1 Remove hardcoded artifact references (proposal, specs, design, tasks)
+- [x] 3.2 Read artifact list dynamically from `openspec status --json`
+- [x] 3.3 Adjust artifact creation guidelines to be schema-agnostic
+- [x] 3.4 Handle schema-specific artifact types (e.g., TDD's `tests` artifact)
+
+## 4. Update Apply Change Skill
+
+- [x] 4.1 Make task detection work with different schema structures
+- [x] 4.2 Adjust context file reading for schema-specific artifacts
+
+## 5. Documentation
+
+- [x] 5.1 Add schema descriptions to help text or skill instructions
+- [x] 5.2 Document when to use each schema (TDD for bug fixes, spec-driven for features, etc.)
diff --git a/openspec/changes/archive/2026-01-06-add-per-change-schema-metadata/design.md b/openspec/changes/archive/2026-01-06-add-per-change-schema-metadata/design.md
new file mode 100644
index 0000000..58671ff
--- /dev/null
+++ b/openspec/changes/archive/2026-01-06-add-per-change-schema-metadata/design.md
@@ -0,0 +1,147 @@
+## Context
+
+The experimental artifact workflow supports multiple schemas (`spec-driven`, `tdd`), but schema selection must be passed on every command. This creates friction for agents and users.
+
+We need a lightweight metadata file to persist the schema choice per change.
+
+## Goals / Non-Goals
+
+**Goals:**
+- Store schema choice once at change creation
+- Auto-detect schema in experimental workflow commands
+- Maintain backward compatibility (no metadata = default)
+- Validate metadata with Zod schema
+
+**Non-Goals:**
+- Migrate existing changes (they use default)
+- Extend to legacy commands
+- Store additional metadata beyond schema (keep minimal for now)
+
+## Decisions
+
+### Decision: Zod Schema Design
+
+The metadata file (`.openspec.yaml`) will be validated with this Zod schema:
+
+```typescript
+// src/core/artifact-graph/types.ts (or new metadata.ts)
+
+import { z } from 'zod';
+import { listSchemas } from './resolver.js';
+
+/**
+ * Schema for per-change metadata stored in .openspec.yaml
+ */
+export const ChangeMetadataSchema = z.object({
+  // Required: which workflow schema this change uses
+  schema: z.string().min(1, { message: 'schema is required' }).refine(
+    (val) => listSchemas().includes(val),
+    (val) => ({ message: `Unknown schema '${val}'. Available: ${listSchemas().join(', ')}` })
+  ),
+
+  // Optional: creation timestamp (ISO date string)
+  created: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, {
+    message: 'created must be YYYY-MM-DD format'
+  }).optional(),
+});
+
+export type ChangeMetadata = z.infer<typeof ChangeMetadataSchema>;
+```
+
+**Rationale:**
+- `schema` is required and validated against available schemas at parse time
+- `created` is optional, ISO date format for consistency
+- Minimal fields - can extend later without breaking existing files
+- Follows existing codebase pattern (see `ArtifactSchema`, `SchemaYamlSchema`)
+
+### Decision: File Location and Format
+
+**Location:** `openspec/changes/<name>/.openspec.yaml`
+
+**Format:**
+```yaml
+schema: tdd
+created: 2025-01-05
+```
+
+**Alternatives considered:**
+- `change.yaml` - less hidden, but clutters directory
+- Frontmatter in `proposal.md` - couples to proposal existence
+- `openspec.json` - YAML matches existing schema files
+
+### Decision: Read/Write Functions
+
+```typescript
+// src/utils/change-metadata.ts
+
+import * as fs from 'node:fs';
+import * as path from 'node:path';
+import * as yaml from 'yaml';
+import { ChangeMetadataSchema, type ChangeMetadata } from '../core/artifact-graph/types.js';
+
+const METADATA_FILENAME = '.openspec.yaml';
+
+export function writeChangeMetadata(
+  changeDir: string,
+  metadata: ChangeMetadata
+): void {
+  // Validate before writing
+  const validated = ChangeMetadataSchema.parse(metadata);
+  const content = yaml.stringify(validated);
+  fs.writeFileSync(path.join(changeDir, METADATA_FILENAME), content);
+}
+
+export function readChangeMetadata(
+  changeDir: string
+): ChangeMetadata | null {
+  const metaPath = path.join(changeDir, METADATA_FILENAME);
+
+  if (!fs.existsSync(metaPath)) {
+    return null;
+  }
+
+  const content = fs.readFileSync(metaPath, 'utf-8');
+  const parsed = yaml.parse(content);
+
+  // Validate and return (throws ZodError if invalid)
+  return ChangeMetadataSchema.parse(parsed);
+}
+```
+
+### Decision: Schema Resolution Order
+
+When determining which schema to use:
+
+1. **Explicit `--schema` flag** (highest priority - user override)
+2. **`.openspec.yaml` metadata** (persisted choice)
+3. **Default `spec-driven`** (fallback)
+
+```typescript
+function resolveSchemaForChange(
+  changeDir: string,
+  explicitSchema?: string
+): string {
+  if (explicitSchema) return explicitSchema;
+
+  const metadata = readChangeMetadata(changeDir);
+  if (metadata?.schema) return metadata.schema;
+
+  return 'spec-driven';
+}
+```
+
+## Risks / Trade-offs
+
+- **Extra file per change** â†’ Minimal overhead, hidden file
+- **YAML parsing dependency** â†’ Already using `yaml` package for schema files
+- **Schema validation at read time** â†’ Fail fast with clear error if corrupted
+
+## Migration Plan
+
+No migration needed:
+- Existing changes without `.openspec.yaml` continue to work (use default)
+- New changes created with `openspec new change --schema X` get metadata file
+
+## Open Questions
+
+- Should `openspec new change` prompt for schema interactively if not specified? (Leaning no - default is fine)
diff --git a/openspec/changes/archive/2026-01-06-add-per-change-schema-metadata/proposal.md b/openspec/changes/archive/2026-01-06-add-per-change-schema-metadata/proposal.md
new file mode 100644
index 0000000..524de58
--- /dev/null
+++ b/openspec/changes/archive/2026-01-06-add-per-change-schema-metadata/proposal.md
@@ -0,0 +1,29 @@
+## Why
+
+Currently, the schema (workflow type) must be passed via `--schema` flag on every experimental workflow command. This is repetitive and error-prone. Agents have no way to know which schema a change uses, so they default to `spec-driven` and cannot leverage alternative workflows like `tdd`.
+
+## What Changes
+
+**Scope: Experimental artifact workflow only** (`openspec new change`, `openspec status`, `openspec instructions`, `openspec templates`)
+
+- Store schema choice in `.openspec.yaml` metadata file when creating a change via `openspec new change`
+- Auto-detect schema from metadata in experimental workflow commands
+- Make `--schema` flag optional (override only, metadata takes precedence)
+- Add `--schema` option to `openspec new change` command
+
+**Not affected**: Legacy commands (`openspec validate`, `openspec archive`, `openspec list`, `openspec show`)
+
+## Capabilities
+
+### New Capabilities
+- `change-metadata`: Reading/writing per-change metadata files
+
+### Modified Capabilities
+- `cli-artifact-workflow`: Commands auto-detect schema from change metadata
+
+## Impact
+
+- **Affected code**: `src/utils/change-utils.ts`, `src/core/artifact-graph/instruction-loader.ts`, `src/commands/artifact-workflow.ts`
+- **Agent skills**: Can be simplified - no longer need to pass schema explicitly
+- **Backward compatible**: Changes without `.openspec.yaml` fall back to `spec-driven` default
+- **Isolation**: All changes contained within experimental workflow code; legacy commands untouched
diff --git a/openspec/changes/archive/2026-01-06-add-per-change-schema-metadata/specs/cli-artifact-workflow/spec.md b/openspec/changes/archive/2026-01-06-add-per-change-schema-metadata/specs/cli-artifact-workflow/spec.md
new file mode 100644
index 0000000..a6f1db5
--- /dev/null
+++ b/openspec/changes/archive/2026-01-06-add-per-change-schema-metadata/specs/cli-artifact-workflow/spec.md
@@ -0,0 +1,98 @@
+## ADDED Requirements
+
+### Requirement: Change Metadata
+
+The system SHALL store and validate per-change metadata in `.openspec.yaml` files using a Zod schema.
+
+#### Scenario: Metadata file created with new change
+
+- **WHEN** user runs `openspec new change add-feature --schema tdd`
+- **THEN** the system creates `.openspec.yaml` in the change directory
+- **AND** the file contains `schema: tdd` and `created: <YYYY-MM-DD>`
+
+#### Scenario: Metadata validated on read
+
+- **WHEN** the system reads `.openspec.yaml`
+- **AND** the `schema` field references an unknown schema
+- **THEN** the system displays a validation error listing available schemas
+
+#### Scenario: Metadata schema validation
+
+- **WHEN** `.openspec.yaml` contains invalid YAML or missing required fields
+- **THEN** the system displays a Zod validation error with details
+
+#### Scenario: Missing metadata file
+
+- **WHEN** a change directory has no `.openspec.yaml` file
+- **THEN** the system falls back to the default schema (`spec-driven`)
+
+## MODIFIED Requirements
+
+### Requirement: New Change Command
+
+The system SHALL create new change directories with validation and optional schema metadata.
+
+#### Scenario: Create valid change
+
+- **WHEN** user runs `openspec new change add-feature`
+- **THEN** the system creates `openspec/changes/add-feature/` directory
+- **AND** creates `.openspec.yaml` with `schema: spec-driven` (default)
+
+#### Scenario: Create change with schema
+
+- **WHEN** user runs `openspec new change add-feature --schema tdd`
+- **THEN** the system creates `openspec/changes/add-feature/` directory
+- **AND** creates `.openspec.yaml` with `schema: tdd`
+
+#### Scenario: Invalid schema on create
+
+- **WHEN** user runs `openspec new change add-feature --schema unknown`
+- **THEN** the system displays an error listing available schemas
+- **AND** does not create the change directory
+
+#### Scenario: Invalid change name
+
+- **WHEN** user runs `openspec new change "Add Feature"` with invalid name
+- **THEN** the system displays validation error with guidance
+
+#### Scenario: Duplicate change name
+
+- **WHEN** user runs `openspec new change existing-change` for an existing change
+- **THEN** the system displays an error indicating the change already exists
+
+#### Scenario: Create with description
+
+- **WHEN** user runs `openspec new change add-feature --description "Add new feature"`
+- **THEN** the system creates the change directory with description in README.md
+
+### Requirement: Schema Selection
+
+The system SHALL support custom schema selection for workflow commands, with automatic detection from change metadata.
+
+#### Scenario: Schema auto-detected from metadata
+
+- **WHEN** user runs `openspec status --change <id>` without `--schema`
+- **AND** the change has `.openspec.yaml` with `schema: tdd`
+- **THEN** the system uses the `tdd` schema
+
+#### Scenario: Explicit schema overrides metadata
+
+- **WHEN** user runs `openspec status --change <id> --schema spec-driven`
+- **AND** the change has `.openspec.yaml` with `schema: tdd`
+- **THEN** the system uses `spec-driven` (explicit flag wins)
+
+#### Scenario: Default schema fallback
+
+- **WHEN** user runs workflow commands without `--schema`
+- **AND** the change has no `.openspec.yaml` file
+- **THEN** the system uses the "spec-driven" schema
+
+#### Scenario: Custom schema via flag
+
+- **WHEN** user runs `openspec status --change <id> --schema tdd`
+- **THEN** the system uses the specified schema for artifact graph
+
+#### Scenario: Unknown schema
+
+- **WHEN** user specifies an unknown schema
+- **THEN** the system displays an error listing available schemas
diff --git a/openspec/changes/archive/2026-01-06-add-per-change-schema-metadata/tasks.md b/openspec/changes/archive/2026-01-06-add-per-change-schema-metadata/tasks.md
new file mode 100644
index 0000000..5853131
--- /dev/null
+++ b/openspec/changes/archive/2026-01-06-add-per-change-schema-metadata/tasks.md
@@ -0,0 +1,29 @@
+## 1. Zod Schema and Types
+
+- [x] 1.1 Add `ChangeMetadataSchema` Zod schema to `src/core/artifact-graph/types.ts`
+- [x] 1.2 Export `ChangeMetadata` type inferred from schema
+
+## 2. Core Metadata Functions
+
+- [x] 2.1 Create `src/utils/change-metadata.ts` with `writeChangeMetadata()` function
+- [x] 2.2 Add `readChangeMetadata()` function with Zod validation
+- [x] 2.3 Update `createChange()` to accept optional `schema` param and write metadata
+
+## 3. Auto-Detection in Instruction Loader
+
+- [x] 3.1 Modify `loadChangeContext()` to read schema from `.openspec.yaml`
+- [x] 3.2 Make `schemaName` parameter optional (fall back to metadata, then default)
+
+## 4. CLI Updates
+
+- [x] 4.1 Add `--schema <name>` option to `openspec new change` command
+- [x] 4.2 Verify existing commands (`status`, `instructions`) work with auto-detection
+
+## 5. Tests
+
+- [x] 5.1 Test `ChangeMetadataSchema` validates correctly (valid/invalid cases)
+- [x] 5.2 Test `writeChangeMetadata()` creates valid YAML
+- [x] 5.3 Test `readChangeMetadata()` parses and validates schema
+- [x] 5.4 Test `loadChangeContext()` auto-detects schema from metadata
+- [x] 5.5 Test fallback to default when no metadata exists
+- [x] 5.6 Test `--schema` flag overrides metadata
diff --git a/openspec/changes/archive/2026-01-06-add-specs-apply-command/.openspec.yaml b/openspec/changes/archive/2026-01-06-add-specs-apply-command/.openspec.yaml
new file mode 100644
index 0000000..5d67ddc
--- /dev/null
+++ b/openspec/changes/archive/2026-01-06-add-specs-apply-command/.openspec.yaml
@@ -0,0 +1,2 @@
+schema: spec-driven
+created: 2026-01-06
diff --git a/openspec/changes/archive/2026-01-06-add-specs-apply-command/design.md b/openspec/changes/archive/2026-01-06-add-specs-apply-command/design.md
new file mode 100644
index 0000000..a3b2559
--- /dev/null
+++ b/openspec/changes/archive/2026-01-06-add-specs-apply-command/design.md
@@ -0,0 +1,77 @@
+## Context
+
+Currently, delta specs are only applied to main specs when running `openspec archive`. This bundles two concerns:
+1. Applying spec changes (delta â†’ main)
+2. Archiving the change (move to archive folder)
+
+Users want flexibility to sync specs earlier, especially when iterating. The archive command already contains the reconciliation logic in `buildUpdatedSpec()`.
+
+## Goals / Non-Goals
+
+**Goals:**
+- Decouple spec syncing from archiving
+- Provide `/opsx:sync` skill for agents to sync specs on demand
+- Keep operation idempotent (safe to run multiple times)
+
+**Non-Goals:**
+- Tracking whether specs have been synced (no state)
+- Changing archive behavior (it will continue to apply specs)
+- Supporting partial application (all deltas sync together)
+
+## Decisions
+
+### 1. Reuse existing reconciliation logic
+
+**Decision**: Extract `buildUpdatedSpec()` logic from `ArchiveCommand` into a shared module.
+
+**Rationale**: The archive command already implements delta parsing and application. Rather than duplicate, we extract and reuse.
+
+**Alternatives considered**:
+- Duplicate logic in new command (rejected: maintenance burden)
+- Have sync call archive with flags (rejected: coupling)
+
+### 2. No state tracking
+
+**Decision**: Don't track whether specs have been synced. Each invocation reads delta and main specs, reconciles.
+
+**Rationale**:
+- Idempotent operations don't need state
+- Avoids sync issues between flag and reality
+- Simpler implementation and mental model
+
+**Alternatives considered**:
+- Track `specsSynced: true` in `.openspec.yaml` (rejected: unnecessary complexity)
+- Store snapshot of synced deltas (rejected: over-engineering)
+
+### 3. Agent-driven approach (no CLI command)
+
+**Decision**: The `/opsx:sync` skill is fully agent-driven - the agent reads delta specs and directly edits main specs.
+
+**Rationale**:
+- Allows intelligent merging (add scenarios without copying entire requirements)
+- Delta represents *intent*, not wholesale replacement
+- More flexible and natural editing workflow
+- Archive still uses programmatic merge (for finalized changes)
+
+### 4. Archive behavior unchanged
+
+**Decision**: Archive continues to apply specs as part of its flow. If specs are already reconciled, the operation is a no-op.
+
+**Rationale**: Backward compatibility. Users who don't use `/opsx:sync` get the same experience.
+
+## Risks / Trade-offs
+
+**[Risk] Multiple changes modify same spec**
+â†’ Last to sync wins. Same as today with archive. Users should coordinate or use sequential archives.
+
+**[Risk] User syncs specs then continues editing deltas**
+â†’ Running `/opsx:sync` again reconciles. Idempotent design handles this.
+
+**[Trade-off] No undo mechanism**
+â†’ Users can `git checkout` main specs if needed. Explicit undo command is out of scope.
+
+## Implementation Approach
+
+1. Extract spec application logic from `ArchiveCommand.buildUpdatedSpec()` into `src/core/specs-apply.ts`
+2. Add skill template for `/opsx:sync` in `skill-templates.ts`
+3. Register skill in managed skills
diff --git a/openspec/changes/archive/2026-01-06-add-specs-apply-command/proposal.md b/openspec/changes/archive/2026-01-06-add-specs-apply-command/proposal.md
new file mode 100644
index 0000000..22fccb6
--- /dev/null
+++ b/openspec/changes/archive/2026-01-06-add-specs-apply-command/proposal.md
@@ -0,0 +1,32 @@
+## Why
+
+Spec application is currently bundled with archive - users must run `openspec archive` to apply delta specs to main specs. This couples two distinct concerns (applying specs vs. archiving the change) and forces users to wait until they're "done" to see main specs updated. Users want the flexibility to sync specs earlier in the workflow while iterating.
+
+## What Changes
+
+- Add `/opsx:sync` skill that syncs delta specs to main specs as a standalone action
+- The operation is idempotent - safe to run multiple times, agent reconciles main specs to match deltas
+- Archive continues to work as today (applies specs if not already reconciled, then moves to archive)
+- No new state tracking - the agent reads delta and main specs, reconciles on each run
+- Agent-driven approach allows intelligent merging (partial updates, adding scenarios)
+
+**Workflow becomes:**
+```
+/opsx:new â†’ /opsx:continue â†’ /opsx:apply â†’ archive
+                                  â”‚
+                                  â””â”€â”€ /opsx:sync (optional, anytime)
+```
+
+## Capabilities
+
+### New Capabilities
+- `specs-sync-skill`: Skill template for `/opsx:sync` command that reconciles main specs with delta specs
+
+### Modified Capabilities
+- None (agent-driven, no CLI command needed)
+
+## Impact
+
+- **Skills**: New `openspec-sync-specs` skill in `skill-templates.ts`
+- **Archive**: No changes needed - already does reconciliation, will continue to work
+- **Agent workflow**: Users gain flexibility to sync specs before archive
diff --git a/openspec/changes/archive/2026-01-06-add-specs-apply-command/specs/specs-sync-skill/spec.md b/openspec/changes/archive/2026-01-06-add-specs-apply-command/specs/specs-sync-skill/spec.md
new file mode 100644
index 0000000..084b3f1
--- /dev/null
+++ b/openspec/changes/archive/2026-01-06-add-specs-apply-command/specs/specs-sync-skill/spec.md
@@ -0,0 +1,67 @@
+## ADDED Requirements
+
+### Requirement: Specs Sync Skill
+The system SHALL provide an `/opsx:sync` skill that syncs delta specs from a change to the main specs.
+
+#### Scenario: Sync delta specs to main specs
+- **WHEN** agent executes `/opsx:sync` with a change name
+- **THEN** the agent reads delta specs from `openspec/changes/<name>/specs/`
+- **AND** reads corresponding main specs from `openspec/specs/`
+- **AND** reconciles main specs to match what the deltas describe
+
+#### Scenario: Idempotent operation
+- **WHEN** agent executes `/opsx:sync` multiple times on the same change
+- **THEN** the result is the same as running it once
+- **AND** no duplicate requirements are created
+
+#### Scenario: Change selection prompt
+- **WHEN** agent executes `/opsx:sync` without specifying a change
+- **THEN** the agent prompts user to select from available changes
+- **AND** shows changes that have delta specs
+
+### Requirement: Delta Reconciliation Logic
+The agent SHALL reconcile main specs with delta specs using the delta operation headers.
+
+#### Scenario: ADDED requirements
+- **WHEN** delta contains `## ADDED Requirements` with a requirement
+- **AND** the requirement does not exist in main spec
+- **THEN** add the requirement to main spec
+
+#### Scenario: ADDED requirement already exists
+- **WHEN** delta contains `## ADDED Requirements` with a requirement
+- **AND** a requirement with the same name already exists in main spec
+- **THEN** update the existing requirement to match the delta version
+
+#### Scenario: MODIFIED requirements
+- **WHEN** delta contains `## MODIFIED Requirements` with a requirement
+- **AND** the requirement exists in main spec
+- **THEN** replace the requirement in main spec with the delta version
+
+#### Scenario: REMOVED requirements
+- **WHEN** delta contains `## REMOVED Requirements` with a requirement name
+- **AND** the requirement exists in main spec
+- **THEN** remove the requirement from main spec
+
+#### Scenario: RENAMED requirements
+- **WHEN** delta contains `## RENAMED Requirements` with FROM:/TO: format
+- **AND** the FROM requirement exists in main spec
+- **THEN** rename the requirement to the TO name
+
+#### Scenario: New capability spec
+- **WHEN** delta spec exists for a capability not in main specs
+- **THEN** create new main spec file at `openspec/specs/<capability>/spec.md`
+
+### Requirement: Skill Output
+The skill SHALL provide clear feedback on what was synced.
+
+#### Scenario: Show synced changes
+- **WHEN** reconciliation completes successfully
+- **THEN** display summary of changes per capability:
+  - Number of requirements added
+  - Number of requirements modified
+  - Number of requirements removed
+  - Number of requirements renamed
+
+#### Scenario: No changes needed
+- **WHEN** main specs already match delta specs
+- **THEN** display "Specs already in sync - no changes needed"
diff --git a/openspec/changes/archive/2026-01-06-add-specs-apply-command/tasks.md b/openspec/changes/archive/2026-01-06-add-specs-apply-command/tasks.md
new file mode 100644
index 0000000..7af3bb0
--- /dev/null
+++ b/openspec/changes/archive/2026-01-06-add-specs-apply-command/tasks.md
@@ -0,0 +1,40 @@
+## Tasks
+
+### Core Implementation
+
+- [x] Extract spec application logic from `ArchiveCommand` into `src/core/specs-apply.ts`
+  - Move `buildUpdatedSpec()`, `findSpecUpdates()`, `writeUpdatedSpec()` to shared module
+  - Keep `ArchiveCommand` importing from the new module
+  - Ensure all validation logic is preserved
+
+### Skill Template
+
+- [x] Add `getSyncSpecsSkillTemplate()` function in `src/core/templates/skill-templates.ts`
+  - Skill name: `openspec-sync-specs`
+  - Description: Sync delta specs to main specs
+  - **Agent-driven**: Instructions for agent to read deltas and edit main specs directly
+
+- [x] Add `/opsx:sync` slash command template in `skill-templates.ts`
+  - Mirror the skill template for slash command format
+  - **Agent-driven**: No CLI command, agent does the merge
+
+### Registration
+
+- [x] Register skill in managed skills (via `artifact-experimental-setup`)
+  - Add to skill list with appropriate metadata
+  - Ensure it appears in setup output
+
+### Design Decision
+
+**Why agent-driven instead of CLI-driven?**
+
+The programmatic merge operates at requirement-level granularity:
+- MODIFIED requires copying ALL scenarios, not just the changed ones
+- If agent forgets a scenario, it gets deleted
+- Delta specs become bloated with copied content
+
+Agent-driven approach:
+- Agent can apply partial updates (add a scenario without copying others)
+- Delta represents *intent*, not wholesale replacement
+- More flexible and natural editing workflow
+- Archive still uses programmatic merge (for finalized changes)
diff --git a/openspec/changes/archive/2026-01-06-make-apply-instructions-schema-aware/proposal.md b/openspec/changes/archive/2026-01-06-make-apply-instructions-schema-aware/proposal.md
new file mode 100644
index 0000000..b9c86ed
--- /dev/null
+++ b/openspec/changes/archive/2026-01-06-make-apply-instructions-schema-aware/proposal.md
@@ -0,0 +1,138 @@
+## Why
+
+The `generateApplyInstructions` function is hardcoded to check for `spec-driven` artifacts (`proposal.md`, `specs/`, `design.md`, `tasks.md`). If a user selects a different schema like `tdd`, the apply instructions are meaningless - they check for files that don't exist in that schema.
+
+This blocks the experimental workflow from supporting multiple schemas properly.
+
+## What Changes
+
+**Scope: Experimental artifact workflow** (`openspec instructions apply`)
+
+**Depends on:** `add-per-change-schema-metadata` (to know which schema a change uses)
+
+- Make `generateApplyInstructions` read artifact definitions from the schema
+- Dynamically determine which artifacts exist based on schema
+- Define when a change becomes "implementable" (see Design Decision below)
+- Generate schema-appropriate context files and instructions
+
+## Design Decision: When is a change implementable?
+
+This is the key question. Different approaches:
+
+### Option A: Explicit `apply` artifact in schema
+
+Add a field to mark which artifact is the "implementation gate":
+
+```yaml
+artifacts:
+  - id: tasks
+    generates: tasks.md
+    apply: true  # â† This artifact triggers apply mode
+```
+
+**Pros:** Explicit, flexible
+**Cons:** Another field to maintain, what if multiple artifacts are `apply: true`?
+
+### Option B: Leaf artifacts are implementable
+
+The artifact(s) with no dependents (nothing depends on them) are the apply target.
+
+- `spec-driven`: `tasks` is a leaf â†’ apply = execute tasks
+- `tdd`: `docs` is a leaf â†’ but that doesn't make sense for TDD...
+
+**Pros:** No extra schema field, derived from graph
+**Cons:** Doesn't match TDD semantics (implementation is the action, not docs)
+
+### Option C: Schema-level `apply_phase` definition
+
+Add a top-level field to the schema:
+
+```yaml
+name: spec-driven
+apply_phase:
+  requires: [tasks]  # Must exist before apply
+  tracks: tasks.md   # File with checkboxes to track
+  instruction: "Work through tasks, mark complete as you go"
+```
+
+```yaml
+name: tdd
+apply_phase:
+  requires: [tests]  # Must have tests before implementing
+  tracks: null       # No checkbox tracking - just make tests pass
+  instruction: "Run tests, implement until green, refactor"
+```
+
+**Pros:** Full flexibility, schema controls its own apply semantics
+**Cons:** More complex schema format
+
+### Option D: Convention-based (artifact ID matching)
+
+If artifact ID is `tasks` or `implementation`, it's the apply target.
+
+**Pros:** Simple, no schema changes
+**Cons:** Brittle, doesn't work for custom schemas
+
+### Option E: All artifacts complete â†’ apply available
+
+Apply becomes available when ALL schema artifacts exist. Implementation is whatever the user does after planning.
+
+**Pros:** Simple, no schema changes
+**Cons:** Doesn't guide what "apply" means for different workflows
+
+---
+
+## Decision: Add `apply` block to schema.yaml
+
+Add a top-level `apply` field to schema definitions:
+
+```yaml
+name: spec-driven
+version: 1
+description: Default OpenSpec workflow
+
+artifacts:
+  # ... existing artifacts ...
+
+apply:
+  requires: [tasks]           # Artifacts that must exist before apply
+  tracks: tasks.md            # File with checkboxes for progress (optional)
+  instruction: |              # Guidance shown to agent
+    Read context files, work through pending tasks, mark complete as you go.
+    Pause if you hit blockers or need clarification.
+```
+
+```yaml
+name: tdd
+version: 1
+description: Test-driven development workflow
+
+artifacts:
+  # ... existing artifacts ...
+
+apply:
+  requires: [tests]           # Must have tests before implementing
+  tracks: null                # No checkbox tracking
+  instruction: |
+    Run tests to see failures. Implement minimal code to pass each test.
+    Refactor while keeping tests green.
+```
+
+**Key properties:**
+- `requires`: Array of artifact IDs that must exist before apply is available
+- `tracks`: Path to file with checkboxes (relative to change dir), or `null` if no tracking
+- `instruction`: Custom guidance for the apply phase
+
+**Fallback behavior:** Schemas without `apply` block default to "all artifacts must exist"
+
+## Capabilities
+
+### Modified Capabilities
+- `cli-artifact-workflow`: Apply instructions become schema-aware
+
+## Impact
+
+- **Affected code**: `src/commands/artifact-workflow.ts` (generateApplyInstructions)
+- **Schema format**: May need new `apply_phase` field
+- **Existing schemas**: Need to add apply_phase to `spec-driven` and `tdd`
+- **Backward compatible**: Schemas without apply_phase can use default behavior
diff --git a/openspec/changes/archive/2026-01-06-make-apply-instructions-schema-aware/specs/cli-artifact-workflow/spec.md b/openspec/changes/archive/2026-01-06-make-apply-instructions-schema-aware/specs/cli-artifact-workflow/spec.md
new file mode 100644
index 0000000..c1ac247
--- /dev/null
+++ b/openspec/changes/archive/2026-01-06-make-apply-instructions-schema-aware/specs/cli-artifact-workflow/spec.md
@@ -0,0 +1,60 @@
+## ADDED Requirements
+
+### Requirement: Schema Apply Block
+
+The system SHALL support an `apply` block in schema definitions that controls when and how implementation begins.
+
+#### Scenario: Schema with apply block
+
+- **WHEN** a schema defines an `apply` block
+- **THEN** the system uses `apply.requires` to determine which artifacts must exist before apply
+- **AND** uses `apply.tracks` to identify the file for progress tracking (or null if none)
+- **AND** uses `apply.instruction` for guidance shown to the agent
+
+#### Scenario: Schema without apply block
+
+- **WHEN** a schema has no `apply` block
+- **THEN** the system requires all artifacts to exist before apply is available
+- **AND** uses default instruction: "All artifacts complete. Proceed with implementation."
+
+### Requirement: Apply Instructions Command
+
+The system SHALL generate schema-aware apply instructions via `openspec instructions apply`.
+
+#### Scenario: Generate apply instructions
+
+- **WHEN** user runs `openspec instructions apply --change <id>`
+- **AND** all required artifacts (per schema's `apply.requires`) exist
+- **THEN** the system outputs:
+  - Context files from all existing artifacts
+  - Schema-specific instruction text
+  - Progress tracking file path (if `apply.tracks` is set)
+
+#### Scenario: Apply blocked by missing artifacts
+
+- **WHEN** user runs `openspec instructions apply --change <id>`
+- **AND** required artifacts are missing
+- **THEN** the system indicates apply is blocked
+- **AND** lists which artifacts must be created first
+
+#### Scenario: Apply instructions JSON output
+
+- **WHEN** user runs `openspec instructions apply --change <id> --json`
+- **THEN** the system outputs JSON with:
+  - `contextFiles`: array of paths to existing artifacts
+  - `instruction`: the apply instruction text
+  - `tracks`: path to progress file or null
+  - `applyRequires`: list of required artifact IDs
+
+## MODIFIED Requirements
+
+### Requirement: Status Command
+
+The system SHALL display artifact completion status for a change, including apply readiness.
+
+#### Scenario: Status JSON includes apply requirements
+
+- **WHEN** user runs `openspec status --change <id> --json`
+- **THEN** the system outputs JSON with:
+  - `changeName`, `schemaName`, `isComplete`, `artifacts` array
+  - `applyRequires`: array of artifact IDs needed for apply phase
diff --git a/openspec/changes/archive/2026-01-06-make-apply-instructions-schema-aware/tasks.md b/openspec/changes/archive/2026-01-06-make-apply-instructions-schema-aware/tasks.md
new file mode 100644
index 0000000..29408bd
--- /dev/null
+++ b/openspec/changes/archive/2026-01-06-make-apply-instructions-schema-aware/tasks.md
@@ -0,0 +1,35 @@
+## Prerequisites
+
+- [x] 0.1 Implement `add-per-change-schema-metadata` first (to auto-detect schema)
+
+## 1. Schema Format
+
+- [x] 1.1 Add `ApplyPhaseSchema` Zod schema to `src/core/artifact-graph/types.ts`
+- [x] 1.2 Update `SchemaYamlSchema` to include optional `apply` field
+- [x] 1.3 Export `ApplyPhase` type
+
+## 2. Update Existing Schemas
+
+- [x] 2.1 Add `apply` block to `schemas/spec-driven/schema.yaml`
+- [x] 2.2 Add `apply` block to `schemas/tdd/schema.yaml`
+
+## 3. Refactor generateApplyInstructions
+
+- [x] 3.1 Load schema via `resolveSchema(schemaName)`
+- [x] 3.2 Read `apply.requires` to determine required artifacts
+- [x] 3.3 Check artifact existence dynamically (not hardcoded paths)
+- [x] 3.4 Use `apply.tracks` for progress tracking (or skip if null)
+- [x] 3.5 Use `apply.instruction` for the instruction text
+- [x] 3.6 Build `contextFiles` from all existing artifacts in schema
+
+## 4. Handle Fallback
+
+- [x] 4.1 If schema has no `apply` block, require all artifacts to exist
+- [x] 4.2 Default instruction: "All artifacts complete. Proceed with implementation."
+
+## 5. Tests
+
+- [x] 5.1 Test apply instructions with spec-driven schema
+- [x] 5.2 Test apply instructions with tdd schema
+- [x] 5.3 Test fallback when schema has no apply block
+- [x] 5.4 Test blocked state when required artifacts missing
diff --git a/openspec/changes/archive/2026-01-06-opsx-archive-command/.openspec.yaml b/openspec/changes/archive/2026-01-06-opsx-archive-command/.openspec.yaml
new file mode 100644
index 0000000..75b7b3e
--- /dev/null
+++ b/openspec/changes/archive/2026-01-06-opsx-archive-command/.openspec.yaml
@@ -0,0 +1,2 @@
+schema: spec-driven
+created: 2026-01-07
diff --git a/openspec/changes/archive/2026-01-06-opsx-archive-command/design.md b/openspec/changes/archive/2026-01-06-opsx-archive-command/design.md
new file mode 100644
index 0000000..7e01aea
--- /dev/null
+++ b/openspec/changes/archive/2026-01-06-opsx-archive-command/design.md
@@ -0,0 +1,84 @@
+## Context
+
+The experimental workflow (OPSX) provides a complete lifecycle for creating changes:
+- `/opsx:new` - Scaffold a new change with schema
+- `/opsx:continue` - Create next artifact
+- `/opsx:ff` - Fast-forward all artifacts
+- `/opsx:apply` - Implement tasks
+- `/opsx:sync` - Sync delta specs to main
+
+The missing piece is archiving. The existing `openspec archive` command works but:
+1. Applies specs programmatically (not agent-driven)
+2. Doesn't use the artifact graph for completion checking
+3. Doesn't integrate with the OPSX workflow philosophy
+
+## Goals / Non-Goals
+
+**Goals:**
+- Add `/opsx:archive` skill to complete the OPSX workflow lifecycle
+- Use artifact graph for schema-aware completion checking
+- Integrate with `/opsx:sync` for agent-driven spec syncing
+- Preserve `.openspec.yaml` schema metadata in archive
+
+**Non-Goals:**
+- Replacing the existing `openspec archive` CLI command
+- Changing how specs are applied in the CLI command
+- Modifying the artifact graph or schema system
+
+## Decisions
+
+### Decision 1: Skill-only implementation (no new CLI command)
+
+The `/opsx:archive` will be a slash command/skill only, not a new CLI command.
+
+**Rationale**: The existing `openspec archive` CLI command already handles the core archive functionality (moving to archive folder, date prefixing). The OPSX version just needs different pre-archive checks and optional sync prompting, which are agent behaviors better suited to a skill.
+
+**Alternatives considered**:
+- Adding flags to `openspec archive` (e.g., `--experimental`) - Rejected: adds complexity to CLI, harder to maintain two code paths
+- New CLI command `openspec archive-experimental` - Rejected: unnecessary duplication, agent skills are the OPSX pattern
+
+### Decision 2: Prompt for sync before archive
+
+The skill will check for unsynced delta specs and prompt the user before archiving.
+
+**Rationale**: The OPSX philosophy is agent-driven intelligent merging via `/opsx:sync`. Rather than programmatically applying specs like the regular archive command, we prompt the user to sync first if needed. This maintains workflow flexibility (user can decline and just archive).
+
+**Flow**:
+1. Check if `specs/` directory exists in the change
+2. If yes, ask: "This change has delta specs. Would you like to sync them to main specs before archiving?"
+3. If user says yes, execute `/opsx:sync` logic
+4. Proceed with archive regardless of answer
+
+### Decision 3: Use artifact graph for completion checking
+
+The skill will use `openspec status --change "<name>" --json` to check artifact completion instead of just validating proposal.md and specs.
+
+**Rationale**: The experimental workflow is schema-aware. Different schemas have different required artifacts. The artifact graph knows which artifacts are complete/incomplete for the current schema.
+
+**Behavior**:
+- Show warning if any artifacts are not `done`
+- Don't block archive (user may have valid reasons to archive early)
+- List incomplete artifacts so user can make informed decision
+
+### Decision 4: Reuse tasks.md completion check from regular archive
+
+The skill will parse tasks.md and warn about incomplete tasks, same as regular archive.
+
+**Rationale**: Task completion checking is valuable regardless of workflow. The logic is simple (count `- [ ]` vs `- [x]`) and doesn't need special OPSX handling.
+
+### Decision 5: Move change to archive/ with date prefix
+
+Same archive behavior as regular command: move to `openspec/changes/archive/YYYY-MM-DD-<name>/`.
+
+**Rationale**: Consistency with existing archive convention. The `.openspec.yaml` file moves with the change, preserving schema metadata.
+
+## Risks / Trade-offs
+
+**Risk**: Users confused about when to use `/opsx:archive` vs `openspec archive`
+â†’ **Mitigation**: Documentation should clarify: use `/opsx:archive` if you've been using the OPSX workflow, use `openspec archive` otherwise. Both produce the same archived result.
+
+**Risk**: Incomplete sync if user declines and has delta specs
+â†’ **Mitigation**: The prompt is informational; user has full control. They may want to archive without syncing (e.g., abandoned change). Log a note in output.
+
+**Trade-off**: No programmatic spec application in OPSX archive
+â†’ **Accepted**: This is intentional. OPSX philosophy is agent-driven merging. If user wants programmatic application, use `openspec archive` instead.
diff --git a/openspec/changes/archive/2026-01-06-opsx-archive-command/proposal.md b/openspec/changes/archive/2026-01-06-opsx-archive-command/proposal.md
new file mode 100644
index 0000000..263faae
--- /dev/null
+++ b/openspec/changes/archive/2026-01-06-opsx-archive-command/proposal.md
@@ -0,0 +1,28 @@
+## Why
+
+The experimental workflow (OPSX) provides a schema-driven, artifact-by-artifact approach to creating changes with `/opsx:new`, `/opsx:continue`, `/opsx:ff`, `/opsx:apply`, and `/opsx:sync`. However, there's no corresponding archive command to finalize and archive completed changes. Users must currently fall back to the regular `openspec archive` command, which doesn't integrate with the OPSX philosophy of agent-driven spec syncing and schema-aware artifact tracking.
+
+## What Changes
+
+- Add `/opsx:archive` slash command for archiving changes in the experimental workflow
+- Use artifact graph to check completion status (schema-aware) instead of just validating proposal + specs
+- Prompt for `/opsx:sync` before archiving instead of programmatically applying specs
+- Preserve `.openspec.yaml` schema metadata when moving to archive
+- Integrate with existing OPSX commands for a cohesive workflow
+
+## Capabilities
+
+### New Capabilities
+
+- `opsx-archive-skill`: Slash command and skill for archiving completed changes in the experimental workflow. Checks artifact completion via artifact graph, verifies task completion, optionally syncs specs via `/opsx:sync`, and moves the change to `archive/YYYY-MM-DD-<name>/`.
+
+### Modified Capabilities
+
+(none - this is a new skill that doesn't modify existing specs)
+
+## Impact
+
+- New file: `.claude/commands/opsx/archive.md`
+- New skill definition (generated via `openspec artifact-experimental-setup`)
+- No changes to existing archive command or other OPSX commands
+- Completes the OPSX command suite for full lifecycle management
diff --git a/openspec/changes/archive/2026-01-06-opsx-archive-command/specs/opsx-archive-skill/spec.md b/openspec/changes/archive/2026-01-06-opsx-archive-command/specs/opsx-archive-skill/spec.md
new file mode 100644
index 0000000..59891c6
--- /dev/null
+++ b/openspec/changes/archive/2026-01-06-opsx-archive-command/specs/opsx-archive-skill/spec.md
@@ -0,0 +1,122 @@
+## ADDED Requirements
+
+### Requirement: OPSX Archive Skill
+
+The system SHALL provide an `/opsx:archive` skill that archives completed changes in the experimental workflow.
+
+#### Scenario: Archive a change with all artifacts complete
+
+- **WHEN** agent executes `/opsx:archive` with a change name
+- **AND** all artifacts in the schema are complete
+- **AND** all tasks are complete
+- **THEN** the agent moves the change to `openspec/changes/archive/YYYY-MM-DD-<name>/`
+- **AND** displays success message with archived location
+
+#### Scenario: Change selection prompt
+
+- **WHEN** agent executes `/opsx:archive` without specifying a change
+- **THEN** the agent prompts user to select from available changes
+- **AND** shows only active changes (excludes archive/)
+
+### Requirement: Artifact Completion Check
+
+The skill SHALL check artifact completion status using the artifact graph before archiving.
+
+#### Scenario: Incomplete artifacts warning
+
+- **WHEN** agent checks artifact status
+- **AND** one or more artifacts have status other than `done`
+- **THEN** display warning listing incomplete artifacts
+- **AND** prompt user for confirmation to continue
+- **AND** proceed if user confirms
+
+#### Scenario: All artifacts complete
+
+- **WHEN** agent checks artifact status
+- **AND** all artifacts have status `done`
+- **THEN** proceed without warning
+
+### Requirement: Task Completion Check
+
+The skill SHALL check task completion status from tasks.md before archiving.
+
+#### Scenario: Incomplete tasks found
+
+- **WHEN** agent reads tasks.md
+- **AND** incomplete tasks are found (marked with `- [ ]`)
+- **THEN** display warning showing count of incomplete tasks
+- **AND** prompt user for confirmation to continue
+- **AND** proceed if user confirms
+
+#### Scenario: All tasks complete
+
+- **WHEN** agent reads tasks.md
+- **AND** all tasks are complete (marked with `- [x]`)
+- **THEN** proceed without task-related warning
+
+#### Scenario: No tasks file
+
+- **WHEN** tasks.md does not exist
+- **THEN** proceed without task-related warning
+
+### Requirement: Spec Sync Prompt
+
+The skill SHALL prompt to sync delta specs before archiving if specs exist.
+
+#### Scenario: Delta specs exist
+
+- **WHEN** agent checks for delta specs
+- **AND** `specs/` directory exists in the change with spec files
+- **THEN** prompt user: "This change has delta specs. Would you like to sync them to main specs before archiving?"
+- **AND** if user confirms, execute `/opsx:sync` logic
+- **AND** proceed with archive regardless of sync choice
+
+#### Scenario: No delta specs
+
+- **WHEN** agent checks for delta specs
+- **AND** no `specs/` directory or no spec files exist
+- **THEN** proceed without sync prompt
+
+### Requirement: Archive Process
+
+The skill SHALL move the change to the archive folder with date prefix.
+
+#### Scenario: Successful archive
+
+- **WHEN** archiving a change
+- **THEN** create `archive/` directory if it doesn't exist
+- **AND** generate target name as `YYYY-MM-DD-<change-name>` using current date
+- **AND** move entire change directory to archive location
+- **AND** preserve `.openspec.yaml` file in archived change
+
+#### Scenario: Archive already exists
+
+- **WHEN** target archive directory already exists
+- **THEN** fail with error message
+- **AND** suggest renaming existing archive or using different date
+
+### Requirement: Skill Output
+
+The skill SHALL provide clear feedback about the archive operation.
+
+#### Scenario: Archive complete with sync
+
+- **WHEN** archive completes after syncing specs
+- **THEN** display summary:
+  - Specs synced (from `/opsx:sync` output)
+  - Change archived to location
+  - Schema that was used
+
+#### Scenario: Archive complete without sync
+
+- **WHEN** archive completes without syncing specs
+- **THEN** display summary:
+  - Note that specs were not synced (if applicable)
+  - Change archived to location
+  - Schema that was used
+
+#### Scenario: Archive complete with warnings
+
+- **WHEN** archive completes with incomplete artifacts or tasks
+- **THEN** include note about what was incomplete
+- **AND** suggest reviewing if archive was intentional
diff --git a/openspec/changes/archive/2026-01-06-opsx-archive-command/tasks.md b/openspec/changes/archive/2026-01-06-opsx-archive-command/tasks.md
new file mode 100644
index 0000000..2b1582a
--- /dev/null
+++ b/openspec/changes/archive/2026-01-06-opsx-archive-command/tasks.md
@@ -0,0 +1,23 @@
+## 1. Create Slash Command
+
+- [x] 1.1 Create `.claude/commands/opsx/archive.md` with skill definition
+- [x] 1.2 Add YAML frontmatter (name, description, category, tags)
+- [x] 1.3 Implement change selection logic (prompt if not provided)
+- [x] 1.4 Implement artifact completion check using `openspec status --json`
+- [x] 1.5 Implement task completion check (parse tasks.md for `- [ ]`)
+- [x] 1.6 Implement spec sync prompt (check for specs/ directory, offer `/opsx:sync`)
+- [x] 1.7 Implement archive process (move to archive/YYYY-MM-DD-<name>/)
+- [x] 1.8 Add output formatting for success/warning cases
+
+## 2. Regenerate Skills
+
+- [x] 2.1 Run `openspec artifact-experimental-setup` to regenerate skills
+- [x] 2.2 Verify skill appears in `.claude/skills/` directory
+
+## 3. Testing
+
+- [x] 3.1 Test `/opsx:archive` with a complete change (all artifacts, all tasks done)
+- [x] 3.2 Test `/opsx:archive` with incomplete artifacts (verify warning shown)
+- [x] 3.3 Test `/opsx:archive` with incomplete tasks (verify warning shown)
+- [x] 3.4 Test `/opsx:archive` with delta specs (verify sync prompt shown)
+- [x] 3.5 Test `/opsx:archive` without change name (verify selection prompt)
diff --git a/openspec/changes/fix-cline-workflows-implementation/specs/cli-init/spec.md b/openspec/changes/fix-cline-workflows-implementation/specs/cli-init/spec.md
deleted file mode 100644
index 2459a48..0000000
--- a/openspec/changes/fix-cline-workflows-implementation/specs/cli-init/spec.md
+++ /dev/null
@@ -1,11 +0,0 @@
-# Delta for CLI Init
-
-## MODIFIED Requirements
-### Requirement: Slash Command Configuration
-
-#### Scenario: Generating slash commands for Cline
-- **WHEN** the user selects Cline during initialization
-- **THEN** create `.clinerules/workflows/openspec-proposal.md`, `.clinerules/workflows/openspec-apply.md`, and `.clinerules/workflows/openspec-archive.md`
-- **AND** populate each file from shared templates so command text matches other tools
-- **AND** include Cline-specific Markdown heading frontmatter
-- **AND** each template includes instructions for the relevant OpenSpec workflow stage
diff --git a/openspec/changes/make-validation-scope-aware/proposal.md b/openspec/changes/make-validation-scope-aware/proposal.md
deleted file mode 100644
index 391b703..0000000
--- a/openspec/changes/make-validation-scope-aware/proposal.md
+++ /dev/null
@@ -1,12 +0,0 @@
-## Why
-Validation currently errors on changes without spec deltas, even when the change is intentionally proposal-only or tooling-only. This creates false negatives and noisy CI.
-
-## What Changes
-- Make change validation scope-aware: validate only artifacts that exist.
-- Only error on "No deltas found" if spec delta files exist but parse to zero deltas.
-- Keep archive stricter: if specs exist but parse to zero deltas, fail; allow `--skip-specs` for tooling-only changes.
-
-## Impact
-- Affected specs: cli-validate
-- Affected code: `src/commands/validate.ts`, `src/core/validation/validator.ts`
-
diff --git a/openspec/changes/make-validation-scope-aware/specs/cli-validate/spec.md b/openspec/changes/make-validation-scope-aware/specs/cli-validate/spec.md
deleted file mode 100644
index cae28c9..0000000
--- a/openspec/changes/make-validation-scope-aware/specs/cli-validate/spec.md
+++ /dev/null
@@ -1,25 +0,0 @@
-## ADDED Requirements
-### Requirement: Scope-Aware Change Validation
-The validator SHALL validate only artifacts that exist for a change, avoiding errors for proposal-only or tooling-only changes.
-
-#### Scenario: Proposal-only change
-- **WHEN** a change contains `proposal.md` but has no `specs/` directory or contains no `*/spec.md` files
-- **THEN** validate the proposal (Why/What sections)
-- **AND** do not require or validate spec deltas
-
-#### Scenario: Delta validation when specs exist
-- **WHEN** a change contains one or more `specs/<capability>/spec.md` files
-- **THEN** validate delta-formatted specs with existing rules (SHALL/MUST, scenarios, duplicates, conflicts)
-
-## MODIFIED Requirements
-### Requirement: Validation SHALL provide actionable remediation steps
-Validation output SHALL include specific guidance to fix each error, including expected structure, example headers, and suggested commands to verify fixes.
-
-#### Scenario: No deltas found in change
-- **WHEN** validating a change that contains `specs/` with one or more `*/spec.md` files but the parser finds zero deltas
-- **THEN** show error "No deltas found" with guidance:
-  - Ensure `openspec/changes/{id}/specs/` has `.md` files that include delta headers
-  - Use delta headers: `## ADDED Requirements`, `## MODIFIED Requirements`, `## REMOVED Requirements`, `## RENAMED Requirements`
-  - Each requirement must include at least one `#### Scenario:` block
-  - Try: `openspec change show {id} --json --deltas-only` to inspect parsed deltas
-
diff --git a/openspec/changes/make-validation-scope-aware/tasks.md b/openspec/changes/make-validation-scope-aware/tasks.md
deleted file mode 100644
index 9ccf390..0000000
--- a/openspec/changes/make-validation-scope-aware/tasks.md
+++ /dev/null
@@ -1,16 +0,0 @@
-## 1. Validator changes
-- [ ] 1.1 Change `validateChangeDeltaSpecs` to only emit "Change must have at least one delta" when `specs/` exists and contains at least one `*/spec.md` but parsed total deltas is 0
-- [ ] 1.2 Return valid (no error) when `specs/` directory is missing or has no `spec.md` files
-
-## 2. CLI changes
-- [ ] 2.1 In bulk validation, keep current behavior (call delta validator). Behavior remains correct after 1.1
-- [ ] 2.2 Add a short INFO log in human-readable mode when a change has no `specs/` (optional)
-
-## 3. Documentation
-- [ ] 3.1 Update README and template: "Validation checks only existing artifacts. Proposal-only changes are valid without spec deltas."
-
-## 4. Tests
-- [ ] 4.1 Add test: proposal-only change passes validation without deltas
-- [ ] 4.2 Add test: specs present but zero parsed deltas â†’ ERROR
-- [ ] 4.3 Add test: specs present with proper deltas â†’ valid
-
diff --git a/openspec/specs/artifact-graph/spec.md b/openspec/specs/artifact-graph/spec.md
new file mode 100644
index 0000000..f122301
--- /dev/null
+++ b/openspec/specs/artifact-graph/spec.md
@@ -0,0 +1,130 @@
+# artifact-graph Specification
+
+## Purpose
+TBD - created by archiving change add-artifact-graph-core. Update Purpose after archive.
+## Requirements
+### Requirement: Schema Loading
+The system SHALL load artifact graph definitions from YAML schema files within schema directories.
+
+#### Scenario: Valid schema loaded
+- **WHEN** a schema directory contains a valid `schema.yaml` file
+- **THEN** the system returns an ArtifactGraph with all artifacts and dependencies
+
+#### Scenario: Invalid schema rejected
+- **WHEN** a schema YAML file is missing required fields
+- **THEN** the system throws an error with a descriptive message
+
+#### Scenario: Cyclic dependencies detected
+- **WHEN** a schema contains cyclic artifact dependencies
+- **THEN** the system throws an error listing the artifact IDs in the cycle
+
+#### Scenario: Invalid dependency reference
+- **WHEN** an artifact's `requires` array references a non-existent artifact ID
+- **THEN** the system throws an error identifying the invalid reference
+
+#### Scenario: Duplicate artifact IDs rejected
+- **WHEN** a schema contains multiple artifacts with the same ID
+- **THEN** the system throws an error identifying the duplicate
+
+#### Scenario: Schema directory not found
+- **WHEN** resolving a schema name that has no corresponding directory
+- **THEN** the system throws an error listing available schemas
+
+### Requirement: Build Order Calculation
+The system SHALL compute a valid topological build order for artifacts.
+
+#### Scenario: Linear dependency chain
+- **WHEN** artifacts form a linear chain (A â†’ B â†’ C)
+- **THEN** getBuildOrder() returns [A, B, C]
+
+#### Scenario: Diamond dependency
+- **WHEN** artifacts form a diamond (A â†’ B, A â†’ C, B â†’ D, C â†’ D)
+- **THEN** getBuildOrder() returns A before B and C, and D last
+
+#### Scenario: Independent artifacts
+- **WHEN** artifacts have no dependencies
+- **THEN** getBuildOrder() returns them in a stable order
+
+### Requirement: State Detection
+The system SHALL detect artifact completion state by scanning the filesystem.
+
+#### Scenario: Simple file exists
+- **WHEN** an artifact generates "proposal.md" and the file exists
+- **THEN** the artifact is marked as completed
+
+#### Scenario: Simple file missing
+- **WHEN** an artifact generates "proposal.md" and the file does not exist
+- **THEN** the artifact is not marked as completed
+
+#### Scenario: Glob pattern with files
+- **WHEN** an artifact generates "specs/*.md" and the specs/ directory contains .md files
+- **THEN** the artifact is marked as completed
+
+#### Scenario: Glob pattern empty
+- **WHEN** an artifact generates "specs/*.md" and the specs/ directory is empty or missing
+- **THEN** the artifact is not marked as completed
+
+#### Scenario: Missing change directory
+- **WHEN** the change directory does not exist
+- **THEN** all artifacts are marked as not completed (empty state)
+
+### Requirement: Ready Artifact Query
+The system SHALL identify which artifacts are ready to be created based on dependency completion.
+
+#### Scenario: Root artifacts ready initially
+- **WHEN** no artifacts are completed
+- **THEN** getNextArtifacts() returns artifacts with no dependencies
+
+#### Scenario: Dependent artifact becomes ready
+- **WHEN** an artifact's dependencies are all completed
+- **THEN** getNextArtifacts() includes that artifact
+
+#### Scenario: Blocked artifacts excluded
+- **WHEN** an artifact has uncompleted dependencies
+- **THEN** getNextArtifacts() does not include that artifact
+
+### Requirement: Completion Check
+The system SHALL determine when all artifacts in a graph are complete.
+
+#### Scenario: All complete
+- **WHEN** all artifacts in the graph are in the completed set
+- **THEN** isComplete() returns true
+
+#### Scenario: Partially complete
+- **WHEN** some artifacts in the graph are not completed
+- **THEN** isComplete() returns false
+
+### Requirement: Blocked Query
+The system SHALL identify which artifacts are blocked and return all their unmet dependencies.
+
+#### Scenario: Artifact blocked by single dependency
+- **WHEN** artifact B requires artifact A and A is not complete
+- **THEN** getBlocked() returns `{ B: ['A'] }`
+
+#### Scenario: Artifact blocked by multiple dependencies
+- **WHEN** artifact C requires A and B, and only A is complete
+- **THEN** getBlocked() returns `{ C: ['B'] }`
+
+#### Scenario: Artifact blocked by all dependencies
+- **WHEN** artifact C requires A and B, and neither is complete
+- **THEN** getBlocked() returns `{ C: ['A', 'B'] }`
+
+### Requirement: Schema Directory Structure
+The system SHALL support self-contained schema directories with co-located templates.
+
+#### Scenario: Schema with templates
+- **WHEN** a schema directory contains `schema.yaml` and `templates/` subdirectory
+- **THEN** artifacts can reference templates relative to the schema's templates directory
+
+#### Scenario: User schema override
+- **WHEN** a schema directory exists at `${XDG_DATA_HOME}/openspec/schemas/<name>/`
+- **THEN** the system uses that directory instead of the built-in
+
+#### Scenario: Built-in schema fallback
+- **WHEN** no user override exists for a schema
+- **THEN** the system uses the package built-in schema directory
+
+#### Scenario: List available schemas
+- **WHEN** listing schemas
+- **THEN** the system returns schema names from both user and package directories
+
diff --git a/openspec/specs/change-creation/spec.md b/openspec/specs/change-creation/spec.md
new file mode 100644
index 0000000..3e85719
--- /dev/null
+++ b/openspec/specs/change-creation/spec.md
@@ -0,0 +1,67 @@
+# change-creation Specification
+
+## Purpose
+Provide programmatic utilities for creating and validating OpenSpec change directories.
+## Requirements
+### Requirement: Change Creation
+The system SHALL provide a function to create new change directories programmatically.
+
+#### Scenario: Create change
+- **WHEN** `createChange(projectRoot, 'add-auth')` is called
+- **THEN** the system creates `openspec/changes/add-auth/` directory
+
+#### Scenario: Duplicate change rejected
+- **WHEN** `createChange(projectRoot, 'add-auth')` is called and `openspec/changes/add-auth/` already exists
+- **THEN** the system throws an error indicating the change already exists
+
+#### Scenario: Creates parent directories if needed
+- **WHEN** `createChange(projectRoot, 'add-auth')` is called and `openspec/changes/` does not exist
+- **THEN** the system creates the full path including parent directories
+
+#### Scenario: Invalid change name rejected
+- **WHEN** `createChange(projectRoot, 'Add Auth')` is called with an invalid name
+- **THEN** the system throws a validation error
+
+### Requirement: Change Name Validation
+The system SHALL validate change names follow kebab-case conventions.
+
+#### Scenario: Valid kebab-case name accepted
+- **WHEN** a change name like `add-user-auth` is validated
+- **THEN** validation returns `{ valid: true }`
+
+#### Scenario: Numeric suffixes accepted
+- **WHEN** a change name like `add-feature-2` is validated
+- **THEN** validation returns `{ valid: true }`
+
+#### Scenario: Single word accepted
+- **WHEN** a change name like `refactor` is validated
+- **THEN** validation returns `{ valid: true }`
+
+#### Scenario: Uppercase characters rejected
+- **WHEN** a change name like `Add-Auth` is validated
+- **THEN** validation returns `{ valid: false, error: "..." }`
+
+#### Scenario: Spaces rejected
+- **WHEN** a change name like `add auth` is validated
+- **THEN** validation returns `{ valid: false, error: "..." }`
+
+#### Scenario: Underscores rejected
+- **WHEN** a change name like `add_auth` is validated
+- **THEN** validation returns `{ valid: false, error: "..." }`
+
+#### Scenario: Special characters rejected
+- **WHEN** a change name like `add-auth!` is validated
+- **THEN** validation returns `{ valid: false, error: "..." }`
+
+#### Scenario: Leading hyphen rejected
+- **WHEN** a change name like `-add-auth` is validated
+- **THEN** validation returns `{ valid: false, error: "..." }`
+
+#### Scenario: Trailing hyphen rejected
+- **WHEN** a change name like `add-auth-` is validated
+- **THEN** validation returns `{ valid: false, error: "..." }`
+
+#### Scenario: Consecutive hyphens rejected
+- **WHEN** a change name like `add--auth` is validated
+- **THEN** validation returns `{ valid: false, error: "..." }`
+
diff --git a/openspec/specs/cli-artifact-workflow/spec.md b/openspec/specs/cli-artifact-workflow/spec.md
new file mode 100644
index 0000000..7ca8855
--- /dev/null
+++ b/openspec/specs/cli-artifact-workflow/spec.md
@@ -0,0 +1,222 @@
+# cli-artifact-workflow Specification
+
+## Purpose
+TBD - created by archiving change add-artifact-workflow-cli. Update Purpose after archive.
+## Requirements
+### Requirement: Status Command
+
+The system SHALL display artifact completion status for a change, including scaffolded (empty) changes.
+
+> **Fixes bug**: Previously required `proposal.md` to exist via `getActiveChangeIds()`.
+
+#### Scenario: Show status with all states
+
+- **WHEN** user runs `openspec status --change <id>`
+- **THEN** the system displays each artifact with status indicator:
+  - `[x]` for completed artifacts
+  - `[ ]` for ready artifacts
+  - `[-]` for blocked artifacts (with missing dependencies listed)
+
+#### Scenario: Status shows completion summary
+
+- **WHEN** user runs `openspec status --change <id>`
+- **THEN** output includes completion percentage and count (e.g., "2/4 artifacts complete")
+
+#### Scenario: Status JSON output
+
+- **WHEN** user runs `openspec status --change <id> --json`
+- **THEN** the system outputs JSON with changeName, schemaName, isComplete, and artifacts array
+
+#### Scenario: Status JSON includes apply requirements
+
+- **WHEN** user runs `openspec status --change <id> --json`
+- **THEN** the system outputs JSON with:
+  - `changeName`, `schemaName`, `isComplete`, `artifacts` array
+  - `applyRequires`: array of artifact IDs needed for apply phase
+
+#### Scenario: Status on scaffolded change
+
+- **WHEN** user runs `openspec status --change <id>` on a change with no artifacts
+- **THEN** system displays all artifacts with their status
+- **AND** root artifacts (no dependencies) show as ready `[ ]`
+- **AND** dependent artifacts show as blocked `[-]`
+
+#### Scenario: Missing change parameter
+
+- **WHEN** user runs `openspec status` without `--change`
+- **THEN** the system displays an error with list of available changes
+- **AND** includes scaffolded changes (directories without proposal.md)
+
+#### Scenario: Unknown change
+
+- **WHEN** user runs `openspec status --change unknown-id`
+- **AND** directory `openspec/changes/unknown-id/` does not exist
+- **THEN** the system displays an error listing all available change directories
+
+### Requirement: Instructions Command
+
+The system SHALL output enriched instructions for creating an artifact, including for scaffolded changes.
+
+#### Scenario: Show enriched instructions
+
+- **WHEN** user runs `openspec instructions <artifact> --change <id>`
+- **THEN** the system outputs:
+  - Artifact metadata (ID, output path, description)
+  - Template content
+  - Dependency status (done/missing)
+  - Unlocked artifacts (what becomes available after completion)
+
+#### Scenario: Instructions JSON output
+
+- **WHEN** user runs `openspec instructions <artifact> --change <id> --json`
+- **THEN** the system outputs JSON matching ArtifactInstructions interface
+
+#### Scenario: Unknown artifact
+
+- **WHEN** user runs `openspec instructions unknown-artifact --change <id>`
+- **THEN** the system displays an error listing valid artifact IDs for the schema
+
+#### Scenario: Artifact with unmet dependencies
+
+- **WHEN** user requests instructions for a blocked artifact
+- **THEN** the system displays instructions with a warning about missing dependencies
+
+#### Scenario: Instructions on scaffolded change
+
+- **WHEN** user runs `openspec instructions proposal --change <id>` on a scaffolded change
+- **THEN** system outputs template and metadata for creating the proposal
+- **AND** does not require any artifacts to already exist
+
+### Requirement: Templates Command
+The system SHALL show resolved template paths for all artifacts in a schema.
+
+#### Scenario: List template paths with default schema
+- **WHEN** user runs `openspec templates`
+- **THEN** the system displays each artifact with its resolved template path using the default schema
+
+#### Scenario: List template paths with custom schema
+- **WHEN** user runs `openspec templates --schema tdd`
+- **THEN** the system displays template paths for the specified schema
+
+#### Scenario: Templates JSON output
+- **WHEN** user runs `openspec templates --json`
+- **THEN** the system outputs JSON mapping artifact IDs to template paths
+
+#### Scenario: Template resolution source
+- **WHEN** displaying template paths
+- **THEN** the system indicates whether each template is from user override or package built-in
+
+### Requirement: New Change Command
+The system SHALL create new change directories with validation.
+
+#### Scenario: Create valid change
+- **WHEN** user runs `openspec new change add-feature`
+- **THEN** the system creates `openspec/changes/add-feature/` directory
+
+#### Scenario: Invalid change name
+- **WHEN** user runs `openspec new change "Add Feature"` with invalid name
+- **THEN** the system displays validation error with guidance
+
+#### Scenario: Duplicate change name
+- **WHEN** user runs `openspec new change existing-change` for an existing change
+- **THEN** the system displays an error indicating the change already exists
+
+#### Scenario: Create with description
+- **WHEN** user runs `openspec new change add-feature --description "Add new feature"`
+- **THEN** the system creates the change directory with description in README.md
+
+### Requirement: Schema Selection
+The system SHALL support custom schema selection for workflow commands.
+
+#### Scenario: Default schema
+- **WHEN** user runs workflow commands without `--schema`
+- **THEN** the system uses the "spec-driven" schema
+
+#### Scenario: Custom schema
+- **WHEN** user runs `openspec status --change <id> --schema tdd`
+- **THEN** the system uses the specified schema for artifact graph
+
+#### Scenario: Unknown schema
+- **WHEN** user specifies an unknown schema
+- **THEN** the system displays an error listing available schemas
+
+### Requirement: Output Formatting
+The system SHALL provide consistent output formatting.
+
+#### Scenario: Color output
+- **WHEN** terminal supports colors
+- **THEN** status indicators use colors: green (done), yellow (ready), red (blocked)
+
+#### Scenario: No color output
+- **WHEN** `--no-color` flag is used or NO_COLOR environment variable is set
+- **THEN** output uses text-only indicators without ANSI colors
+
+#### Scenario: Progress indication
+- **WHEN** loading change state takes time
+- **THEN** the system displays a spinner during loading
+
+### Requirement: Experimental Isolation
+The system SHALL implement artifact workflow commands in isolation for easy removal.
+
+#### Scenario: Single file implementation
+- **WHEN** artifact workflow feature is implemented
+- **THEN** all commands are in `src/commands/artifact-workflow.ts`
+
+#### Scenario: Help text marking
+- **WHEN** user runs `--help` on any artifact workflow command
+- **THEN** help text indicates the command is experimental
+
+### Requirement: Schema Apply Block
+
+The system SHALL support an `apply` block in schema definitions that controls when and how implementation begins.
+
+#### Scenario: Schema with apply block
+
+- **WHEN** a schema defines an `apply` block
+- **THEN** the system uses `apply.requires` to determine which artifacts must exist before apply
+- **AND** uses `apply.tracks` to identify the file for progress tracking (or null if none)
+- **AND** uses `apply.instruction` for guidance shown to the agent
+
+#### Scenario: Schema without apply block
+
+- **WHEN** a schema has no `apply` block
+- **THEN** the system requires all artifacts to exist before apply is available
+- **AND** uses default instruction: "All artifacts complete. Proceed with implementation."
+
+### Requirement: Apply Instructions Command
+
+The system SHALL generate schema-aware apply instructions via `openspec instructions apply`.
+
+#### Scenario: Generate apply instructions
+
+- **WHEN** user runs `openspec instructions apply --change <id>`
+- **AND** all required artifacts (per schema's `apply.requires`) exist
+- **THEN** the system outputs:
+  - Context files from all existing artifacts
+  - Schema-specific instruction text
+  - Progress tracking file path (if `apply.tracks` is set)
+
+#### Scenario: Apply blocked by missing artifacts
+
+- **WHEN** user runs `openspec instructions apply --change <id>`
+- **AND** required artifacts are missing
+- **THEN** the system indicates apply is blocked
+- **AND** lists which artifacts must be created first
+
+#### Scenario: Apply instructions JSON output
+
+- **WHEN** user runs `openspec instructions apply --change <id> --json`
+- **THEN** the system outputs JSON with:
+  - `contextFiles`: array of paths to existing artifacts
+  - `instruction`: the apply instruction text
+  - `tracks`: path to progress file or null
+  - `applyRequires`: list of required artifact IDs
+
+## REMOVED Requirements
+
+### Requirement: Next Command
+
+**Reason**: Redundant with Status Command - `openspec status` already shows which artifacts are ready (status: "ready") vs blocked vs done.
+
+**Migration**: Use `openspec status --change <id> --json` and filter artifacts with `status: "ready"` to find artifacts that can be created next.
+
diff --git a/openspec/specs/cli-init/spec.md b/openspec/specs/cli-init/spec.md
index 10866f3..e4f8500 100644
--- a/openspec/specs/cli-init/spec.md
+++ b/openspec/specs/cli-init/spec.md
@@ -172,6 +172,12 @@ The command SHALL use consistent exit codes to indicate different failure modes.
 ### Requirement: Slash Command Configuration
 The init command SHALL generate slash command files for supported editors using shared templates.
 
+#### Scenario: Generating slash commands for Antigravity
+- **WHEN** the user selects Antigravity during initialization
+- **THEN** create `.agent/workflows/openspec-proposal.md`, `.agent/workflows/openspec-apply.md`, and `.agent/workflows/openspec-archive.md`
+- **AND** ensure each file begins with YAML frontmatter that contains only a `description: <stage summary>` field followed by the shared OpenSpec workflow instructions wrapped in managed markers
+- **AND** populate the workflow body with the same proposal/apply/archive guidance used for other tools so Antigravity behaves like Windsurf while pointing to the `.agent/workflows/` directory
+
 #### Scenario: Generating slash commands for Claude Code
 - **WHEN** the user selects Claude Code during initialization
 - **THEN** create `.claude/commands/openspec/proposal.md`, `.claude/commands/openspec/apply.md`, and `.claude/commands/openspec/archive.md`
@@ -186,7 +192,7 @@ The init command SHALL generate slash command files for supported editors using
 
 #### Scenario: Generating slash commands for Cline
 - **WHEN** the user selects Cline during initialization
-- **THEN** create `.clinerules/openspec-proposal.md`, `.clinerules/openspec-apply.md`, and `.clinerules/openspec-archive.md`
+- **THEN** create `.clinerules/workflows/openspec-proposal.md`, `.clinerules/workflows/openspec-apply.md`, and `.clinerules/workflows/openspec-archive.md`
 - **AND** populate each file from shared templates so command text matches other tools
 - **AND** include Cline-specific Markdown heading frontmatter
 - **AND** each template includes instructions for the relevant OpenSpec workflow stage
diff --git a/openspec/specs/cli-update/spec.md b/openspec/specs/cli-update/spec.md
index d181d7d..bd104b8 100644
--- a/openspec/specs/cli-update/spec.md
+++ b/openspec/specs/cli-update/spec.md
@@ -52,6 +52,11 @@ The update command SHALL always update the core OpenSpec files and display an AS
 ### Requirement: Slash Command Updates
 The update command SHALL refresh existing slash command files for configured tools without creating new ones, and ensure the OpenCode archive command accepts change ID arguments.
 
+#### Scenario: Updating slash commands for Antigravity
+- **WHEN** `.agent/workflows/` contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
+- **THEN** refresh the OpenSpec-managed portion of each file so the workflow copy matches other tools while preserving the existing single-field `description` frontmatter
+- **AND** skip creating any missing workflow files during update, mirroring the behavior for Windsurf and other IDEs
+
 #### Scenario: Updating slash commands for Claude Code
 - **WHEN** `.claude/commands/openspec/` contains `proposal.md`, `apply.md`, and `archive.md`
 - **THEN** refresh each file using shared templates
@@ -63,7 +68,7 @@ The update command SHALL refresh existing slash command files for configured too
 - **AND** ensure templates include instructions for the relevant workflow stage
 
 #### Scenario: Updating slash commands for Cline
-- **WHEN** `.clinerules/` contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
+- **WHEN** `.clinerules/workflows/` contains `openspec-proposal.md`, `openspec-apply.md`, and `openspec-archive.md`
 - **THEN** refresh each file using shared templates
 - **AND** include Cline-specific Markdown heading frontmatter
 - **AND** ensure templates include instructions for the relevant workflow stage
diff --git a/openspec/specs/cli-view/spec.md b/openspec/specs/cli-view/spec.md
index b761b36..c77c4c7 100644
--- a/openspec/specs/cli-view/spec.md
+++ b/openspec/specs/cli-view/spec.md
@@ -20,12 +20,13 @@ The system SHALL provide a `view` command that displays a dashboard overview of
 
 ### Requirement: Summary Section
 
-The dashboard SHALL display a summary section with key project metrics.
+The dashboard SHALL display a summary section with key project metrics, including draft change count.
 
 #### Scenario: Complete summary display
 
 - **WHEN** dashboard is rendered with specs and changes
 - **THEN** system shows total number of specifications and requirements
+- **AND** shows number of draft changes
 - **AND** shows number of active changes in progress
 - **AND** shows number of completed changes
 - **AND** shows overall task progress percentage
@@ -46,11 +47,13 @@ The dashboard SHALL show active changes with visual progress indicators.
 
 ### Requirement: Completed Changes Display
 
-The dashboard SHALL list completed changes in a separate section.
+The dashboard SHALL list completed changes in a separate section, only showing changes with ALL tasks completed.
+
+> **Fixes bug**: Previously, changes with `total === 0` were incorrectly shown as completed.
 
 #### Scenario: Completed changes listing
 
-- **WHEN** there are completed changes (all tasks done)
+- **WHEN** there are changes with `tasks.total > 0` AND `tasks.completed === tasks.total`
 - **THEN** system shows them with checkmark indicators in a dedicated section
 
 #### Scenario: Mixed completion states
@@ -58,6 +61,12 @@ The dashboard SHALL list completed changes in a separate section.
 - **WHEN** some changes are complete and others active
 - **THEN** system separates them into appropriate sections
 
+#### Scenario: Empty changes not completed
+
+- **WHEN** a change has no tasks.md or zero tasks defined
+- **THEN** system does NOT show it in "Completed Changes" section
+- **AND** shows it in "Draft Changes" section instead
+
 ### Requirement: Specifications Display
 
 The dashboard SHALL display specifications sorted by requirement count.
@@ -103,3 +112,18 @@ The view command SHALL handle errors gracefully.
 - **WHEN** specs or changes have invalid format
 - **THEN** system skips invalid items and continues rendering
 
+### Requirement: Draft Changes Display
+
+The dashboard SHALL display changes without tasks in a separate "Draft" section.
+
+#### Scenario: Draft changes listing
+
+- **WHEN** there are changes with no tasks.md or zero tasks defined
+- **THEN** system shows them in a "Draft Changes" section
+- **AND** uses a distinct indicator (e.g., `â—‹`) to show draft status
+
+#### Scenario: Draft section ordering
+
+- **WHEN** multiple draft changes exist
+- **THEN** system sorts them alphabetically by name
+
diff --git a/openspec/specs/instruction-loader/spec.md b/openspec/specs/instruction-loader/spec.md
new file mode 100644
index 0000000..d2a473e
--- /dev/null
+++ b/openspec/specs/instruction-loader/spec.md
@@ -0,0 +1,70 @@
+# instruction-loader Specification
+
+## Purpose
+The instruction-loader loads instruction templates from schema directories, validates and enriches them with metadata and parameters (such as change context and dependency status), and exposes them for use by downstream services including template retrieval, parameter substitution, and enrichment.
+
+## Requirements
+### Requirement: Template Loading
+The system SHALL load templates from schema directories.
+
+#### Scenario: Load template from schema directory
+- **WHEN** `loadTemplate(schemaName, templatePath)` is called
+- **THEN** the system loads the template from `schemas/<schemaName>/templates/<templatePath>`
+
+#### Scenario: Template file not found
+- **WHEN** a template file does not exist in the schema's templates directory
+- **THEN** the system throws an error with the template path
+
+### Requirement: Change Context Loading
+The system SHALL load change context combining graph and completion state.
+
+#### Scenario: Load context for existing change
+- **WHEN** `loadChangeContext(projectRoot, changeName)` is called for an existing change
+- **THEN** the system returns a context with graph, completed set, schema name, and change info
+
+#### Scenario: Load context with custom schema
+- **WHEN** `loadChangeContext(projectRoot, changeName, schemaName)` is called
+- **THEN** the system uses the specified schema instead of default
+
+#### Scenario: Load context for non-existent change directory
+- **WHEN** `loadChangeContext` is called for a non-existent change directory
+- **THEN** the system returns context with empty completed set
+
+### Requirement: Template Enrichment
+The system SHALL enrich templates with change-specific context.
+
+#### Scenario: Include artifact metadata
+- **WHEN** instructions are generated for an artifact
+- **THEN** the output includes change name, artifact ID, schema name, and output path
+
+#### Scenario: Include dependency status
+- **WHEN** an artifact has dependencies
+- **THEN** the output shows each dependency with completion status (done/missing)
+
+#### Scenario: Include unlocked artifacts
+- **WHEN** instructions are generated
+- **THEN** the output includes which artifacts become available after this one
+
+#### Scenario: Root artifact indicator
+- **WHEN** an artifact has no dependencies
+- **THEN** the dependency section indicates this is a root artifact
+
+### Requirement: Status Formatting
+The system SHALL format change status as readable output.
+
+#### Scenario: All artifacts completed
+- **WHEN** all artifacts are completed
+- **THEN** status shows all artifacts as "done"
+
+#### Scenario: Mixed completion status
+- **WHEN** some artifacts are completed
+- **THEN** status shows completed as "done", ready as "ready", blocked as "blocked"
+
+#### Scenario: Blocked artifact details
+- **WHEN** an artifact is blocked
+- **THEN** status shows which dependencies are missing
+
+#### Scenario: Include output paths
+- **WHEN** status is formatted
+- **THEN** each artifact shows its output path pattern
+
diff --git a/openspec/specs/opsx-archive-skill/spec.md b/openspec/specs/opsx-archive-skill/spec.md
new file mode 100644
index 0000000..ccb4cee
--- /dev/null
+++ b/openspec/specs/opsx-archive-skill/spec.md
@@ -0,0 +1,122 @@
+# OPSX Archive Skill Spec
+
+### Requirement: OPSX Archive Skill
+
+The system SHALL provide an `/opsx:archive` skill that archives completed changes in the experimental workflow.
+
+#### Scenario: Archive a change with all artifacts complete
+
+- **WHEN** agent executes `/opsx:archive` with a change name
+- **AND** all artifacts in the schema are complete
+- **AND** all tasks are complete
+- **THEN** the agent moves the change to `openspec/changes/archive/YYYY-MM-DD-<name>/`
+- **AND** displays success message with archived location
+
+#### Scenario: Change selection prompt
+
+- **WHEN** agent executes `/opsx:archive` without specifying a change
+- **THEN** the agent prompts user to select from available changes
+- **AND** shows only active changes (excludes archive/)
+
+### Requirement: Artifact Completion Check
+
+The skill SHALL check artifact completion status using the artifact graph before archiving.
+
+#### Scenario: Incomplete artifacts warning
+
+- **WHEN** agent checks artifact status
+- **AND** one or more artifacts have status other than `done`
+- **THEN** display warning listing incomplete artifacts
+- **AND** prompt user for confirmation to continue
+- **AND** proceed if user confirms
+
+#### Scenario: All artifacts complete
+
+- **WHEN** agent checks artifact status
+- **AND** all artifacts have status `done`
+- **THEN** proceed without warning
+
+### Requirement: Task Completion Check
+
+The skill SHALL check task completion status from tasks.md before archiving.
+
+#### Scenario: Incomplete tasks found
+
+- **WHEN** agent reads tasks.md
+- **AND** incomplete tasks are found (marked with `- [ ]`)
+- **THEN** display warning showing count of incomplete tasks
+- **AND** prompt user for confirmation to continue
+- **AND** proceed if user confirms
+
+#### Scenario: All tasks complete
+
+- **WHEN** agent reads tasks.md
+- **AND** all tasks are complete (marked with `- [x]`)
+- **THEN** proceed without task-related warning
+
+#### Scenario: No tasks file
+
+- **WHEN** tasks.md does not exist
+- **THEN** proceed without task-related warning
+
+### Requirement: Spec Sync Prompt
+
+The skill SHALL prompt to sync delta specs before archiving if specs exist.
+
+#### Scenario: Delta specs exist
+
+- **WHEN** agent checks for delta specs
+- **AND** `specs/` directory exists in the change with spec files
+- **THEN** prompt user: "This change has delta specs. Would you like to sync them to main specs before archiving?"
+- **AND** if user confirms, execute `/opsx:sync` logic
+- **AND** proceed with archive regardless of sync choice
+
+#### Scenario: No delta specs
+
+- **WHEN** agent checks for delta specs
+- **AND** no `specs/` directory or no spec files exist
+- **THEN** proceed without sync prompt
+
+### Requirement: Archive Process
+
+The skill SHALL move the change to the archive folder with date prefix.
+
+#### Scenario: Successful archive
+
+- **WHEN** archiving a change
+- **THEN** create `archive/` directory if it doesn't exist
+- **AND** generate target name as `YYYY-MM-DD-<change-name>` using current date
+- **AND** move entire change directory to archive location
+- **AND** preserve `.openspec.yaml` file in archived change
+
+#### Scenario: Archive already exists
+
+- **WHEN** target archive directory already exists
+- **THEN** fail with error message
+- **AND** suggest renaming existing archive or using different date
+
+### Requirement: Skill Output
+
+The skill SHALL provide clear feedback about the archive operation.
+
+#### Scenario: Archive complete with sync
+
+- **WHEN** archive completes after syncing specs
+- **THEN** display summary:
+  - Specs synced (from `/opsx:sync` output)
+  - Change archived to location
+  - Schema that was used
+
+#### Scenario: Archive complete without sync
+
+- **WHEN** archive completes without syncing specs
+- **THEN** display summary:
+  - Note that specs were not synced (if applicable)
+  - Change archived to location
+  - Schema that was used
+
+#### Scenario: Archive complete with warnings
+
+- **WHEN** archive completes with incomplete artifacts or tasks
+- **THEN** include note about what was incomplete
+- **AND** suggest reviewing if archive was intentional
diff --git a/openspec/specs/specs-sync-skill/spec.md b/openspec/specs/specs-sync-skill/spec.md
new file mode 100644
index 0000000..780c6e1
--- /dev/null
+++ b/openspec/specs/specs-sync-skill/spec.md
@@ -0,0 +1,72 @@
+# specs-sync-skill Specification
+
+## Purpose
+Defines the agent skill for syncing delta specs from changes to main specs.
+
+## Requirements
+
+### Requirement: Specs Sync Skill
+The system SHALL provide an `/opsx:sync` skill that syncs delta specs from a change to the main specs.
+
+#### Scenario: Sync delta specs to main specs
+- **WHEN** agent executes `/opsx:sync` with a change name
+- **THEN** the agent reads delta specs from `openspec/changes/<name>/specs/`
+- **AND** reads corresponding main specs from `openspec/specs/`
+- **AND** reconciles main specs to match what the deltas describe
+
+#### Scenario: Idempotent operation
+- **WHEN** agent executes `/opsx:sync` multiple times on the same change
+- **THEN** the result is the same as running it once
+- **AND** no duplicate requirements are created
+
+#### Scenario: Change selection prompt
+- **WHEN** agent executes `/opsx:sync` without specifying a change
+- **THEN** the agent prompts user to select from available changes
+- **AND** shows changes that have delta specs
+
+### Requirement: Delta Reconciliation Logic
+The agent SHALL reconcile main specs with delta specs using the delta operation headers.
+
+#### Scenario: ADDED requirements
+- **WHEN** delta contains `## ADDED Requirements` with a requirement
+- **AND** the requirement does not exist in main spec
+- **THEN** add the requirement to main spec
+
+#### Scenario: ADDED requirement already exists
+- **WHEN** delta contains `## ADDED Requirements` with a requirement
+- **AND** a requirement with the same name already exists in main spec
+- **THEN** update the existing requirement to match the delta version
+
+#### Scenario: MODIFIED requirements
+- **WHEN** delta contains `## MODIFIED Requirements` with a requirement
+- **AND** the requirement exists in main spec
+- **THEN** replace the requirement in main spec with the delta version
+
+#### Scenario: REMOVED requirements
+- **WHEN** delta contains `## REMOVED Requirements` with a requirement name
+- **AND** the requirement exists in main spec
+- **THEN** remove the requirement from main spec
+
+#### Scenario: RENAMED requirements
+- **WHEN** delta contains `## RENAMED Requirements` with FROM:/TO: format
+- **AND** the FROM requirement exists in main spec
+- **THEN** rename the requirement to the TO name
+
+#### Scenario: New capability spec
+- **WHEN** delta spec exists for a capability not in main specs
+- **THEN** create new main spec file at `openspec/specs/<capability>/spec.md`
+
+### Requirement: Skill Output
+The skill SHALL provide clear feedback on what was applied.
+
+#### Scenario: Show applied changes
+- **WHEN** reconciliation completes successfully
+- **THEN** display summary of changes per capability:
+  - Number of requirements added
+  - Number of requirements modified
+  - Number of requirements removed
+  - Number of requirements renamed
+
+#### Scenario: No changes needed
+- **WHEN** main specs already match delta specs
+- **THEN** display "Specs already in sync - no changes needed"
diff --git a/package.json b/package.json
index 486873d..a7f366d 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "@fission-ai/openspec",
-  "version": "0.17.2",
+  "version": "0.18.0",
   "description": "AI-native system for spec-driven development",
   "keywords": [
     "openspec",
@@ -32,6 +32,7 @@
   "files": [
     "dist",
     "bin",
+    "schemas",
     "scripts/postinstall.js",
     "!dist/**/*.test.js",
     "!dist/**/__tests__",
@@ -73,7 +74,9 @@
     "@inquirer/prompts": "^7.8.0",
     "chalk": "^5.5.0",
     "commander": "^14.0.0",
+    "fast-glob": "^3.3.3",
     "ora": "^8.2.0",
+    "yaml": "^2.8.2",
     "zod": "^4.0.17"
   }
 }
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 6661eed..032d0d8 100644
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -20,9 +20,15 @@ importers:
       commander:
         specifier: ^14.0.0
         version: 14.0.0
+      fast-glob:
+        specifier: ^3.3.3
+        version: 3.3.3
       ora:
         specifier: ^8.2.0
         version: 8.2.0
+      yaml:
+        specifier: ^2.8.2
+        version: 2.8.2
       zod:
         specifier: ^4.0.17
         version: 4.0.17
@@ -47,7 +53,7 @@ importers:
         version: 8.50.1(eslint@9.39.2)(typescript@5.9.3)
       vitest:
         specifier: ^3.2.4
-        version: 3.2.4(@types/node@24.2.0)(@vitest/ui@3.2.4)
+        version: 3.2.4(@types/node@24.2.0)(@vitest/ui@3.2.4)(yaml@2.8.2)
 
 packages:
 
@@ -1576,6 +1582,11 @@ packages:
     resolution: {integrity: sha512-r6lPcBGxZXlIcymEu7InxDMhdW0KDxpLgoFLcguasxCaJ/SOIZwINatK9KY/tf+ZrlywOKU0UDj3ATXUBfxJXA==}
     engines: {node: '>=8'}
 
+  yaml@2.8.2:
+    resolution: {integrity: sha512-mplynKqc1C2hTVYxd0PU2xQAc22TI1vShAYGksCCfxbn/dFwnHTNi1bvYsBTkhdUNtGIf5xNOg938rrSSYvS9A==}
+    engines: {node: '>= 14.6'}
+    hasBin: true
+
   yocto-queue@0.1.0:
     resolution: {integrity: sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==}
     engines: {node: '>=10'}
@@ -2202,13 +2213,13 @@ snapshots:
       chai: 5.2.1
       tinyrainbow: 2.0.0
 
-  '@vitest/mocker@3.2.4(vite@7.0.6(@types/node@24.2.0))':
+  '@vitest/mocker@3.2.4(vite@7.0.6(@types/node@24.2.0)(yaml@2.8.2))':
     dependencies:
       '@vitest/spy': 3.2.4
       estree-walker: 3.0.3
       magic-string: 0.30.17
     optionalDependencies:
-      vite: 7.0.6(@types/node@24.2.0)
+      vite: 7.0.6(@types/node@24.2.0)(yaml@2.8.2)
 
   '@vitest/pretty-format@3.2.4':
     dependencies:
@@ -2239,7 +2250,7 @@ snapshots:
       sirv: 3.0.1
       tinyglobby: 0.2.14
       tinyrainbow: 2.0.0
-      vitest: 3.2.4(@types/node@24.2.0)(@vitest/ui@3.2.4)
+      vitest: 3.2.4(@types/node@24.2.0)(@vitest/ui@3.2.4)(yaml@2.8.2)
 
   '@vitest/utils@3.2.4':
     dependencies:
@@ -2987,13 +2998,13 @@ snapshots:
     dependencies:
       punycode: 2.3.1
 
-  vite-node@3.2.4(@types/node@24.2.0):
+  vite-node@3.2.4(@types/node@24.2.0)(yaml@2.8.2):
     dependencies:
       cac: 6.7.14
       debug: 4.4.1
       es-module-lexer: 1.7.0
       pathe: 2.0.3
-      vite: 7.0.6(@types/node@24.2.0)
+      vite: 7.0.6(@types/node@24.2.0)(yaml@2.8.2)
     transitivePeerDependencies:
       - '@types/node'
       - jiti
@@ -3008,7 +3019,7 @@ snapshots:
       - tsx
       - yaml
 
-  vite@7.0.6(@types/node@24.2.0):
+  vite@7.0.6(@types/node@24.2.0)(yaml@2.8.2):
     dependencies:
       esbuild: 0.25.8
       fdir: 6.4.6(picomatch@4.0.3)
@@ -3019,12 +3030,13 @@ snapshots:
     optionalDependencies:
       '@types/node': 24.2.0
       fsevents: 2.3.3
+      yaml: 2.8.2
 
-  vitest@3.2.4(@types/node@24.2.0)(@vitest/ui@3.2.4):
+  vitest@3.2.4(@types/node@24.2.0)(@vitest/ui@3.2.4)(yaml@2.8.2):
     dependencies:
       '@types/chai': 5.2.2
       '@vitest/expect': 3.2.4
-      '@vitest/mocker': 3.2.4(vite@7.0.6(@types/node@24.2.0))
+      '@vitest/mocker': 3.2.4(vite@7.0.6(@types/node@24.2.0)(yaml@2.8.2))
       '@vitest/pretty-format': 3.2.4
       '@vitest/runner': 3.2.4
       '@vitest/snapshot': 3.2.4
@@ -3042,8 +3054,8 @@ snapshots:
       tinyglobby: 0.2.14
       tinypool: 1.1.1
       tinyrainbow: 2.0.0
-      vite: 7.0.6(@types/node@24.2.0)
-      vite-node: 3.2.4(@types/node@24.2.0)
+      vite: 7.0.6(@types/node@24.2.0)(yaml@2.8.2)
+      vite-node: 3.2.4(@types/node@24.2.0)(yaml@2.8.2)
       why-is-node-running: 2.3.0
     optionalDependencies:
       '@types/node': 24.2.0
@@ -3079,6 +3091,8 @@ snapshots:
       string-width: 4.2.3
       strip-ansi: 6.0.1
 
+  yaml@2.8.2: {}
+
   yocto-queue@0.1.0: {}
 
   yoctocolors-cjs@2.1.2: {}
diff --git a/schemas/spec-driven/schema.yaml b/schemas/spec-driven/schema.yaml
new file mode 100644
index 0000000..d4a6813
--- /dev/null
+++ b/schemas/spec-driven/schema.yaml
@@ -0,0 +1,148 @@
+name: spec-driven
+version: 1
+description: Default OpenSpec workflow - proposal â†’ specs â†’ design â†’ tasks
+artifacts:
+  - id: proposal
+    generates: proposal.md
+    description: Initial proposal document outlining the change
+    template: proposal.md
+    instruction: |
+      Create the proposal document that establishes WHY this change is needed.
+
+      Sections:
+      - **Why**: 1-2 sentences on the problem or opportunity. What problem does this solve? Why now?
+      - **What Changes**: Bullet list of changes. Be specific about new capabilities, modifications, or removals. Mark breaking changes with **BREAKING**.
+      - **Capabilities**: Identify which specs will be created or modified:
+        - **New Capabilities**: List capabilities being introduced. Each becomes a new `specs/<name>/spec.md`. Use kebab-case names (e.g., `user-auth`, `data-export`).
+        - **Modified Capabilities**: List existing capabilities whose REQUIREMENTS are changing. Only include if spec-level behavior changes (not just implementation details). Each needs a delta spec file. Check `openspec/specs/` for existing spec names. Leave empty if no requirement changes.
+      - **Impact**: Affected code, APIs, dependencies, or systems.
+
+      IMPORTANT: The Capabilities section is critical. It creates the contract between
+      proposal and specs phases. Research existing specs before filling this in.
+      Each capability listed here will need a corresponding spec file.
+
+      Keep it concise (1-2 pages). Focus on the "why" not the "how" -
+      implementation details belong in design.md.
+
+      This is the foundation - specs, design, and tasks all build on this.
+    requires: []
+
+  - id: specs
+    generates: "specs/**/*.md"
+    description: Detailed specifications for the change
+    template: spec.md
+    instruction: |
+      Create specification files that define WHAT the system should do.
+
+      Create one spec file per capability/feature area in specs/<name>/spec.md.
+
+      Delta operations (use ## headers):
+      - **ADDED Requirements**: New capabilities
+      - **MODIFIED Requirements**: Changed behavior - MUST include full updated content
+      - **REMOVED Requirements**: Deprecated features - MUST include **Reason** and **Migration**
+      - **RENAMED Requirements**: Name changes only - use FROM:/TO: format
+
+      Format requirements:
+      - Each requirement: `### Requirement: <name>` followed by description
+      - Use SHALL/MUST for normative requirements (avoid should/may)
+      - Each scenario: `#### Scenario: <name>` with WHEN/THEN format
+      - **CRITICAL**: Scenarios MUST use exactly 4 hashtags (`####`). Using 3 hashtags or bullets will fail silently.
+      - Every requirement MUST have at least one scenario.
+
+      MODIFIED requirements workflow:
+      1. Locate the existing requirement in openspec/specs/<capability>/spec.md
+      2. Copy the ENTIRE requirement block (from `### Requirement:` through all scenarios)
+      3. Paste under `## MODIFIED Requirements` and edit to reflect new behavior
+      4. Ensure header text matches exactly (whitespace-insensitive)
+
+      Common pitfall: Using MODIFIED with partial content loses detail at archive time.
+      If adding new concerns without changing existing behavior, use ADDED instead.
+
+      Example:
+      ```
+      ## ADDED Requirements
+
+      ### Requirement: User can export data
+      The system SHALL allow users to export their data in CSV format.
+
+      #### Scenario: Successful export
+      - **WHEN** user clicks "Export" button
+      - **THEN** system downloads a CSV file with all user data
+
+      ## REMOVED Requirements
+
+      ### Requirement: Legacy export
+      **Reason**: Replaced by new export system
+      **Migration**: Use new export endpoint at /api/v2/export
+      ```
+
+      Specs should be testable - each scenario is a potential test case.
+    requires:
+      - proposal
+
+  - id: design
+    generates: design.md
+    description: Technical design document with implementation details
+    template: design.md
+    instruction: |
+      Create the design document that explains HOW to implement the change.
+
+      When to include design.md (create only if any apply):
+      - Cross-cutting change (multiple services/modules) or new architectural pattern
+      - New external dependency or significant data model changes
+      - Security, performance, or migration complexity
+      - Ambiguity that benefits from technical decisions before coding
+
+      Sections:
+      - **Context**: Background, current state, constraints, stakeholders
+      - **Goals / Non-Goals**: What this design achieves and explicitly excludes
+      - **Decisions**: Key technical choices with rationale (why X over Y?). Include alternatives considered for each decision.
+      - **Risks / Trade-offs**: Known limitations, things that could go wrong. Format: [Risk] â†’ Mitigation
+      - **Migration Plan**: Steps to deploy, rollback strategy (if applicable)
+      - **Open Questions**: Outstanding decisions or unknowns to resolve
+
+      Focus on architecture and approach, not line-by-line implementation.
+      Reference the proposal for motivation and specs for requirements.
+
+      Good design docs explain the "why" behind technical decisions.
+    requires:
+      - proposal
+
+  - id: tasks
+    generates: tasks.md
+    description: Implementation tasks derived from specs and design
+    template: tasks.md
+    instruction: |
+      Create the task list that breaks down the implementation work.
+
+      Guidelines:
+      - Group related tasks under ## numbered headings
+      - Each task is a checkbox: - [ ] X.Y Task description
+      - Tasks should be small enough to complete in one session
+      - Order tasks by dependency (what must be done first?)
+
+      Example:
+      ```
+      ## 1. Setup
+
+      - [ ] 1.1 Create new module structure
+      - [ ] 1.2 Add dependencies to package.json
+
+      ## 2. Core Implementation
+
+      - [ ] 2.1 Implement data export function
+      - [ ] 2.2 Add CSV formatting utilities
+      ```
+
+      Reference specs for what needs to be built, design for how to build it.
+      Each task should be verifiable - you know when it's done.
+    requires:
+      - specs
+      - design
+
+apply:
+  requires: [tasks]
+  tracks: tasks.md
+  instruction: |
+    Read context files, work through pending tasks, mark complete as you go.
+    Pause if you hit blockers or need clarification.
diff --git a/schemas/spec-driven/templates/design.md b/schemas/spec-driven/templates/design.md
new file mode 100644
index 0000000..4ab5bd8
--- /dev/null
+++ b/schemas/spec-driven/templates/design.md
@@ -0,0 +1,19 @@
+## Context
+
+<!-- Background and current state -->
+
+## Goals / Non-Goals
+
+**Goals:**
+<!-- What this design aims to achieve -->
+
+**Non-Goals:**
+<!-- What is explicitly out of scope -->
+
+## Decisions
+
+<!-- Key design decisions and rationale -->
+
+## Risks / Trade-offs
+
+<!-- Known risks and trade-offs -->
diff --git a/schemas/spec-driven/templates/proposal.md b/schemas/spec-driven/templates/proposal.md
new file mode 100644
index 0000000..c79b85d
--- /dev/null
+++ b/schemas/spec-driven/templates/proposal.md
@@ -0,0 +1,23 @@
+## Why
+
+<!-- Explain the motivation for this change. What problem does this solve? Why now? -->
+
+## What Changes
+
+<!-- Describe what will change. Be specific about new capabilities, modifications, or removals. -->
+
+## Capabilities
+
+### New Capabilities
+<!-- Capabilities being introduced. Replace <name> with kebab-case identifier (e.g., user-auth, data-export, api-rate-limiting). Each creates specs/<name>/spec.md -->
+- `<name>`: <brief description of what this capability covers>
+
+### Modified Capabilities
+<!-- Existing capabilities whose REQUIREMENTS are changing (not just implementation).
+     Only list here if spec-level behavior changes. Each needs a delta spec file.
+     Use existing spec names from openspec/specs/. Leave empty if no requirement changes. -->
+- `<existing-name>`: <what requirement is changing>
+
+## Impact
+
+<!-- Affected code, APIs, dependencies, systems -->
diff --git a/schemas/spec-driven/templates/spec.md b/schemas/spec-driven/templates/spec.md
new file mode 100644
index 0000000..095d711
--- /dev/null
+++ b/schemas/spec-driven/templates/spec.md
@@ -0,0 +1,8 @@
+## ADDED Requirements
+
+### Requirement: <!-- requirement name -->
+<!-- requirement text -->
+
+#### Scenario: <!-- scenario name -->
+- **WHEN** <!-- condition -->
+- **THEN** <!-- expected outcome -->
diff --git a/schemas/spec-driven/templates/tasks.md b/schemas/spec-driven/templates/tasks.md
new file mode 100644
index 0000000..88ce51e
--- /dev/null
+++ b/schemas/spec-driven/templates/tasks.md
@@ -0,0 +1,9 @@
+## 1. <!-- Task Group Name -->
+
+- [ ] 1.1 <!-- Task description -->
+- [ ] 1.2 <!-- Task description -->
+
+## 2. <!-- Task Group Name -->
+
+- [ ] 2.1 <!-- Task description -->
+- [ ] 2.2 <!-- Task description -->
diff --git a/schemas/tdd/schema.yaml b/schemas/tdd/schema.yaml
new file mode 100644
index 0000000..dd9b21d
--- /dev/null
+++ b/schemas/tdd/schema.yaml
@@ -0,0 +1,213 @@
+name: tdd
+version: 1
+description: Test-driven development workflow - tests â†’ implementation â†’ docs
+artifacts:
+  - id: spec
+    generates: spec.md
+    description: Feature specification defining requirements
+    template: spec.md
+    instruction: |
+      Create the feature specification that defines WHAT to build.
+
+      Sections:
+      - **Feature**: Name and high-level description of the feature's purpose and user value
+      - **Requirements**: List of specific requirements. Use SHALL/MUST for normative language.
+      - **Acceptance Criteria**: Testable criteria in WHEN/THEN format
+
+      Format requirements:
+      - Each requirement should be specific and testable
+      - Use `#### Scenario: <name>` with WHEN/THEN format for acceptance criteria
+      - Define edge cases and error scenarios explicitly
+      - Every requirement MUST have at least one scenario
+
+      Example:
+      ```
+      ## Feature: User Authentication
+
+      Users can securely log into the application.
+
+      ## Requirements
+
+      ### Requirement: Password validation
+      The system SHALL validate passwords meet minimum security requirements.
+
+      #### Scenario: Valid password accepted
+      - **WHEN** password has 8+ chars, uppercase, lowercase, and number
+      - **THEN** password is accepted
+
+      #### Scenario: Weak password rejected
+      - **WHEN** password is less than 8 characters
+      - **THEN** system displays "Password too short" error
+      ```
+
+      This spec drives test creation - each scenario becomes a test case.
+    requires: []
+
+  - id: tests
+    generates: "tests/*.test.ts"
+    description: Test files written before implementation
+    template: test.md
+    instruction: |
+      Write tests BEFORE implementation (TDD red phase).
+
+      File naming:
+      - Create test files as `tests/<feature>.test.ts`
+      - One test file per feature/capability
+      - Use descriptive names matching the spec
+
+      Test structure:
+      - Use Given/When/Then format matching spec scenarios
+      - Group related tests with `describe()` blocks
+      - Each scenario from spec becomes at least one `it()` test
+
+      Coverage requirements:
+      - Cover each requirement from the spec
+      - Include happy path (success cases)
+      - Include edge cases (boundary conditions)
+      - Include error scenarios (invalid input, failures)
+      - Tests should fail initially (no implementation yet)
+
+      Example:
+      ```typescript
+      describe('Password validation', () => {
+        it('accepts valid password with all requirements', () => {
+          // GIVEN a password meeting all requirements
+          const password = 'SecurePass1';
+          // WHEN validating
+          const result = validatePassword(password);
+          // THEN it should be accepted
+          expect(result.valid).toBe(true);
+        });
+
+        it('rejects password shorter than 8 characters', () => {
+          // GIVEN a short password
+          const password = 'Short1';
+          // WHEN validating
+          const result = validatePassword(password);
+          // THEN it should be rejected with message
+          expect(result.valid).toBe(false);
+          expect(result.error).toBe('Password too short');
+        });
+      });
+      ```
+
+      Follow the spec requirements exactly - tests verify the spec.
+    requires:
+      - spec
+
+  - id: implementation
+    generates: "src/*.ts"
+    description: Implementation code to pass the tests
+    template: implementation.md
+    instruction: |
+      Implement the feature to make tests pass (TDD green phase).
+
+      TDD workflow:
+      1. Run tests - confirm they fail (red)
+      2. Write minimal code to pass ONE test
+      3. Run tests - confirm that test passes (green)
+      4. Refactor if needed while keeping tests green
+      5. Repeat for next failing test
+
+      Implementation guidelines:
+      - Write minimal code to pass each test - no more, no less
+      - Run tests frequently to verify progress
+      - Keep functions small and focused
+      - Use clear, descriptive names
+
+      Code organization:
+      - Create source files in `src/<feature>.ts`
+      - Export public API clearly
+      - Keep implementation details private
+      - Add JSDoc comments for public functions
+
+      Example structure:
+      ```typescript
+      /**
+       * Validates a password meets security requirements.
+       * @param password - The password to validate
+       * @returns Validation result with valid flag and optional error
+       */
+      export function validatePassword(password: string): ValidationResult {
+        if (password.length < 8) {
+          return { valid: false, error: 'Password too short' };
+        }
+        // ... additional checks
+        return { valid: true };
+      }
+      ```
+
+      Don't over-engineer - implement only what tests require.
+    requires:
+      - tests
+
+  - id: docs
+    generates: "docs/*.md"
+    description: Documentation for the implemented feature
+    template: docs.md
+    instruction: |
+      Document the implemented feature.
+
+      Sections:
+      - **Overview**: What the feature does and why it exists (1-2 paragraphs)
+      - **Getting Started**: Quick start guide to use the feature immediately
+      - **Examples**: Code examples showing common use cases
+      - **Reference**: Detailed API documentation, configuration options
+
+      Guidelines:
+      - Write for the user, not the developer
+      - Start with the most common use case
+      - Include copy-pasteable code examples
+      - Document all configuration options with defaults
+      - Note any limitations, edge cases, or gotchas
+      - Link to related features or specs
+
+      Example structure:
+      ```markdown
+      ## Overview
+
+      Password validation ensures user passwords meet security requirements
+      before account creation or password changes.
+
+      ## Getting Started
+
+      Import and use the validation function:
+
+      ```typescript
+      import { validatePassword } from './password';
+
+      const result = validatePassword('MySecurePass1');
+      if (!result.valid) {
+        console.error(result.error);
+      }
+      ```
+
+      ## Examples
+
+      ### Basic validation
+      ...
+
+      ### Custom error handling
+      ...
+
+      ## Reference
+
+      ### validatePassword(password)
+
+      | Parameter | Type | Description |
+      |-----------|------|-------------|
+      | password | string | The password to validate |
+
+      **Returns**: `{ valid: boolean, error?: string }`
+      ```
+
+      Reference the spec for requirements, implementation for details.
+    requires:
+      - implementation
+
+apply:
+  requires: [tests]
+  tracks: null
+  instruction: |
+    Run tests to see failures. Implement minimal code to pass each test.
+    Refactor while keeping tests green.
diff --git a/schemas/tdd/templates/docs.md b/schemas/tdd/templates/docs.md
new file mode 100644
index 0000000..fae40a6
--- /dev/null
+++ b/schemas/tdd/templates/docs.md
@@ -0,0 +1,15 @@
+## Overview
+
+<!-- Feature overview -->
+
+## Getting Started
+
+<!-- Quick start guide -->
+
+## Examples
+
+<!-- Code examples -->
+
+## Reference
+
+<!-- API reference or additional details -->
diff --git a/schemas/tdd/templates/implementation.md b/schemas/tdd/templates/implementation.md
new file mode 100644
index 0000000..fac9db9
--- /dev/null
+++ b/schemas/tdd/templates/implementation.md
@@ -0,0 +1,11 @@
+## Implementation Notes
+
+<!-- Technical implementation details -->
+
+## API
+
+<!-- Public API documentation -->
+
+## Usage
+
+<!-- Usage examples -->
diff --git a/schemas/tdd/templates/spec.md b/schemas/tdd/templates/spec.md
new file mode 100644
index 0000000..232e783
--- /dev/null
+++ b/schemas/tdd/templates/spec.md
@@ -0,0 +1,11 @@
+## Feature: <!-- feature name -->
+
+<!-- Feature description -->
+
+## Requirements
+
+<!-- List of requirements -->
+
+## Acceptance Criteria
+
+<!-- List of acceptance criteria -->
diff --git a/schemas/tdd/templates/test.md b/schemas/tdd/templates/test.md
new file mode 100644
index 0000000..cfa1a11
--- /dev/null
+++ b/schemas/tdd/templates/test.md
@@ -0,0 +1,11 @@
+## Test Plan
+
+<!-- Describe the testing strategy -->
+
+## Test Cases
+
+### <!-- Test case name -->
+
+- **Given:** <!-- preconditions -->
+- **When:** <!-- action -->
+- **Then:** <!-- expected result -->
diff --git a/src/cli/index.ts b/src/cli/index.ts
index e8cb2f5..6dd2ac2 100644
--- a/src/cli/index.ts
+++ b/src/cli/index.ts
@@ -14,6 +14,7 @@ import { ValidateCommand } from '../commands/validate.js';
 import { ShowCommand } from '../commands/show.js';
 import { CompletionCommand } from '../commands/completion.js';
 import { registerConfigCommand } from '../commands/config.js';
+import { registerArtifactWorkflowCommands } from '../commands/artifact-workflow.js';
 
 const program = new Command();
 const require = createRequire(import.meta.url);
@@ -95,11 +96,14 @@ program
   .description('List items (changes by default). Use --specs to list specs.')
   .option('--specs', 'List specs instead of changes')
   .option('--changes', 'List changes explicitly (default)')
-  .action(async (options?: { specs?: boolean; changes?: boolean }) => {
+  .option('--sort <order>', 'Sort order: "recent" (default) or "name"', 'recent')
+  .option('--json', 'Output as JSON (for programmatic use)')
+  .action(async (options?: { specs?: boolean; changes?: boolean; sort?: string; json?: boolean }) => {
     try {
       const listCommand = new ListCommand();
       const mode: 'changes' | 'specs' = options?.specs ? 'specs' : 'changes';
-      await listCommand.execute('.', mode);
+      const sort = options?.sort === 'name' ? 'name' : 'recent';
+      await listCommand.execute('.', mode, { sort, json: options?.json });
     } catch (error) {
       console.log(); // Empty line for spacing
       ora().fail(`Error: ${(error as Error).message}`);
@@ -316,4 +320,7 @@ program
     }
   });
 
+// Register artifact workflow commands (experimental)
+registerArtifactWorkflowCommands(program);
+
 program.parse();
diff --git a/src/commands/artifact-workflow.ts b/src/commands/artifact-workflow.ts
new file mode 100644
index 0000000..d979136
--- /dev/null
+++ b/src/commands/artifact-workflow.ts
@@ -0,0 +1,1055 @@
+/**
+ * Artifact Workflow CLI Commands (Experimental)
+ *
+ * This file contains all artifact workflow commands in isolation for easy removal.
+ * Commands expose the ArtifactGraph and InstructionLoader APIs to users and agents.
+ *
+ * To remove this feature:
+ * 1. Delete this file
+ * 2. Remove the registerArtifactWorkflowCommands() call from src/cli/index.ts
+ */
+
+import type { Command } from 'commander';
+import ora from 'ora';
+import chalk from 'chalk';
+import path from 'path';
+import * as fs from 'fs';
+import {
+  loadChangeContext,
+  formatChangeStatus,
+  generateInstructions,
+  listSchemas,
+  listSchemasWithInfo,
+  getSchemaDir,
+  resolveSchema,
+  ArtifactGraph,
+  type ChangeStatus,
+  type ArtifactInstructions,
+  type SchemaInfo,
+} from '../core/artifact-graph/index.js';
+import { createChange, validateChangeName } from '../utils/change-utils.js';
+import { getNewChangeSkillTemplate, getContinueChangeSkillTemplate, getApplyChangeSkillTemplate, getFfChangeSkillTemplate, getSyncSpecsSkillTemplate, getArchiveChangeSkillTemplate, getOpsxNewCommandTemplate, getOpsxContinueCommandTemplate, getOpsxApplyCommandTemplate, getOpsxFfCommandTemplate, getOpsxSyncCommandTemplate, getOpsxArchiveCommandTemplate } from '../core/templates/skill-templates.js';
+import { FileSystemUtils } from '../utils/file-system.js';
+
+// -----------------------------------------------------------------------------
+// Types for Apply Instructions
+// -----------------------------------------------------------------------------
+
+interface TaskItem {
+  id: string;
+  description: string;
+  done: boolean;
+}
+
+interface ApplyInstructions {
+  changeName: string;
+  changeDir: string;
+  schemaName: string;
+  contextFiles: Record<string, string>;
+  progress: {
+    total: number;
+    complete: number;
+    remaining: number;
+  };
+  tasks: TaskItem[];
+  state: 'blocked' | 'all_done' | 'ready';
+  missingArtifacts?: string[];
+  instruction: string;
+}
+
+const DEFAULT_SCHEMA = 'spec-driven';
+
+/**
+ * Checks if color output is disabled via NO_COLOR env or --no-color flag.
+ */
+function isColorDisabled(): boolean {
+  return process.env.NO_COLOR === '1' || process.env.NO_COLOR === 'true';
+}
+
+/**
+ * Gets the color function based on status.
+ */
+function getStatusColor(status: 'done' | 'ready' | 'blocked'): (text: string) => string {
+  if (isColorDisabled()) {
+    return (text: string) => text;
+  }
+  switch (status) {
+    case 'done':
+      return chalk.green;
+    case 'ready':
+      return chalk.yellow;
+    case 'blocked':
+      return chalk.red;
+  }
+}
+
+/**
+ * Gets the status indicator for an artifact.
+ */
+function getStatusIndicator(status: 'done' | 'ready' | 'blocked'): string {
+  const color = getStatusColor(status);
+  switch (status) {
+    case 'done':
+      return color('[x]');
+    case 'ready':
+      return color('[ ]');
+    case 'blocked':
+      return color('[-]');
+  }
+}
+
+/**
+ * Validates that a change exists and returns available changes if not.
+ * Checks directory existence directly to support scaffolded changes (without proposal.md).
+ */
+async function validateChangeExists(
+  changeName: string | undefined,
+  projectRoot: string
+): Promise<string> {
+  const changesPath = path.join(projectRoot, 'openspec', 'changes');
+
+  // Get all change directories (not just those with proposal.md)
+  const getAvailableChanges = async (): Promise<string[]> => {
+    try {
+      const entries = await fs.promises.readdir(changesPath, { withFileTypes: true });
+      return entries
+        .filter((e) => e.isDirectory() && e.name !== 'archive' && !e.name.startsWith('.'))
+        .map((e) => e.name);
+    } catch {
+      return [];
+    }
+  };
+
+  if (!changeName) {
+    const available = await getAvailableChanges();
+    if (available.length === 0) {
+      throw new Error('No changes found. Create one with: openspec new change <name>');
+    }
+    throw new Error(
+      `Missing required option --change. Available changes:\n  ${available.join('\n  ')}`
+    );
+  }
+
+  // Validate change name format to prevent path traversal
+  const nameValidation = validateChangeName(changeName);
+  if (!nameValidation.valid) {
+    throw new Error(`Invalid change name '${changeName}': ${nameValidation.error}`);
+  }
+
+  // Check directory existence directly
+  const changePath = path.join(changesPath, changeName);
+  const exists = fs.existsSync(changePath) && fs.statSync(changePath).isDirectory();
+
+  if (!exists) {
+    const available = await getAvailableChanges();
+    if (available.length === 0) {
+      throw new Error(
+        `Change '${changeName}' not found. No changes exist. Create one with: openspec new change <name>`
+      );
+    }
+    throw new Error(
+      `Change '${changeName}' not found. Available changes:\n  ${available.join('\n  ')}`
+    );
+  }
+
+  return changeName;
+}
+
+/**
+ * Validates that a schema exists and returns available schemas if not.
+ */
+function validateSchemaExists(schemaName: string): string {
+  const schemaDir = getSchemaDir(schemaName);
+  if (!schemaDir) {
+    const availableSchemas = listSchemas();
+    throw new Error(
+      `Schema '${schemaName}' not found. Available schemas:\n  ${availableSchemas.join('\n  ')}`
+    );
+  }
+  return schemaName;
+}
+
+// -----------------------------------------------------------------------------
+// Status Command
+// -----------------------------------------------------------------------------
+
+interface StatusOptions {
+  change?: string;
+  schema?: string;
+  json?: boolean;
+}
+
+async function statusCommand(options: StatusOptions): Promise<void> {
+  const spinner = ora('Loading change status...').start();
+
+  try {
+    const projectRoot = process.cwd();
+    const changeName = await validateChangeExists(options.change, projectRoot);
+
+    // Validate schema if explicitly provided
+    if (options.schema) {
+      validateSchemaExists(options.schema);
+    }
+
+    // loadChangeContext will auto-detect schema from metadata if not provided
+    const context = loadChangeContext(projectRoot, changeName, options.schema);
+    const status = formatChangeStatus(context);
+
+    spinner.stop();
+
+    if (options.json) {
+      console.log(JSON.stringify(status, null, 2));
+      return;
+    }
+
+    printStatusText(status);
+  } catch (error) {
+    spinner.stop();
+    throw error;
+  }
+}
+
+function printStatusText(status: ChangeStatus): void {
+  const doneCount = status.artifacts.filter((a) => a.status === 'done').length;
+  const total = status.artifacts.length;
+
+  console.log(`Change: ${status.changeName}`);
+  console.log(`Schema: ${status.schemaName}`);
+  console.log(`Progress: ${doneCount}/${total} artifacts complete`);
+  console.log();
+
+  for (const artifact of status.artifacts) {
+    const indicator = getStatusIndicator(artifact.status);
+    const color = getStatusColor(artifact.status);
+    let line = `${indicator} ${artifact.id}`;
+
+    if (artifact.status === 'blocked' && artifact.missingDeps && artifact.missingDeps.length > 0) {
+      line += color(` (blocked by: ${artifact.missingDeps.join(', ')})`);
+    }
+
+    console.log(line);
+  }
+
+  if (status.isComplete) {
+    console.log();
+    console.log(chalk.green('All artifacts complete!'));
+  }
+}
+
+// -----------------------------------------------------------------------------
+// Instructions Command
+// -----------------------------------------------------------------------------
+
+interface InstructionsOptions {
+  change?: string;
+  schema?: string;
+  json?: boolean;
+}
+
+async function instructionsCommand(
+  artifactId: string | undefined,
+  options: InstructionsOptions
+): Promise<void> {
+  const spinner = ora('Generating instructions...').start();
+
+  try {
+    const projectRoot = process.cwd();
+    const changeName = await validateChangeExists(options.change, projectRoot);
+
+    // Validate schema if explicitly provided
+    if (options.schema) {
+      validateSchemaExists(options.schema);
+    }
+
+    // loadChangeContext will auto-detect schema from metadata if not provided
+    const context = loadChangeContext(projectRoot, changeName, options.schema);
+
+    if (!artifactId) {
+      spinner.stop();
+      const validIds = context.graph.getAllArtifacts().map((a) => a.id);
+      throw new Error(
+        `Missing required argument <artifact>. Valid artifacts:\n  ${validIds.join('\n  ')}`
+      );
+    }
+
+    const artifact = context.graph.getArtifact(artifactId);
+
+    if (!artifact) {
+      spinner.stop();
+      const validIds = context.graph.getAllArtifacts().map((a) => a.id);
+      throw new Error(
+        `Artifact '${artifactId}' not found in schema '${context.schemaName}'. Valid artifacts:\n  ${validIds.join('\n  ')}`
+      );
+    }
+
+    const instructions = generateInstructions(context, artifactId);
+    const isBlocked = instructions.dependencies.some((d) => !d.done);
+
+    spinner.stop();
+
+    if (options.json) {
+      console.log(JSON.stringify(instructions, null, 2));
+      return;
+    }
+
+    printInstructionsText(instructions, isBlocked);
+  } catch (error) {
+    spinner.stop();
+    throw error;
+  }
+}
+
+function printInstructionsText(instructions: ArtifactInstructions, isBlocked: boolean): void {
+  const {
+    artifactId,
+    changeName,
+    schemaName,
+    changeDir,
+    outputPath,
+    description,
+    instruction,
+    template,
+    dependencies,
+    unlocks,
+  } = instructions;
+
+  // Opening tag
+  console.log(`<artifact id="${artifactId}" change="${changeName}" schema="${schemaName}">`);
+  console.log();
+
+  // Warning for blocked artifacts
+  if (isBlocked) {
+    const missing = dependencies.filter((d) => !d.done).map((d) => d.id);
+    console.log('<warning>');
+    console.log('This artifact has unmet dependencies. Complete them first or proceed with caution.');
+    console.log(`Missing: ${missing.join(', ')}`);
+    console.log('</warning>');
+    console.log();
+  }
+
+  // Task directive
+  console.log('<task>');
+  console.log(`Create the ${artifactId} artifact for change "${changeName}".`);
+  console.log(description);
+  console.log('</task>');
+  console.log();
+
+  // Context (dependencies)
+  if (dependencies.length > 0) {
+    console.log('<context>');
+    console.log('Read these files for context before creating this artifact:');
+    console.log();
+    for (const dep of dependencies) {
+      const status = dep.done ? 'done' : 'missing';
+      const fullPath = path.join(changeDir, dep.path);
+      console.log(`<dependency id="${dep.id}" status="${status}">`);
+      console.log(`  <path>${fullPath}</path>`);
+      console.log(`  <description>${dep.description}</description>`);
+      console.log('</dependency>');
+    }
+    console.log('</context>');
+    console.log();
+  }
+
+  // Output location
+  console.log('<output>');
+  console.log(`Write to: ${path.join(changeDir, outputPath)}`);
+  console.log('</output>');
+  console.log();
+
+  // Instruction (guidance)
+  if (instruction) {
+    console.log('<instruction>');
+    console.log(instruction.trim());
+    console.log('</instruction>');
+    console.log();
+  }
+
+  // Template
+  console.log('<template>');
+  console.log(template.trim());
+  console.log('</template>');
+  console.log();
+
+  // Success criteria placeholder
+  console.log('<success_criteria>');
+  console.log('<!-- To be defined in schema validation rules -->');
+  console.log('</success_criteria>');
+  console.log();
+
+  // Unlocks
+  if (unlocks.length > 0) {
+    console.log('<unlocks>');
+    console.log(`Completing this artifact enables: ${unlocks.join(', ')}`);
+    console.log('</unlocks>');
+    console.log();
+  }
+
+  // Closing tag
+  console.log('</artifact>');
+}
+
+// -----------------------------------------------------------------------------
+// Apply Instructions Command
+// -----------------------------------------------------------------------------
+
+interface ApplyInstructionsOptions {
+  change?: string;
+  schema?: string;
+  json?: boolean;
+}
+
+/**
+ * Parses tasks.md content and extracts task items with their completion status.
+ */
+function parseTasksFile(content: string): TaskItem[] {
+  const tasks: TaskItem[] = [];
+  const lines = content.split('\n');
+  let taskIndex = 0;
+
+  for (const line of lines) {
+    // Match checkbox patterns: - [ ] or - [x] or - [X]
+    const checkboxMatch = line.match(/^[-*]\s*\[([ xX])\]\s*(.+)$/);
+    if (checkboxMatch) {
+      taskIndex++;
+      const done = checkboxMatch[1].toLowerCase() === 'x';
+      const description = checkboxMatch[2].trim();
+      tasks.push({
+        id: `${taskIndex}`,
+        description,
+        done,
+      });
+    }
+  }
+
+  return tasks;
+}
+
+/**
+ * Checks if an artifact output exists in the change directory.
+ * Supports glob patterns (e.g., "specs/*.md") by verifying at least one matching file exists.
+ */
+function artifactOutputExists(changeDir: string, generates: string): boolean {
+  // Normalize the generates path to use platform-specific separators
+  const normalizedGenerates = generates.split('/').join(path.sep);
+  const fullPath = path.join(changeDir, normalizedGenerates);
+
+  // If it's a glob pattern (contains ** or *), check for matching files
+  if (generates.includes('*')) {
+    // Extract the directory part before the glob pattern
+    const parts = normalizedGenerates.split(path.sep);
+    const dirParts: string[] = [];
+    let patternPart = '';
+    for (const part of parts) {
+      if (part.includes('*')) {
+        patternPart = part;
+        break;
+      }
+      dirParts.push(part);
+    }
+    const dirPath = path.join(changeDir, ...dirParts);
+
+    // Check if directory exists
+    if (!fs.existsSync(dirPath) || !fs.statSync(dirPath).isDirectory()) {
+      return false;
+    }
+
+    // Extract expected extension from pattern (e.g., "*.md" -> ".md")
+    const extMatch = patternPart.match(/\*(\.[a-zA-Z0-9]+)$/);
+    const expectedExt = extMatch ? extMatch[1] : null;
+
+    // Recursively check for matching files
+    const hasMatchingFiles = (dir: string): boolean => {
+      try {
+        const entries = fs.readdirSync(dir, { withFileTypes: true });
+        for (const entry of entries) {
+          if (entry.isDirectory()) {
+            // For ** patterns, recurse into subdirectories
+            if (generates.includes('**') && hasMatchingFiles(path.join(dir, entry.name))) {
+              return true;
+            }
+          } else if (entry.isFile()) {
+            // Check if file matches expected extension (or any file if no extension specified)
+            if (!expectedExt || entry.name.endsWith(expectedExt)) {
+              return true;
+            }
+          }
+        }
+      } catch {
+        return false;
+      }
+      return false;
+    };
+
+    return hasMatchingFiles(dirPath);
+  }
+
+  return fs.existsSync(fullPath);
+}
+
+/**
+ * Generates apply instructions for implementing tasks from a change.
+ * Schema-aware: reads apply phase configuration from schema to determine
+ * required artifacts, tracking file, and instruction.
+ */
+async function generateApplyInstructions(
+  projectRoot: string,
+  changeName: string,
+  schemaName?: string
+): Promise<ApplyInstructions> {
+  // loadChangeContext will auto-detect schema from metadata if not provided
+  const context = loadChangeContext(projectRoot, changeName, schemaName);
+  const changeDir = path.join(projectRoot, 'openspec', 'changes', changeName);
+
+  // Get the full schema to access the apply phase configuration
+  const schema = resolveSchema(context.schemaName);
+  const applyConfig = schema.apply;
+
+  // Determine required artifacts and tracking file from schema
+  // Fallback: if no apply block, require all artifacts
+  const requiredArtifactIds = applyConfig?.requires ?? schema.artifacts.map((a) => a.id);
+  const tracksFile = applyConfig?.tracks ?? null;
+  const schemaInstruction = applyConfig?.instruction ?? null;
+
+  // Check which required artifacts are missing
+  const missingArtifacts: string[] = [];
+  for (const artifactId of requiredArtifactIds) {
+    const artifact = schema.artifacts.find((a) => a.id === artifactId);
+    if (artifact && !artifactOutputExists(changeDir, artifact.generates)) {
+      missingArtifacts.push(artifactId);
+    }
+  }
+
+  // Build context files from all existing artifacts in schema
+  const contextFiles: Record<string, string> = {};
+  for (const artifact of schema.artifacts) {
+    if (artifactOutputExists(changeDir, artifact.generates)) {
+      contextFiles[artifact.id] = path.join(changeDir, artifact.generates);
+    }
+  }
+
+  // Parse tasks if tracking file exists
+  let tasks: TaskItem[] = [];
+  let tracksFileExists = false;
+  if (tracksFile) {
+    const tracksPath = path.join(changeDir, tracksFile);
+    tracksFileExists = fs.existsSync(tracksPath);
+    if (tracksFileExists) {
+      const tasksContent = await fs.promises.readFile(tracksPath, 'utf-8');
+      tasks = parseTasksFile(tasksContent);
+    }
+  }
+
+  // Calculate progress
+  const total = tasks.length;
+  const complete = tasks.filter((t) => t.done).length;
+  const remaining = total - complete;
+
+  // Determine state and instruction
+  let state: ApplyInstructions['state'];
+  let instruction: string;
+
+  if (missingArtifacts.length > 0) {
+    state = 'blocked';
+    instruction = `Cannot apply this change yet. Missing artifacts: ${missingArtifacts.join(', ')}.\nUse the openspec-continue-change skill to create the missing artifacts first.`;
+  } else if (tracksFile && !tracksFileExists) {
+    // Tracking file configured but doesn't exist yet
+    const tracksFilename = path.basename(tracksFile);
+    state = 'blocked';
+    instruction = `The ${tracksFilename} file is missing and must be created.\nUse openspec-continue-change to generate the tracking file.`;
+  } else if (tracksFile && tracksFileExists && total === 0) {
+    // Tracking file exists but contains no tasks
+    const tracksFilename = path.basename(tracksFile);
+    state = 'blocked';
+    instruction = `The ${tracksFilename} file exists but contains no tasks.\nAdd tasks to ${tracksFilename} or regenerate it with openspec-continue-change.`;
+  } else if (tracksFile && remaining === 0 && total > 0) {
+    state = 'all_done';
+    instruction = 'All tasks are complete! This change is ready to be archived.\nConsider running tests and reviewing the changes before archiving.';
+  } else if (!tracksFile) {
+    // No tracking file (e.g., TDD schema) - ready to apply
+    state = 'ready';
+    instruction = schemaInstruction?.trim() ?? 'All required artifacts complete. Proceed with implementation.';
+  } else {
+    state = 'ready';
+    instruction = schemaInstruction?.trim() ?? 'Read context files, work through pending tasks, mark complete as you go.\nPause if you hit blockers or need clarification.';
+  }
+
+  return {
+    changeName,
+    changeDir,
+    schemaName: context.schemaName,
+    contextFiles,
+    progress: { total, complete, remaining },
+    tasks,
+    state,
+    missingArtifacts: missingArtifacts.length > 0 ? missingArtifacts : undefined,
+    instruction,
+  };
+}
+
+async function applyInstructionsCommand(options: ApplyInstructionsOptions): Promise<void> {
+  const spinner = ora('Generating apply instructions...').start();
+
+  try {
+    const projectRoot = process.cwd();
+    const changeName = await validateChangeExists(options.change, projectRoot);
+
+    // Validate schema if explicitly provided
+    if (options.schema) {
+      validateSchemaExists(options.schema);
+    }
+
+    // generateApplyInstructions uses loadChangeContext which auto-detects schema
+    const instructions = await generateApplyInstructions(projectRoot, changeName, options.schema);
+
+    spinner.stop();
+
+    if (options.json) {
+      console.log(JSON.stringify(instructions, null, 2));
+      return;
+    }
+
+    printApplyInstructionsText(instructions);
+  } catch (error) {
+    spinner.stop();
+    throw error;
+  }
+}
+
+function printApplyInstructionsText(instructions: ApplyInstructions): void {
+  const { changeName, schemaName, contextFiles, progress, tasks, state, missingArtifacts, instruction } = instructions;
+
+  console.log(`## Apply: ${changeName}`);
+  console.log(`Schema: ${schemaName}`);
+  console.log();
+
+  // Warning for blocked state
+  if (state === 'blocked' && missingArtifacts) {
+    console.log('### âš ï¸ Blocked');
+    console.log();
+    console.log(`Missing artifacts: ${missingArtifacts.join(', ')}`);
+    console.log('Use the openspec-continue-change skill to create these first.');
+    console.log();
+  }
+
+  // Context files (dynamically from schema)
+  const contextFileEntries = Object.entries(contextFiles);
+  if (contextFileEntries.length > 0) {
+    console.log('### Context Files');
+    for (const [artifactId, filePath] of contextFileEntries) {
+      console.log(`- ${artifactId}: ${filePath}`);
+    }
+    console.log();
+  }
+
+  // Progress (only show if we have tracking)
+  if (progress.total > 0 || tasks.length > 0) {
+    console.log('### Progress');
+    if (state === 'all_done') {
+      console.log(`${progress.complete}/${progress.total} complete âœ“`);
+    } else {
+      console.log(`${progress.complete}/${progress.total} complete`);
+    }
+    console.log();
+  }
+
+  // Tasks
+  if (tasks.length > 0) {
+    console.log('### Tasks');
+    for (const task of tasks) {
+      const checkbox = task.done ? '[x]' : '[ ]';
+      console.log(`- ${checkbox} ${task.description}`);
+    }
+    console.log();
+  }
+
+  // Instruction
+  console.log('### Instruction');
+  console.log(instruction);
+}
+
+// -----------------------------------------------------------------------------
+// Templates Command
+// -----------------------------------------------------------------------------
+
+interface TemplatesOptions {
+  schema?: string;
+  json?: boolean;
+}
+
+interface TemplateInfo {
+  artifactId: string;
+  templatePath: string;
+  source: 'user' | 'package';
+}
+
+async function templatesCommand(options: TemplatesOptions): Promise<void> {
+  const spinner = ora('Loading templates...').start();
+
+  try {
+    const schemaName = validateSchemaExists(options.schema ?? DEFAULT_SCHEMA);
+    const schema = resolveSchema(schemaName);
+    const graph = ArtifactGraph.fromSchema(schema);
+    const schemaDir = getSchemaDir(schemaName)!;
+
+    // Determine if this is a user override or package built-in
+    const { getUserSchemasDir } = await import('../core/artifact-graph/resolver.js');
+    const userSchemasDir = getUserSchemasDir();
+    const isUserOverride = schemaDir.startsWith(userSchemasDir);
+
+    const templates: TemplateInfo[] = graph.getAllArtifacts().map((artifact) => ({
+      artifactId: artifact.id,
+      templatePath: path.join(schemaDir, 'templates', artifact.template),
+      source: isUserOverride ? 'user' : 'package',
+    }));
+
+    spinner.stop();
+
+    if (options.json) {
+      const output: Record<string, { path: string; source: string }> = {};
+      for (const t of templates) {
+        output[t.artifactId] = { path: t.templatePath, source: t.source };
+      }
+      console.log(JSON.stringify(output, null, 2));
+      return;
+    }
+
+    console.log(`Schema: ${schemaName}`);
+    console.log(`Source: ${isUserOverride ? 'user override' : 'package built-in'}`);
+    console.log();
+
+    for (const t of templates) {
+      console.log(`${t.artifactId}:`);
+      console.log(`  ${t.templatePath}`);
+    }
+  } catch (error) {
+    spinner.stop();
+    throw error;
+  }
+}
+
+// -----------------------------------------------------------------------------
+// New Change Command
+// -----------------------------------------------------------------------------
+
+interface NewChangeOptions {
+  description?: string;
+  schema?: string;
+}
+
+async function newChangeCommand(name: string | undefined, options: NewChangeOptions): Promise<void> {
+  if (!name) {
+    throw new Error('Missing required argument <name>');
+  }
+
+  const validation = validateChangeName(name);
+  if (!validation.valid) {
+    throw new Error(validation.error);
+  }
+
+  // Validate schema if provided
+  if (options.schema) {
+    validateSchemaExists(options.schema);
+  }
+
+  const schemaDisplay = options.schema ? ` with schema '${options.schema}'` : '';
+  const spinner = ora(`Creating change '${name}'${schemaDisplay}...`).start();
+
+  try {
+    const projectRoot = process.cwd();
+    await createChange(projectRoot, name, { schema: options.schema });
+
+    // If description provided, create README.md with description
+    if (options.description) {
+      const { promises: fs } = await import('fs');
+      const changeDir = path.join(projectRoot, 'openspec', 'changes', name);
+      const readmePath = path.join(changeDir, 'README.md');
+      await fs.writeFile(readmePath, `# ${name}\n\n${options.description}\n`, 'utf-8');
+    }
+
+    const schemaUsed = options.schema ?? DEFAULT_SCHEMA;
+    spinner.succeed(`Created change '${name}' at openspec/changes/${name}/ (schema: ${schemaUsed})`);
+  } catch (error) {
+    spinner.fail(`Failed to create change '${name}'`);
+    throw error;
+  }
+}
+
+// -----------------------------------------------------------------------------
+// Artifact Experimental Setup Command
+// -----------------------------------------------------------------------------
+
+/**
+ * Generates Agent Skills and slash commands for the experimental artifact workflow.
+ * Creates .claude/skills/ directory with SKILL.md files following Agent Skills spec.
+ * Creates .claude/commands/opsx/ directory with slash command files.
+ */
+async function artifactExperimentalSetupCommand(): Promise<void> {
+  const spinner = ora('Setting up experimental artifact workflow...').start();
+
+  try {
+    const projectRoot = process.cwd();
+    const skillsDir = path.join(projectRoot, '.claude', 'skills');
+    const commandsDir = path.join(projectRoot, '.claude', 'commands', 'opsx');
+
+    // Get skill templates
+    const newChangeSkill = getNewChangeSkillTemplate();
+    const continueChangeSkill = getContinueChangeSkillTemplate();
+    const applyChangeSkill = getApplyChangeSkillTemplate();
+    const ffChangeSkill = getFfChangeSkillTemplate();
+    const syncSpecsSkill = getSyncSpecsSkillTemplate();
+    const archiveChangeSkill = getArchiveChangeSkillTemplate();
+
+    // Get command templates
+    const newCommand = getOpsxNewCommandTemplate();
+    const continueCommand = getOpsxContinueCommandTemplate();
+    const applyCommand = getOpsxApplyCommandTemplate();
+    const ffCommand = getOpsxFfCommandTemplate();
+    const syncCommand = getOpsxSyncCommandTemplate();
+    const archiveCommand = getOpsxArchiveCommandTemplate();
+
+    // Create skill directories and SKILL.md files
+    const skills = [
+      { template: newChangeSkill, dirName: 'openspec-new-change' },
+      { template: continueChangeSkill, dirName: 'openspec-continue-change' },
+      { template: applyChangeSkill, dirName: 'openspec-apply-change' },
+      { template: ffChangeSkill, dirName: 'openspec-ff-change' },
+      { template: syncSpecsSkill, dirName: 'openspec-sync-specs' },
+      { template: archiveChangeSkill, dirName: 'openspec-archive-change' },
+    ];
+
+    const createdSkillFiles: string[] = [];
+
+    for (const { template, dirName } of skills) {
+      const skillDir = path.join(skillsDir, dirName);
+      const skillFile = path.join(skillDir, 'SKILL.md');
+
+      // Generate SKILL.md content with YAML frontmatter
+      const skillContent = `---
+name: ${template.name}
+description: ${template.description}
+---
+
+${template.instructions}
+`;
+
+      // Write the skill file
+      await FileSystemUtils.writeFile(skillFile, skillContent);
+      createdSkillFiles.push(path.relative(projectRoot, skillFile));
+    }
+
+    // Create slash command files
+    const commands = [
+      { template: newCommand, fileName: 'new.md' },
+      { template: continueCommand, fileName: 'continue.md' },
+      { template: applyCommand, fileName: 'apply.md' },
+      { template: ffCommand, fileName: 'ff.md' },
+      { template: syncCommand, fileName: 'sync.md' },
+      { template: archiveCommand, fileName: 'archive.md' },
+    ];
+
+    const createdCommandFiles: string[] = [];
+
+    for (const { template, fileName } of commands) {
+      const commandFile = path.join(commandsDir, fileName);
+
+      // Generate command content with YAML frontmatter
+      const commandContent = `---
+name: ${template.name}
+description: ${template.description}
+category: ${template.category}
+tags: [${template.tags.join(', ')}]
+---
+
+${template.content}
+`;
+
+      // Write the command file
+      await FileSystemUtils.writeFile(commandFile, commandContent);
+      createdCommandFiles.push(path.relative(projectRoot, commandFile));
+    }
+
+    spinner.succeed('Experimental artifact workflow setup complete!');
+
+    // Print success message
+    console.log();
+    console.log(chalk.bold('ğŸ§ª Experimental Artifact Workflow Setup Complete'));
+    console.log();
+    console.log(chalk.bold('Skills Created:'));
+    for (const file of createdSkillFiles) {
+      console.log(chalk.green('  âœ“ ' + file));
+    }
+    console.log();
+    console.log(chalk.bold('Slash Commands Created:'));
+    for (const file of createdCommandFiles) {
+      console.log(chalk.green('  âœ“ ' + file));
+    }
+    console.log();
+    console.log(chalk.bold('ğŸ“– Usage:'));
+    console.log();
+    console.log('  ' + chalk.cyan('Skills') + ' work automatically in compatible editors:');
+    console.log('  â€¢ Claude Code - Auto-detected, ready to use');
+    console.log('  â€¢ Cursor - Enable in Settings â†’ Rules â†’ Import Settings');
+    console.log('  â€¢ Windsurf - Auto-imports from .claude directory');
+    console.log();
+    console.log('  Ask Claude naturally:');
+    console.log('  â€¢ "I want to start a new OpenSpec change to add <feature>"');
+    console.log('  â€¢ "Continue working on this change"');
+    console.log('  â€¢ "Implement the tasks for this change"');
+    console.log();
+    console.log('  ' + chalk.cyan('Slash Commands') + ' for explicit invocation:');
+    console.log('  â€¢ /opsx:new - Start a new change');
+    console.log('  â€¢ /opsx:continue - Create the next artifact');
+    console.log('  â€¢ /opsx:apply - Implement tasks');
+    console.log('  â€¢ /opsx:ff - Fast-forward: create all artifacts at once');
+    console.log('  â€¢ /opsx:sync - Sync delta specs to main specs');
+    console.log('  â€¢ /opsx:archive - Archive a completed change');
+    console.log();
+    console.log(chalk.yellow('ğŸ’¡ This is an experimental feature.'));
+    console.log('   Feedback welcome at: https://github.com/Fission-AI/OpenSpec/issues');
+    console.log();
+  } catch (error) {
+    spinner.fail('Failed to setup experimental artifact workflow');
+    throw error;
+  }
+}
+
+// -----------------------------------------------------------------------------
+// Schemas Command
+// -----------------------------------------------------------------------------
+
+interface SchemasOptions {
+  json?: boolean;
+}
+
+async function schemasCommand(options: SchemasOptions): Promise<void> {
+  const schemas = listSchemasWithInfo();
+
+  if (options.json) {
+    console.log(JSON.stringify(schemas, null, 2));
+    return;
+  }
+
+  console.log('Available schemas:');
+  console.log();
+
+  for (const schema of schemas) {
+    const sourceLabel = schema.source === 'user' ? chalk.dim(' (user override)') : '';
+    console.log(`  ${chalk.bold(schema.name)}${sourceLabel}`);
+    console.log(`    ${schema.description}`);
+    console.log(`    Artifacts: ${schema.artifacts.join(' â†’ ')}`);
+    console.log();
+  }
+}
+
+// -----------------------------------------------------------------------------
+// Command Registration
+// -----------------------------------------------------------------------------
+
+/**
+ * Registers all artifact workflow commands on the given program.
+ * All commands are marked as experimental in their help text.
+ */
+export function registerArtifactWorkflowCommands(program: Command): void {
+  // Status command
+  program
+    .command('status')
+    .description('[Experimental] Display artifact completion status for a change')
+    .option('--change <id>', 'Change name to show status for')
+    .option('--schema <name>', 'Schema override (auto-detected from .openspec.yaml)')
+    .option('--json', 'Output as JSON')
+    .action(async (options: StatusOptions) => {
+      try {
+        await statusCommand(options);
+      } catch (error) {
+        console.log();
+        ora().fail(`Error: ${(error as Error).message}`);
+        process.exit(1);
+      }
+    });
+
+  // Instructions command
+  program
+    .command('instructions [artifact]')
+    .description('[Experimental] Output enriched instructions for creating an artifact or applying tasks')
+    .option('--change <id>', 'Change name')
+    .option('--schema <name>', 'Schema override (auto-detected from .openspec.yaml)')
+    .option('--json', 'Output as JSON')
+    .action(async (artifactId: string | undefined, options: InstructionsOptions) => {
+      try {
+        // Special case: "apply" is not an artifact, but a command to get apply instructions
+        if (artifactId === 'apply') {
+          await applyInstructionsCommand(options);
+        } else {
+          await instructionsCommand(artifactId, options);
+        }
+      } catch (error) {
+        console.log();
+        ora().fail(`Error: ${(error as Error).message}`);
+        process.exit(1);
+      }
+    });
+
+  // Templates command
+  program
+    .command('templates')
+    .description('[Experimental] Show resolved template paths for all artifacts in a schema')
+    .option('--schema <name>', `Schema to use (default: ${DEFAULT_SCHEMA})`)
+    .option('--json', 'Output as JSON mapping artifact IDs to template paths')
+    .action(async (options: TemplatesOptions) => {
+      try {
+        await templatesCommand(options);
+      } catch (error) {
+        console.log();
+        ora().fail(`Error: ${(error as Error).message}`);
+        process.exit(1);
+      }
+    });
+
+  // Schemas command
+  program
+    .command('schemas')
+    .description('[Experimental] List available workflow schemas with descriptions')
+    .option('--json', 'Output as JSON (for agent use)')
+    .action(async (options: SchemasOptions) => {
+      try {
+        await schemasCommand(options);
+      } catch (error) {
+        console.log();
+        ora().fail(`Error: ${(error as Error).message}`);
+        process.exit(1);
+      }
+    });
+
+  // New command group with change subcommand
+  const newCmd = program.command('new').description('[Experimental] Create new items');
+
+  newCmd
+    .command('change <name>')
+    .description('[Experimental] Create a new change directory')
+    .option('--description <text>', 'Description to add to README.md')
+    .option('--schema <name>', `Workflow schema to use (default: ${DEFAULT_SCHEMA})`)
+    .action(async (name: string, options: NewChangeOptions) => {
+      try {
+        await newChangeCommand(name, options);
+      } catch (error) {
+        console.log();
+        ora().fail(`Error: ${(error as Error).message}`);
+        process.exit(1);
+      }
+    });
+
+  // Artifact experimental setup command
+  program
+    .command('artifact-experimental-setup')
+    .description('[Experimental] Setup Agent Skills for the experimental artifact workflow')
+    .action(async () => {
+      try {
+        await artifactExperimentalSetupCommand();
+      } catch (error) {
+        console.log();
+        ora().fail(`Error: ${(error as Error).message}`);
+        process.exit(1);
+      }
+    });
+}
diff --git a/src/core/archive.ts b/src/core/archive.ts
index c975602..1121ec2 100644
--- a/src/core/archive.ts
+++ b/src/core/archive.ts
@@ -1,21 +1,14 @@
 import { promises as fs } from 'fs';
 import path from 'path';
-import { FileSystemUtils } from '../utils/file-system.js';
 import { getTaskProgressForChange, formatTaskStatus } from '../utils/task-progress.js';
 import { Validator } from './validation/validator.js';
 import chalk from 'chalk';
 import {
-  extractRequirementsSection,
-  parseDeltaSpec,
-  normalizeRequirementName,
-  type RequirementBlock,
-} from './parsers/requirement-blocks.js';
-
-interface SpecUpdate {
-  source: string;
-  target: string;
-  exists: boolean;
-}
+  findSpecUpdates,
+  buildUpdatedSpec,
+  writeUpdatedSpec,
+  type SpecUpdate,
+} from './specs-apply.js';
 
 export class ArchiveCommand {
   async execute(
@@ -168,7 +161,7 @@ export class ArchiveCommand {
       console.log('Skipping spec updates (--skip-specs flag provided).');
     } else {
       // Find specs to update
-      const specUpdates = await this.findSpecUpdates(changeDir, mainSpecsDir);
+      const specUpdates = await findSpecUpdates(changeDir, mainSpecsDir);
       
       if (specUpdates.length > 0) {
         console.log('\nSpecs to update:');
@@ -195,7 +188,7 @@ export class ArchiveCommand {
           const prepared: Array<{ update: SpecUpdate; rebuilt: string; counts: { added: number; modified: number; removed: number; renamed: number } }> = [];
           try {
             for (const update of specUpdates) {
-              const built = await this.buildUpdatedSpec(update, changeName!);
+              const built = await buildUpdatedSpec(update, changeName!);
               prepared.push({ update, rebuilt: built.rebuilt, counts: built.counts });
             }
           } catch (err: any) {
@@ -220,7 +213,7 @@ export class ArchiveCommand {
                 return;
               }
             }
-            await this.writeUpdatedSpec(p.update, p.rebuilt, p.counts);
+            await writeUpdatedSpec(p.update, p.rebuilt, p.counts);
             totals.added += p.counts.added;
             totals.modified += p.counts.modified;
             totals.removed += p.counts.removed;
@@ -302,306 +295,6 @@ export class ArchiveCommand {
     }
   }
 
-  // Deprecated: replaced by shared task-progress utilities
-  private async checkIncompleteTasks(_tasksPath: string): Promise<number> {
-    return 0;
-  }
-
-  private async findSpecUpdates(changeDir: string, mainSpecsDir: string): Promise<SpecUpdate[]> {
-    const updates: SpecUpdate[] = [];
-    const changeSpecsDir = path.join(changeDir, 'specs');
-
-    try {
-      const entries = await fs.readdir(changeSpecsDir, { withFileTypes: true });
-      
-      for (const entry of entries) {
-        if (entry.isDirectory()) {
-          const specFile = path.join(changeSpecsDir, entry.name, 'spec.md');
-          const targetFile = path.join(mainSpecsDir, entry.name, 'spec.md');
-          
-          try {
-            await fs.access(specFile);
-            
-            // Check if target exists
-            let exists = false;
-            try {
-              await fs.access(targetFile);
-              exists = true;
-            } catch {
-              exists = false;
-            }
-
-            updates.push({
-              source: specFile,
-              target: targetFile,
-              exists
-            });
-          } catch {
-            // Source spec doesn't exist, skip
-          }
-        }
-      }
-    } catch {
-      // No specs directory in change
-    }
-
-    return updates;
-  }
-
-  private async buildUpdatedSpec(update: SpecUpdate, changeName: string): Promise<{ rebuilt: string; counts: { added: number; modified: number; removed: number; renamed: number } }> {
-    // Read change spec content (delta-format expected)
-    const changeContent = await fs.readFile(update.source, 'utf-8');
-
-    // Parse deltas from the change spec file
-    const plan = parseDeltaSpec(changeContent);
-    const specName = path.basename(path.dirname(update.target));
-
-    // Pre-validate duplicates within sections
-    const addedNames = new Set<string>();
-    for (const add of plan.added) {
-      const name = normalizeRequirementName(add.name);
-      if (addedNames.has(name)) {
-        throw new Error(
-          `${specName} validation failed - duplicate requirement in ADDED for header "### Requirement: ${add.name}"`
-        );
-      }
-      addedNames.add(name);
-    }
-    const modifiedNames = new Set<string>();
-    for (const mod of plan.modified) {
-      const name = normalizeRequirementName(mod.name);
-      if (modifiedNames.has(name)) {
-        throw new Error(
-          `${specName} validation failed - duplicate requirement in MODIFIED for header "### Requirement: ${mod.name}"`
-        );
-      }
-      modifiedNames.add(name);
-    }
-    const removedNamesSet = new Set<string>();
-    for (const rem of plan.removed) {
-      const name = normalizeRequirementName(rem);
-      if (removedNamesSet.has(name)) {
-        throw new Error(
-          `${specName} validation failed - duplicate requirement in REMOVED for header "### Requirement: ${rem}"`
-        );
-      }
-      removedNamesSet.add(name);
-    }
-    const renamedFromSet = new Set<string>();
-    const renamedToSet = new Set<string>();
-    for (const { from, to } of plan.renamed) {
-      const fromNorm = normalizeRequirementName(from);
-      const toNorm = normalizeRequirementName(to);
-      if (renamedFromSet.has(fromNorm)) {
-        throw new Error(
-          `${specName} validation failed - duplicate FROM in RENAMED for header "### Requirement: ${from}"`
-        );
-      }
-      if (renamedToSet.has(toNorm)) {
-        throw new Error(
-          `${specName} validation failed - duplicate TO in RENAMED for header "### Requirement: ${to}"`
-        );
-      }
-      renamedFromSet.add(fromNorm);
-      renamedToSet.add(toNorm);
-    }
-
-    // Pre-validate cross-section conflicts
-    const conflicts: Array<{ name: string; a: string; b: string }> = [];
-    for (const n of modifiedNames) {
-      if (removedNamesSet.has(n)) conflicts.push({ name: n, a: 'MODIFIED', b: 'REMOVED' });
-      if (addedNames.has(n)) conflicts.push({ name: n, a: 'MODIFIED', b: 'ADDED' });
-    }
-    for (const n of addedNames) {
-      if (removedNamesSet.has(n)) conflicts.push({ name: n, a: 'ADDED', b: 'REMOVED' });
-    }
-    // Renamed interplay: MODIFIED must reference the NEW header, not FROM
-    for (const { from, to } of plan.renamed) {
-      const fromNorm = normalizeRequirementName(from);
-      const toNorm = normalizeRequirementName(to);
-      if (modifiedNames.has(fromNorm)) {
-        throw new Error(
-          `${specName} validation failed - when a rename exists, MODIFIED must reference the NEW header "### Requirement: ${to}"`
-        );
-      }
-      // Detect ADDED colliding with a RENAMED TO
-      if (addedNames.has(toNorm)) {
-        throw new Error(
-          `${specName} validation failed - RENAMED TO header collides with ADDED for "### Requirement: ${to}"`
-        );
-      }
-    }
-    if (conflicts.length > 0) {
-      const c = conflicts[0];
-      throw new Error(
-        `${specName} validation failed - requirement present in multiple sections (${c.a} and ${c.b}) for header "### Requirement: ${c.name}"`
-      );
-    }
-    const hasAnyDelta = (plan.added.length + plan.modified.length + plan.removed.length + plan.renamed.length) > 0;
-    if (!hasAnyDelta) {
-      throw new Error(
-        `Delta parsing found no operations for ${path.basename(path.dirname(update.source))}. ` +
-        `Provide ADDED/MODIFIED/REMOVED/RENAMED sections in change spec.`
-      );
-    }
-
-    // Load or create base target content
-    let targetContent: string;
-    try {
-      targetContent = await fs.readFile(update.target, 'utf-8');
-    } catch {
-      // Target spec does not exist; only ADDED operations are permitted
-      if (plan.modified.length > 0 || plan.removed.length > 0 || plan.renamed.length > 0) {
-        throw new Error(
-          `${specName}: target spec does not exist; only ADDED requirements are allowed for new specs.`
-        );
-      }
-      targetContent = this.buildSpecSkeleton(specName, changeName);
-    }
-
-    // Extract requirements section and build name->block map
-    const parts = extractRequirementsSection(targetContent);
-    const nameToBlock = new Map<string, RequirementBlock>();
-    for (const block of parts.bodyBlocks) {
-      nameToBlock.set(normalizeRequirementName(block.name), block);
-    }
-
-    // Apply operations in order: RENAMED â†’ REMOVED â†’ MODIFIED â†’ ADDED
-    // RENAMED
-    for (const r of plan.renamed) {
-      const from = normalizeRequirementName(r.from);
-      const to = normalizeRequirementName(r.to);
-      if (!nameToBlock.has(from)) {
-        throw new Error(
-          `${specName} RENAMED failed for header "### Requirement: ${r.from}" - source not found`
-        );
-      }
-      if (nameToBlock.has(to)) {
-        throw new Error(
-          `${specName} RENAMED failed for header "### Requirement: ${r.to}" - target already exists`
-        );
-      }
-      const block = nameToBlock.get(from)!;
-      const newHeader = `### Requirement: ${to}`;
-      const rawLines = block.raw.split('\n');
-      rawLines[0] = newHeader;
-      const renamedBlock: RequirementBlock = {
-        headerLine: newHeader,
-        name: to,
-        raw: rawLines.join('\n'),
-      };
-      nameToBlock.delete(from);
-      nameToBlock.set(to, renamedBlock);
-    }
-
-    // REMOVED
-    for (const name of plan.removed) {
-      const key = normalizeRequirementName(name);
-      if (!nameToBlock.has(key)) {
-        throw new Error(
-          `${specName} REMOVED failed for header "### Requirement: ${name}" - not found`
-        );
-      }
-      nameToBlock.delete(key);
-    }
-
-    // MODIFIED
-    for (const mod of plan.modified) {
-      const key = normalizeRequirementName(mod.name);
-      if (!nameToBlock.has(key)) {
-        throw new Error(
-          `${specName} MODIFIED failed for header "### Requirement: ${mod.name}" - not found`
-        );
-      }
-      // Replace block with provided raw (ensure header line matches key)
-      const modHeaderMatch = mod.raw.split('\n')[0].match(/^###\s*Requirement:\s*(.+)\s*$/);
-      if (!modHeaderMatch || normalizeRequirementName(modHeaderMatch[1]) !== key) {
-        throw new Error(
-          `${specName} MODIFIED failed for header "### Requirement: ${mod.name}" - header mismatch in content`
-        );
-      }
-      nameToBlock.set(key, mod);
-    }
-
-    // ADDED
-    for (const add of plan.added) {
-      const key = normalizeRequirementName(add.name);
-      if (nameToBlock.has(key)) {
-        throw new Error(
-          `${specName} ADDED failed for header "### Requirement: ${add.name}" - already exists`
-        );
-      }
-      nameToBlock.set(key, add);
-    }
-
-    // Duplicates within resulting map are implicitly prevented by key uniqueness.
-
-    // Recompose requirements section preserving original ordering where possible
-    const keptOrder: RequirementBlock[] = [];
-    const seen = new Set<string>();
-    for (const block of parts.bodyBlocks) {
-      const key = normalizeRequirementName(block.name);
-      const replacement = nameToBlock.get(key);
-      if (replacement) {
-        keptOrder.push(replacement);
-        seen.add(key);
-      }
-    }
-    // Append any newly added that were not in original order
-    for (const [key, block] of nameToBlock.entries()) {
-      if (!seen.has(key)) {
-        keptOrder.push(block);
-      }
-    }
-
-    const reqBody = [
-      parts.preamble && parts.preamble.trim() ? parts.preamble.trimEnd() : ''
-    ]
-      .filter(Boolean)
-      .concat(keptOrder.map(b => b.raw))
-      .join('\n\n')
-      .trimEnd();
-
-    const rebuilt = [
-      parts.before.trimEnd(),
-      parts.headerLine,
-      reqBody,
-      parts.after
-    ]
-      .filter((s, idx) => !(idx === 0 && s === ''))
-      .join('\n')
-      .replace(/\n{3,}/g, '\n\n');
-
-    return {
-      rebuilt,
-      counts: {
-        added: plan.added.length,
-        modified: plan.modified.length,
-        removed: plan.removed.length,
-        renamed: plan.renamed.length,
-      }
-    };
-  }
-
-  private async writeUpdatedSpec(update: SpecUpdate, rebuilt: string, counts: { added: number; modified: number; removed: number; renamed: number }): Promise<void> {
-    // Create target directory if needed
-    const targetDir = path.dirname(update.target);
-    await fs.mkdir(targetDir, { recursive: true });
-    await fs.writeFile(update.target, rebuilt);
-
-    const specName = path.basename(path.dirname(update.target));
-    console.log(`Applying changes to openspec/specs/${specName}/spec.md:`);
-    if (counts.added) console.log(`  + ${counts.added} added`);
-    if (counts.modified) console.log(`  ~ ${counts.modified} modified`);
-    if (counts.removed) console.log(`  - ${counts.removed} removed`);
-    if (counts.renamed) console.log(`  â†’ ${counts.renamed} renamed`);
-  }
-
-  private buildSpecSkeleton(specFolderName: string, changeName: string): string {
-    const titleBase = specFolderName;
-    return `# ${titleBase} Specification\n\n## Purpose\nTBD - created by archiving change ${changeName}. Update Purpose after archive.\n\n## Requirements\n`;
-  }
-
   private getArchiveDate(): string {
     // Returns date in YYYY-MM-DD format
     return new Date().toISOString().split('T')[0];
diff --git a/src/core/artifact-graph/graph.ts b/src/core/artifact-graph/graph.ts
new file mode 100644
index 0000000..3f960e6
--- /dev/null
+++ b/src/core/artifact-graph/graph.ts
@@ -0,0 +1,167 @@
+import type { Artifact, SchemaYaml, CompletedSet, BlockedArtifacts } from './types.js';
+import { loadSchema, parseSchema } from './schema.js';
+
+/**
+ * Represents an artifact dependency graph.
+ * Provides methods for querying build order, ready artifacts, and completion status.
+ */
+export class ArtifactGraph {
+  private artifacts: Map<string, Artifact>;
+  private schema: SchemaYaml;
+
+  private constructor(schema: SchemaYaml) {
+    this.schema = schema;
+    this.artifacts = new Map(schema.artifacts.map(a => [a.id, a]));
+  }
+
+  /**
+   * Creates an ArtifactGraph from a YAML file path.
+   */
+  static fromYaml(filePath: string): ArtifactGraph {
+    const schema = loadSchema(filePath);
+    return new ArtifactGraph(schema);
+  }
+
+  /**
+   * Creates an ArtifactGraph from YAML content string.
+   */
+  static fromYamlContent(yamlContent: string): ArtifactGraph {
+    const schema = parseSchema(yamlContent);
+    return new ArtifactGraph(schema);
+  }
+
+  /**
+   * Creates an ArtifactGraph from a pre-validated schema object.
+   */
+  static fromSchema(schema: SchemaYaml): ArtifactGraph {
+    return new ArtifactGraph(schema);
+  }
+
+  /**
+   * Gets a single artifact by ID.
+   */
+  getArtifact(id: string): Artifact | undefined {
+    return this.artifacts.get(id);
+  }
+
+  /**
+   * Gets all artifacts in the graph.
+   */
+  getAllArtifacts(): Artifact[] {
+    return Array.from(this.artifacts.values());
+  }
+
+  /**
+   * Gets the schema name.
+   */
+  getName(): string {
+    return this.schema.name;
+  }
+
+  /**
+   * Gets the schema version.
+   */
+  getVersion(): number {
+    return this.schema.version;
+  }
+
+  /**
+   * Computes the topological build order using Kahn's algorithm.
+   * Returns artifact IDs in the order they should be built.
+   */
+  getBuildOrder(): string[] {
+    const inDegree = new Map<string, number>();
+    const dependents = new Map<string, string[]>();
+
+    // Initialize all artifacts
+    for (const artifact of this.artifacts.values()) {
+      inDegree.set(artifact.id, artifact.requires.length);
+      dependents.set(artifact.id, []);
+    }
+
+    // Build reverse adjacency (who depends on whom)
+    for (const artifact of this.artifacts.values()) {
+      for (const req of artifact.requires) {
+        dependents.get(req)!.push(artifact.id);
+      }
+    }
+
+    // Start with roots (in-degree 0), sorted for determinism
+    const queue = [...this.artifacts.keys()]
+      .filter(id => inDegree.get(id) === 0)
+      .sort();
+
+    const result: string[] = [];
+
+    while (queue.length > 0) {
+      const current = queue.shift()!;
+      result.push(current);
+
+      // Collect newly ready artifacts, then sort before adding
+      const newlyReady: string[] = [];
+      for (const dep of dependents.get(current)!) {
+        const newDegree = inDegree.get(dep)! - 1;
+        inDegree.set(dep, newDegree);
+        if (newDegree === 0) {
+          newlyReady.push(dep);
+        }
+      }
+      queue.push(...newlyReady.sort());
+    }
+
+    return result;
+  }
+
+  /**
+   * Gets artifacts that are ready to be created (all dependencies completed).
+   */
+  getNextArtifacts(completed: CompletedSet): string[] {
+    const ready: string[] = [];
+
+    for (const artifact of this.artifacts.values()) {
+      if (completed.has(artifact.id)) {
+        continue; // Already completed
+      }
+
+      const allDepsCompleted = artifact.requires.every(req => completed.has(req));
+      if (allDepsCompleted) {
+        ready.push(artifact.id);
+      }
+    }
+
+    // Sort for deterministic ordering
+    return ready.sort();
+  }
+
+  /**
+   * Checks if all artifacts in the graph are completed.
+   */
+  isComplete(completed: CompletedSet): boolean {
+    for (const artifact of this.artifacts.values()) {
+      if (!completed.has(artifact.id)) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  /**
+   * Gets blocked artifacts and their unmet dependencies.
+   */
+  getBlocked(completed: CompletedSet): BlockedArtifacts {
+    const blocked: BlockedArtifacts = {};
+
+    for (const artifact of this.artifacts.values()) {
+      if (completed.has(artifact.id)) {
+        continue; // Already completed
+      }
+
+      const unmetDeps = artifact.requires.filter(req => !completed.has(req));
+      if (unmetDeps.length > 0) {
+        blocked[artifact.id] = unmetDeps.sort();
+      }
+    }
+
+    return blocked;
+  }
+}
diff --git a/src/core/artifact-graph/index.ts b/src/core/artifact-graph/index.ts
new file mode 100644
index 0000000..2322fec
--- /dev/null
+++ b/src/core/artifact-graph/index.ts
@@ -0,0 +1,44 @@
+// Types
+export {
+  ArtifactSchema,
+  SchemaYamlSchema,
+  type Artifact,
+  type SchemaYaml,
+  type CompletedSet,
+  type BlockedArtifacts,
+} from './types.js';
+
+// Schema loading and validation
+export { loadSchema, parseSchema, SchemaValidationError } from './schema.js';
+
+// Graph operations
+export { ArtifactGraph } from './graph.js';
+
+// State detection
+export { detectCompleted } from './state.js';
+
+// Schema resolution
+export {
+  resolveSchema,
+  listSchemas,
+  listSchemasWithInfo,
+  getSchemaDir,
+  getPackageSchemasDir,
+  getUserSchemasDir,
+  SchemaLoadError,
+  type SchemaInfo,
+} from './resolver.js';
+
+// Instruction loading
+export {
+  loadTemplate,
+  loadChangeContext,
+  generateInstructions,
+  formatChangeStatus,
+  TemplateLoadError,
+  type ChangeContext,
+  type ArtifactInstructions,
+  type DependencyInfo,
+  type ArtifactStatus,
+  type ChangeStatus,
+} from './instruction-loader.js';
diff --git a/src/core/artifact-graph/instruction-loader.ts b/src/core/artifact-graph/instruction-loader.ts
new file mode 100644
index 0000000..92b6de2
--- /dev/null
+++ b/src/core/artifact-graph/instruction-loader.ts
@@ -0,0 +1,302 @@
+import * as fs from 'node:fs';
+import * as path from 'node:path';
+import { getSchemaDir, resolveSchema } from './resolver.js';
+import { ArtifactGraph } from './graph.js';
+import { detectCompleted } from './state.js';
+import { resolveSchemaForChange } from '../../utils/change-metadata.js';
+import type { Artifact, CompletedSet } from './types.js';
+
+/**
+ * Error thrown when loading a template fails.
+ */
+export class TemplateLoadError extends Error {
+  constructor(
+    message: string,
+    public readonly templatePath: string
+  ) {
+    super(message);
+    this.name = 'TemplateLoadError';
+  }
+}
+
+/**
+ * Change context containing graph, completion state, and metadata.
+ */
+export interface ChangeContext {
+  /** The artifact dependency graph */
+  graph: ArtifactGraph;
+  /** Set of completed artifact IDs */
+  completed: CompletedSet;
+  /** Schema name being used */
+  schemaName: string;
+  /** Change name */
+  changeName: string;
+  /** Path to the change directory */
+  changeDir: string;
+}
+
+/**
+ * Enriched instructions for creating an artifact.
+ */
+export interface ArtifactInstructions {
+  /** Change name */
+  changeName: string;
+  /** Artifact ID */
+  artifactId: string;
+  /** Schema name */
+  schemaName: string;
+  /** Full path to change directory */
+  changeDir: string;
+  /** Output path pattern (e.g., "proposal.md") */
+  outputPath: string;
+  /** Artifact description */
+  description: string;
+  /** Guidance on how to create this artifact (from schema instruction field) */
+  instruction: string | undefined;
+  /** Template content (structure to follow) */
+  template: string;
+  /** Dependencies with completion status and paths */
+  dependencies: DependencyInfo[];
+  /** Artifacts that become available after completing this one */
+  unlocks: string[];
+}
+
+/**
+ * Dependency information including path and description.
+ */
+export interface DependencyInfo {
+  /** Artifact ID */
+  id: string;
+  /** Whether the dependency is completed */
+  done: boolean;
+  /** Relative output path of the dependency (e.g., "proposal.md") */
+  path: string;
+  /** Description of the dependency artifact */
+  description: string;
+}
+
+/**
+ * Status of a single artifact in the workflow.
+ */
+export interface ArtifactStatus {
+  /** Artifact ID */
+  id: string;
+  /** Output path pattern */
+  outputPath: string;
+  /** Status: done, ready, or blocked */
+  status: 'done' | 'ready' | 'blocked';
+  /** Missing dependencies (only for blocked) */
+  missingDeps?: string[];
+}
+
+/**
+ * Formatted change status.
+ */
+export interface ChangeStatus {
+  /** Change name */
+  changeName: string;
+  /** Schema name */
+  schemaName: string;
+  /** Whether all artifacts are complete */
+  isComplete: boolean;
+  /** Artifact IDs required before apply phase (from schema's apply.requires) */
+  applyRequires: string[];
+  /** Status of each artifact */
+  artifacts: ArtifactStatus[];
+}
+
+/**
+ * Loads a template from a schema's templates directory.
+ *
+ * @param schemaName - Schema name (e.g., "spec-driven")
+ * @param templatePath - Relative path within the templates directory (e.g., "proposal.md")
+ * @returns The template content
+ * @throws TemplateLoadError if the template cannot be loaded
+ */
+export function loadTemplate(schemaName: string, templatePath: string): string {
+  const schemaDir = getSchemaDir(schemaName);
+  if (!schemaDir) {
+    throw new TemplateLoadError(
+      `Schema '${schemaName}' not found`,
+      templatePath
+    );
+  }
+
+  const fullPath = path.join(schemaDir, 'templates', templatePath);
+
+  if (!fs.existsSync(fullPath)) {
+    throw new TemplateLoadError(
+      `Template not found: ${fullPath}`,
+      fullPath
+    );
+  }
+
+  try {
+    return fs.readFileSync(fullPath, 'utf-8');
+  } catch (err) {
+    const ioError = err instanceof Error ? err : new Error(String(err));
+    throw new TemplateLoadError(
+      `Failed to read template: ${ioError.message}`,
+      fullPath
+    );
+  }
+}
+
+/**
+ * Loads change context combining graph and completion state.
+ *
+ * Schema resolution order:
+ * 1. Explicit schemaName parameter (if provided)
+ * 2. Schema from .openspec.yaml metadata (if exists in change directory)
+ * 3. Default 'spec-driven'
+ *
+ * @param projectRoot - Project root directory
+ * @param changeName - Change name
+ * @param schemaName - Optional schema name override. If not provided, auto-detected from metadata.
+ * @returns Change context with graph, completed set, and metadata
+ */
+export function loadChangeContext(
+  projectRoot: string,
+  changeName: string,
+  schemaName?: string
+): ChangeContext {
+  const changeDir = path.join(projectRoot, 'openspec', 'changes', changeName);
+
+  // Resolve schema: explicit > metadata > default
+  const resolvedSchemaName = resolveSchemaForChange(changeDir, schemaName);
+
+  const schema = resolveSchema(resolvedSchemaName);
+  const graph = ArtifactGraph.fromSchema(schema);
+  const completed = detectCompleted(graph, changeDir);
+
+  return {
+    graph,
+    completed,
+    schemaName: resolvedSchemaName,
+    changeName,
+    changeDir,
+  };
+}
+
+/**
+ * Generates enriched instructions for creating an artifact.
+ *
+ * @param context - Change context
+ * @param artifactId - Artifact ID to generate instructions for
+ * @returns Enriched artifact instructions
+ * @throws Error if artifact not found
+ */
+export function generateInstructions(
+  context: ChangeContext,
+  artifactId: string
+): ArtifactInstructions {
+  const artifact = context.graph.getArtifact(artifactId);
+  if (!artifact) {
+    throw new Error(`Artifact '${artifactId}' not found in schema '${context.schemaName}'`);
+  }
+
+  const template = loadTemplate(context.schemaName, artifact.template);
+  const dependencies = getDependencyInfo(artifact, context.graph, context.completed);
+  const unlocks = getUnlockedArtifacts(context.graph, artifactId);
+
+  return {
+    changeName: context.changeName,
+    artifactId: artifact.id,
+    schemaName: context.schemaName,
+    changeDir: context.changeDir,
+    outputPath: artifact.generates,
+    description: artifact.description,
+    instruction: artifact.instruction,
+    template,
+    dependencies,
+    unlocks,
+  };
+}
+
+/**
+ * Gets dependency info including paths and descriptions.
+ */
+function getDependencyInfo(
+  artifact: Artifact,
+  graph: ArtifactGraph,
+  completed: CompletedSet
+): DependencyInfo[] {
+  return artifact.requires.map(id => {
+    const depArtifact = graph.getArtifact(id);
+    return {
+      id,
+      done: completed.has(id),
+      path: depArtifact?.generates ?? id,
+      description: depArtifact?.description ?? '',
+    };
+  });
+}
+
+/**
+ * Gets artifacts that become available after completing the given artifact.
+ */
+function getUnlockedArtifacts(graph: ArtifactGraph, artifactId: string): string[] {
+  const unlocks: string[] = [];
+
+  for (const artifact of graph.getAllArtifacts()) {
+    if (artifact.requires.includes(artifactId)) {
+      unlocks.push(artifact.id);
+    }
+  }
+
+  return unlocks.sort();
+}
+
+/**
+ * Formats the status of all artifacts in a change.
+ *
+ * @param context - Change context
+ * @returns Formatted change status
+ */
+export function formatChangeStatus(context: ChangeContext): ChangeStatus {
+  // Load schema to get apply phase configuration
+  const schema = resolveSchema(context.schemaName);
+  const applyRequires = schema.apply?.requires ?? schema.artifacts.map(a => a.id);
+
+  const artifacts = context.graph.getAllArtifacts();
+  const ready = new Set(context.graph.getNextArtifacts(context.completed));
+  const blocked = context.graph.getBlocked(context.completed);
+
+  const artifactStatuses: ArtifactStatus[] = artifacts.map(artifact => {
+    if (context.completed.has(artifact.id)) {
+      return {
+        id: artifact.id,
+        outputPath: artifact.generates,
+        status: 'done' as const,
+      };
+    }
+
+    if (ready.has(artifact.id)) {
+      return {
+        id: artifact.id,
+        outputPath: artifact.generates,
+        status: 'ready' as const,
+      };
+    }
+
+    return {
+      id: artifact.id,
+      outputPath: artifact.generates,
+      status: 'blocked' as const,
+      missingDeps: blocked[artifact.id] ?? [],
+    };
+  });
+
+  // Sort by build order for consistent output
+  const buildOrder = context.graph.getBuildOrder();
+  const orderMap = new Map(buildOrder.map((id, idx) => [id, idx]));
+  artifactStatuses.sort((a, b) => (orderMap.get(a.id) ?? 0) - (orderMap.get(b.id) ?? 0));
+
+  return {
+    changeName: context.changeName,
+    schemaName: context.schemaName,
+    isComplete: context.graph.isComplete(context.completed),
+    applyRequires,
+    artifacts: artifactStatuses,
+  };
+}
diff --git a/src/core/artifact-graph/resolver.ts b/src/core/artifact-graph/resolver.ts
new file mode 100644
index 0000000..52b2620
--- /dev/null
+++ b/src/core/artifact-graph/resolver.ts
@@ -0,0 +1,226 @@
+import * as fs from 'node:fs';
+import * as path from 'node:path';
+import { fileURLToPath } from 'node:url';
+import { getGlobalDataDir } from '../global-config.js';
+import { parseSchema, SchemaValidationError } from './schema.js';
+import type { SchemaYaml } from './types.js';
+
+/**
+ * Error thrown when loading a schema fails.
+ */
+export class SchemaLoadError extends Error {
+  constructor(
+    message: string,
+    public readonly schemaPath: string,
+    public readonly cause?: Error
+  ) {
+    super(message);
+    this.name = 'SchemaLoadError';
+  }
+}
+
+/**
+ * Gets the package's built-in schemas directory path.
+ * Uses import.meta.url to resolve relative to the current module.
+ */
+export function getPackageSchemasDir(): string {
+  const currentFile = fileURLToPath(import.meta.url);
+  // Navigate from dist/core/artifact-graph/ to package root's schemas/
+  return path.join(path.dirname(currentFile), '..', '..', '..', 'schemas');
+}
+
+/**
+ * Gets the user's schema override directory path.
+ */
+export function getUserSchemasDir(): string {
+  return path.join(getGlobalDataDir(), 'schemas');
+}
+
+/**
+ * Resolves a schema name to its directory path.
+ *
+ * Resolution order:
+ * 1. User override: ${XDG_DATA_HOME}/openspec/schemas/<name>/schema.yaml
+ * 2. Package built-in: <package>/schemas/<name>/schema.yaml
+ *
+ * @param name - Schema name (e.g., "spec-driven")
+ * @returns The path to the schema directory, or null if not found
+ */
+export function getSchemaDir(name: string): string | null {
+  // 1. Check user override directory
+  const userDir = path.join(getUserSchemasDir(), name);
+  const userSchemaPath = path.join(userDir, 'schema.yaml');
+  if (fs.existsSync(userSchemaPath)) {
+    return userDir;
+  }
+
+  // 2. Check package built-in directory
+  const packageDir = path.join(getPackageSchemasDir(), name);
+  const packageSchemaPath = path.join(packageDir, 'schema.yaml');
+  if (fs.existsSync(packageSchemaPath)) {
+    return packageDir;
+  }
+
+  return null;
+}
+
+/**
+ * Resolves a schema name to a SchemaYaml object.
+ *
+ * Resolution order:
+ * 1. User override: ${XDG_DATA_HOME}/openspec/schemas/<name>/schema.yaml
+ * 2. Package built-in: <package>/schemas/<name>/schema.yaml
+ *
+ * @param name - Schema name (e.g., "spec-driven")
+ * @returns The resolved schema object
+ * @throws Error if schema is not found in any location
+ */
+export function resolveSchema(name: string): SchemaYaml {
+  // Normalize name (remove .yaml extension if provided)
+  const normalizedName = name.replace(/\.ya?ml$/, '');
+
+  const schemaDir = getSchemaDir(normalizedName);
+  if (!schemaDir) {
+    const availableSchemas = listSchemas();
+    throw new Error(
+      `Schema '${normalizedName}' not found. Available schemas: ${availableSchemas.join(', ')}`
+    );
+  }
+
+  const schemaPath = path.join(schemaDir, 'schema.yaml');
+
+  // Load and parse the schema
+  let content: string;
+  try {
+    content = fs.readFileSync(schemaPath, 'utf-8');
+  } catch (err) {
+    const ioError = err instanceof Error ? err : new Error(String(err));
+    throw new SchemaLoadError(
+      `Failed to read schema at '${schemaPath}': ${ioError.message}`,
+      schemaPath,
+      ioError
+    );
+  }
+
+  try {
+    return parseSchema(content);
+  } catch (err) {
+    if (err instanceof SchemaValidationError) {
+      throw new SchemaLoadError(
+        `Invalid schema at '${schemaPath}': ${err.message}`,
+        schemaPath,
+        err
+      );
+    }
+    const parseError = err instanceof Error ? err : new Error(String(err));
+    throw new SchemaLoadError(
+      `Failed to parse schema at '${schemaPath}': ${parseError.message}`,
+      schemaPath,
+      parseError
+    );
+  }
+}
+
+/**
+ * Lists all available schema names.
+ * Combines user override and package built-in schemas.
+ */
+export function listSchemas(): string[] {
+  const schemas = new Set<string>();
+
+  // Add package built-in schemas
+  const packageDir = getPackageSchemasDir();
+  if (fs.existsSync(packageDir)) {
+    for (const entry of fs.readdirSync(packageDir, { withFileTypes: true })) {
+      if (entry.isDirectory()) {
+        const schemaPath = path.join(packageDir, entry.name, 'schema.yaml');
+        if (fs.existsSync(schemaPath)) {
+          schemas.add(entry.name);
+        }
+      }
+    }
+  }
+
+  // Add user override schemas (may override package schemas)
+  const userDir = getUserSchemasDir();
+  if (fs.existsSync(userDir)) {
+    for (const entry of fs.readdirSync(userDir, { withFileTypes: true })) {
+      if (entry.isDirectory()) {
+        const schemaPath = path.join(userDir, entry.name, 'schema.yaml');
+        if (fs.existsSync(schemaPath)) {
+          schemas.add(entry.name);
+        }
+      }
+    }
+  }
+
+  return Array.from(schemas).sort();
+}
+
+/**
+ * Schema info with metadata (name, description, artifacts).
+ */
+export interface SchemaInfo {
+  name: string;
+  description: string;
+  artifacts: string[];
+  source: 'package' | 'user';
+}
+
+/**
+ * Lists all available schemas with their descriptions and artifact lists.
+ * Useful for agent skills to present schema selection to users.
+ */
+export function listSchemasWithInfo(): SchemaInfo[] {
+  const schemas: SchemaInfo[] = [];
+  const seenNames = new Set<string>();
+
+  // Add user override schemas first (they take precedence)
+  const userDir = getUserSchemasDir();
+  if (fs.existsSync(userDir)) {
+    for (const entry of fs.readdirSync(userDir, { withFileTypes: true })) {
+      if (entry.isDirectory()) {
+        const schemaPath = path.join(userDir, entry.name, 'schema.yaml');
+        if (fs.existsSync(schemaPath)) {
+          try {
+            const schema = parseSchema(fs.readFileSync(schemaPath, 'utf-8'));
+            schemas.push({
+              name: entry.name,
+              description: schema.description || '',
+              artifacts: schema.artifacts.map((a) => a.id),
+              source: 'user',
+            });
+            seenNames.add(entry.name);
+          } catch {
+            // Skip invalid schemas
+          }
+        }
+      }
+    }
+  }
+
+  // Add package built-in schemas (if not overridden)
+  const packageDir = getPackageSchemasDir();
+  if (fs.existsSync(packageDir)) {
+    for (const entry of fs.readdirSync(packageDir, { withFileTypes: true })) {
+      if (entry.isDirectory() && !seenNames.has(entry.name)) {
+        const schemaPath = path.join(packageDir, entry.name, 'schema.yaml');
+        if (fs.existsSync(schemaPath)) {
+          try {
+            const schema = parseSchema(fs.readFileSync(schemaPath, 'utf-8'));
+            schemas.push({
+              name: entry.name,
+              description: schema.description || '',
+              artifacts: schema.artifacts.map((a) => a.id),
+              source: 'package',
+            });
+          } catch {
+            // Skip invalid schemas
+          }
+        }
+      }
+    }
+  }
+
+  return schemas.sort((a, b) => a.name.localeCompare(b.name));
+}
diff --git a/src/core/artifact-graph/schema.ts b/src/core/artifact-graph/schema.ts
new file mode 100644
index 0000000..6371745
--- /dev/null
+++ b/src/core/artifact-graph/schema.ts
@@ -0,0 +1,124 @@
+import * as fs from 'node:fs';
+import { parse as parseYaml } from 'yaml';
+import { SchemaYamlSchema, type SchemaYaml, type Artifact } from './types.js';
+
+export class SchemaValidationError extends Error {
+  constructor(message: string) {
+    super(message);
+    this.name = 'SchemaValidationError';
+  }
+}
+
+/**
+ * Loads and validates an artifact schema from a YAML file.
+ */
+export function loadSchema(filePath: string): SchemaYaml {
+  const content = fs.readFileSync(filePath, 'utf-8');
+  return parseSchema(content);
+}
+
+/**
+ * Parses and validates an artifact schema from YAML content.
+ */
+export function parseSchema(yamlContent: string): SchemaYaml {
+  const parsed = parseYaml(yamlContent);
+
+  // Validate with Zod
+  const result = SchemaYamlSchema.safeParse(parsed);
+  if (!result.success) {
+    const errors = result.error.issues.map(e => `${e.path.join('.')}: ${e.message}`).join(', ');
+    throw new SchemaValidationError(`Invalid schema: ${errors}`);
+  }
+
+  const schema = result.data;
+
+  // Check for duplicate artifact IDs
+  validateNoDuplicateIds(schema.artifacts);
+
+  // Check that all requires references are valid
+  validateRequiresReferences(schema.artifacts);
+
+  // Check for cycles
+  validateNoCycles(schema.artifacts);
+
+  return schema;
+}
+
+/**
+ * Validates that there are no duplicate artifact IDs.
+ */
+function validateNoDuplicateIds(artifacts: Artifact[]): void {
+  const seen = new Set<string>();
+  for (const artifact of artifacts) {
+    if (seen.has(artifact.id)) {
+      throw new SchemaValidationError(`Duplicate artifact ID: ${artifact.id}`);
+    }
+    seen.add(artifact.id);
+  }
+}
+
+/**
+ * Validates that all `requires` references point to valid artifact IDs.
+ */
+function validateRequiresReferences(artifacts: Artifact[]): void {
+  const validIds = new Set(artifacts.map(a => a.id));
+
+  for (const artifact of artifacts) {
+    for (const req of artifact.requires) {
+      if (!validIds.has(req)) {
+        throw new SchemaValidationError(
+          `Invalid dependency reference in artifact '${artifact.id}': '${req}' does not exist`
+        );
+      }
+    }
+  }
+}
+
+/**
+ * Validates that there are no cyclic dependencies.
+ * Uses DFS to detect cycles and reports the full cycle path.
+ */
+function validateNoCycles(artifacts: Artifact[]): void {
+  const artifactMap = new Map(artifacts.map(a => [a.id, a]));
+  const visited = new Set<string>();
+  const inStack = new Set<string>();
+  const parent = new Map<string, string>();
+
+  function dfs(id: string): string | null {
+    visited.add(id);
+    inStack.add(id);
+
+    const artifact = artifactMap.get(id);
+    if (!artifact) return null;
+
+    for (const dep of artifact.requires) {
+      if (!visited.has(dep)) {
+        parent.set(dep, id);
+        const cycle = dfs(dep);
+        if (cycle) return cycle;
+      } else if (inStack.has(dep)) {
+        // Found a cycle - reconstruct the path
+        const cyclePath = [dep];
+        let current = id;
+        while (current !== dep) {
+          cyclePath.unshift(current);
+          current = parent.get(current)!;
+        }
+        cyclePath.unshift(dep);
+        return cyclePath.join(' â†’ ');
+      }
+    }
+
+    inStack.delete(id);
+    return null;
+  }
+
+  for (const artifact of artifacts) {
+    if (!visited.has(artifact.id)) {
+      const cycle = dfs(artifact.id);
+      if (cycle) {
+        throw new SchemaValidationError(`Cyclic dependency detected: ${cycle}`);
+      }
+    }
+  }
+}
diff --git a/src/core/artifact-graph/state.ts b/src/core/artifact-graph/state.ts
new file mode 100644
index 0000000..55c6fd0
--- /dev/null
+++ b/src/core/artifact-graph/state.ts
@@ -0,0 +1,64 @@
+import * as fs from 'node:fs';
+import * as path from 'node:path';
+import fg from 'fast-glob';
+import type { CompletedSet } from './types.js';
+import type { ArtifactGraph } from './graph.js';
+import { FileSystemUtils } from '../../utils/file-system.js';
+
+/**
+ * Detects which artifacts are completed by checking file existence in the change directory.
+ * Returns a Set of completed artifact IDs.
+ *
+ * @param graph - The artifact graph to check
+ * @param changeDir - The change directory to scan for files
+ * @returns Set of artifact IDs whose generated files exist
+ */
+export function detectCompleted(graph: ArtifactGraph, changeDir: string): CompletedSet {
+  const completed = new Set<string>();
+
+  // Handle missing change directory gracefully
+  if (!fs.existsSync(changeDir)) {
+    return completed;
+  }
+
+  for (const artifact of graph.getAllArtifacts()) {
+    if (isArtifactComplete(artifact.generates, changeDir)) {
+      completed.add(artifact.id);
+    }
+  }
+
+  return completed;
+}
+
+/**
+ * Checks if an artifact is complete by checking if its generated file(s) exist.
+ * Supports both simple paths and glob patterns.
+ */
+function isArtifactComplete(generates: string, changeDir: string): boolean {
+  const fullPattern = path.join(changeDir, generates);
+
+  // Check if it's a glob pattern
+  if (isGlobPattern(generates)) {
+    return hasGlobMatches(fullPattern);
+  }
+
+  // Simple file path - check if file exists
+  return fs.existsSync(fullPattern);
+}
+
+/**
+ * Checks if a path contains glob pattern characters.
+ */
+function isGlobPattern(pattern: string): boolean {
+  return pattern.includes('*') || pattern.includes('?') || pattern.includes('[');
+}
+
+/**
+ * Checks if a glob pattern has any matches.
+ * Normalizes Windows backslashes to forward slashes for cross-platform glob compatibility.
+ */
+function hasGlobMatches(pattern: string): boolean {
+  const normalizedPattern = FileSystemUtils.toPosixPath(pattern);
+  const matches = fg.sync(normalizedPattern, { onlyFiles: true });
+  return matches.length > 0;
+}
diff --git a/src/core/artifact-graph/types.ts b/src/core/artifact-graph/types.ts
new file mode 100644
index 0000000..fb0d127
--- /dev/null
+++ b/src/core/artifact-graph/types.ts
@@ -0,0 +1,65 @@
+import { z } from 'zod';
+
+// Artifact definition schema
+export const ArtifactSchema = z.object({
+  id: z.string().min(1, { error: 'Artifact ID is required' }),
+  generates: z.string().min(1, { error: 'generates field is required' }),
+  description: z.string(),
+  template: z.string().min(1, { error: 'template field is required' }),
+  instruction: z.string().optional(),
+  requires: z.array(z.string()).default([]),
+});
+
+// Apply phase configuration for schema-aware apply instructions
+export const ApplyPhaseSchema = z.object({
+  // Artifact IDs that must exist before apply is available
+  requires: z.array(z.string()).min(1, { error: 'At least one required artifact' }),
+  // Path to file with checkboxes for progress (relative to change dir), or null if no tracking
+  tracks: z.string().nullable().optional(),
+  // Custom guidance for the apply phase
+  instruction: z.string().optional(),
+});
+
+// Full schema YAML structure
+export const SchemaYamlSchema = z.object({
+  name: z.string().min(1, { error: 'Schema name is required' }),
+  version: z.number().int().positive({ error: 'Version must be a positive integer' }),
+  description: z.string().optional(),
+  artifacts: z.array(ArtifactSchema).min(1, { error: 'At least one artifact required' }),
+  // Optional apply phase configuration (for schema-aware apply instructions)
+  apply: ApplyPhaseSchema.optional(),
+});
+
+// Derived TypeScript types
+export type Artifact = z.infer<typeof ArtifactSchema>;
+export type ApplyPhase = z.infer<typeof ApplyPhaseSchema>;
+export type SchemaYaml = z.infer<typeof SchemaYamlSchema>;
+
+// Per-change metadata schema
+// Note: schema field is validated at parse time against available schemas
+// using a lazy import to avoid circular dependencies
+export const ChangeMetadataSchema = z.object({
+  // Required: which workflow schema this change uses
+  schema: z.string().min(1, { message: 'schema is required' }),
+
+  // Optional: creation timestamp (ISO date string)
+  created: z
+    .string()
+    .regex(/^\d{4}-\d{2}-\d{2}$/, {
+      message: 'created must be YYYY-MM-DD format',
+    })
+    .optional(),
+});
+
+export type ChangeMetadata = z.infer<typeof ChangeMetadataSchema>;
+
+// Runtime state types (not Zod - internal only)
+
+// Slice 1: Simple completion tracking via filesystem
+export type CompletedSet = Set<string>;
+
+// Return type for blocked query
+export interface BlockedArtifacts {
+  [artifactId: string]: string[];
+}
+
diff --git a/src/core/converters/json-converter.ts b/src/core/converters/json-converter.ts
index 162b4e7..b8468c2 100644
--- a/src/core/converters/json-converter.ts
+++ b/src/core/converters/json-converter.ts
@@ -3,6 +3,7 @@ import path from 'path';
 import { MarkdownParser } from '../parsers/markdown-parser.js';
 import { ChangeParser } from '../parsers/change-parser.js';
 import { Spec, Change } from '../schemas/index.js';
+import { FileSystemUtils } from '../../utils/file-system.js';
 
 export class JsonConverter {
   convertSpecToJson(filePath: string): string {
@@ -43,7 +44,7 @@ export class JsonConverter {
   }
 
   private extractNameFromPath(filePath: string): string {
-    const normalizedPath = filePath.replaceAll('\\', '/');
+    const normalizedPath = FileSystemUtils.toPosixPath(filePath);
     const parts = normalizedPath.split('/');
     
     for (let i = parts.length - 1; i >= 0; i--) {
diff --git a/src/core/global-config.ts b/src/core/global-config.ts
index b690113..271ca5a 100644
--- a/src/core/global-config.ts
+++ b/src/core/global-config.ts
@@ -5,6 +5,7 @@ import * as os from 'node:os';
 // Constants
 export const GLOBAL_CONFIG_DIR_NAME = 'openspec';
 export const GLOBAL_CONFIG_FILE_NAME = 'config.json';
+export const GLOBAL_DATA_DIR_NAME = 'openspec';
 
 // TypeScript interfaces
 export interface GlobalConfig {
@@ -45,6 +46,37 @@ export function getGlobalConfigDir(): string {
   return path.join(os.homedir(), '.config', GLOBAL_CONFIG_DIR_NAME);
 }
 
+/**
+ * Gets the global data directory path following XDG Base Directory Specification.
+ * Used for user data like schema overrides.
+ *
+ * - All platforms: $XDG_DATA_HOME/openspec/ if XDG_DATA_HOME is set
+ * - Unix/macOS fallback: ~/.local/share/openspec/
+ * - Windows fallback: %LOCALAPPDATA%/openspec/
+ */
+export function getGlobalDataDir(): string {
+  // XDG_DATA_HOME takes precedence on all platforms when explicitly set
+  const xdgDataHome = process.env.XDG_DATA_HOME;
+  if (xdgDataHome) {
+    return path.join(xdgDataHome, GLOBAL_DATA_DIR_NAME);
+  }
+
+  const platform = os.platform();
+
+  if (platform === 'win32') {
+    // Windows: use %LOCALAPPDATA%
+    const localAppData = process.env.LOCALAPPDATA;
+    if (localAppData) {
+      return path.join(localAppData, GLOBAL_DATA_DIR_NAME);
+    }
+    // Fallback for Windows if LOCALAPPDATA is not set
+    return path.join(os.homedir(), 'AppData', 'Local', GLOBAL_DATA_DIR_NAME);
+  }
+
+  // Unix/macOS fallback: ~/.local/share
+  return path.join(os.homedir(), '.local', 'share', GLOBAL_DATA_DIR_NAME);
+}
+
 /**
  * Gets the path to the global config file.
  */
diff --git a/src/core/index.ts b/src/core/index.ts
index 22afd94..e867709 100644
--- a/src/core/index.ts
+++ b/src/core/index.ts
@@ -2,9 +2,11 @@
 export {
   GLOBAL_CONFIG_DIR_NAME,
   GLOBAL_CONFIG_FILE_NAME,
+  GLOBAL_DATA_DIR_NAME,
   type GlobalConfig,
   getGlobalConfigDir,
   getGlobalConfigPath,
   getGlobalConfig,
-  saveGlobalConfig
+  saveGlobalConfig,
+  getGlobalDataDir
 } from './global-config.js';
\ No newline at end of file
diff --git a/src/core/list.ts b/src/core/list.ts
index c815540..3f40829 100644
--- a/src/core/list.ts
+++ b/src/core/list.ts
@@ -9,13 +9,78 @@ interface ChangeInfo {
   name: string;
   completedTasks: number;
   totalTasks: number;
+  lastModified: Date;
+}
+
+interface ListOptions {
+  sort?: 'recent' | 'name';
+  json?: boolean;
+}
+
+/**
+ * Get the most recent modification time of any file in a directory (recursive).
+ * Falls back to the directory's own mtime if no files are found.
+ */
+async function getLastModified(dirPath: string): Promise<Date> {
+  let latest: Date | null = null;
+
+  async function walk(dir: string): Promise<void> {
+    const entries = await fs.readdir(dir, { withFileTypes: true });
+    for (const entry of entries) {
+      const fullPath = path.join(dir, entry.name);
+      if (entry.isDirectory()) {
+        await walk(fullPath);
+      } else {
+        const stat = await fs.stat(fullPath);
+        if (latest === null || stat.mtime > latest) {
+          latest = stat.mtime;
+        }
+      }
+    }
+  }
+
+  await walk(dirPath);
+
+  // If no files found, use the directory's own modification time
+  if (latest === null) {
+    const dirStat = await fs.stat(dirPath);
+    return dirStat.mtime;
+  }
+
+  return latest;
+}
+
+/**
+ * Format a date as relative time (e.g., "2 hours ago", "3 days ago")
+ */
+function formatRelativeTime(date: Date): string {
+  const now = new Date();
+  const diffMs = now.getTime() - date.getTime();
+  const diffSecs = Math.floor(diffMs / 1000);
+  const diffMins = Math.floor(diffSecs / 60);
+  const diffHours = Math.floor(diffMins / 60);
+  const diffDays = Math.floor(diffHours / 24);
+
+  if (diffDays > 30) {
+    return date.toLocaleDateString();
+  } else if (diffDays > 0) {
+    return `${diffDays}d ago`;
+  } else if (diffHours > 0) {
+    return `${diffHours}h ago`;
+  } else if (diffMins > 0) {
+    return `${diffMins}m ago`;
+  } else {
+    return 'just now';
+  }
 }
 
 export class ListCommand {
-  async execute(targetPath: string = '.', mode: 'changes' | 'specs' = 'changes'): Promise<void> {
+  async execute(targetPath: string = '.', mode: 'changes' | 'specs' = 'changes', options: ListOptions = {}): Promise<void> {
+    const { sort = 'recent', json = false } = options;
+
     if (mode === 'changes') {
       const changesDir = path.join(targetPath, 'openspec', 'changes');
-      
+
       // Check if changes directory exists
       try {
         await fs.access(changesDir);
@@ -30,24 +95,48 @@ export class ListCommand {
         .map(entry => entry.name);
 
       if (changeDirs.length === 0) {
-        console.log('No active changes found.');
+        if (json) {
+          console.log(JSON.stringify({ changes: [] }));
+        } else {
+          console.log('No active changes found.');
+        }
         return;
       }
 
       // Collect information about each change
       const changes: ChangeInfo[] = [];
-      
+
       for (const changeDir of changeDirs) {
         const progress = await getTaskProgressForChange(changesDir, changeDir);
+        const changePath = path.join(changesDir, changeDir);
+        const lastModified = await getLastModified(changePath);
         changes.push({
           name: changeDir,
           completedTasks: progress.completed,
-          totalTasks: progress.total
+          totalTasks: progress.total,
+          lastModified
         });
       }
 
-      // Sort alphabetically by name
-      changes.sort((a, b) => a.name.localeCompare(b.name));
+      // Sort by preference (default: recent first)
+      if (sort === 'recent') {
+        changes.sort((a, b) => b.lastModified.getTime() - a.lastModified.getTime());
+      } else {
+        changes.sort((a, b) => a.name.localeCompare(b.name));
+      }
+
+      // JSON output for programmatic use
+      if (json) {
+        const jsonOutput = changes.map(c => ({
+          name: c.name,
+          completedTasks: c.completedTasks,
+          totalTasks: c.totalTasks,
+          lastModified: c.lastModified.toISOString(),
+          status: c.totalTasks === 0 ? 'no-tasks' : c.completedTasks === c.totalTasks ? 'complete' : 'in-progress'
+        }));
+        console.log(JSON.stringify({ changes: jsonOutput }, null, 2));
+        return;
+      }
 
       // Display results
       console.log('Changes:');
@@ -56,7 +145,8 @@ export class ListCommand {
       for (const change of changes) {
         const paddedName = change.name.padEnd(nameWidth);
         const status = formatTaskStatus({ total: change.totalTasks, completed: change.completedTasks });
-        console.log(`${padding}${paddedName}     ${status}`);
+        const timeAgo = formatRelativeTime(change.lastModified);
+        console.log(`${padding}${paddedName}     ${status.padEnd(12)}  ${timeAgo}`);
       }
       return;
     }
diff --git a/src/core/specs-apply.ts b/src/core/specs-apply.ts
new file mode 100644
index 0000000..9ce0f12
--- /dev/null
+++ b/src/core/specs-apply.ts
@@ -0,0 +1,483 @@
+/**
+ * Spec Application Logic
+ *
+ * Extracted from ArchiveCommand to enable standalone spec application.
+ * Applies delta specs from a change to main specs without archiving.
+ */
+
+import { promises as fs } from 'fs';
+import path from 'path';
+import chalk from 'chalk';
+import {
+  extractRequirementsSection,
+  parseDeltaSpec,
+  normalizeRequirementName,
+  type RequirementBlock,
+} from './parsers/requirement-blocks.js';
+import { Validator } from './validation/validator.js';
+
+// -----------------------------------------------------------------------------
+// Types
+// -----------------------------------------------------------------------------
+
+export interface SpecUpdate {
+  source: string;
+  target: string;
+  exists: boolean;
+}
+
+export interface ApplyResult {
+  capability: string;
+  added: number;
+  modified: number;
+  removed: number;
+  renamed: number;
+}
+
+export interface SpecsApplyOutput {
+  changeName: string;
+  capabilities: ApplyResult[];
+  totals: {
+    added: number;
+    modified: number;
+    removed: number;
+    renamed: number;
+  };
+  noChanges: boolean;
+}
+
+// -----------------------------------------------------------------------------
+// Public API
+// -----------------------------------------------------------------------------
+
+/**
+ * Find all delta spec files that need to be applied from a change.
+ */
+export async function findSpecUpdates(changeDir: string, mainSpecsDir: string): Promise<SpecUpdate[]> {
+  const updates: SpecUpdate[] = [];
+  const changeSpecsDir = path.join(changeDir, 'specs');
+
+  try {
+    const entries = await fs.readdir(changeSpecsDir, { withFileTypes: true });
+
+    for (const entry of entries) {
+      if (entry.isDirectory()) {
+        const specFile = path.join(changeSpecsDir, entry.name, 'spec.md');
+        const targetFile = path.join(mainSpecsDir, entry.name, 'spec.md');
+
+        try {
+          await fs.access(specFile);
+
+          // Check if target exists
+          let exists = false;
+          try {
+            await fs.access(targetFile);
+            exists = true;
+          } catch {
+            exists = false;
+          }
+
+          updates.push({
+            source: specFile,
+            target: targetFile,
+            exists,
+          });
+        } catch {
+          // Source spec doesn't exist, skip
+        }
+      }
+    }
+  } catch {
+    // No specs directory in change
+  }
+
+  return updates;
+}
+
+/**
+ * Build an updated spec by applying delta operations.
+ * Returns the rebuilt content and counts of operations.
+ */
+export async function buildUpdatedSpec(
+  update: SpecUpdate,
+  changeName: string
+): Promise<{ rebuilt: string; counts: { added: number; modified: number; removed: number; renamed: number } }> {
+  // Read change spec content (delta-format expected)
+  const changeContent = await fs.readFile(update.source, 'utf-8');
+
+  // Parse deltas from the change spec file
+  const plan = parseDeltaSpec(changeContent);
+  const specName = path.basename(path.dirname(update.target));
+
+  // Pre-validate duplicates within sections
+  const addedNames = new Set<string>();
+  for (const add of plan.added) {
+    const name = normalizeRequirementName(add.name);
+    if (addedNames.has(name)) {
+      throw new Error(
+        `${specName} validation failed - duplicate requirement in ADDED for header "### Requirement: ${add.name}"`
+      );
+    }
+    addedNames.add(name);
+  }
+  const modifiedNames = new Set<string>();
+  for (const mod of plan.modified) {
+    const name = normalizeRequirementName(mod.name);
+    if (modifiedNames.has(name)) {
+      throw new Error(
+        `${specName} validation failed - duplicate requirement in MODIFIED for header "### Requirement: ${mod.name}"`
+      );
+    }
+    modifiedNames.add(name);
+  }
+  const removedNamesSet = new Set<string>();
+  for (const rem of plan.removed) {
+    const name = normalizeRequirementName(rem);
+    if (removedNamesSet.has(name)) {
+      throw new Error(
+        `${specName} validation failed - duplicate requirement in REMOVED for header "### Requirement: ${rem}"`
+      );
+    }
+    removedNamesSet.add(name);
+  }
+  const renamedFromSet = new Set<string>();
+  const renamedToSet = new Set<string>();
+  for (const { from, to } of plan.renamed) {
+    const fromNorm = normalizeRequirementName(from);
+    const toNorm = normalizeRequirementName(to);
+    if (renamedFromSet.has(fromNorm)) {
+      throw new Error(
+        `${specName} validation failed - duplicate FROM in RENAMED for header "### Requirement: ${from}"`
+      );
+    }
+    if (renamedToSet.has(toNorm)) {
+      throw new Error(
+        `${specName} validation failed - duplicate TO in RENAMED for header "### Requirement: ${to}"`
+      );
+    }
+    renamedFromSet.add(fromNorm);
+    renamedToSet.add(toNorm);
+  }
+
+  // Pre-validate cross-section conflicts
+  const conflicts: Array<{ name: string; a: string; b: string }> = [];
+  for (const n of modifiedNames) {
+    if (removedNamesSet.has(n)) conflicts.push({ name: n, a: 'MODIFIED', b: 'REMOVED' });
+    if (addedNames.has(n)) conflicts.push({ name: n, a: 'MODIFIED', b: 'ADDED' });
+  }
+  for (const n of addedNames) {
+    if (removedNamesSet.has(n)) conflicts.push({ name: n, a: 'ADDED', b: 'REMOVED' });
+  }
+  // Renamed interplay: MODIFIED must reference the NEW header, not FROM
+  for (const { from, to } of plan.renamed) {
+    const fromNorm = normalizeRequirementName(from);
+    const toNorm = normalizeRequirementName(to);
+    if (modifiedNames.has(fromNorm)) {
+      throw new Error(
+        `${specName} validation failed - when a rename exists, MODIFIED must reference the NEW header "### Requirement: ${to}"`
+      );
+    }
+    // Detect ADDED colliding with a RENAMED TO
+    if (addedNames.has(toNorm)) {
+      throw new Error(
+        `${specName} validation failed - RENAMED TO header collides with ADDED for "### Requirement: ${to}"`
+      );
+    }
+  }
+  if (conflicts.length > 0) {
+    const c = conflicts[0];
+    throw new Error(
+      `${specName} validation failed - requirement present in multiple sections (${c.a} and ${c.b}) for header "### Requirement: ${c.name}"`
+    );
+  }
+  const hasAnyDelta = plan.added.length + plan.modified.length + plan.removed.length + plan.renamed.length > 0;
+  if (!hasAnyDelta) {
+    throw new Error(
+      `Delta parsing found no operations for ${path.basename(path.dirname(update.source))}. ` +
+        `Provide ADDED/MODIFIED/REMOVED/RENAMED sections in change spec.`
+    );
+  }
+
+  // Load or create base target content
+  let targetContent: string;
+  let isNewSpec = false;
+  try {
+    targetContent = await fs.readFile(update.target, 'utf-8');
+  } catch {
+    // Target spec does not exist; MODIFIED and RENAMED are not allowed for new specs
+    // REMOVED will be ignored with a warning since there's nothing to remove
+    if (plan.modified.length > 0 || plan.renamed.length > 0) {
+      throw new Error(
+        `${specName}: target spec does not exist; only ADDED requirements are allowed for new specs. MODIFIED and RENAMED operations require an existing spec.`
+      );
+    }
+    // Warn about REMOVED requirements being ignored for new specs
+    if (plan.removed.length > 0) {
+      console.log(
+        chalk.yellow(
+          `âš ï¸  Warning: ${specName} - ${plan.removed.length} REMOVED requirement(s) ignored for new spec (nothing to remove).`
+        )
+      );
+    }
+    isNewSpec = true;
+    targetContent = buildSpecSkeleton(specName, changeName);
+  }
+
+  // Extract requirements section and build name->block map
+  const parts = extractRequirementsSection(targetContent);
+  const nameToBlock = new Map<string, RequirementBlock>();
+  for (const block of parts.bodyBlocks) {
+    nameToBlock.set(normalizeRequirementName(block.name), block);
+  }
+
+  // Apply operations in order: RENAMED â†’ REMOVED â†’ MODIFIED â†’ ADDED
+  // RENAMED
+  for (const r of plan.renamed) {
+    const from = normalizeRequirementName(r.from);
+    const to = normalizeRequirementName(r.to);
+    if (!nameToBlock.has(from)) {
+      throw new Error(`${specName} RENAMED failed for header "### Requirement: ${r.from}" - source not found`);
+    }
+    if (nameToBlock.has(to)) {
+      throw new Error(`${specName} RENAMED failed for header "### Requirement: ${r.to}" - target already exists`);
+    }
+    const block = nameToBlock.get(from)!;
+    const newHeader = `### Requirement: ${to}`;
+    const rawLines = block.raw.split('\n');
+    rawLines[0] = newHeader;
+    const renamedBlock: RequirementBlock = {
+      headerLine: newHeader,
+      name: to,
+      raw: rawLines.join('\n'),
+    };
+    nameToBlock.delete(from);
+    nameToBlock.set(to, renamedBlock);
+  }
+
+  // REMOVED
+  for (const name of plan.removed) {
+    const key = normalizeRequirementName(name);
+    if (!nameToBlock.has(key)) {
+      // For new specs, REMOVED requirements are already warned about and ignored
+      // For existing specs, missing requirements are an error
+      if (!isNewSpec) {
+        throw new Error(`${specName} REMOVED failed for header "### Requirement: ${name}" - not found`);
+      }
+      // Skip removal for new specs (already warned above)
+      continue;
+    }
+    nameToBlock.delete(key);
+  }
+
+  // MODIFIED
+  for (const mod of plan.modified) {
+    const key = normalizeRequirementName(mod.name);
+    if (!nameToBlock.has(key)) {
+      throw new Error(`${specName} MODIFIED failed for header "### Requirement: ${mod.name}" - not found`);
+    }
+    // Replace block with provided raw (ensure header line matches key)
+    const modHeaderMatch = mod.raw.split('\n')[0].match(/^###\s*Requirement:\s*(.+)\s*$/);
+    if (!modHeaderMatch || normalizeRequirementName(modHeaderMatch[1]) !== key) {
+      throw new Error(
+        `${specName} MODIFIED failed for header "### Requirement: ${mod.name}" - header mismatch in content`
+      );
+    }
+    nameToBlock.set(key, mod);
+  }
+
+  // ADDED
+  for (const add of plan.added) {
+    const key = normalizeRequirementName(add.name);
+    if (nameToBlock.has(key)) {
+      throw new Error(`${specName} ADDED failed for header "### Requirement: ${add.name}" - already exists`);
+    }
+    nameToBlock.set(key, add);
+  }
+
+  // Duplicates within resulting map are implicitly prevented by key uniqueness.
+
+  // Recompose requirements section preserving original ordering where possible
+  const keptOrder: RequirementBlock[] = [];
+  const seen = new Set<string>();
+  for (const block of parts.bodyBlocks) {
+    const key = normalizeRequirementName(block.name);
+    const replacement = nameToBlock.get(key);
+    if (replacement) {
+      keptOrder.push(replacement);
+      seen.add(key);
+    }
+  }
+  // Append any newly added that were not in original order
+  for (const [key, block] of nameToBlock.entries()) {
+    if (!seen.has(key)) {
+      keptOrder.push(block);
+    }
+  }
+
+  const reqBody = [parts.preamble && parts.preamble.trim() ? parts.preamble.trimEnd() : '']
+    .filter(Boolean)
+    .concat(keptOrder.map((b) => b.raw))
+    .join('\n\n')
+    .trimEnd();
+
+  const rebuilt = [parts.before.trimEnd(), parts.headerLine, reqBody, parts.after]
+    .filter((s, idx) => !(idx === 0 && s === ''))
+    .join('\n')
+    .replace(/\n{3,}/g, '\n\n');
+
+  return {
+    rebuilt,
+    counts: {
+      added: plan.added.length,
+      modified: plan.modified.length,
+      removed: plan.removed.length,
+      renamed: plan.renamed.length,
+    },
+  };
+}
+
+/**
+ * Write an updated spec to disk.
+ */
+export async function writeUpdatedSpec(
+  update: SpecUpdate,
+  rebuilt: string,
+  counts: { added: number; modified: number; removed: number; renamed: number }
+): Promise<void> {
+  // Create target directory if needed
+  const targetDir = path.dirname(update.target);
+  await fs.mkdir(targetDir, { recursive: true });
+  await fs.writeFile(update.target, rebuilt);
+
+  const specName = path.basename(path.dirname(update.target));
+  console.log(`Applying changes to openspec/specs/${specName}/spec.md:`);
+  if (counts.added) console.log(`  + ${counts.added} added`);
+  if (counts.modified) console.log(`  ~ ${counts.modified} modified`);
+  if (counts.removed) console.log(`  - ${counts.removed} removed`);
+  if (counts.renamed) console.log(`  â†’ ${counts.renamed} renamed`);
+}
+
+/**
+ * Build a skeleton spec for new capabilities.
+ */
+export function buildSpecSkeleton(specFolderName: string, changeName: string): string {
+  const titleBase = specFolderName;
+  return `# ${titleBase} Specification\n\n## Purpose\nTBD - created by archiving change ${changeName}. Update Purpose after archive.\n\n## Requirements\n`;
+}
+
+/**
+ * Apply all delta specs from a change to main specs.
+ *
+ * @param projectRoot - The project root directory
+ * @param changeName - The name of the change to apply
+ * @param options - Options for the operation
+ * @returns Result of the operation with counts
+ */
+export async function applySpecs(
+  projectRoot: string,
+  changeName: string,
+  options: {
+    dryRun?: boolean;
+    skipValidation?: boolean;
+    silent?: boolean;
+  } = {}
+): Promise<SpecsApplyOutput> {
+  const changeDir = path.join(projectRoot, 'openspec', 'changes', changeName);
+  const mainSpecsDir = path.join(projectRoot, 'openspec', 'specs');
+
+  // Verify change exists
+  try {
+    const stat = await fs.stat(changeDir);
+    if (!stat.isDirectory()) {
+      throw new Error(`Change '${changeName}' not found.`);
+    }
+  } catch {
+    throw new Error(`Change '${changeName}' not found.`);
+  }
+
+  // Find specs to update
+  const specUpdates = await findSpecUpdates(changeDir, mainSpecsDir);
+
+  if (specUpdates.length === 0) {
+    return {
+      changeName,
+      capabilities: [],
+      totals: { added: 0, modified: 0, removed: 0, renamed: 0 },
+      noChanges: true,
+    };
+  }
+
+  // Prepare all updates first (validation pass, no writes)
+  const prepared: Array<{
+    update: SpecUpdate;
+    rebuilt: string;
+    counts: { added: number; modified: number; removed: number; renamed: number };
+  }> = [];
+
+  for (const update of specUpdates) {
+    const built = await buildUpdatedSpec(update, changeName);
+    prepared.push({ update, rebuilt: built.rebuilt, counts: built.counts });
+  }
+
+  // Validate rebuilt specs unless validation is skipped
+  if (!options.skipValidation) {
+    const validator = new Validator();
+    for (const p of prepared) {
+      const specName = path.basename(path.dirname(p.update.target));
+      const report = await validator.validateSpecContent(specName, p.rebuilt);
+      if (!report.valid) {
+        const errors = report.issues
+          .filter((i) => i.level === 'ERROR')
+          .map((i) => `  âœ— ${i.message}`)
+          .join('\n');
+        throw new Error(`Validation errors in rebuilt spec for ${specName}:\n${errors}`);
+      }
+    }
+  }
+
+  // Build results
+  const capabilities: ApplyResult[] = [];
+  const totals = { added: 0, modified: 0, removed: 0, renamed: 0 };
+
+  for (const p of prepared) {
+    const capability = path.basename(path.dirname(p.update.target));
+
+    if (!options.dryRun) {
+      // Write the updated spec
+      const targetDir = path.dirname(p.update.target);
+      await fs.mkdir(targetDir, { recursive: true });
+      await fs.writeFile(p.update.target, p.rebuilt);
+
+      if (!options.silent) {
+        console.log(`Applying changes to openspec/specs/${capability}/spec.md:`);
+        if (p.counts.added) console.log(`  + ${p.counts.added} added`);
+        if (p.counts.modified) console.log(`  ~ ${p.counts.modified} modified`);
+        if (p.counts.removed) console.log(`  - ${p.counts.removed} removed`);
+        if (p.counts.renamed) console.log(`  â†’ ${p.counts.renamed} renamed`);
+      }
+    } else if (!options.silent) {
+      console.log(`Would apply changes to openspec/specs/${capability}/spec.md:`);
+      if (p.counts.added) console.log(`  + ${p.counts.added} added`);
+      if (p.counts.modified) console.log(`  ~ ${p.counts.modified} modified`);
+      if (p.counts.removed) console.log(`  - ${p.counts.removed} removed`);
+      if (p.counts.renamed) console.log(`  â†’ ${p.counts.renamed} renamed`);
+    }
+
+    capabilities.push({
+      capability,
+      ...p.counts,
+    });
+
+    totals.added += p.counts.added;
+    totals.modified += p.counts.modified;
+    totals.removed += p.counts.removed;
+    totals.renamed += p.counts.renamed;
+  }
+
+  return {
+    changeName,
+    capabilities,
+    totals,
+    noChanges: false,
+  };
+}
diff --git a/src/core/templates/skill-templates.ts b/src/core/templates/skill-templates.ts
new file mode 100644
index 0000000..8723e55
--- /dev/null
+++ b/src/core/templates/skill-templates.ts
@@ -0,0 +1,1502 @@
+/**
+ * Agent Skill Templates
+ *
+ * Templates for generating Agent Skills compatible with:
+ * - Claude Code
+ * - Cursor (Settings â†’ Rules â†’ Import Settings)
+ * - Windsurf
+ * - Other Agent Skills-compatible editors
+ */
+
+export interface SkillTemplate {
+  name: string;
+  description: string;
+  instructions: string;
+}
+
+/**
+ * Template for openspec-new-change skill
+ * Based on /opsx:new command
+ */
+export function getNewChangeSkillTemplate(): SkillTemplate {
+  return {
+    name: 'openspec-new-change',
+    description: 'Start a new OpenSpec change using the experimental artifact workflow. Use when the user wants to create a new feature, fix, or modification with a structured step-by-step approach.',
+    instructions: `Start a new change using the experimental artifact-driven approach.
+
+**Input**: The user's request should include a change name (kebab-case) OR a description of what they want to build.
+
+**Steps**
+
+1. **If no clear input provided, ask what they want to build**
+
+   Use the **AskUserQuestion tool** (open-ended, no preset options) to ask:
+   > "What change do you want to work on? Describe what you want to build or fix."
+
+   From their description, derive a kebab-case name (e.g., "add user authentication" â†’ \`add-user-auth\`).
+
+   **IMPORTANT**: Do NOT proceed without understanding what the user wants to build.
+
+2. **Select a workflow schema**
+
+   Run \`openspec schemas --json\` to get available schemas with descriptions.
+
+   Use the **AskUserQuestion tool** to let the user choose a workflow:
+   - Present each schema with its description
+   - Mark \`spec-driven\` as "(default)" if it's available
+   - Example options: "spec-driven - proposal â†’ specs â†’ design â†’ tasks (default)", "tdd - tests â†’ implementation â†’ docs"
+
+   If user doesn't have a preference, default to \`spec-driven\`.
+
+3. **Create the change directory**
+   \`\`\`bash
+   openspec new change "<name>" --schema "<selected-schema>"
+   \`\`\`
+   This creates a scaffolded change at \`openspec/changes/<name>/\` with the selected schema.
+
+4. **Show the artifact status**
+   \`\`\`bash
+   openspec status --change "<name>"
+   \`\`\`
+   This shows which artifacts need to be created and which are ready (dependencies satisfied).
+
+5. **Get instructions for the first artifact**
+   The first artifact depends on the schema (e.g., \`proposal\` for spec-driven, \`spec\` for tdd).
+   Check the status output to find the first artifact with status "ready".
+   \`\`\`bash
+   openspec instructions <first-artifact-id> --change "<name>"
+   \`\`\`
+   This outputs the template and context for creating the first artifact.
+
+6. **STOP and wait for user direction**
+
+**Output**
+
+After completing the steps, summarize:
+- Change name and location
+- Selected schema/workflow and its artifact sequence
+- Current status (0/N artifacts complete)
+- The template for the first artifact
+- Prompt: "Ready to create the first artifact? Just describe what this change is about and I'll draft it, or ask me to continue."
+
+**Guardrails**
+- Do NOT create any artifacts yet - just show the instructions
+- Do NOT advance beyond showing the first artifact template
+- If the name is invalid (not kebab-case), ask for a valid name
+- If a change with that name already exists, suggest continuing that change instead
+- Always pass --schema to preserve the user's workflow choice`
+  };
+}
+
+/**
+ * Template for openspec-continue-change skill
+ * Based on /opsx:continue command
+ */
+export function getContinueChangeSkillTemplate(): SkillTemplate {
+  return {
+    name: 'openspec-continue-change',
+    description: 'Continue working on an OpenSpec change by creating the next artifact. Use when the user wants to progress their change, create the next artifact, or continue their workflow.',
+    instructions: `Continue working on a change by creating the next artifact.
+
+**Input**: Optionally specify a change name. If omitted, MUST prompt for available changes.
+
+**Steps**
+
+1. **If no change name provided, prompt for selection**
+
+   Run \`openspec list --json\` to get available changes sorted by most recently modified. Then use the **AskUserQuestion tool** to let the user select which change to work on.
+
+   Present the top 3-4 most recently modified changes as options, showing:
+   - Change name
+   - Schema (from \`schema\` field if present, otherwise "spec-driven")
+   - Status (e.g., "0/5 tasks", "complete", "no tasks")
+   - How recently it was modified (from \`lastModified\` field)
+
+   Mark the most recently modified change as "(Recommended)" since it's likely what the user wants to continue.
+
+   **IMPORTANT**: Do NOT guess or auto-select a change. Always let the user choose.
+
+2. **Check current status**
+   \`\`\`bash
+   openspec status --change "<name>" --json
+   \`\`\`
+   Parse the JSON to understand current state. The response includes:
+   - \`schemaName\`: The workflow schema being used (e.g., "spec-driven", "tdd")
+   - \`artifacts\`: Array of artifacts with their status ("done", "ready", "blocked")
+   - \`isComplete\`: Boolean indicating if all artifacts are complete
+
+3. **Act based on status**:
+
+   ---
+
+   **If all artifacts are complete (\`isComplete: true\`)**:
+   - Congratulate the user
+   - Show final status including the schema used
+   - Suggest: "All artifacts created! You can now implement this change or archive it."
+   - STOP
+
+   ---
+
+   **If artifacts are ready to create** (status shows artifacts with \`status: "ready"\`):
+   - Pick the FIRST artifact with \`status: "ready"\` from the status output
+   - Get its instructions:
+     \`\`\`bash
+     openspec instructions <artifact-id> --change "<name>" --json
+     \`\`\`
+   - Parse the JSON to get template, dependencies, and what it unlocks
+   - **Create the artifact file** using the template as a starting point:
+     - Read any completed dependency files for context
+     - Fill in the template based on context and user's goals
+     - Write to the output path specified in instructions
+   - Show what was created and what's now unlocked
+   - STOP after creating ONE artifact
+
+   ---
+
+   **If no artifacts are ready (all blocked)**:
+   - This shouldn't happen with a valid schema
+   - Show status and suggest checking for issues
+
+4. **After creating an artifact, show progress**
+   \`\`\`bash
+   openspec status --change "<name>"
+   \`\`\`
+
+**Output**
+
+After each invocation, show:
+- Which artifact was created
+- Schema workflow being used
+- Current progress (N/M complete)
+- What artifacts are now unlocked
+- Prompt: "Want to continue? Just ask me to continue or tell me what to do next."
+
+**Artifact Creation Guidelines**
+
+The artifact types and their purpose depend on the schema. Use the \`instruction\` field from the instructions output to understand what to create.
+
+Common artifact patterns:
+
+**spec-driven schema** (proposal â†’ specs â†’ design â†’ tasks):
+- **proposal.md**: Ask user about the change if not clear. Fill in Why, What Changes, Capabilities, Impact.
+  - The Capabilities section is critical - each capability listed will need a spec file.
+- **specs/*.md**: Create one spec per capability listed in the proposal.
+- **design.md**: Document technical decisions, architecture, and implementation approach.
+- **tasks.md**: Break down implementation into checkboxed tasks.
+
+**tdd schema** (spec â†’ tests â†’ implementation â†’ docs):
+- **spec.md**: Feature specification defining what to build.
+- **tests/*.test.ts**: Write tests BEFORE implementation (TDD red phase).
+- **src/*.ts**: Implement to make tests pass (TDD green phase).
+- **docs/*.md**: Document the implemented feature.
+
+For other schemas, follow the \`instruction\` field from the CLI output.
+
+**Guardrails**
+- Create ONE artifact per invocation
+- Always read dependency artifacts before creating a new one
+- Never skip artifacts or create out of order
+- If context is unclear, ask the user before creating
+- Verify the artifact file exists after writing before marking progress
+- Use the schema's artifact sequence, don't assume specific artifact names`
+  };
+}
+
+/**
+ * Template for openspec-apply-change skill
+ * For implementing tasks from a completed (or in-progress) change
+ */
+export function getApplyChangeSkillTemplate(): SkillTemplate {
+  return {
+    name: 'openspec-apply-change',
+    description: 'Implement tasks from an OpenSpec change. Use when the user wants to start implementing, continue implementation, or work through tasks.',
+    instructions: `Implement tasks from an OpenSpec change.
+
+**Input**: Optionally specify a change name. If omitted, MUST prompt for available changes.
+
+**Steps**
+
+1. **If no change name provided, prompt for selection**
+
+   Run \`openspec list --json\` to get available changes. Use the **AskUserQuestion tool** to let the user select.
+
+   Show changes that are implementation-ready (have tasks artifact).
+   Include the schema used for each change if available.
+   Mark changes with incomplete tasks as "(In Progress)".
+
+   **IMPORTANT**: Do NOT guess or auto-select a change. Always let the user choose.
+
+2. **Check status to understand the schema**
+   \`\`\`bash
+   openspec status --change "<name>" --json
+   \`\`\`
+   Parse the JSON to understand:
+   - \`schemaName\`: The workflow being used (e.g., "spec-driven", "tdd")
+   - Which artifact contains the tasks (typically "tasks" for spec-driven, check status for others)
+
+3. **Get apply instructions**
+
+   \`\`\`bash
+   openspec instructions apply --change "<name>" --json
+   \`\`\`
+
+   This returns:
+   - Context file paths (varies by schema - could be proposal/specs/design/tasks or spec/tests/implementation/docs)
+   - Progress (total, complete, remaining)
+   - Task list with status
+   - Dynamic instruction based on current state
+
+   **Handle states:**
+   - If \`state: "blocked"\` (missing artifacts): show message, suggest using openspec-continue-change
+   - If \`state: "all_done"\`: congratulate, suggest archive
+   - Otherwise: proceed to implementation
+
+4. **Read context files**
+
+   Read the files listed in \`contextFiles\` from the apply instructions output.
+   The files depend on the schema being used:
+   - **spec-driven**: proposal, specs, design, tasks
+   - **tdd**: spec, tests, implementation, docs
+   - Other schemas: follow the contextFiles from CLI output
+
+5. **Show current progress**
+
+   Display:
+   - Schema being used
+   - Progress: "N/M tasks complete"
+   - Remaining tasks overview
+   - Dynamic instruction from CLI
+
+6. **Implement tasks (loop until done or blocked)**
+
+   For each pending task:
+   - Show which task is being worked on
+   - Make the code changes required
+   - Keep changes minimal and focused
+   - Mark task complete in the tasks file: \`- [ ]\` â†’ \`- [x]\`
+   - Continue to next task
+
+   **Pause if:**
+   - Task is unclear â†’ ask for clarification
+   - Implementation reveals a design issue â†’ suggest updating artifacts
+   - Error or blocker encountered â†’ report and wait for guidance
+   - User interrupts
+
+7. **On completion or pause, show status**
+
+   Display:
+   - Tasks completed this session
+   - Overall progress: "N/M tasks complete"
+   - If all done: suggest archive
+   - If paused: explain why and wait for guidance
+
+**Output During Implementation**
+
+\`\`\`
+## Implementing: <change-name> (schema: <schema-name>)
+
+Working on task 3/7: <task description>
+[...implementation happening...]
+âœ“ Task complete
+
+Working on task 4/7: <task description>
+[...implementation happening...]
+âœ“ Task complete
+\`\`\`
+
+**Output On Completion**
+
+\`\`\`
+## Implementation Complete
+
+**Change:** <change-name>
+**Schema:** <schema-name>
+**Progress:** 7/7 tasks complete âœ“
+
+### Completed This Session
+- [x] Task 1
+- [x] Task 2
+...
+
+All tasks complete! Ready to archive this change.
+\`\`\`
+
+**Output On Pause (Issue Encountered)**
+
+\`\`\`
+## Implementation Paused
+
+**Change:** <change-name>
+**Schema:** <schema-name>
+**Progress:** 4/7 tasks complete
+
+### Issue Encountered
+<description of the issue>
+
+**Options:**
+1. <option 1>
+2. <option 2>
+3. Other approach
+
+What would you like to do?
+\`\`\`
+
+**Guardrails**
+- Keep going through tasks until done or blocked
+- Always read context files before starting (from the apply instructions output)
+- If task is ambiguous, pause and ask before implementing
+- If implementation reveals issues, pause and suggest artifact updates
+- Keep code changes minimal and scoped to each task
+- Update task checkbox immediately after completing each task
+- Pause on errors, blockers, or unclear requirements - don't guess
+- Use contextFiles from CLI output, don't assume specific file names
+
+**Fluid Workflow Integration**
+
+This skill supports the "actions on a change" model:
+
+- **Can be invoked anytime**: Before all artifacts are done (if tasks exist), after partial implementation, interleaved with other actions
+- **Allows artifact updates**: If implementation reveals design issues, suggest updating artifacts - not phase-locked, work fluidly`
+  };
+}
+
+/**
+ * Template for openspec-ff-change skill
+ * Fast-forward through artifact creation
+ */
+export function getFfChangeSkillTemplate(): SkillTemplate {
+  return {
+    name: 'openspec-ff-change',
+    description: 'Fast-forward through OpenSpec artifact creation. Use when the user wants to quickly create all artifacts needed for implementation without stepping through each one individually.',
+    instructions: `Fast-forward through artifact creation - generate everything needed to start implementation in one go.
+
+**Input**: The user's request should include a change name (kebab-case) OR a description of what they want to build.
+
+**Steps**
+
+1. **If no clear input provided, ask what they want to build**
+
+   Use the **AskUserQuestion tool** (open-ended, no preset options) to ask:
+   > "What change do you want to work on? Describe what you want to build or fix."
+
+   From their description, derive a kebab-case name (e.g., "add user authentication" â†’ \`add-user-auth\`).
+
+   **IMPORTANT**: Do NOT proceed without understanding what the user wants to build.
+
+2. **Create the change directory**
+   \`\`\`bash
+   openspec new change "<name>"
+   \`\`\`
+   This creates a scaffolded change at \`openspec/changes/<name>/\`.
+
+3. **Get the artifact build order**
+   \`\`\`bash
+   openspec status --change "<name>" --json
+   \`\`\`
+   Parse the JSON to get:
+   - \`applyRequires\`: array of artifact IDs needed before implementation (e.g., \`["tasks"]\`)
+   - \`artifacts\`: list of all artifacts with their status and dependencies
+
+4. **Create artifacts in sequence until apply-ready**
+
+   Use the **TodoWrite tool** to track progress through the artifacts.
+
+   Loop through artifacts in dependency order (artifacts with no pending dependencies first):
+
+   a. **For each artifact that is \`ready\` (dependencies satisfied)**:
+      - Get instructions:
+        \`\`\`bash
+        openspec instructions <artifact-id> --change "<name>" --json
+        \`\`\`
+      - The instructions JSON includes:
+        - \`template\`: The template content to use
+        - \`instruction\`: Schema-specific guidance for this artifact type
+        - \`outputPath\`: Where to write the artifact
+        - \`dependencies\`: Completed artifacts to read for context
+      - Read any completed dependency files for context
+      - Create the artifact file following the schema's \`instruction\`
+      - Show brief progress: "âœ“ Created <artifact-id>"
+
+   b. **Continue until all \`applyRequires\` artifacts are complete**
+      - After creating each artifact, re-run \`openspec status --change "<name>" --json\`
+      - Check if every artifact ID in \`applyRequires\` has \`status: "done"\` in the artifacts array
+      - Stop when all \`applyRequires\` artifacts are done
+
+   c. **If an artifact requires user input** (unclear context):
+      - Use **AskUserQuestion tool** to clarify
+      - Then continue with creation
+
+5. **Show final status**
+   \`\`\`bash
+   openspec status --change "<name>"
+   \`\`\`
+
+**Output**
+
+After completing all artifacts, summarize:
+- Change name and location
+- List of artifacts created with brief descriptions
+- What's ready: "All artifacts created! Ready for implementation."
+- Prompt: "Run \`/opsx:apply\` or ask me to implement to start working on the tasks."
+
+**Artifact Creation Guidelines**
+
+- Follow the \`instruction\` field from \`openspec instructions\` for each artifact type
+- The schema defines what each artifact should contain - follow it
+- Read dependency artifacts for context before creating new ones
+- Use the \`template\` as a starting point, filling in based on context
+
+**Guardrails**
+- Create ALL artifacts needed for implementation (as defined by schema's \`apply.requires\`)
+- Always read dependency artifacts before creating a new one
+- If context is critically unclear, ask the user - but prefer making reasonable decisions to keep momentum
+- If a change with that name already exists, suggest continuing that change instead
+- Verify each artifact file exists after writing before proceeding to next`
+  };
+}
+
+/**
+ * Template for openspec-sync-specs skill
+ * For syncing delta specs from a change to main specs (agent-driven)
+ */
+export function getSyncSpecsSkillTemplate(): SkillTemplate {
+  return {
+    name: 'openspec-sync-specs',
+    description: 'Sync delta specs from a change to main specs. Use when the user wants to update main specs with changes from a delta spec, without archiving the change.',
+    instructions: `Sync delta specs from a change to main specs.
+
+This is an **agent-driven** operation - you will read delta specs and directly edit main specs to apply the changes. This allows intelligent merging (e.g., adding a scenario without copying the entire requirement).
+
+**Input**: Optionally specify a change name. If omitted, MUST prompt for available changes.
+
+**Steps**
+
+1. **If no change name provided, prompt for selection**
+
+   Run \`openspec list --json\` to get available changes. Use the **AskUserQuestion tool** to let the user select.
+
+   Show changes that have delta specs (under \`specs/\` directory).
+
+   **IMPORTANT**: Do NOT guess or auto-select a change. Always let the user choose.
+
+2. **Find delta specs**
+
+   Look for delta spec files in \`openspec/changes/<name>/specs/*/spec.md\`.
+
+   Each delta spec file contains sections like:
+   - \`## ADDED Requirements\` - New requirements to add
+   - \`## MODIFIED Requirements\` - Changes to existing requirements
+   - \`## REMOVED Requirements\` - Requirements to remove
+   - \`## RENAMED Requirements\` - Requirements to rename (FROM:/TO: format)
+
+   If no delta specs found, inform user and stop.
+
+3. **For each delta spec, apply changes to main specs**
+
+   For each capability with a delta spec at \`openspec/changes/<name>/specs/<capability>/spec.md\`:
+
+   a. **Read the delta spec** to understand the intended changes
+
+   b. **Read the main spec** at \`openspec/specs/<capability>/spec.md\` (may not exist yet)
+
+   c. **Apply changes intelligently**:
+
+      **ADDED Requirements:**
+      - If requirement doesn't exist in main spec â†’ add it
+      - If requirement already exists â†’ update it to match (treat as implicit MODIFIED)
+
+      **MODIFIED Requirements:**
+      - Find the requirement in main spec
+      - Apply the changes - this can be:
+        - Adding new scenarios (don't need to copy existing ones)
+        - Modifying existing scenarios
+        - Changing the requirement description
+      - Preserve scenarios/content not mentioned in the delta
+
+      **REMOVED Requirements:**
+      - Remove the entire requirement block from main spec
+
+      **RENAMED Requirements:**
+      - Find the FROM requirement, rename to TO
+
+   d. **Create new main spec** if capability doesn't exist yet:
+      - Create \`openspec/specs/<capability>/spec.md\`
+      - Add Purpose section (can be brief, mark as TBD)
+      - Add Requirements section with the ADDED requirements
+
+4. **Show summary**
+
+   After applying all changes, summarize:
+   - Which capabilities were updated
+   - What changes were made (requirements added/modified/removed/renamed)
+
+**Delta Spec Format Reference**
+
+\`\`\`markdown
+## ADDED Requirements
+
+### Requirement: New Feature
+The system SHALL do something new.
+
+#### Scenario: Basic case
+- **WHEN** user does X
+- **THEN** system does Y
+
+## MODIFIED Requirements
+
+### Requirement: Existing Feature
+#### Scenario: New scenario to add
+- **WHEN** user does A
+- **THEN** system does B
+
+## REMOVED Requirements
+
+### Requirement: Deprecated Feature
+
+## RENAMED Requirements
+
+- FROM: \`### Requirement: Old Name\`
+- TO: \`### Requirement: New Name\`
+\`\`\`
+
+**Key Principle: Intelligent Merging**
+
+Unlike programmatic merging, you can apply **partial updates**:
+- To add a scenario, just include that scenario under MODIFIED - don't copy existing scenarios
+- The delta represents *intent*, not a wholesale replacement
+- Use your judgment to merge changes sensibly
+
+**Output On Success**
+
+\`\`\`
+## Specs Synced: <change-name>
+
+Updated main specs:
+
+**<capability-1>**:
+- Added requirement: "New Feature"
+- Modified requirement: "Existing Feature" (added 1 scenario)
+
+**<capability-2>**:
+- Created new spec file
+- Added requirement: "Another Feature"
+
+Main specs are now updated. The change remains active - archive when implementation is complete.
+\`\`\`
+
+**Guardrails**
+- Read both delta and main specs before making changes
+- Preserve existing content not mentioned in delta
+- If something is unclear, ask for clarification
+- Show what you're changing as you go
+- The operation should be idempotent - running twice should give same result`
+  };
+}
+
+// -----------------------------------------------------------------------------
+// Slash Command Templates
+// -----------------------------------------------------------------------------
+
+export interface CommandTemplate {
+  name: string;
+  description: string;
+  category: string;
+  tags: string[];
+  content: string;
+}
+
+/**
+ * Template for /opsx:new slash command
+ */
+export function getOpsxNewCommandTemplate(): CommandTemplate {
+  return {
+    name: 'OPSX: New',
+    description: 'Start a new change using the experimental artifact workflow (OPSX)',
+    category: 'Workflow',
+    tags: ['workflow', 'artifacts', 'experimental'],
+    content: `Start a new change using the experimental artifact-driven approach.
+
+**Input**: The argument after \`/opsx:new\` is the change name (kebab-case), OR a description of what the user wants to build.
+
+**Steps**
+
+1. **If no input provided, ask what they want to build**
+
+   Use the **AskUserQuestion tool** (open-ended, no preset options) to ask:
+   > "What change do you want to work on? Describe what you want to build or fix."
+
+   From their description, derive a kebab-case name (e.g., "add user authentication" â†’ \`add-user-auth\`).
+
+   **IMPORTANT**: Do NOT proceed without understanding what the user wants to build.
+
+2. **Select a workflow schema**
+
+   Run \`openspec schemas --json\` to get available schemas with descriptions.
+
+   Use the **AskUserQuestion tool** to let the user choose a workflow:
+   - Present each schema with its description
+   - Mark \`spec-driven\` as "(default)" if it's available
+   - Example options: "spec-driven - proposal â†’ specs â†’ design â†’ tasks (default)", "tdd - tests â†’ implementation â†’ docs"
+
+   If user doesn't have a preference, default to \`spec-driven\`.
+
+3. **Create the change directory**
+   \`\`\`bash
+   openspec new change "<name>" --schema "<selected-schema>"
+   \`\`\`
+   This creates a scaffolded change at \`openspec/changes/<name>/\` with the selected schema.
+
+4. **Show the artifact status**
+   \`\`\`bash
+   openspec status --change "<name>"
+   \`\`\`
+   This shows which artifacts need to be created and which are ready (dependencies satisfied).
+
+5. **Get instructions for the first artifact**
+   The first artifact depends on the schema. Check the status output to find the first artifact with status "ready".
+   \`\`\`bash
+   openspec instructions <first-artifact-id> --change "<name>"
+   \`\`\`
+   This outputs the template and context for creating the first artifact.
+
+6. **STOP and wait for user direction**
+
+**Output**
+
+After completing the steps, summarize:
+- Change name and location
+- Selected schema/workflow and its artifact sequence
+- Current status (0/N artifacts complete)
+- The template for the first artifact
+- Prompt: "Ready to create the first artifact? Run \`/opsx:continue\` or just describe what this change is about and I'll draft it."
+
+**Guardrails**
+- Do NOT create any artifacts yet - just show the instructions
+- Do NOT advance beyond showing the first artifact template
+- If the name is invalid (not kebab-case), ask for a valid name
+- If a change with that name already exists, suggest using \`/opsx:continue\` instead
+- Always pass --schema to preserve the user's workflow choice`
+  };
+}
+
+/**
+ * Template for /opsx:continue slash command
+ */
+export function getOpsxContinueCommandTemplate(): CommandTemplate {
+  return {
+    name: 'OPSX: Continue',
+    description: 'Continue working on a change - create the next artifact (Experimental)',
+    category: 'Workflow',
+    tags: ['workflow', 'artifacts', 'experimental'],
+    content: `Continue working on a change by creating the next artifact.
+
+**Input**: Optionally specify \`--change <name>\` after \`/opsx:continue\`. If omitted, MUST prompt for available changes.
+
+**Steps**
+
+1. **If no change name provided, prompt for selection**
+
+   Run \`openspec list --json\` to get available changes sorted by most recently modified. Then use the **AskUserQuestion tool** to let the user select which change to work on.
+
+   Present the top 3-4 most recently modified changes as options, showing:
+   - Change name
+   - Schema (from \`schema\` field if present, otherwise "spec-driven")
+   - Status (e.g., "0/5 tasks", "complete", "no tasks")
+   - How recently it was modified (from \`lastModified\` field)
+
+   Mark the most recently modified change as "(Recommended)" since it's likely what the user wants to continue.
+
+   **IMPORTANT**: Do NOT guess or auto-select a change. Always let the user choose.
+
+2. **Check current status**
+   \`\`\`bash
+   openspec status --change "<name>" --json
+   \`\`\`
+   Parse the JSON to understand current state. The response includes:
+   - \`schemaName\`: The workflow schema being used (e.g., "spec-driven", "tdd")
+   - \`artifacts\`: Array of artifacts with their status ("done", "ready", "blocked")
+   - \`isComplete\`: Boolean indicating if all artifacts are complete
+
+3. **Act based on status**:
+
+   ---
+
+   **If all artifacts are complete (\`isComplete: true\`)**:
+   - Congratulate the user
+   - Show final status including the schema used
+   - Suggest: "All artifacts created! You can now implement this change or archive it."
+   - STOP
+
+   ---
+
+   **If artifacts are ready to create** (status shows artifacts with \`status: "ready"\`):
+   - Pick the FIRST artifact with \`status: "ready"\` from the status output
+   - Get its instructions:
+     \`\`\`bash
+     openspec instructions <artifact-id> --change "<name>" --json
+     \`\`\`
+   - Parse the JSON to get template, dependencies, and what it unlocks
+   - **Create the artifact file** using the template as a starting point:
+     - Read any completed dependency files for context
+     - Fill in the template based on context and user's goals
+     - Write to the output path specified in instructions
+   - Show what was created and what's now unlocked
+   - STOP after creating ONE artifact
+
+   ---
+
+   **If no artifacts are ready (all blocked)**:
+   - This shouldn't happen with a valid schema
+   - Show status and suggest checking for issues
+
+4. **After creating an artifact, show progress**
+   \`\`\`bash
+   openspec status --change "<name>"
+   \`\`\`
+
+**Output**
+
+After each invocation, show:
+- Which artifact was created
+- Schema workflow being used
+- Current progress (N/M complete)
+- What artifacts are now unlocked
+- Prompt: "Run \`/opsx:continue\` to create the next artifact"
+
+**Artifact Creation Guidelines**
+
+The artifact types and their purpose depend on the schema. Use the \`instruction\` field from the instructions output to understand what to create.
+
+Common artifact patterns:
+
+**spec-driven schema** (proposal â†’ specs â†’ design â†’ tasks):
+- **proposal.md**: Ask user about the change if not clear. Fill in Why, What Changes, Capabilities, Impact.
+  - The Capabilities section is critical - each capability listed will need a spec file.
+- **specs/*.md**: Create one spec per capability listed in the proposal.
+- **design.md**: Document technical decisions, architecture, and implementation approach.
+- **tasks.md**: Break down implementation into checkboxed tasks.
+
+**tdd schema** (spec â†’ tests â†’ implementation â†’ docs):
+- **spec.md**: Feature specification defining what to build.
+- **tests/*.test.ts**: Write tests BEFORE implementation (TDD red phase).
+- **src/*.ts**: Implement to make tests pass (TDD green phase).
+- **docs/*.md**: Document the implemented feature.
+
+For other schemas, follow the \`instruction\` field from the CLI output.
+
+**Guardrails**
+- Create ONE artifact per invocation
+- Always read dependency artifacts before creating a new one
+- Never skip artifacts or create out of order
+- If context is unclear, ask the user before creating
+- Verify the artifact file exists after writing before marking progress
+- Use the schema's artifact sequence, don't assume specific artifact names`
+  };
+}
+
+/**
+ * Template for /opsx:apply slash command
+ */
+export function getOpsxApplyCommandTemplate(): CommandTemplate {
+  return {
+    name: 'OPSX: Apply',
+    description: 'Implement tasks from an OpenSpec change (Experimental)',
+    category: 'Workflow',
+    tags: ['workflow', 'artifacts', 'experimental'],
+    content: `Implement tasks from an OpenSpec change.
+
+**Input**: Optionally specify \`--change <name>\` after \`/opsx:apply\`. If omitted, MUST prompt for available changes.
+
+**Steps**
+
+1. **If no change name provided, prompt for selection**
+
+   Run \`openspec list --json\` to get available changes. Use the **AskUserQuestion tool** to let the user select.
+
+   Show changes that are implementation-ready (have tasks artifact).
+   Include the schema used for each change if available.
+   Mark changes with incomplete tasks as "(In Progress)".
+
+   **IMPORTANT**: Do NOT guess or auto-select a change. Always let the user choose.
+
+2. **Check status to understand the schema**
+   \`\`\`bash
+   openspec status --change "<name>" --json
+   \`\`\`
+   Parse the JSON to understand:
+   - \`schemaName\`: The workflow being used (e.g., "spec-driven", "tdd")
+   - Which artifact contains the tasks (typically "tasks" for spec-driven, check status for others)
+
+3. **Get apply instructions**
+
+   \`\`\`bash
+   openspec instructions apply --change "<name>" --json
+   \`\`\`
+
+   This returns:
+   - Context file paths (varies by schema)
+   - Progress (total, complete, remaining)
+   - Task list with status
+   - Dynamic instruction based on current state
+
+   **Handle states:**
+   - If \`state: "blocked"\` (missing artifacts): show message, suggest using \`/opsx:continue\`
+   - If \`state: "all_done"\`: congratulate, suggest archive
+   - Otherwise: proceed to implementation
+
+4. **Read context files**
+
+   Read the files listed in \`contextFiles\` from the apply instructions output.
+   The files depend on the schema being used:
+   - **spec-driven**: proposal, specs, design, tasks
+   - **tdd**: spec, tests, implementation, docs
+   - Other schemas: follow the contextFiles from CLI output
+
+5. **Show current progress**
+
+   Display:
+   - Schema being used
+   - Progress: "N/M tasks complete"
+   - Remaining tasks overview
+   - Dynamic instruction from CLI
+
+6. **Implement tasks (loop until done or blocked)**
+
+   For each pending task:
+   - Show which task is being worked on
+   - Make the code changes required
+   - Keep changes minimal and focused
+   - Mark task complete in the tasks file: \`- [ ]\` â†’ \`- [x]\`
+   - Continue to next task
+
+   **Pause if:**
+   - Task is unclear â†’ ask for clarification
+   - Implementation reveals a design issue â†’ suggest updating artifacts
+   - Error or blocker encountered â†’ report and wait for guidance
+   - User interrupts
+
+7. **On completion or pause, show status**
+
+   Display:
+   - Tasks completed this session
+   - Overall progress: "N/M tasks complete"
+   - If all done: suggest archive
+   - If paused: explain why and wait for guidance
+
+**Output During Implementation**
+
+\`\`\`
+## Implementing: <change-name> (schema: <schema-name>)
+
+Working on task 3/7: <task description>
+[...implementation happening...]
+âœ“ Task complete
+
+Working on task 4/7: <task description>
+[...implementation happening...]
+âœ“ Task complete
+\`\`\`
+
+**Output On Completion**
+
+\`\`\`
+## Implementation Complete
+
+**Change:** <change-name>
+**Schema:** <schema-name>
+**Progress:** 7/7 tasks complete âœ“
+
+### Completed This Session
+- [x] Task 1
+- [x] Task 2
+...
+
+All tasks complete! Ready to archive this change.
+\`\`\`
+
+**Output On Pause (Issue Encountered)**
+
+\`\`\`
+## Implementation Paused
+
+**Change:** <change-name>
+**Schema:** <schema-name>
+**Progress:** 4/7 tasks complete
+
+### Issue Encountered
+<description of the issue>
+
+**Options:**
+1. <option 1>
+2. <option 2>
+3. Other approach
+
+What would you like to do?
+\`\`\`
+
+**Guardrails**
+- Keep going through tasks until done or blocked
+- Always read context files before starting (from the apply instructions output)
+- If task is ambiguous, pause and ask before implementing
+- If implementation reveals issues, pause and suggest artifact updates
+- Keep code changes minimal and scoped to each task
+- Update task checkbox immediately after completing each task
+- Pause on errors, blockers, or unclear requirements - don't guess
+- Use contextFiles from CLI output, don't assume specific file names
+
+**Fluid Workflow Integration**
+
+This skill supports the "actions on a change" model:
+
+- **Can be invoked anytime**: Before all artifacts are done (if tasks exist), after partial implementation, interleaved with other actions
+- **Allows artifact updates**: If implementation reveals design issues, suggest updating artifacts - not phase-locked, work fluidly`
+  };
+}
+
+
+/**
+ * Template for /opsx:ff slash command
+ */
+export function getOpsxFfCommandTemplate(): CommandTemplate {
+  return {
+    name: 'OPSX: Fast Forward',
+    description: 'Create a change and generate all artifacts needed for implementation in one go',
+    category: 'Workflow',
+    tags: ['workflow', 'artifacts', 'experimental'],
+    content: `Fast-forward through artifact creation - generate everything needed to start implementation.
+
+**Input**: The argument after \`/opsx:ff\` is the change name (kebab-case), OR a description of what the user wants to build.
+
+**Steps**
+
+1. **If no input provided, ask what they want to build**
+
+   Use the **AskUserQuestion tool** (open-ended, no preset options) to ask:
+   > "What change do you want to work on? Describe what you want to build or fix."
+
+   From their description, derive a kebab-case name (e.g., "add user authentication" â†’ \`add-user-auth\`).
+
+   **IMPORTANT**: Do NOT proceed without understanding what the user wants to build.
+
+2. **Create the change directory**
+   \`\`\`bash
+   openspec new change "<name>"
+   \`\`\`
+   This creates a scaffolded change at \`openspec/changes/<name>/\`.
+
+3. **Get the artifact build order**
+   \`\`\`bash
+   openspec status --change "<name>" --json
+   \`\`\`
+   Parse the JSON to get:
+   - \`applyRequires\`: array of artifact IDs needed before implementation (e.g., \`["tasks"]\`)
+   - \`artifacts\`: list of all artifacts with their status and dependencies
+
+4. **Create artifacts in sequence until apply-ready**
+
+   Use the **TodoWrite tool** to track progress through the artifacts.
+
+   Loop through artifacts in dependency order (artifacts with no pending dependencies first):
+
+   a. **For each artifact that is \`ready\` (dependencies satisfied)**:
+      - Get instructions:
+        \`\`\`bash
+        openspec instructions <artifact-id> --change "<name>" --json
+        \`\`\`
+      - The instructions JSON includes:
+        - \`template\`: The template content to use
+        - \`instruction\`: Schema-specific guidance for this artifact type
+        - \`outputPath\`: Where to write the artifact
+        - \`dependencies\`: Completed artifacts to read for context
+      - Read any completed dependency files for context
+      - Create the artifact file following the schema's \`instruction\`
+      - Show brief progress: "âœ“ Created <artifact-id>"
+
+   b. **Continue until all \`applyRequires\` artifacts are complete**
+      - After creating each artifact, re-run \`openspec status --change "<name>" --json\`
+      - Check if every artifact ID in \`applyRequires\` has \`status: "done"\` in the artifacts array
+      - Stop when all \`applyRequires\` artifacts are done
+
+   c. **If an artifact requires user input** (unclear context):
+      - Use **AskUserQuestion tool** to clarify
+      - Then continue with creation
+
+5. **Show final status**
+   \`\`\`bash
+   openspec status --change "<name>"
+   \`\`\`
+
+**Output**
+
+After completing all artifacts, summarize:
+- Change name and location
+- List of artifacts created with brief descriptions
+- What's ready: "All artifacts created! Ready for implementation."
+- Prompt: "Run \`/opsx:apply\` to start implementing."
+
+**Artifact Creation Guidelines**
+
+- Follow the \`instruction\` field from \`openspec instructions\` for each artifact type
+- The schema defines what each artifact should contain - follow it
+- Read dependency artifacts for context before creating new ones
+- Use the \`template\` as a starting point, filling in based on context
+
+**Guardrails**
+- Create ALL artifacts needed for implementation (as defined by schema's \`apply.requires\`)
+- Always read dependency artifacts before creating a new one
+- If context is critically unclear, ask the user - but prefer making reasonable decisions to keep momentum
+- If a change with that name already exists, ask if user wants to continue it or create a new one
+- Verify each artifact file exists after writing before proceeding to next`
+  };
+}
+
+/**
+ * Template for openspec-archive-change skill
+ * For archiving completed changes in the experimental workflow
+ */
+export function getArchiveChangeSkillTemplate(): SkillTemplate {
+  return {
+    name: 'openspec-archive-change',
+    description: 'Archive a completed change in the experimental workflow. Use when the user wants to finalize and archive a change after implementation is complete.',
+    instructions: `Archive a completed change in the experimental workflow.
+
+**Input**: Optionally specify a change name. If omitted, MUST prompt for available changes.
+
+**Steps**
+
+1. **If no change name provided, prompt for selection**
+
+   Run \`openspec list --json\` to get available changes. Use the **AskUserQuestion tool** to let the user select.
+
+   Show only active changes (not already archived).
+   Include the schema used for each change if available.
+
+   **IMPORTANT**: Do NOT guess or auto-select a change. Always let the user choose.
+
+2. **Check artifact completion status**
+
+   Run \`openspec status --change "<name>" --json\` to check artifact completion.
+
+   Parse the JSON to understand:
+   - \`schemaName\`: The workflow being used
+   - \`artifacts\`: List of artifacts with their status (\`done\` or other)
+
+   **If any artifacts are not \`done\`:**
+   - Display warning listing incomplete artifacts
+   - Use **AskUserQuestion tool** to confirm user wants to proceed
+   - Proceed if user confirms
+
+3. **Check task completion status**
+
+   Read the tasks file (typically \`tasks.md\`) to check for incomplete tasks.
+
+   Count tasks marked with \`- [ ]\` (incomplete) vs \`- [x]\` (complete).
+
+   **If incomplete tasks found:**
+   - Display warning showing count of incomplete tasks
+   - Use **AskUserQuestion tool** to confirm user wants to proceed
+   - Proceed if user confirms
+
+   **If no tasks file exists:** Proceed without task-related warning.
+
+4. **Check if delta specs need syncing**
+
+   Check if \`specs/\` directory exists in the change with spec files.
+
+   **If delta specs exist, perform a quick sync check:**
+
+   a. **For each delta spec** at \`openspec/changes/<name>/specs/<capability>/spec.md\`:
+      - Extract requirement names (lines matching \`### Requirement: <name>\`)
+      - Note which sections exist (ADDED, MODIFIED, REMOVED)
+
+   b. **Check corresponding main spec** at \`openspec/specs/<capability>/spec.md\`:
+      - If main spec doesn't exist â†’ needs sync
+      - If main spec exists, check if ADDED requirement names appear in it
+      - If any ADDED requirements are missing from main spec â†’ needs sync
+
+   c. **Report findings:**
+
+      **If sync needed:**
+      \`\`\`
+      âš ï¸ Delta specs may not be synced:
+      - specs/auth/spec.md â†’ Main spec missing requirement "Token Refresh"
+      - specs/api/spec.md â†’ Main spec doesn't exist yet
+
+      Would you like to sync now before archiving?
+      \`\`\`
+      - Use **AskUserQuestion tool** with options: "Sync now", "Archive without syncing"
+      - If user chooses sync, execute /opsx:sync logic (use the openspec-sync-specs skill)
+
+      **If already synced (all requirements found):**
+      - Proceed without prompting (specs appear to be in sync)
+
+   **If no delta specs exist:** Proceed without sync-related checks.
+
+5. **Perform the archive**
+
+   Create the archive directory if it doesn't exist:
+   \`\`\`bash
+   mkdir -p openspec/changes/archive
+   \`\`\`
+
+   Generate target name using current date: \`YYYY-MM-DD-<change-name>\`
+
+   **Check if target already exists:**
+   - If yes: Fail with error, suggest renaming existing archive or using different date
+   - If no: Move the change directory to archive
+
+   \`\`\`bash
+   mv openspec/changes/<name> openspec/changes/archive/YYYY-MM-DD-<name>
+   \`\`\`
+
+6. **Display summary**
+
+   Show archive completion summary including:
+   - Change name
+   - Schema that was used
+   - Archive location
+   - Whether specs were synced (if applicable)
+   - Note about any warnings (incomplete artifacts/tasks)
+
+**Output On Success**
+
+\`\`\`
+## Archive Complete
+
+**Change:** <change-name>
+**Schema:** <schema-name>
+**Archived to:** openspec/changes/archive/YYYY-MM-DD-<name>/
+**Specs:** âœ“ Synced to main specs (or "No delta specs" or "âš ï¸ Not synced")
+
+All artifacts complete. All tasks complete.
+\`\`\`
+
+**Guardrails**
+- Always prompt for change selection if not provided
+- Use artifact graph (openspec status --json) for completion checking
+- Don't block archive on warnings - just inform and confirm
+- Preserve .openspec.yaml when moving to archive (it moves with the directory)
+- Show clear summary of what happened
+- If sync is requested, use openspec-sync-specs approach (agent-driven)
+- Quick sync check: look for requirement names in delta specs, verify they exist in main specs`
+  };
+}
+
+/**
+ * Template for /opsx:sync slash command
+ */
+export function getOpsxSyncCommandTemplate(): CommandTemplate {
+  return {
+    name: 'OPSX: Sync',
+    description: 'Sync delta specs from a change to main specs',
+    category: 'Workflow',
+    tags: ['workflow', 'specs', 'experimental'],
+    content: `Sync delta specs from a change to main specs.
+
+This is an **agent-driven** operation - you will read delta specs and directly edit main specs to apply the changes. This allows intelligent merging (e.g., adding a scenario without copying the entire requirement).
+
+**Input**: Optionally specify \`--change <name>\` after \`/opsx:sync\`. If omitted, MUST prompt for available changes.
+
+**Steps**
+
+1. **If no change name provided, prompt for selection**
+
+   Run \`openspec list --json\` to get available changes. Use the **AskUserQuestion tool** to let the user select.
+
+   Show changes that have delta specs (under \`specs/\` directory).
+
+   **IMPORTANT**: Do NOT guess or auto-select a change. Always let the user choose.
+
+2. **Find delta specs**
+
+   Look for delta spec files in \`openspec/changes/<name>/specs/*/spec.md\`.
+
+   Each delta spec file contains sections like:
+   - \`## ADDED Requirements\` - New requirements to add
+   - \`## MODIFIED Requirements\` - Changes to existing requirements
+   - \`## REMOVED Requirements\` - Requirements to remove
+   - \`## RENAMED Requirements\` - Requirements to rename (FROM:/TO: format)
+
+   If no delta specs found, inform user and stop.
+
+3. **For each delta spec, apply changes to main specs**
+
+   For each capability with a delta spec at \`openspec/changes/<name>/specs/<capability>/spec.md\`:
+
+   a. **Read the delta spec** to understand the intended changes
+
+   b. **Read the main spec** at \`openspec/specs/<capability>/spec.md\` (may not exist yet)
+
+   c. **Apply changes intelligently**:
+
+      **ADDED Requirements:**
+      - If requirement doesn't exist in main spec â†’ add it
+      - If requirement already exists â†’ update it to match (treat as implicit MODIFIED)
+
+      **MODIFIED Requirements:**
+      - Find the requirement in main spec
+      - Apply the changes - this can be:
+        - Adding new scenarios (don't need to copy existing ones)
+        - Modifying existing scenarios
+        - Changing the requirement description
+      - Preserve scenarios/content not mentioned in the delta
+
+      **REMOVED Requirements:**
+      - Remove the entire requirement block from main spec
+
+      **RENAMED Requirements:**
+      - Find the FROM requirement, rename to TO
+
+   d. **Create new main spec** if capability doesn't exist yet:
+      - Create \`openspec/specs/<capability>/spec.md\`
+      - Add Purpose section (can be brief, mark as TBD)
+      - Add Requirements section with the ADDED requirements
+
+4. **Show summary**
+
+   After applying all changes, summarize:
+   - Which capabilities were updated
+   - What changes were made (requirements added/modified/removed/renamed)
+
+**Delta Spec Format Reference**
+
+\`\`\`markdown
+## ADDED Requirements
+
+### Requirement: New Feature
+The system SHALL do something new.
+
+#### Scenario: Basic case
+- **WHEN** user does X
+- **THEN** system does Y
+
+## MODIFIED Requirements
+
+### Requirement: Existing Feature
+#### Scenario: New scenario to add
+- **WHEN** user does A
+- **THEN** system does B
+
+## REMOVED Requirements
+
+### Requirement: Deprecated Feature
+
+## RENAMED Requirements
+
+- FROM: \`### Requirement: Old Name\`
+- TO: \`### Requirement: New Name\`
+\`\`\`
+
+**Key Principle: Intelligent Merging**
+
+Unlike programmatic merging, you can apply **partial updates**:
+- To add a scenario, just include that scenario under MODIFIED - don't copy existing scenarios
+- The delta represents *intent*, not a wholesale replacement
+- Use your judgment to merge changes sensibly
+
+**Output On Success**
+
+\`\`\`
+## Specs Synced: <change-name>
+
+Updated main specs:
+
+**<capability-1>**:
+- Added requirement: "New Feature"
+- Modified requirement: "Existing Feature" (added 1 scenario)
+
+**<capability-2>**:
+- Created new spec file
+- Added requirement: "Another Feature"
+
+Main specs are now updated. The change remains active - archive when implementation is complete.
+\`\`\`
+
+**Guardrails**
+- Read both delta and main specs before making changes
+- Preserve existing content not mentioned in delta
+- If something is unclear, ask for clarification
+- Show what you're changing as you go
+- The operation should be idempotent - running twice should give same result`
+  };
+}
+
+/**
+ * Template for /opsx:archive slash command
+ */
+export function getOpsxArchiveCommandTemplate(): CommandTemplate {
+  return {
+    name: 'OPSX: Archive',
+    description: 'Archive a completed change in the experimental workflow',
+    category: 'Workflow',
+    tags: ['workflow', 'archive', 'experimental'],
+    content: `Archive a completed change in the experimental workflow.
+
+**Input**: Optionally specify \`--change <name>\` after \`/opsx:archive\`. If omitted, MUST prompt for available changes.
+
+**Steps**
+
+1. **If no change name provided, prompt for selection**
+
+   Run \`openspec list --json\` to get available changes. Use the **AskUserQuestion tool** to let the user select.
+
+   Show only active changes (not already archived).
+   Include the schema used for each change if available.
+
+   **IMPORTANT**: Do NOT guess or auto-select a change. Always let the user choose.
+
+2. **Check artifact completion status**
+
+   Run \`openspec status --change "<name>" --json\` to check artifact completion.
+
+   Parse the JSON to understand:
+   - \`schemaName\`: The workflow being used
+   - \`artifacts\`: List of artifacts with their status (\`done\` or other)
+
+   **If any artifacts are not \`done\`:**
+   - Display warning listing incomplete artifacts
+   - Prompt user for confirmation to continue
+   - Proceed if user confirms
+
+3. **Check task completion status**
+
+   Read the tasks file (typically \`tasks.md\`) to check for incomplete tasks.
+
+   Count tasks marked with \`- [ ]\` (incomplete) vs \`- [x]\` (complete).
+
+   **If incomplete tasks found:**
+   - Display warning showing count of incomplete tasks
+   - Prompt user for confirmation to continue
+   - Proceed if user confirms
+
+   **If no tasks file exists:** Proceed without task-related warning.
+
+4. **Check if delta specs need syncing**
+
+   Check if \`specs/\` directory exists in the change with spec files.
+
+   **If delta specs exist, perform a quick sync check:**
+
+   a. **For each delta spec** at \`openspec/changes/<name>/specs/<capability>/spec.md\`:
+      - Extract requirement names (lines matching \`### Requirement: <name>\`)
+      - Note which sections exist (ADDED, MODIFIED, REMOVED)
+
+   b. **Check corresponding main spec** at \`openspec/specs/<capability>/spec.md\`:
+      - If main spec doesn't exist â†’ needs sync
+      - If main spec exists, check if ADDED requirement names appear in it
+      - If any ADDED requirements are missing from main spec â†’ needs sync
+
+   c. **Report findings:**
+
+      **If sync needed:**
+      \`\`\`
+      âš ï¸ Delta specs may not be synced:
+      - specs/auth/spec.md â†’ Main spec missing requirement "Token Refresh"
+      - specs/api/spec.md â†’ Main spec doesn't exist yet
+
+      Would you like to sync now before archiving?
+      \`\`\`
+      - Use **AskUserQuestion tool** with options: "Sync now", "Archive without syncing"
+      - If user chooses sync, execute \`/opsx:sync\` logic
+
+      **If already synced (all requirements found):**
+      - Proceed without prompting (specs appear to be in sync)
+
+   **If no delta specs exist:** Proceed without sync-related checks.
+
+5. **Perform the archive**
+
+   Create the archive directory if it doesn't exist:
+   \`\`\`bash
+   mkdir -p openspec/changes/archive
+   \`\`\`
+
+   Generate target name using current date: \`YYYY-MM-DD-<change-name>\`
+
+   **Check if target already exists:**
+   - If yes: Fail with error, suggest renaming existing archive or using different date
+   - If no: Move the change directory to archive
+
+   \`\`\`bash
+   mv openspec/changes/<name> openspec/changes/archive/YYYY-MM-DD-<name>
+   \`\`\`
+
+6. **Display summary**
+
+   Show archive completion summary including:
+   - Change name
+   - Schema that was used
+   - Archive location
+   - Spec sync status (synced / not synced / no delta specs)
+   - Note about any warnings (incomplete artifacts/tasks)
+
+**Output On Success**
+
+\`\`\`
+## Archive Complete
+
+**Change:** <change-name>
+**Schema:** <schema-name>
+**Archived to:** openspec/changes/archive/YYYY-MM-DD-<name>/
+**Specs:** âœ“ Synced to main specs
+
+All artifacts complete. All tasks complete.
+\`\`\`
+
+**Output On Success (No Delta Specs)**
+
+\`\`\`
+## Archive Complete
+
+**Change:** <change-name>
+**Schema:** <schema-name>
+**Archived to:** openspec/changes/archive/YYYY-MM-DD-<name>/
+**Specs:** No delta specs
+
+All artifacts complete. All tasks complete.
+\`\`\`
+
+**Output On Success With Warnings**
+
+\`\`\`
+## Archive Complete (with warnings)
+
+**Change:** <change-name>
+**Schema:** <schema-name>
+**Archived to:** openspec/changes/archive/YYYY-MM-DD-<name>/
+**Specs:** âš ï¸ Not synced
+
+**Warnings:**
+- Archived with 2 incomplete artifacts
+- Archived with 3 incomplete tasks
+- Delta specs were not synced (user chose to skip)
+
+Review the archive if this was not intentional.
+\`\`\`
+
+**Output On Error (Archive Exists)**
+
+\`\`\`
+## Archive Failed
+
+**Change:** <change-name>
+**Target:** openspec/changes/archive/YYYY-MM-DD-<name>/
+
+Target archive directory already exists.
+
+**Options:**
+1. Rename the existing archive
+2. Delete the existing archive if it's a duplicate
+3. Wait until a different date to archive
+\`\`\`
+
+**Guardrails**
+- Always prompt for change selection if not provided
+- Use artifact graph (openspec status --json) for completion checking
+- Don't block archive on warnings - just inform and confirm
+- Preserve .openspec.yaml when moving to archive (it moves with the directory)
+- Quick sync check: look for requirement names in delta specs, verify they exist in main specs
+- Show clear summary of what happened
+- If sync is requested, use /opsx:sync approach (agent-driven)`
+  };
+}
diff --git a/src/core/update.ts b/src/core/update.ts
index 6d75898..41fd772 100644
--- a/src/core/update.ts
+++ b/src/core/update.ts
@@ -107,7 +107,7 @@ export class UpdateCommand {
 
     if (updatedSlashFiles.length > 0) {
       // Normalize to forward slashes for cross-platform log consistency
-      const normalized = updatedSlashFiles.map((p) => p.replace(/\\/g, '/'));
+      const normalized = updatedSlashFiles.map((p) => FileSystemUtils.toPosixPath(p));
       summaryParts.push(`Updated slash commands: ${normalized.join(', ')}`);
     }
 
diff --git a/src/core/validation/validator.ts b/src/core/validation/validator.ts
index c15b70c..e6928cb 100644
--- a/src/core/validation/validator.ts
+++ b/src/core/validation/validator.ts
@@ -5,12 +5,13 @@ import { SpecSchema, ChangeSchema, Spec, Change } from '../schemas/index.js';
 import { MarkdownParser } from '../parsers/markdown-parser.js';
 import { ChangeParser } from '../parsers/change-parser.js';
 import { ValidationReport, ValidationIssue, ValidationLevel } from './types.js';
-import { 
+import {
   MIN_PURPOSE_LENGTH,
   MAX_REQUIREMENT_TEXT_LENGTH,
-  VALIDATION_MESSAGES 
+  VALIDATION_MESSAGES
 } from './constants.js';
 import { parseDeltaSpec, normalizeRequirementName } from '../parsers/requirement-blocks.js';
+import { FileSystemUtils } from '../../utils/file-system.js';
 
 export class Validator {
   private strictMode: boolean;
@@ -359,7 +360,7 @@ export class Validator {
   }
 
   private extractNameFromPath(filePath: string): string {
-    const normalizedPath = filePath.replaceAll('\\', '/');
+    const normalizedPath = FileSystemUtils.toPosixPath(filePath);
     const parts = normalizedPath.split('/');
     
     // Look for the directory name after 'specs' or 'changes'
diff --git a/src/core/view.ts b/src/core/view.ts
index 0a80e61..e67c352 100644
--- a/src/core/view.ts
+++ b/src/core/view.ts
@@ -23,16 +23,26 @@ export class ViewCommand {
     // Display summary metrics
     this.displaySummary(changesData, specsData);
 
+    // Display draft changes
+    if (changesData.draft.length > 0) {
+      console.log(chalk.bold.gray('\nDraft Changes'));
+      console.log('â”€'.repeat(60));
+      changesData.draft.forEach((change) => {
+        console.log(`  ${chalk.gray('â—‹')} ${change.name}`);
+      });
+    }
+
     // Display active changes
     if (changesData.active.length > 0) {
       console.log(chalk.bold.cyan('\nActive Changes'));
       console.log('â”€'.repeat(60));
-      changesData.active.forEach(change => {
+      changesData.active.forEach((change) => {
         const progressBar = this.createProgressBar(change.progress.completed, change.progress.total);
-        const percentage = change.progress.total > 0 
-          ? Math.round((change.progress.completed / change.progress.total) * 100)
-          : 0;
-        
+        const percentage =
+          change.progress.total > 0
+            ? Math.round((change.progress.completed / change.progress.total) * 100)
+            : 0;
+
         console.log(
           `  ${chalk.yellow('â—‰')} ${chalk.bold(change.name.padEnd(30))} ${progressBar} ${chalk.dim(`${percentage}%`)}`
         );
@@ -43,7 +53,7 @@ export class ViewCommand {
     if (changesData.completed.length > 0) {
       console.log(chalk.bold.green('\nCompleted Changes'));
       console.log('â”€'.repeat(60));
-      changesData.completed.forEach(change => {
+      changesData.completed.forEach((change) => {
         console.log(`  ${chalk.green('âœ“')} ${change.name}`);
       });
     }
@@ -69,33 +79,43 @@ export class ViewCommand {
   }
 
   private async getChangesData(openspecDir: string): Promise<{
+    draft: Array<{ name: string }>;
     active: Array<{ name: string; progress: { total: number; completed: number } }>;
     completed: Array<{ name: string }>;
   }> {
     const changesDir = path.join(openspecDir, 'changes');
-    
+
     if (!fs.existsSync(changesDir)) {
-      return { active: [], completed: [] };
+      return { draft: [], active: [], completed: [] };
     }
 
+    const draft: Array<{ name: string }> = [];
     const active: Array<{ name: string; progress: { total: number; completed: number } }> = [];
     const completed: Array<{ name: string }> = [];
 
     const entries = fs.readdirSync(changesDir, { withFileTypes: true });
-    
+
     for (const entry of entries) {
       if (entry.isDirectory() && entry.name !== 'archive') {
         const progress = await getTaskProgressForChange(changesDir, entry.name);
-        
-        if (progress.total === 0 || progress.completed === progress.total) {
+
+        if (progress.total === 0) {
+          // No tasks defined yet - still in planning/draft phase
+          draft.push({ name: entry.name });
+        } else if (progress.completed === progress.total) {
+          // All tasks complete
           completed.push({ name: entry.name });
         } else {
+          // Has tasks but not all complete
           active.push({ name: entry.name, progress });
         }
       }
     }
 
-    // Sort active changes by completion percentage (ascending) and then by name for deterministic ordering
+    // Sort all categories by name for deterministic ordering
+    draft.sort((a, b) => a.name.localeCompare(b.name));
+
+    // Sort active changes by completion percentage (ascending) and then by name
     active.sort((a, b) => {
       const percentageA = a.progress.total > 0 ? a.progress.completed / a.progress.total : 0;
       const percentageB = b.progress.total > 0 ? b.progress.completed / b.progress.total : 0;
@@ -106,7 +126,7 @@ export class ViewCommand {
     });
     completed.sort((a, b) => a.name.localeCompare(b.name));
 
-    return { active, completed };
+    return { draft, active, completed };
   }
 
   private async getSpecsData(openspecDir: string): Promise<Array<{ name: string; requirementCount: number }>> {
@@ -142,35 +162,45 @@ export class ViewCommand {
   }
 
   private displaySummary(
-    changesData: { active: any[]; completed: any[] },
+    changesData: { draft: any[]; active: any[]; completed: any[] },
     specsData: any[]
   ): void {
-    const totalChanges = changesData.active.length + changesData.completed.length;
+    const totalChanges =
+      changesData.draft.length + changesData.active.length + changesData.completed.length;
     const totalSpecs = specsData.length;
     const totalRequirements = specsData.reduce((sum, spec) => sum + spec.requirementCount, 0);
-    
+
     // Calculate total task progress
     let totalTasks = 0;
     let completedTasks = 0;
-    
-    changesData.active.forEach(change => {
+
+    changesData.active.forEach((change) => {
       totalTasks += change.progress.total;
       completedTasks += change.progress.completed;
     });
-    
+
     changesData.completed.forEach(() => {
       // Completed changes count as 100% done (we don't know exact task count)
       // This is a simplification
     });
 
     console.log(chalk.bold('Summary:'));
-    console.log(`  ${chalk.cyan('â—')} Specifications: ${chalk.bold(totalSpecs)} specs, ${chalk.bold(totalRequirements)} requirements`);
-    console.log(`  ${chalk.yellow('â—')} Active Changes: ${chalk.bold(changesData.active.length)} in progress`);
+    console.log(
+      `  ${chalk.cyan('â—')} Specifications: ${chalk.bold(totalSpecs)} specs, ${chalk.bold(totalRequirements)} requirements`
+    );
+    if (changesData.draft.length > 0) {
+      console.log(`  ${chalk.gray('â—')} Draft Changes: ${chalk.bold(changesData.draft.length)}`);
+    }
+    console.log(
+      `  ${chalk.yellow('â—')} Active Changes: ${chalk.bold(changesData.active.length)} in progress`
+    );
     console.log(`  ${chalk.green('â—')} Completed Changes: ${chalk.bold(changesData.completed.length)}`);
-    
+
     if (totalTasks > 0) {
       const overallProgress = Math.round((completedTasks / totalTasks) * 100);
-      console.log(`  ${chalk.magenta('â—')} Task Progress: ${chalk.bold(`${completedTasks}/${totalTasks}`)} (${overallProgress}% complete)`);
+      console.log(
+        `  ${chalk.magenta('â—')} Task Progress: ${chalk.bold(`${completedTasks}/${totalTasks}`)} (${overallProgress}% complete)`
+      );
     }
   }
 
diff --git a/src/utils/change-metadata.ts b/src/utils/change-metadata.ts
new file mode 100644
index 0000000..537284d
--- /dev/null
+++ b/src/utils/change-metadata.ts
@@ -0,0 +1,171 @@
+import * as fs from 'node:fs';
+import * as path from 'node:path';
+import * as yaml from 'yaml';
+import { ChangeMetadataSchema, type ChangeMetadata } from '../core/artifact-graph/types.js';
+import { listSchemas } from '../core/artifact-graph/resolver.js';
+
+const METADATA_FILENAME = '.openspec.yaml';
+
+/**
+ * Error thrown when change metadata validation fails.
+ */
+export class ChangeMetadataError extends Error {
+  constructor(
+    message: string,
+    public readonly metadataPath: string,
+    public readonly cause?: Error
+  ) {
+    super(message);
+    this.name = 'ChangeMetadataError';
+  }
+}
+
+/**
+ * Validates that a schema name is valid (exists in available schemas).
+ *
+ * @param schemaName - The schema name to validate
+ * @returns The validated schema name
+ * @throws Error if schema is not found
+ */
+export function validateSchemaName(schemaName: string): string {
+  const availableSchemas = listSchemas();
+  if (!availableSchemas.includes(schemaName)) {
+    throw new Error(
+      `Unknown schema '${schemaName}'. Available: ${availableSchemas.join(', ')}`
+    );
+  }
+  return schemaName;
+}
+
+/**
+ * Writes change metadata to .openspec.yaml in the change directory.
+ *
+ * @param changeDir - The path to the change directory
+ * @param metadata - The metadata to write
+ * @throws ChangeMetadataError if validation fails or write fails
+ */
+export function writeChangeMetadata(
+  changeDir: string,
+  metadata: ChangeMetadata
+): void {
+  const metaPath = path.join(changeDir, METADATA_FILENAME);
+
+  // Validate schema exists
+  validateSchemaName(metadata.schema);
+
+  // Validate with Zod
+  const parseResult = ChangeMetadataSchema.safeParse(metadata);
+  if (!parseResult.success) {
+    throw new ChangeMetadataError(
+      `Invalid metadata: ${parseResult.error.message}`,
+      metaPath
+    );
+  }
+
+  // Write YAML file
+  const content = yaml.stringify(parseResult.data);
+  try {
+    fs.writeFileSync(metaPath, content, 'utf-8');
+  } catch (err) {
+    const ioError = err instanceof Error ? err : new Error(String(err));
+    throw new ChangeMetadataError(
+      `Failed to write metadata: ${ioError.message}`,
+      metaPath,
+      ioError
+    );
+  }
+}
+
+/**
+ * Reads change metadata from .openspec.yaml in the change directory.
+ *
+ * @param changeDir - The path to the change directory
+ * @returns The validated metadata, or null if no metadata file exists
+ * @throws ChangeMetadataError if the file exists but is invalid
+ */
+export function readChangeMetadata(changeDir: string): ChangeMetadata | null {
+  const metaPath = path.join(changeDir, METADATA_FILENAME);
+
+  if (!fs.existsSync(metaPath)) {
+    return null;
+  }
+
+  let content: string;
+  try {
+    content = fs.readFileSync(metaPath, 'utf-8');
+  } catch (err) {
+    const ioError = err instanceof Error ? err : new Error(String(err));
+    throw new ChangeMetadataError(
+      `Failed to read metadata: ${ioError.message}`,
+      metaPath,
+      ioError
+    );
+  }
+
+  let parsed: unknown;
+  try {
+    parsed = yaml.parse(content);
+  } catch (err) {
+    const parseError = err instanceof Error ? err : new Error(String(err));
+    throw new ChangeMetadataError(
+      `Invalid YAML in metadata file: ${parseError.message}`,
+      metaPath,
+      parseError
+    );
+  }
+
+  // Validate with Zod
+  const parseResult = ChangeMetadataSchema.safeParse(parsed);
+  if (!parseResult.success) {
+    throw new ChangeMetadataError(
+      `Invalid metadata: ${parseResult.error.message}`,
+      metaPath
+    );
+  }
+
+  // Validate that the schema exists
+  const availableSchemas = listSchemas();
+  if (!availableSchemas.includes(parseResult.data.schema)) {
+    throw new ChangeMetadataError(
+      `Unknown schema '${parseResult.data.schema}'. Available: ${availableSchemas.join(', ')}`,
+      metaPath
+    );
+  }
+
+  return parseResult.data;
+}
+
+/**
+ * Resolves the schema for a change, with explicit override taking precedence.
+ *
+ * Resolution order:
+ * 1. Explicit schema (if provided)
+ * 2. Schema from .openspec.yaml metadata (if exists)
+ * 3. Default 'spec-driven'
+ *
+ * @param changeDir - The path to the change directory
+ * @param explicitSchema - Optional explicit schema override
+ * @returns The resolved schema name
+ */
+export function resolveSchemaForChange(
+  changeDir: string,
+  explicitSchema?: string
+): string {
+  // 1. Explicit override wins
+  if (explicitSchema) {
+    return explicitSchema;
+  }
+
+  // 2. Try reading from metadata
+  try {
+    const metadata = readChangeMetadata(changeDir);
+    if (metadata?.schema) {
+      return metadata.schema;
+    }
+  } catch {
+    // If metadata read fails, fall back to default
+  }
+
+  // 3. Default
+  return 'spec-driven';
+}
diff --git a/src/utils/change-utils.ts b/src/utils/change-utils.ts
new file mode 100644
index 0000000..31222c7
--- /dev/null
+++ b/src/utils/change-utils.ts
@@ -0,0 +1,131 @@
+import path from 'path';
+import { FileSystemUtils } from './file-system.js';
+import { writeChangeMetadata, validateSchemaName } from './change-metadata.js';
+
+const DEFAULT_SCHEMA = 'spec-driven';
+
+/**
+ * Options for creating a change.
+ */
+export interface CreateChangeOptions {
+  /** The workflow schema to use (default: 'spec-driven') */
+  schema?: string;
+}
+
+/**
+ * Result of validating a change name.
+ */
+export interface ValidationResult {
+  valid: boolean;
+  error?: string;
+}
+
+/**
+ * Validates that a change name follows kebab-case conventions.
+ *
+ * Valid names:
+ * - Start with a lowercase letter
+ * - Contain only lowercase letters, numbers, and hyphens
+ * - Do not start or end with a hyphen
+ * - Do not contain consecutive hyphens
+ *
+ * @param name - The change name to validate
+ * @returns Validation result with `valid: true` or `valid: false` with an error message
+ *
+ * @example
+ * validateChangeName('add-auth') // { valid: true }
+ * validateChangeName('Add-Auth') // { valid: false, error: '...' }
+ */
+export function validateChangeName(name: string): ValidationResult {
+  // Pattern: starts with lowercase letter, followed by lowercase letters/numbers,
+  // optionally followed by hyphen + lowercase letters/numbers (repeatable)
+  const kebabCasePattern = /^[a-z][a-z0-9]*(-[a-z0-9]+)*$/;
+
+  if (!name) {
+    return { valid: false, error: 'Change name cannot be empty' };
+  }
+
+  if (!kebabCasePattern.test(name)) {
+    // Provide specific error messages for common mistakes
+    if (/[A-Z]/.test(name)) {
+      return { valid: false, error: 'Change name must be lowercase (use kebab-case)' };
+    }
+    if (/\s/.test(name)) {
+      return { valid: false, error: 'Change name cannot contain spaces (use hyphens instead)' };
+    }
+    if (/_/.test(name)) {
+      return { valid: false, error: 'Change name cannot contain underscores (use hyphens instead)' };
+    }
+    if (name.startsWith('-')) {
+      return { valid: false, error: 'Change name cannot start with a hyphen' };
+    }
+    if (name.endsWith('-')) {
+      return { valid: false, error: 'Change name cannot end with a hyphen' };
+    }
+    if (/--/.test(name)) {
+      return { valid: false, error: 'Change name cannot contain consecutive hyphens' };
+    }
+    if (/[^a-z0-9-]/.test(name)) {
+      return { valid: false, error: 'Change name can only contain lowercase letters, numbers, and hyphens' };
+    }
+    if (/^[0-9]/.test(name)) {
+      return { valid: false, error: 'Change name must start with a letter' };
+    }
+
+    return { valid: false, error: 'Change name must follow kebab-case convention (e.g., add-auth, refactor-db)' };
+  }
+
+  return { valid: true };
+}
+
+/**
+ * Creates a new change directory with metadata file.
+ *
+ * @param projectRoot - The root directory of the project (where `openspec/` lives)
+ * @param name - The change name (must be valid kebab-case)
+ * @param options - Optional settings for the change
+ * @throws Error if the change name is invalid
+ * @throws Error if the schema name is invalid
+ * @throws Error if the change directory already exists
+ *
+ * @example
+ * // Creates openspec/changes/add-auth/ with default schema
+ * await createChange('/path/to/project', 'add-auth')
+ *
+ * @example
+ * // Creates openspec/changes/add-auth/ with TDD schema
+ * await createChange('/path/to/project', 'add-auth', { schema: 'tdd' })
+ */
+export async function createChange(
+  projectRoot: string,
+  name: string,
+  options: CreateChangeOptions = {}
+): Promise<void> {
+  // Validate the name first
+  const validation = validateChangeName(name);
+  if (!validation.valid) {
+    throw new Error(validation.error);
+  }
+
+  // Determine schema (validate if provided)
+  const schemaName = options.schema ?? DEFAULT_SCHEMA;
+  validateSchemaName(schemaName);
+
+  // Build the change directory path
+  const changeDir = path.join(projectRoot, 'openspec', 'changes', name);
+
+  // Check if change already exists
+  if (await FileSystemUtils.directoryExists(changeDir)) {
+    throw new Error(`Change '${name}' already exists at ${changeDir}`);
+  }
+
+  // Create the directory (including parent directories if needed)
+  await FileSystemUtils.createDirectory(changeDir);
+
+  // Write metadata file with schema and creation date
+  const today = new Date().toISOString().split('T')[0];
+  writeChangeMetadata(changeDir, {
+    schema: schemaName,
+    created: today,
+  });
+}
diff --git a/src/utils/file-system.ts b/src/utils/file-system.ts
index 364b5cd..bce759d 100644
--- a/src/utils/file-system.ts
+++ b/src/utils/file-system.ts
@@ -42,6 +42,14 @@ function findMarkerIndex(
 }
 
 export class FileSystemUtils {
+  /**
+   * Converts a path to use forward slashes (POSIX style).
+   * Essential for cross-platform compatibility with glob libraries like fast-glob.
+   */
+  static toPosixPath(p: string): string {
+    return p.replace(/\\/g, '/');
+  }
+
   private static isWindowsBasePath(basePath: string): boolean {
     return /^[A-Za-z]:[\\/]/.test(basePath) || basePath.startsWith('\\');
   }
diff --git a/src/utils/index.ts b/src/utils/index.ts
index b1cb3e6..6e21a30 100644
--- a/src/utils/index.ts
+++ b/src/utils/index.ts
@@ -1,2 +1,12 @@
-// Shared utilities will be implemented here
-export {};
\ No newline at end of file
+// Shared utilities
+export { validateChangeName, createChange } from './change-utils.js';
+export type { ValidationResult, CreateChangeOptions } from './change-utils.js';
+
+// Change metadata utilities
+export {
+  readChangeMetadata,
+  writeChangeMetadata,
+  resolveSchemaForChange,
+  validateSchemaName,
+  ChangeMetadataError,
+} from './change-metadata.js';
\ No newline at end of file
diff --git a/test/commands/artifact-workflow.test.ts b/test/commands/artifact-workflow.test.ts
new file mode 100644
index 0000000..d502514
--- /dev/null
+++ b/test/commands/artifact-workflow.test.ts
@@ -0,0 +1,579 @@
+import { describe, it, expect, beforeEach, afterEach } from 'vitest';
+import { promises as fs } from 'fs';
+import path from 'path';
+import os from 'os';
+import { runCLI } from '../helpers/run-cli.js';
+
+describe('artifact-workflow CLI commands', () => {
+  let tempDir: string;
+  let changesDir: string;
+
+  beforeEach(async () => {
+    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'openspec-artifact-workflow-'));
+    changesDir = path.join(tempDir, 'openspec', 'changes');
+    await fs.mkdir(changesDir, { recursive: true });
+  });
+
+  afterEach(async () => {
+    if (tempDir) {
+      await fs.rm(tempDir, { recursive: true, force: true });
+    }
+  });
+
+  /**
+   * Gets combined output from CLI result (ora outputs to stdout).
+   */
+  function getOutput(result: { stdout: string; stderr: string }): string {
+    return result.stdout + result.stderr;
+  }
+
+  /**
+   * Creates a test change with the specified artifacts completed.
+   * Note: An "active" change requires at least a proposal.md file to be detected.
+   * If no artifacts are specified, we create an empty proposal to make it detectable.
+   */
+  async function createTestChange(
+    changeName: string,
+    artifacts: ('proposal' | 'design' | 'specs' | 'tasks')[] = []
+  ): Promise<string> {
+    const changeDir = path.join(changesDir, changeName);
+    await fs.mkdir(changeDir, { recursive: true });
+
+    // Always create proposal.md for the change to be detected as active
+    // Content varies based on whether 'proposal' is in artifacts list
+    const proposalContent = artifacts.includes('proposal')
+      ? '## Why\nTest proposal content that is long enough.\n\n## What Changes\n- **test:** Something'
+      : '## Why\nMinimal proposal.\n\n## What Changes\n- **test:** Placeholder';
+    await fs.writeFile(path.join(changeDir, 'proposal.md'), proposalContent);
+
+    if (artifacts.includes('design')) {
+      await fs.writeFile(path.join(changeDir, 'design.md'), '# Design\n\nTechnical design.');
+    }
+
+    if (artifacts.includes('specs')) {
+      // specs artifact uses glob pattern "specs/*.md" - files directly in specs/ directory
+      const specsDir = path.join(changeDir, 'specs');
+      await fs.mkdir(specsDir, { recursive: true });
+      await fs.writeFile(path.join(specsDir, 'test-spec.md'), '## Purpose\nTest spec.');
+    }
+
+    if (artifacts.includes('tasks')) {
+      await fs.writeFile(path.join(changeDir, 'tasks.md'), '## Tasks\n- [ ] Task 1');
+    }
+
+    return changeDir;
+  }
+
+  describe('status command', () => {
+    it('shows status for scaffolded change without proposal.md', async () => {
+      // Create empty change directory (no proposal.md)
+      const changeDir = path.join(changesDir, 'scaffolded-change');
+      await fs.mkdir(changeDir, { recursive: true });
+
+      const result = await runCLI(['status', '--change', 'scaffolded-change'], { cwd: tempDir });
+      expect(result.exitCode).toBe(0);
+      expect(result.stdout).toContain('scaffolded-change');
+      expect(result.stdout).toContain('0/4 artifacts complete');
+    });
+
+    it('shows status for a change with proposal only', async () => {
+      // createTestChange always creates proposal.md, so this has 1 artifact complete
+      await createTestChange('minimal-change');
+
+      const result = await runCLI(['status', '--change', 'minimal-change'], { cwd: tempDir });
+      expect(result.exitCode).toBe(0);
+      expect(result.stdout).toContain('minimal-change');
+      expect(result.stdout).toContain('spec-driven');
+      expect(result.stdout).toContain('1/4 artifacts complete');
+    });
+
+    it('shows status for a change with proposal and design', async () => {
+      await createTestChange('partial-change', ['proposal', 'design']);
+
+      const result = await runCLI(['status', '--change', 'partial-change'], { cwd: tempDir });
+      expect(result.exitCode).toBe(0);
+      expect(result.stdout).toContain('2/4 artifacts complete');
+      expect(result.stdout).toContain('[x]');
+    });
+
+    it('outputs JSON when --json flag is used', async () => {
+      await createTestChange('json-change', ['proposal', 'design']);
+
+      const result = await runCLI(['status', '--change', 'json-change', '--json'], {
+        cwd: tempDir,
+      });
+      expect(result.exitCode).toBe(0);
+
+      const json = JSON.parse(result.stdout);
+      expect(json.changeName).toBe('json-change');
+      expect(json.schemaName).toBe('spec-driven');
+      expect(json.isComplete).toBe(false);
+      expect(Array.isArray(json.artifacts)).toBe(true);
+      expect(json.artifacts).toHaveLength(4);
+
+      const proposalArtifact = json.artifacts.find((a: any) => a.id === 'proposal');
+      expect(proposalArtifact.status).toBe('done');
+    });
+
+    it('shows complete status when all artifacts are done', async () => {
+      await createTestChange('complete-change', ['proposal', 'design', 'specs', 'tasks']);
+
+      const result = await runCLI(['status', '--change', 'complete-change'], { cwd: tempDir });
+      expect(result.exitCode).toBe(0);
+      expect(result.stdout).toContain('4/4 artifacts complete');
+      expect(result.stdout).toContain('All artifacts complete!');
+    });
+
+    it('errors when --change is missing and lists available changes', async () => {
+      await createTestChange('some-change');
+
+      const result = await runCLI(['status'], { cwd: tempDir });
+      expect(result.exitCode).toBe(1);
+      const output = getOutput(result);
+      expect(output).toContain('Missing required option --change');
+      expect(output).toContain('some-change');
+    });
+
+    it('errors for unknown change name and lists available changes', async () => {
+      await createTestChange('existing-change');
+
+      const result = await runCLI(['status', '--change', 'nonexistent'], { cwd: tempDir });
+      expect(result.exitCode).toBe(1);
+      const output = getOutput(result);
+      expect(output).toContain("Change 'nonexistent' not found");
+      expect(output).toContain('existing-change');
+    });
+
+    it('supports --schema option', async () => {
+      await createTestChange('tdd-change');
+
+      const result = await runCLI(['status', '--change', 'tdd-change', '--schema', 'tdd'], {
+        cwd: tempDir,
+      });
+      expect(result.exitCode).toBe(0);
+      expect(result.stdout).toContain('tdd');
+    });
+
+    it('errors for unknown schema', async () => {
+      await createTestChange('test-change');
+
+      const result = await runCLI(['status', '--change', 'test-change', '--schema', 'unknown'], {
+        cwd: tempDir,
+      });
+      expect(result.exitCode).toBe(1);
+      const output = getOutput(result);
+      expect(output).toContain("Schema 'unknown' not found");
+    });
+
+    it('rejects path traversal in change name', async () => {
+      const result = await runCLI(['status', '--change', '../foo'], { cwd: tempDir });
+      expect(result.exitCode).toBe(1);
+      const output = getOutput(result);
+      expect(output).toContain('Invalid change name');
+    });
+
+    it('rejects absolute path in change name', async () => {
+      const result = await runCLI(['status', '--change', '/etc/passwd'], { cwd: tempDir });
+      expect(result.exitCode).toBe(1);
+      const output = getOutput(result);
+      expect(output).toContain('Invalid change name');
+    });
+
+    it('rejects slashes in change name', async () => {
+      const result = await runCLI(['status', '--change', 'foo/bar'], { cwd: tempDir });
+      expect(result.exitCode).toBe(1);
+      const output = getOutput(result);
+      expect(output).toContain('Invalid change name');
+    });
+  });
+
+  describe('instructions command', () => {
+    it('shows instructions for proposal on scaffolded change', async () => {
+      // Create empty change directory (no proposal.md)
+      const changeDir = path.join(changesDir, 'scaffolded-change');
+      await fs.mkdir(changeDir, { recursive: true });
+
+      const result = await runCLI(['instructions', 'proposal', '--change', 'scaffolded-change'], {
+        cwd: tempDir,
+      });
+      expect(result.exitCode).toBe(0);
+      expect(result.stdout).toContain('<artifact id="proposal"');
+      expect(result.stdout).toContain('proposal.md');
+      expect(result.stdout).toContain('<template>');
+    });
+
+    it('shows instructions for design artifact', async () => {
+      await createTestChange('instr-change');
+
+      const result = await runCLI(['instructions', 'design', '--change', 'instr-change'], {
+        cwd: tempDir,
+      });
+      expect(result.exitCode).toBe(0);
+      expect(result.stdout).toContain('<artifact id="design"');
+      expect(result.stdout).toContain('design.md');
+      expect(result.stdout).toContain('<template>');
+    });
+
+    it('shows blocked warning for artifact with unmet dependencies', async () => {
+      // tasks depends on design and specs, which are not done yet
+      await createTestChange('blocked-change');
+
+      const result = await runCLI(['instructions', 'tasks', '--change', 'blocked-change'], {
+        cwd: tempDir,
+      });
+      expect(result.exitCode).toBe(0);
+      expect(result.stdout).toContain('<warning>');
+      expect(result.stdout).toContain('status="missing"');
+    });
+
+    it('outputs JSON for instructions', async () => {
+      await createTestChange('json-instr', ['proposal']);
+
+      const result = await runCLI(['instructions', 'design', '--change', 'json-instr', '--json'], {
+        cwd: tempDir,
+      });
+      expect(result.exitCode).toBe(0);
+
+      const json = JSON.parse(result.stdout);
+      expect(json.artifactId).toBe('design');
+      expect(json.outputPath).toContain('design.md');
+      expect(typeof json.template).toBe('string');
+      expect(Array.isArray(json.dependencies)).toBe(true);
+    });
+
+    it('errors when artifact argument is missing', async () => {
+      await createTestChange('test-change');
+
+      const result = await runCLI(['instructions', '--change', 'test-change'], { cwd: tempDir });
+      expect(result.exitCode).toBe(1);
+      const output = getOutput(result);
+      expect(output).toContain('Missing required argument <artifact>');
+      expect(output).toContain('Valid artifacts');
+    });
+
+    it('errors for unknown artifact', async () => {
+      await createTestChange('test-change');
+
+      const result = await runCLI(['instructions', 'unknown-artifact', '--change', 'test-change'], {
+        cwd: tempDir,
+      });
+      expect(result.exitCode).toBe(1);
+      const output = getOutput(result);
+      expect(output).toContain("Artifact 'unknown-artifact' not found");
+      expect(output).toContain('Valid artifacts');
+    });
+  });
+
+  describe('templates command', () => {
+    it('shows template paths for default schema', async () => {
+      const result = await runCLI(['templates'], { cwd: tempDir });
+      expect(result.exitCode).toBe(0);
+      expect(result.stdout).toContain('Schema: spec-driven');
+      expect(result.stdout).toContain('proposal:');
+      expect(result.stdout).toContain('design:');
+      expect(result.stdout).toContain('specs:');
+      expect(result.stdout).toContain('tasks:');
+    });
+
+    it('shows template paths for custom schema', async () => {
+      const result = await runCLI(['templates', '--schema', 'tdd'], { cwd: tempDir });
+      expect(result.exitCode).toBe(0);
+      expect(result.stdout).toContain('Schema: tdd');
+      expect(result.stdout).toContain('spec:');
+      expect(result.stdout).toContain('tests:');
+    });
+
+    it('outputs JSON mapping of templates', async () => {
+      const result = await runCLI(['templates', '--json'], { cwd: tempDir });
+      expect(result.exitCode).toBe(0);
+
+      const json = JSON.parse(result.stdout);
+      expect(json.proposal).toBeDefined();
+      expect(json.proposal.path).toContain('proposal.md');
+      expect(json.proposal.source).toBe('package');
+    });
+
+    it('errors for unknown schema', async () => {
+      const result = await runCLI(['templates', '--schema', 'nonexistent'], { cwd: tempDir });
+      expect(result.exitCode).toBe(1);
+      const output = getOutput(result);
+      expect(output).toContain("Schema 'nonexistent' not found");
+    });
+  });
+
+  describe('new change command', () => {
+    it('creates a new change directory', async () => {
+      const result = await runCLI(['new', 'change', 'my-new-feature'], { cwd: tempDir });
+      expect(result.exitCode).toBe(0);
+      const output = getOutput(result);
+      expect(output).toContain("Created change 'my-new-feature'");
+
+      const changeDir = path.join(changesDir, 'my-new-feature');
+      const stat = await fs.stat(changeDir);
+      expect(stat.isDirectory()).toBe(true);
+    });
+
+    it('creates README.md when --description is provided', async () => {
+      const result = await runCLI(
+        ['new', 'change', 'described-feature', '--description', 'This is a test feature'],
+        { cwd: tempDir }
+      );
+      expect(result.exitCode).toBe(0);
+
+      const readmePath = path.join(changesDir, 'described-feature', 'README.md');
+      const content = await fs.readFile(readmePath, 'utf-8');
+      expect(content).toContain('described-feature');
+      expect(content).toContain('This is a test feature');
+    });
+
+    it('errors for invalid change name with spaces', async () => {
+      const result = await runCLI(['new', 'change', 'invalid name'], { cwd: tempDir });
+      expect(result.exitCode).toBe(1);
+      const output = getOutput(result);
+      expect(output).toContain('Error');
+    });
+
+    it('errors for duplicate change name', async () => {
+      await createTestChange('existing-change');
+
+      const result = await runCLI(['new', 'change', 'existing-change'], { cwd: tempDir });
+      expect(result.exitCode).toBe(1);
+      const output = getOutput(result);
+      expect(output).toContain('exists');
+    });
+
+    it('errors when name argument is missing', async () => {
+      const result = await runCLI(['new', 'change'], { cwd: tempDir });
+      expect(result.exitCode).toBe(1);
+    });
+  });
+
+  describe('instructions apply command', () => {
+    it('shows apply instructions for spec-driven schema with tasks', async () => {
+      await createTestChange('apply-change', ['proposal', 'design', 'specs', 'tasks']);
+
+      const result = await runCLI(['instructions', 'apply', '--change', 'apply-change'], {
+        cwd: tempDir,
+      });
+      expect(result.exitCode).toBe(0);
+      expect(result.stdout).toContain('## Apply: apply-change');
+      expect(result.stdout).toContain('Schema: spec-driven');
+      expect(result.stdout).toContain('### Context Files');
+      expect(result.stdout).toContain('### Instruction');
+    });
+
+    it('shows blocked state when required artifacts are missing', async () => {
+      // Only create proposal - missing tasks (required by spec-driven apply block)
+      await createTestChange('blocked-apply', ['proposal']);
+
+      const result = await runCLI(['instructions', 'apply', '--change', 'blocked-apply'], {
+        cwd: tempDir,
+      });
+      expect(result.exitCode).toBe(0);
+      expect(result.stdout).toContain('Blocked');
+      expect(result.stdout).toContain('Missing artifacts: tasks');
+    });
+
+    it('outputs JSON for apply instructions', async () => {
+      await createTestChange('json-apply', ['proposal', 'design', 'specs', 'tasks']);
+
+      const result = await runCLI(
+        ['instructions', 'apply', '--change', 'json-apply', '--json'],
+        { cwd: tempDir }
+      );
+      expect(result.exitCode).toBe(0);
+
+      const json = JSON.parse(result.stdout);
+      expect(json.changeName).toBe('json-apply');
+      expect(json.schemaName).toBe('spec-driven');
+      expect(json.state).toBe('ready');
+      expect(json.contextFiles).toBeDefined();
+      expect(typeof json.contextFiles).toBe('object');
+    });
+
+    it('shows schema instruction from apply block', async () => {
+      await createTestChange('instr-apply', ['proposal', 'design', 'specs', 'tasks']);
+
+      const result = await runCLI(['instructions', 'apply', '--change', 'instr-apply'], {
+        cwd: tempDir,
+      });
+      expect(result.exitCode).toBe(0);
+      // Should show the instruction from spec-driven schema apply block
+      expect(result.stdout).toContain('work through pending tasks');
+    });
+
+    it('shows all_done state when all tasks are complete', async () => {
+      const changeDir = await createTestChange('done-apply', [
+        'proposal',
+        'design',
+        'specs',
+        'tasks',
+      ]);
+      // Overwrite tasks with all completed
+      await fs.writeFile(
+        path.join(changeDir, 'tasks.md'),
+        '## Tasks\n- [x] Task 1\n- [x] Task 2'
+      );
+
+      const result = await runCLI(['instructions', 'apply', '--change', 'done-apply'], {
+        cwd: tempDir,
+      });
+      expect(result.exitCode).toBe(0);
+      expect(result.stdout).toContain('complete âœ“');
+      expect(result.stdout).toContain('ready to be archived');
+    });
+
+    it('uses tdd schema apply configuration', async () => {
+      // Create a TDD-style change with spec and tests
+      const changeDir = path.join(changesDir, 'tdd-apply');
+      await fs.mkdir(changeDir, { recursive: true });
+      await fs.writeFile(path.join(changeDir, 'spec.md'), '## Feature\nTest spec.');
+      const testsDir = path.join(changeDir, 'tests');
+      await fs.mkdir(testsDir, { recursive: true });
+      await fs.writeFile(path.join(testsDir, 'test.test.ts'), 'test("works", () => {})');
+
+      const result = await runCLI(
+        ['instructions', 'apply', '--change', 'tdd-apply', '--schema', 'tdd'],
+        { cwd: tempDir }
+      );
+      expect(result.exitCode).toBe(0);
+      expect(result.stdout).toContain('Schema: tdd');
+      // TDD schema has no task tracking, so should show schema instruction
+      expect(result.stdout).toContain('Run tests to see failures');
+    });
+
+    it('spec-driven schema uses apply block configuration', async () => {
+      // Verify that spec-driven schema uses its apply block (requires: [tasks])
+      await createTestChange('apply-config-test', ['proposal', 'design', 'specs', 'tasks']);
+
+      const result = await runCLI(
+        ['instructions', 'apply', '--change', 'apply-config-test', '--json'],
+        { cwd: tempDir }
+      );
+      expect(result.exitCode).toBe(0);
+
+      const json = JSON.parse(result.stdout);
+      // spec-driven schema has apply block with requires: [tasks], so should be ready
+      expect(json.schemaName).toBe('spec-driven');
+      expect(json.state).toBe('ready');
+    });
+
+    it('fallback: requires all artifacts when schema has no apply block', async () => {
+      // Create a minimal schema without an apply block in user schemas dir
+      const userDataDir = path.join(tempDir, 'user-data');
+      const noApplySchemaDir = path.join(userDataDir, 'openspec', 'schemas', 'no-apply');
+      const templatesDir = path.join(noApplySchemaDir, 'templates');
+      await fs.mkdir(templatesDir, { recursive: true });
+
+      // Minimal schema with 2 artifacts, no apply block
+      const schemaContent = `
+name: no-apply
+version: 1
+description: Test schema without apply block
+artifacts:
+  - id: first
+    generates: first.md
+    description: First artifact
+    template: first.md
+    requires: []
+  - id: second
+    generates: second.md
+    description: Second artifact
+    template: second.md
+    requires: [first]
+`;
+      await fs.writeFile(path.join(noApplySchemaDir, 'schema.yaml'), schemaContent);
+      await fs.writeFile(path.join(templatesDir, 'first.md'), '# First\n');
+      await fs.writeFile(path.join(templatesDir, 'second.md'), '# Second\n');
+
+      // Create a change with only the first artifact (missing second)
+      const changeDir = path.join(changesDir, 'no-apply-test');
+      await fs.mkdir(changeDir, { recursive: true });
+      await fs.writeFile(path.join(changeDir, 'first.md'), '# First artifact content');
+
+      // Run with XDG_DATA_HOME pointing to our temp user data dir
+      const result = await runCLI(
+        ['instructions', 'apply', '--change', 'no-apply-test', '--schema', 'no-apply', '--json'],
+        {
+          cwd: tempDir,
+          env: { XDG_DATA_HOME: userDataDir },
+        }
+      );
+      expect(result.exitCode).toBe(0);
+
+      const json = JSON.parse(result.stdout);
+      // Without apply block, fallback requires ALL artifacts - second is missing
+      expect(json.schemaName).toBe('no-apply');
+      expect(json.state).toBe('blocked');
+      expect(json.missingArtifacts).toContain('second');
+    });
+
+    it('fallback: ready when all artifacts exist for schema without apply block', async () => {
+      // Create a minimal schema without an apply block
+      const userDataDir = path.join(tempDir, 'user-data-2');
+      const noApplySchemaDir = path.join(userDataDir, 'openspec', 'schemas', 'no-apply-full');
+      const templatesDir = path.join(noApplySchemaDir, 'templates');
+      await fs.mkdir(templatesDir, { recursive: true });
+
+      const schemaContent = `
+name: no-apply-full
+version: 1
+description: Test schema without apply block
+artifacts:
+  - id: only
+    generates: only.md
+    description: Only artifact
+    template: only.md
+    requires: []
+`;
+      await fs.writeFile(path.join(noApplySchemaDir, 'schema.yaml'), schemaContent);
+      await fs.writeFile(path.join(templatesDir, 'only.md'), '# Only\n');
+
+      // Create a change with the artifact present
+      const changeDir = path.join(changesDir, 'no-apply-full-test');
+      await fs.mkdir(changeDir, { recursive: true });
+      await fs.writeFile(path.join(changeDir, 'only.md'), '# Content');
+
+      const result = await runCLI(
+        ['instructions', 'apply', '--change', 'no-apply-full-test', '--schema', 'no-apply-full', '--json'],
+        {
+          cwd: tempDir,
+          env: { XDG_DATA_HOME: userDataDir },
+        }
+      );
+      expect(result.exitCode).toBe(0);
+
+      const json = JSON.parse(result.stdout);
+      // All artifacts exist, should be ready with default instruction
+      expect(json.schemaName).toBe('no-apply-full');
+      expect(json.state).toBe('ready');
+      expect(json.instruction).toContain('All required artifacts complete');
+    });
+  });
+
+  describe('help text', () => {
+    it('marks status command as experimental in help', async () => {
+      const result = await runCLI(['status', '--help']);
+      expect(result.exitCode).toBe(0);
+      expect(result.stdout).toContain('[Experimental]');
+    });
+
+    it('marks instructions command as experimental in help', async () => {
+      const result = await runCLI(['instructions', '--help']);
+      expect(result.exitCode).toBe(0);
+      expect(result.stdout).toContain('[Experimental]');
+    });
+
+    it('marks templates command as experimental in help', async () => {
+      const result = await runCLI(['templates', '--help']);
+      expect(result.exitCode).toBe(0);
+      expect(result.stdout).toContain('[Experimental]');
+    });
+
+    it('marks new command as experimental in help', async () => {
+      const result = await runCLI(['new', '--help']);
+      expect(result.exitCode).toBe(0);
+      expect(result.stdout).toContain('[Experimental]');
+    });
+  });
+});
diff --git a/test/core/archive.test.ts b/test/core/archive.test.ts
index d950d21..597dbfb 100644
--- a/test/core/archive.test.ts
+++ b/test/core/archive.test.ts
@@ -127,6 +127,133 @@ Then expected result happens`;
       expect(updatedContent).toContain('#### Scenario: Basic test');
     });
 
+    it('should allow REMOVED requirements when creating new spec file (issue #403)', async () => {
+      const changeName = 'new-spec-with-removed';
+      const changeDir = path.join(tempDir, 'openspec', 'changes', changeName);
+      const changeSpecDir = path.join(changeDir, 'specs', 'gift-card');
+      await fs.mkdir(changeSpecDir, { recursive: true });
+      
+      // Create delta spec with both ADDED and REMOVED requirements
+      // This simulates refactoring where old fields are removed and new ones are added
+      const specContent = `# Gift Card - Changes
+
+## ADDED Requirements
+
+### Requirement: Logo and Background Color
+The system SHALL support logo and backgroundColor fields for gift cards.
+
+#### Scenario: Display gift card with logo
+- **WHEN** a gift card is displayed
+- **THEN** it shows the logo and backgroundColor
+
+## REMOVED Requirements
+
+### Requirement: Image Field
+### Requirement: Thumbnail Field`;
+      await fs.writeFile(path.join(changeSpecDir, 'spec.md'), specContent);
+      
+      // Execute archive - should succeed with warning about REMOVED requirements
+      await archiveCommand.execute(changeName, { yes: true, noValidate: true });
+      
+      // Verify warning was logged about REMOVED requirements being ignored
+      expect(console.log).toHaveBeenCalledWith(
+        expect.stringContaining('Warning: gift-card - 2 REMOVED requirement(s) ignored for new spec (nothing to remove).')
+      );
+      
+      // Verify spec was created with only ADDED requirements
+      const mainSpecPath = path.join(tempDir, 'openspec', 'specs', 'gift-card', 'spec.md');
+      const updatedContent = await fs.readFile(mainSpecPath, 'utf-8');
+      expect(updatedContent).toContain('# gift-card Specification');
+      expect(updatedContent).toContain('### Requirement: Logo and Background Color');
+      expect(updatedContent).toContain('#### Scenario: Display gift card with logo');
+      // REMOVED requirements should not be in the final spec
+      expect(updatedContent).not.toContain('### Requirement: Image Field');
+      expect(updatedContent).not.toContain('### Requirement: Thumbnail Field');
+      
+      // Verify change was archived successfully
+      const archiveDir = path.join(tempDir, 'openspec', 'changes', 'archive');
+      const archives = await fs.readdir(archiveDir);
+      expect(archives.length).toBeGreaterThan(0);
+      expect(archives.some(a => a.includes(changeName))).toBe(true);
+    });
+
+    it('should still error on MODIFIED when creating new spec file', async () => {
+      const changeName = 'new-spec-with-modified';
+      const changeDir = path.join(tempDir, 'openspec', 'changes', changeName);
+      const changeSpecDir = path.join(changeDir, 'specs', 'new-capability');
+      await fs.mkdir(changeSpecDir, { recursive: true });
+      
+      // Create delta spec with MODIFIED requirement (should fail for new spec)
+      const specContent = `# New Capability - Changes
+
+## ADDED Requirements
+
+### Requirement: New Feature
+New feature description.
+
+## MODIFIED Requirements
+
+### Requirement: Existing Feature
+Modified content.`;
+      await fs.writeFile(path.join(changeSpecDir, 'spec.md'), specContent);
+      
+      // Execute archive - should abort with error message (not throw, but log and return)
+      await archiveCommand.execute(changeName, { yes: true, noValidate: true });
+      
+      // Verify error message mentions MODIFIED not allowed for new specs
+      expect(console.log).toHaveBeenCalledWith(
+        expect.stringContaining('new-capability: target spec does not exist; only ADDED requirements are allowed for new specs. MODIFIED and RENAMED operations require an existing spec.')
+      );
+      expect(console.log).toHaveBeenCalledWith('Aborted. No files were changed.');
+      
+      // Verify spec was NOT created
+      const mainSpecPath = path.join(tempDir, 'openspec', 'specs', 'new-capability', 'spec.md');
+      await expect(fs.access(mainSpecPath)).rejects.toThrow();
+      
+      // Verify change was NOT archived
+      const archiveDir = path.join(tempDir, 'openspec', 'changes', 'archive');
+      const archives = await fs.readdir(archiveDir);
+      expect(archives.some(a => a.includes(changeName))).toBe(false);
+    });
+
+    it('should still error on RENAMED when creating new spec file', async () => {
+      const changeName = 'new-spec-with-renamed';
+      const changeDir = path.join(tempDir, 'openspec', 'changes', changeName);
+      const changeSpecDir = path.join(changeDir, 'specs', 'another-capability');
+      await fs.mkdir(changeSpecDir, { recursive: true });
+      
+      // Create delta spec with RENAMED requirement (should fail for new spec)
+      const specContent = `# Another Capability - Changes
+
+## ADDED Requirements
+
+### Requirement: New Feature
+New feature description.
+
+## RENAMED Requirements
+- FROM: \`### Requirement: Old Name\`
+- TO: \`### Requirement: New Name\``;
+      await fs.writeFile(path.join(changeSpecDir, 'spec.md'), specContent);
+      
+      // Execute archive - should abort with error message (not throw, but log and return)
+      await archiveCommand.execute(changeName, { yes: true, noValidate: true });
+      
+      // Verify error message mentions RENAMED not allowed for new specs
+      expect(console.log).toHaveBeenCalledWith(
+        expect.stringContaining('another-capability: target spec does not exist; only ADDED requirements are allowed for new specs. MODIFIED and RENAMED operations require an existing spec.')
+      );
+      expect(console.log).toHaveBeenCalledWith('Aborted. No files were changed.');
+      
+      // Verify spec was NOT created
+      const mainSpecPath = path.join(tempDir, 'openspec', 'specs', 'another-capability', 'spec.md');
+      await expect(fs.access(mainSpecPath)).rejects.toThrow();
+      
+      // Verify change was NOT archived
+      const archiveDir = path.join(tempDir, 'openspec', 'changes', 'archive');
+      const archives = await fs.readdir(archiveDir);
+      expect(archives.some(a => a.includes(changeName))).toBe(false);
+    });
+
     it('should throw error if change does not exist', async () => {
       await expect(
         archiveCommand.execute('non-existent-change', { yes: true })
diff --git a/test/core/artifact-graph/graph.test.ts b/test/core/artifact-graph/graph.test.ts
new file mode 100644
index 0000000..5602075
--- /dev/null
+++ b/test/core/artifact-graph/graph.test.ts
@@ -0,0 +1,268 @@
+import { describe, it, expect } from 'vitest';
+import { ArtifactGraph } from '../../../src/core/artifact-graph/graph.js';
+import type { SchemaYaml } from '../../../src/core/artifact-graph/types.js';
+
+describe('artifact-graph/graph', () => {
+  const createSchema = (artifacts: SchemaYaml['artifacts']): SchemaYaml => ({
+    name: 'test',
+    version: 1,
+    artifacts,
+  });
+
+  describe('fromSchema', () => {
+    it('should create graph from schema object', () => {
+      const schema = createSchema([
+        { id: 'A', generates: 'a.md', description: 'A', template: 't.md', requires: [] },
+      ]);
+
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      expect(graph.getName()).toBe('test');
+      expect(graph.getVersion()).toBe(1);
+    });
+  });
+
+  describe('fromYamlContent', () => {
+    it('should create graph from YAML string', () => {
+      const yaml = `
+name: my-workflow
+version: 2
+artifacts:
+  - id: doc
+    generates: doc.md
+    description: Documentation
+    template: templates/doc.md
+`;
+      const graph = ArtifactGraph.fromYamlContent(yaml);
+
+      expect(graph.getName()).toBe('my-workflow');
+      expect(graph.getVersion()).toBe(2);
+      expect(graph.getArtifact('doc')).toBeDefined();
+    });
+  });
+
+  describe('getArtifact', () => {
+    it('should return artifact by ID', () => {
+      const schema = createSchema([
+        { id: 'proposal', generates: 'proposal.md', description: 'Proposal', template: 't.md', requires: [] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      const artifact = graph.getArtifact('proposal');
+
+      expect(artifact).toBeDefined();
+      expect(artifact?.id).toBe('proposal');
+      expect(artifact?.generates).toBe('proposal.md');
+    });
+
+    it('should return undefined for non-existent ID', () => {
+      const schema = createSchema([
+        { id: 'A', generates: 'a.md', description: 'A', template: 't.md', requires: [] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      expect(graph.getArtifact('nonexistent')).toBeUndefined();
+    });
+  });
+
+  describe('getAllArtifacts', () => {
+    it('should return all artifacts', () => {
+      const schema = createSchema([
+        { id: 'A', generates: 'a.md', description: 'A', template: 't.md', requires: [] },
+        { id: 'B', generates: 'b.md', description: 'B', template: 't.md', requires: ['A'] },
+        { id: 'C', generates: 'c.md', description: 'C', template: 't.md', requires: [] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      const artifacts = graph.getAllArtifacts();
+
+      expect(artifacts).toHaveLength(3);
+      expect(artifacts.map(a => a.id).sort()).toEqual(['A', 'B', 'C']);
+    });
+  });
+
+  describe('getBuildOrder', () => {
+    it('should return correct order for linear chain A â†’ B â†’ C', () => {
+      const schema = createSchema([
+        { id: 'C', generates: 'c.md', description: 'C', template: 't.md', requires: ['B'] },
+        { id: 'A', generates: 'a.md', description: 'A', template: 't.md', requires: [] },
+        { id: 'B', generates: 'b.md', description: 'B', template: 't.md', requires: ['A'] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      const order = graph.getBuildOrder();
+
+      expect(order).toEqual(['A', 'B', 'C']);
+    });
+
+    it('should handle diamond dependency correctly', () => {
+      // A â†’ B, A â†’ C, B â†’ D, C â†’ D
+      const schema = createSchema([
+        { id: 'D', generates: 'd.md', description: 'D', template: 't.md', requires: ['B', 'C'] },
+        { id: 'B', generates: 'b.md', description: 'B', template: 't.md', requires: ['A'] },
+        { id: 'C', generates: 'c.md', description: 'C', template: 't.md', requires: ['A'] },
+        { id: 'A', generates: 'a.md', description: 'A', template: 't.md', requires: [] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      const order = graph.getBuildOrder();
+
+      // A must come before B and C; D must come last
+      expect(order.indexOf('A')).toBeLessThan(order.indexOf('B'));
+      expect(order.indexOf('A')).toBeLessThan(order.indexOf('C'));
+      expect(order.indexOf('B')).toBeLessThan(order.indexOf('D'));
+      expect(order.indexOf('C')).toBeLessThan(order.indexOf('D'));
+    });
+
+    it('should return independent artifacts in stable sorted order', () => {
+      const schema = createSchema([
+        { id: 'Z', generates: 'z.md', description: 'Z', template: 't.md', requires: [] },
+        { id: 'A', generates: 'a.md', description: 'A', template: 't.md', requires: [] },
+        { id: 'M', generates: 'm.md', description: 'M', template: 't.md', requires: [] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      const order = graph.getBuildOrder();
+
+      // All independent, should be sorted alphabetically for stability
+      expect(order).toEqual(['A', 'M', 'Z']);
+    });
+  });
+
+  describe('getNextArtifacts', () => {
+    it('should return root artifacts when nothing completed', () => {
+      const schema = createSchema([
+        { id: 'A', generates: 'a.md', description: 'A', template: 't.md', requires: [] },
+        { id: 'B', generates: 'b.md', description: 'B', template: 't.md', requires: ['A'] },
+        { id: 'C', generates: 'c.md', description: 'C', template: 't.md', requires: [] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      const ready = graph.getNextArtifacts(new Set());
+
+      expect(ready.sort()).toEqual(['A', 'C']);
+    });
+
+    it('should include artifact when all deps completed', () => {
+      const schema = createSchema([
+        { id: 'A', generates: 'a.md', description: 'A', template: 't.md', requires: [] },
+        { id: 'B', generates: 'b.md', description: 'B', template: 't.md', requires: ['A'] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      const ready = graph.getNextArtifacts(new Set(['A']));
+
+      expect(ready).toEqual(['B']);
+    });
+
+    it('should not include completed artifacts', () => {
+      const schema = createSchema([
+        { id: 'A', generates: 'a.md', description: 'A', template: 't.md', requires: [] },
+        { id: 'B', generates: 'b.md', description: 'B', template: 't.md', requires: ['A'] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      const ready = graph.getNextArtifacts(new Set(['A', 'B']));
+
+      expect(ready).toEqual([]);
+    });
+
+    it('should handle diamond dependency correctly', () => {
+      // D requires B and C
+      const schema = createSchema([
+        { id: 'A', generates: 'a.md', description: 'A', template: 't.md', requires: [] },
+        { id: 'B', generates: 'b.md', description: 'B', template: 't.md', requires: ['A'] },
+        { id: 'C', generates: 'c.md', description: 'C', template: 't.md', requires: ['A'] },
+        { id: 'D', generates: 'd.md', description: 'D', template: 't.md', requires: ['B', 'C'] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      // Only A completed - B and C ready, D not
+      expect(graph.getNextArtifacts(new Set(['A'])).sort()).toEqual(['B', 'C']);
+
+      // Only B completed (from deps) - C still needed for D
+      expect(graph.getNextArtifacts(new Set(['A', 'B']))).toEqual(['C']);
+
+      // Both B and C completed - D ready
+      expect(graph.getNextArtifacts(new Set(['A', 'B', 'C']))).toEqual(['D']);
+    });
+  });
+
+  describe('isComplete', () => {
+    it('should return true when all artifacts completed', () => {
+      const schema = createSchema([
+        { id: 'A', generates: 'a.md', description: 'A', template: 't.md', requires: [] },
+        { id: 'B', generates: 'b.md', description: 'B', template: 't.md', requires: ['A'] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      expect(graph.isComplete(new Set(['A', 'B']))).toBe(true);
+    });
+
+    it('should return false when some artifacts incomplete', () => {
+      const schema = createSchema([
+        { id: 'A', generates: 'a.md', description: 'A', template: 't.md', requires: [] },
+        { id: 'B', generates: 'b.md', description: 'B', template: 't.md', requires: ['A'] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      expect(graph.isComplete(new Set(['A']))).toBe(false);
+      expect(graph.isComplete(new Set())).toBe(false);
+    });
+  });
+
+  describe('getBlocked', () => {
+    it('should return empty object when nothing is blocked', () => {
+      const schema = createSchema([
+        { id: 'A', generates: 'a.md', description: 'A', template: 't.md', requires: [] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      expect(graph.getBlocked(new Set())).toEqual({});
+    });
+
+    it('should return artifact blocked by single dependency', () => {
+      const schema = createSchema([
+        { id: 'A', generates: 'a.md', description: 'A', template: 't.md', requires: [] },
+        { id: 'B', generates: 'b.md', description: 'B', template: 't.md', requires: ['A'] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      expect(graph.getBlocked(new Set())).toEqual({ B: ['A'] });
+    });
+
+    it('should return artifact blocked by multiple dependencies', () => {
+      const schema = createSchema([
+        { id: 'A', generates: 'a.md', description: 'A', template: 't.md', requires: [] },
+        { id: 'B', generates: 'b.md', description: 'B', template: 't.md', requires: [] },
+        { id: 'C', generates: 'c.md', description: 'C', template: 't.md', requires: ['A', 'B'] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      // Neither A nor B completed
+      expect(graph.getBlocked(new Set())).toEqual({ C: ['A', 'B'] });
+    });
+
+    it('should only list unmet dependencies', () => {
+      const schema = createSchema([
+        { id: 'A', generates: 'a.md', description: 'A', template: 't.md', requires: [] },
+        { id: 'B', generates: 'b.md', description: 'B', template: 't.md', requires: [] },
+        { id: 'C', generates: 'c.md', description: 'C', template: 't.md', requires: ['A', 'B'] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      // A completed, B not
+      expect(graph.getBlocked(new Set(['A']))).toEqual({ C: ['B'] });
+    });
+
+    it('should not include completed artifacts', () => {
+      const schema = createSchema([
+        { id: 'A', generates: 'a.md', description: 'A', template: 't.md', requires: [] },
+        { id: 'B', generates: 'b.md', description: 'B', template: 't.md', requires: ['A'] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      expect(graph.getBlocked(new Set(['A', 'B']))).toEqual({});
+    });
+  });
+});
diff --git a/test/core/artifact-graph/instruction-loader.test.ts b/test/core/artifact-graph/instruction-loader.test.ts
new file mode 100644
index 0000000..1d0e779
--- /dev/null
+++ b/test/core/artifact-graph/instruction-loader.test.ts
@@ -0,0 +1,300 @@
+import { describe, it, expect, beforeEach, afterEach } from 'vitest';
+import * as fs from 'node:fs';
+import * as path from 'node:path';
+import * as os from 'node:os';
+import {
+  loadTemplate,
+  loadChangeContext,
+  generateInstructions,
+  formatChangeStatus,
+  TemplateLoadError,
+} from '../../../src/core/artifact-graph/instruction-loader.js';
+
+describe('instruction-loader', () => {
+  describe('loadTemplate', () => {
+    it('should load template from schema directory', () => {
+      // Uses built-in spec-driven schema
+      const template = loadTemplate('spec-driven', 'proposal.md');
+
+      expect(template).toContain('## Why');
+      expect(template).toContain('## What Changes');
+    });
+
+    it('should throw TemplateLoadError for non-existent template', () => {
+      expect(() => loadTemplate('spec-driven', 'nonexistent.md')).toThrow(
+        TemplateLoadError
+      );
+    });
+
+    it('should throw TemplateLoadError for non-existent schema', () => {
+      expect(() => loadTemplate('nonexistent-schema', 'proposal.md')).toThrow(
+        TemplateLoadError
+      );
+    });
+
+    it('should include template path in error', () => {
+      try {
+        loadTemplate('spec-driven', 'nonexistent.md');
+        expect.fail('Should have thrown');
+      } catch (err) {
+        expect(err).toBeInstanceOf(TemplateLoadError);
+        expect((err as TemplateLoadError).templatePath).toContain('nonexistent.md');
+      }
+    });
+  });
+
+  describe('loadChangeContext', () => {
+    let tempDir: string;
+
+    beforeEach(() => {
+      tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'openspec-test-'));
+    });
+
+    afterEach(() => {
+      fs.rmSync(tempDir, { recursive: true, force: true });
+    });
+
+    it('should load context with default schema', () => {
+      const context = loadChangeContext(tempDir, 'my-change');
+
+      expect(context.schemaName).toBe('spec-driven');
+      expect(context.changeName).toBe('my-change');
+      expect(context.graph.getName()).toBe('spec-driven');
+      expect(context.completed.size).toBe(0);
+    });
+
+    it('should load context with custom schema', () => {
+      const context = loadChangeContext(tempDir, 'my-change', 'tdd');
+
+      expect(context.schemaName).toBe('tdd');
+      expect(context.graph.getName()).toBe('tdd');
+    });
+
+    it('should detect completed artifacts', () => {
+      // Create change directory with proposal.md
+      const changeDir = path.join(tempDir, 'openspec', 'changes', 'my-change');
+      fs.mkdirSync(changeDir, { recursive: true });
+      fs.writeFileSync(path.join(changeDir, 'proposal.md'), '# Proposal');
+
+      const context = loadChangeContext(tempDir, 'my-change');
+
+      expect(context.completed.has('proposal')).toBe(true);
+    });
+
+    it('should return empty completed set for non-existent change directory', () => {
+      const context = loadChangeContext(tempDir, 'nonexistent-change');
+
+      expect(context.completed.size).toBe(0);
+    });
+
+    it('should auto-detect schema from .openspec.yaml metadata', () => {
+      // Create change directory with metadata file
+      const changeDir = path.join(tempDir, 'openspec', 'changes', 'my-change');
+      fs.mkdirSync(changeDir, { recursive: true });
+      fs.writeFileSync(path.join(changeDir, '.openspec.yaml'), 'schema: tdd\ncreated: "2025-01-05"\n');
+
+      // Load without explicit schema - should detect from metadata
+      const context = loadChangeContext(tempDir, 'my-change');
+
+      expect(context.schemaName).toBe('tdd');
+      expect(context.graph.getName()).toBe('tdd');
+    });
+
+    it('should use explicit schema over metadata schema', () => {
+      // Create change directory with metadata file using tdd
+      const changeDir = path.join(tempDir, 'openspec', 'changes', 'my-change');
+      fs.mkdirSync(changeDir, { recursive: true });
+      fs.writeFileSync(path.join(changeDir, '.openspec.yaml'), 'schema: tdd\n');
+
+      // Load with explicit schema - should override metadata
+      const context = loadChangeContext(tempDir, 'my-change', 'spec-driven');
+
+      expect(context.schemaName).toBe('spec-driven');
+      expect(context.graph.getName()).toBe('spec-driven');
+    });
+
+    it('should fall back to default when no metadata and no explicit schema', () => {
+      // Create change directory without metadata file
+      const changeDir = path.join(tempDir, 'openspec', 'changes', 'my-change');
+      fs.mkdirSync(changeDir, { recursive: true });
+
+      const context = loadChangeContext(tempDir, 'my-change');
+
+      expect(context.schemaName).toBe('spec-driven');
+    });
+  });
+
+  describe('generateInstructions', () => {
+    let tempDir: string;
+
+    beforeEach(() => {
+      tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'openspec-test-'));
+    });
+
+    afterEach(() => {
+      fs.rmSync(tempDir, { recursive: true, force: true });
+    });
+
+    it('should include artifact metadata', () => {
+      const context = loadChangeContext(tempDir, 'my-change');
+      const instructions = generateInstructions(context, 'proposal');
+
+      expect(instructions.changeName).toBe('my-change');
+      expect(instructions.artifactId).toBe('proposal');
+      expect(instructions.schemaName).toBe('spec-driven');
+      expect(instructions.outputPath).toBe('proposal.md');
+    });
+
+    it('should include template content', () => {
+      const context = loadChangeContext(tempDir, 'my-change');
+      const instructions = generateInstructions(context, 'proposal');
+
+      expect(instructions.template).toContain('## Why');
+    });
+
+    it('should show dependencies with completion status', () => {
+      const context = loadChangeContext(tempDir, 'my-change');
+      const instructions = generateInstructions(context, 'specs');
+
+      expect(instructions.dependencies).toHaveLength(1);
+      expect(instructions.dependencies[0].id).toBe('proposal');
+      expect(instructions.dependencies[0].done).toBe(false);
+    });
+
+    it('should mark completed dependencies as done', () => {
+      // Create proposal
+      const changeDir = path.join(tempDir, 'openspec', 'changes', 'my-change');
+      fs.mkdirSync(changeDir, { recursive: true });
+      fs.writeFileSync(path.join(changeDir, 'proposal.md'), '# Proposal');
+
+      const context = loadChangeContext(tempDir, 'my-change');
+      const instructions = generateInstructions(context, 'specs');
+
+      expect(instructions.dependencies[0].done).toBe(true);
+    });
+
+    it('should list artifacts unlocked by this one', () => {
+      const context = loadChangeContext(tempDir, 'my-change');
+      const instructions = generateInstructions(context, 'proposal');
+
+      // proposal unlocks specs and design
+      expect(instructions.unlocks).toContain('specs');
+      expect(instructions.unlocks).toContain('design');
+    });
+
+    it('should have empty dependencies for root artifact', () => {
+      const context = loadChangeContext(tempDir, 'my-change');
+      const instructions = generateInstructions(context, 'proposal');
+
+      expect(instructions.dependencies).toHaveLength(0);
+    });
+
+    it('should throw for non-existent artifact', () => {
+      const context = loadChangeContext(tempDir, 'my-change');
+
+      expect(() => generateInstructions(context, 'nonexistent')).toThrow(
+        "Artifact 'nonexistent' not found"
+      );
+    });
+  });
+
+  describe('formatChangeStatus', () => {
+    let tempDir: string;
+
+    beforeEach(() => {
+      tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'openspec-test-'));
+    });
+
+    afterEach(() => {
+      fs.rmSync(tempDir, { recursive: true, force: true });
+    });
+
+    it('should show all artifacts as ready/blocked when nothing completed', () => {
+      const context = loadChangeContext(tempDir, 'my-change');
+      const status = formatChangeStatus(context);
+
+      expect(status.changeName).toBe('my-change');
+      expect(status.schemaName).toBe('spec-driven');
+      expect(status.isComplete).toBe(false);
+
+      // proposal has no deps, should be ready
+      const proposal = status.artifacts.find(a => a.id === 'proposal');
+      expect(proposal?.status).toBe('ready');
+
+      // specs depends on proposal, should be blocked
+      const specs = status.artifacts.find(a => a.id === 'specs');
+      expect(specs?.status).toBe('blocked');
+      expect(specs?.missingDeps).toContain('proposal');
+    });
+
+    it('should show completed artifacts as done', () => {
+      const changeDir = path.join(tempDir, 'openspec', 'changes', 'my-change');
+      fs.mkdirSync(changeDir, { recursive: true });
+      fs.writeFileSync(path.join(changeDir, 'proposal.md'), '# Proposal');
+
+      const context = loadChangeContext(tempDir, 'my-change');
+      const status = formatChangeStatus(context);
+
+      const proposal = status.artifacts.find(a => a.id === 'proposal');
+      expect(proposal?.status).toBe('done');
+
+      // specs should now be ready
+      const specs = status.artifacts.find(a => a.id === 'specs');
+      expect(specs?.status).toBe('ready');
+    });
+
+    it('should include output paths for each artifact', () => {
+      const context = loadChangeContext(tempDir, 'my-change');
+      const status = formatChangeStatus(context);
+
+      const proposal = status.artifacts.find(a => a.id === 'proposal');
+      expect(proposal?.outputPath).toBe('proposal.md');
+
+      const specs = status.artifacts.find(a => a.id === 'specs');
+      expect(specs?.outputPath).toBe('specs/**/*.md');
+    });
+
+    it('should report isComplete true when all done', () => {
+      const changeDir = path.join(tempDir, 'openspec', 'changes', 'my-change');
+      fs.mkdirSync(changeDir, { recursive: true });
+      fs.mkdirSync(path.join(changeDir, 'specs'), { recursive: true });
+
+      // Create all required files for spec-driven schema
+      fs.writeFileSync(path.join(changeDir, 'proposal.md'), '# Proposal');
+      fs.writeFileSync(path.join(changeDir, 'specs', 'test.md'), '# Spec');
+      fs.writeFileSync(path.join(changeDir, 'design.md'), '# Design');
+      fs.writeFileSync(path.join(changeDir, 'tasks.md'), '# Tasks');
+
+      const context = loadChangeContext(tempDir, 'my-change');
+      const status = formatChangeStatus(context);
+
+      expect(status.isComplete).toBe(true);
+      expect(status.artifacts.every(a => a.status === 'done')).toBe(true);
+    });
+
+    it('should show blocked artifacts with missing dependencies', () => {
+      const context = loadChangeContext(tempDir, 'my-change');
+      const status = formatChangeStatus(context);
+
+      // tasks requires specs and design
+      const tasks = status.artifacts.find(a => a.id === 'tasks');
+      expect(tasks?.status).toBe('blocked');
+      expect(tasks?.missingDeps).toContain('specs');
+      expect(tasks?.missingDeps).toContain('design');
+    });
+
+    it('should sort artifacts in build order', () => {
+      const context = loadChangeContext(tempDir, 'my-change');
+      const status = formatChangeStatus(context);
+
+      const ids = status.artifacts.map(a => a.id);
+      const proposalIdx = ids.indexOf('proposal');
+      const specsIdx = ids.indexOf('specs');
+      const tasksIdx = ids.indexOf('tasks');
+
+      // proposal must come before specs, specs before tasks
+      expect(proposalIdx).toBeLessThan(specsIdx);
+      expect(specsIdx).toBeLessThan(tasksIdx);
+    });
+  });
+});
diff --git a/test/core/artifact-graph/resolver.test.ts b/test/core/artifact-graph/resolver.test.ts
new file mode 100644
index 0000000..a87624c
--- /dev/null
+++ b/test/core/artifact-graph/resolver.test.ts
@@ -0,0 +1,327 @@
+import { describe, it, expect, beforeEach, afterEach } from 'vitest';
+import * as fs from 'node:fs';
+import * as path from 'node:path';
+import * as os from 'node:os';
+import {
+  resolveSchema,
+  listSchemas,
+  SchemaLoadError,
+  getSchemaDir,
+  getPackageSchemasDir,
+  getUserSchemasDir,
+} from '../../../src/core/artifact-graph/resolver.js';
+
+describe('artifact-graph/resolver', () => {
+  let tempDir: string;
+  let originalEnv: NodeJS.ProcessEnv;
+
+  beforeEach(() => {
+    tempDir = path.join(os.tmpdir(), `openspec-resolver-test-${Date.now()}`);
+    fs.mkdirSync(tempDir, { recursive: true });
+    originalEnv = { ...process.env };
+  });
+
+  afterEach(() => {
+    process.env = originalEnv;
+    fs.rmSync(tempDir, { recursive: true, force: true });
+  });
+
+  describe('getPackageSchemasDir', () => {
+    it('should return a valid path', () => {
+      const schemasDir = getPackageSchemasDir();
+      expect(typeof schemasDir).toBe('string');
+      expect(schemasDir.length).toBeGreaterThan(0);
+    });
+  });
+
+  describe('getUserSchemasDir', () => {
+    it('should use XDG_DATA_HOME when set', () => {
+      process.env.XDG_DATA_HOME = tempDir;
+      const userDir = getUserSchemasDir();
+      expect(userDir).toBe(path.join(tempDir, 'openspec', 'schemas'));
+    });
+  });
+
+  describe('getSchemaDir', () => {
+    it('should return null for non-existent schema', () => {
+      const dir = getSchemaDir('nonexistent-schema');
+      expect(dir).toBeNull();
+    });
+
+    it('should return package dir for built-in schema', () => {
+      const dir = getSchemaDir('spec-driven');
+      expect(dir).not.toBeNull();
+      expect(dir).toContain('schemas');
+      expect(dir).toContain('spec-driven');
+    });
+
+    it('should prefer user override directory', () => {
+      process.env.XDG_DATA_HOME = tempDir;
+      const userSchemaDir = path.join(tempDir, 'openspec', 'schemas', 'spec-driven');
+      fs.mkdirSync(userSchemaDir, { recursive: true });
+      fs.writeFileSync(
+        path.join(userSchemaDir, 'schema.yaml'),
+        'name: custom\nversion: 1\nartifacts: []'
+      );
+
+      const dir = getSchemaDir('spec-driven');
+      expect(dir).toBe(userSchemaDir);
+    });
+  });
+
+  describe('resolveSchema', () => {
+    it('should return built-in spec-driven schema', () => {
+      const schema = resolveSchema('spec-driven');
+
+      expect(schema.name).toBe('spec-driven');
+      expect(schema.version).toBe(1);
+      expect(schema.artifacts.length).toBeGreaterThan(0);
+    });
+
+    it('should return built-in tdd schema', () => {
+      const schema = resolveSchema('tdd');
+
+      expect(schema.name).toBe('tdd');
+      expect(schema.version).toBe(1);
+      expect(schema.artifacts.length).toBeGreaterThan(0);
+    });
+
+    it('should strip .yaml extension from name', () => {
+      const schema1 = resolveSchema('spec-driven');
+      const schema2 = resolveSchema('spec-driven.yaml');
+
+      expect(schema1).toEqual(schema2);
+    });
+
+    it('should strip .yml extension from name', () => {
+      const schema1 = resolveSchema('spec-driven');
+      const schema2 = resolveSchema('spec-driven.yml');
+
+      expect(schema1).toEqual(schema2);
+    });
+
+    it('should prefer user override over built-in', () => {
+      // Set up global data dir
+      process.env.XDG_DATA_HOME = tempDir;
+      const userSchemaDir = path.join(tempDir, 'openspec', 'schemas', 'spec-driven');
+      fs.mkdirSync(userSchemaDir, { recursive: true });
+
+      // Create a custom schema with same name as built-in
+      const customSchema = `
+name: custom-override
+version: 99
+artifacts:
+  - id: custom
+    generates: custom.md
+    description: Custom artifact
+    template: custom.md
+`;
+      fs.writeFileSync(path.join(userSchemaDir, 'schema.yaml'), customSchema);
+
+      const schema = resolveSchema('spec-driven');
+
+      expect(schema.name).toBe('custom-override');
+      expect(schema.version).toBe(99);
+    });
+
+    it('should validate user override and throw on invalid schema', () => {
+      process.env.XDG_DATA_HOME = tempDir;
+      const userSchemaDir = path.join(tempDir, 'openspec', 'schemas', 'spec-driven');
+      fs.mkdirSync(userSchemaDir, { recursive: true });
+
+      // Create an invalid schema (missing required fields)
+      const invalidSchema = `
+name: invalid
+version: 1
+artifacts:
+  - id: broken
+    # missing generates, description, template
+`;
+      fs.writeFileSync(path.join(userSchemaDir, 'schema.yaml'), invalidSchema);
+
+      expect(() => resolveSchema('spec-driven')).toThrow(SchemaLoadError);
+    });
+
+    it('should include file path in validation error message', () => {
+      process.env.XDG_DATA_HOME = tempDir;
+      const userSchemaDir = path.join(tempDir, 'openspec', 'schemas', 'spec-driven');
+      fs.mkdirSync(userSchemaDir, { recursive: true });
+
+      const invalidSchema = `
+name: invalid
+version: 1
+artifacts:
+  - id: broken
+`;
+      const schemaPath = path.join(userSchemaDir, 'schema.yaml');
+      fs.writeFileSync(schemaPath, invalidSchema);
+
+      try {
+        resolveSchema('spec-driven');
+        expect.fail('Should have thrown');
+      } catch (e) {
+        const error = e as SchemaLoadError;
+        expect(error.message).toContain(schemaPath);
+        expect(error.schemaPath).toBe(schemaPath);
+        expect(error.cause).toBeDefined();
+      }
+    });
+
+    it('should detect cycles in user override schemas', () => {
+      process.env.XDG_DATA_HOME = tempDir;
+      const userSchemaDir = path.join(tempDir, 'openspec', 'schemas', 'spec-driven');
+      fs.mkdirSync(userSchemaDir, { recursive: true });
+
+      // Create a schema with cyclic dependencies
+      const cyclicSchema = `
+name: cyclic
+version: 1
+artifacts:
+  - id: a
+    generates: a.md
+    description: A
+    template: a.md
+    requires: [b]
+  - id: b
+    generates: b.md
+    description: B
+    template: b.md
+    requires: [a]
+`;
+      fs.writeFileSync(path.join(userSchemaDir, 'schema.yaml'), cyclicSchema);
+
+      expect(() => resolveSchema('spec-driven')).toThrow(/Cyclic dependency/);
+    });
+
+    it('should detect invalid requires references in user override schemas', () => {
+      process.env.XDG_DATA_HOME = tempDir;
+      const userSchemaDir = path.join(tempDir, 'openspec', 'schemas', 'spec-driven');
+      fs.mkdirSync(userSchemaDir, { recursive: true });
+
+      // Create a schema with invalid requires reference
+      const invalidRefSchema = `
+name: invalid-ref
+version: 1
+artifacts:
+  - id: a
+    generates: a.md
+    description: A
+    template: a.md
+    requires: [nonexistent]
+`;
+      fs.writeFileSync(path.join(userSchemaDir, 'schema.yaml'), invalidRefSchema);
+
+      expect(() => resolveSchema('spec-driven')).toThrow(/does not exist/);
+    });
+
+    it('should throw SchemaLoadError on YAML syntax errors', () => {
+      process.env.XDG_DATA_HOME = tempDir;
+      const userSchemaDir = path.join(tempDir, 'openspec', 'schemas', 'spec-driven');
+      fs.mkdirSync(userSchemaDir, { recursive: true });
+
+      // Create malformed YAML
+      const malformedYaml = `
+name: bad
+version: [[[invalid yaml
+`;
+      const schemaPath = path.join(userSchemaDir, 'schema.yaml');
+      fs.writeFileSync(schemaPath, malformedYaml);
+
+      try {
+        resolveSchema('spec-driven');
+        expect.fail('Should have thrown');
+      } catch (e) {
+        expect(e).toBeInstanceOf(SchemaLoadError);
+        const error = e as SchemaLoadError;
+        expect(error.message).toContain('Failed to parse');
+        expect(error.message).toContain(schemaPath);
+      }
+    });
+
+    it('should fall back to built-in when user override not found', () => {
+      process.env.XDG_DATA_HOME = tempDir;
+      // Don't create any user schemas
+
+      const schema = resolveSchema('spec-driven');
+
+      expect(schema.name).toBe('spec-driven');
+      expect(schema.version).toBe(1);
+    });
+
+    it('should throw when schema not found', () => {
+      expect(() => resolveSchema('nonexistent-schema')).toThrow(/not found/);
+    });
+
+    it('should list available schemas in error message', () => {
+      try {
+        resolveSchema('nonexistent');
+        expect.fail('Should have thrown');
+      } catch (e) {
+        const error = e as Error;
+        expect(error.message).toContain('spec-driven');
+        expect(error.message).toContain('tdd');
+      }
+    });
+  });
+
+  describe('listSchemas', () => {
+    it('should list built-in schemas', () => {
+      const schemas = listSchemas();
+
+      expect(schemas).toContain('spec-driven');
+      expect(schemas).toContain('tdd');
+    });
+
+    it('should include user override schemas', () => {
+      process.env.XDG_DATA_HOME = tempDir;
+      const userSchemaDir = path.join(tempDir, 'openspec', 'schemas', 'custom-workflow');
+      fs.mkdirSync(userSchemaDir, { recursive: true });
+      fs.writeFileSync(path.join(userSchemaDir, 'schema.yaml'), 'name: custom\nversion: 1\nartifacts: []');
+
+      const schemas = listSchemas();
+
+      expect(schemas).toContain('custom-workflow');
+      expect(schemas).toContain('spec-driven');
+    });
+
+    it('should deduplicate schemas with same name', () => {
+      process.env.XDG_DATA_HOME = tempDir;
+      const userSchemaDir = path.join(tempDir, 'openspec', 'schemas', 'spec-driven');
+      fs.mkdirSync(userSchemaDir, { recursive: true });
+      // Override spec-driven
+      fs.writeFileSync(path.join(userSchemaDir, 'schema.yaml'), 'name: custom\nversion: 1\nartifacts: []');
+
+      const schemas = listSchemas();
+
+      // Should only appear once
+      const count = schemas.filter(s => s === 'spec-driven').length;
+      expect(count).toBe(1);
+    });
+
+    it('should return sorted list', () => {
+      const schemas = listSchemas();
+
+      const sorted = [...schemas].sort();
+      expect(schemas).toEqual(sorted);
+    });
+
+    it('should only include directories with schema.yaml', () => {
+      process.env.XDG_DATA_HOME = tempDir;
+      const userSchemasBase = path.join(tempDir, 'openspec', 'schemas');
+
+      // Create a directory without schema.yaml
+      const emptyDir = path.join(userSchemasBase, 'empty-dir');
+      fs.mkdirSync(emptyDir, { recursive: true });
+
+      // Create a valid schema directory
+      const validDir = path.join(userSchemasBase, 'valid-schema');
+      fs.mkdirSync(validDir, { recursive: true });
+      fs.writeFileSync(path.join(validDir, 'schema.yaml'), 'name: valid\nversion: 1\nartifacts: []');
+
+      const schemas = listSchemas();
+
+      expect(schemas).toContain('valid-schema');
+      expect(schemas).not.toContain('empty-dir');
+    });
+  });
+});
diff --git a/test/core/artifact-graph/schema.test.ts b/test/core/artifact-graph/schema.test.ts
new file mode 100644
index 0000000..069216a
--- /dev/null
+++ b/test/core/artifact-graph/schema.test.ts
@@ -0,0 +1,207 @@
+import { describe, it, expect } from 'vitest';
+import { parseSchema, SchemaValidationError } from '../../../src/core/artifact-graph/schema.js';
+
+describe('artifact-graph/schema', () => {
+  describe('parseSchema', () => {
+    it('should parse valid schema YAML', () => {
+      const yaml = `
+name: test-schema
+version: 1
+description: A test schema
+artifacts:
+  - id: proposal
+    generates: proposal.md
+    description: Initial proposal
+    template: templates/proposal.md
+    requires: []
+  - id: design
+    generates: design.md
+    description: Design document
+    template: templates/design.md
+    requires:
+      - proposal
+`;
+      const schema = parseSchema(yaml);
+
+      expect(schema.name).toBe('test-schema');
+      expect(schema.version).toBe(1);
+      expect(schema.description).toBe('A test schema');
+      expect(schema.artifacts).toHaveLength(2);
+      expect(schema.artifacts[0].id).toBe('proposal');
+      expect(schema.artifacts[1].requires).toEqual(['proposal']);
+    });
+
+    it('should throw on missing required fields', () => {
+      const yaml = `
+name: test-schema
+version: 1
+artifacts:
+  - id: proposal
+    description: Missing generates and template
+`;
+      expect(() => parseSchema(yaml)).toThrow(SchemaValidationError);
+      expect(() => parseSchema(yaml)).toThrow(/generates/);
+    });
+
+    it('should throw on missing schema name', () => {
+      const yaml = `
+version: 1
+artifacts:
+  - id: proposal
+    generates: proposal.md
+    description: Test
+    template: templates/proposal.md
+`;
+      expect(() => parseSchema(yaml)).toThrow(SchemaValidationError);
+      expect(() => parseSchema(yaml)).toThrow(/name/);
+    });
+
+    it('should throw on invalid version (non-positive)', () => {
+      const yaml = `
+name: test
+version: 0
+artifacts:
+  - id: proposal
+    generates: proposal.md
+    description: Test
+    template: templates/proposal.md
+`;
+      expect(() => parseSchema(yaml)).toThrow(SchemaValidationError);
+      expect(() => parseSchema(yaml)).toThrow(/positive/);
+    });
+
+    it('should throw on empty artifacts array', () => {
+      const yaml = `
+name: test
+version: 1
+artifacts: []
+`;
+      expect(() => parseSchema(yaml)).toThrow(SchemaValidationError);
+      expect(() => parseSchema(yaml)).toThrow(/artifact/i);
+    });
+
+    it('should throw on duplicate artifact IDs', () => {
+      const yaml = `
+name: test
+version: 1
+artifacts:
+  - id: proposal
+    generates: proposal.md
+    description: First
+    template: templates/proposal.md
+  - id: proposal
+    generates: other.md
+    description: Duplicate
+    template: templates/other.md
+`;
+      expect(() => parseSchema(yaml)).toThrow(SchemaValidationError);
+      expect(() => parseSchema(yaml)).toThrow(/Duplicate artifact ID: proposal/);
+    });
+
+    it('should throw on invalid requires reference', () => {
+      const yaml = `
+name: test
+version: 1
+artifacts:
+  - id: design
+    generates: design.md
+    description: Design doc
+    template: templates/design.md
+    requires:
+      - nonexistent
+`;
+      expect(() => parseSchema(yaml)).toThrow(SchemaValidationError);
+      expect(() => parseSchema(yaml)).toThrow(/Invalid dependency reference.*nonexistent/);
+    });
+
+    it('should detect self-referencing cycle', () => {
+      const yaml = `
+name: test
+version: 1
+artifacts:
+  - id: A
+    generates: a.md
+    description: Self reference
+    template: templates/a.md
+    requires:
+      - A
+`;
+      expect(() => parseSchema(yaml)).toThrow(SchemaValidationError);
+      expect(() => parseSchema(yaml)).toThrow(/Cyclic dependency detected/);
+    });
+
+    it('should detect simple A â†’ B â†’ A cycle', () => {
+      const yaml = `
+name: test
+version: 1
+artifacts:
+  - id: A
+    generates: a.md
+    description: A
+    template: templates/a.md
+    requires:
+      - B
+  - id: B
+    generates: b.md
+    description: B
+    template: templates/b.md
+    requires:
+      - A
+`;
+      expect(() => parseSchema(yaml)).toThrow(SchemaValidationError);
+      expect(() => parseSchema(yaml)).toThrow(/Cyclic dependency detected/);
+      expect(() => parseSchema(yaml)).toThrow(/â†’/);
+    });
+
+    it('should detect longer A â†’ B â†’ C â†’ A cycle and list all IDs', () => {
+      const yaml = `
+name: test
+version: 1
+artifacts:
+  - id: A
+    generates: a.md
+    description: A
+    template: templates/a.md
+    requires:
+      - C
+  - id: B
+    generates: b.md
+    description: B
+    template: templates/b.md
+    requires:
+      - A
+  - id: C
+    generates: c.md
+    description: C
+    template: templates/c.md
+    requires:
+      - B
+`;
+      expect(() => parseSchema(yaml)).toThrow(SchemaValidationError);
+      expect(() => parseSchema(yaml)).toThrow(/Cyclic dependency detected/);
+      // Should contain all three in the cycle path
+      const error = (() => {
+        try {
+          parseSchema(yaml);
+        } catch (e) {
+          return e;
+        }
+      })() as Error;
+      expect(error.message).toMatch(/A.*â†’.*B|B.*â†’.*C|C.*â†’.*A/);
+    });
+
+    it('should allow default empty requires array', () => {
+      const yaml = `
+name: test
+version: 1
+artifacts:
+  - id: root
+    generates: root.md
+    description: Root artifact
+    template: templates/root.md
+`;
+      const schema = parseSchema(yaml);
+      expect(schema.artifacts[0].requires).toEqual([]);
+    });
+  });
+});
diff --git a/test/core/artifact-graph/state.test.ts b/test/core/artifact-graph/state.test.ts
new file mode 100644
index 0000000..758a767
--- /dev/null
+++ b/test/core/artifact-graph/state.test.ts
@@ -0,0 +1,174 @@
+import { describe, it, expect, beforeEach, afterEach } from 'vitest';
+import * as fs from 'node:fs';
+import * as path from 'node:path';
+import * as os from 'node:os';
+import { detectCompleted } from '../../../src/core/artifact-graph/state.js';
+import { ArtifactGraph } from '../../../src/core/artifact-graph/graph.js';
+import type { SchemaYaml } from '../../../src/core/artifact-graph/types.js';
+
+describe('artifact-graph/state', () => {
+  let tempDir: string;
+
+  const createSchema = (artifacts: SchemaYaml['artifacts']): SchemaYaml => ({
+    name: 'test',
+    version: 1,
+    artifacts,
+  });
+
+  beforeEach(() => {
+    tempDir = path.join(os.tmpdir(), `openspec-state-test-${Date.now()}`);
+    fs.mkdirSync(tempDir, { recursive: true });
+  });
+
+  afterEach(() => {
+    fs.rmSync(tempDir, { recursive: true, force: true });
+  });
+
+  describe('detectCompleted', () => {
+    it('should return empty set when changeDir does not exist', () => {
+      const schema = createSchema([
+        { id: 'A', generates: 'a.md', description: 'A', template: 't.md', requires: [] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      const completed = detectCompleted(graph, '/nonexistent/path');
+
+      expect(completed.size).toBe(0);
+    });
+
+    it('should return empty set when changeDir is empty', () => {
+      const schema = createSchema([
+        { id: 'A', generates: 'a.md', description: 'A', template: 't.md', requires: [] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      const completed = detectCompleted(graph, tempDir);
+
+      expect(completed.size).toBe(0);
+    });
+
+    it('should mark artifact complete when file exists', () => {
+      const schema = createSchema([
+        { id: 'proposal', generates: 'proposal.md', description: 'Proposal', template: 't.md', requires: [] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      // Create the file
+      fs.writeFileSync(path.join(tempDir, 'proposal.md'), 'content');
+
+      const completed = detectCompleted(graph, tempDir);
+
+      expect(completed.has('proposal')).toBe(true);
+    });
+
+    it('should not mark artifact complete when file does not exist', () => {
+      const schema = createSchema([
+        { id: 'proposal', generates: 'proposal.md', description: 'Proposal', template: 't.md', requires: [] },
+        { id: 'design', generates: 'design.md', description: 'Design', template: 't.md', requires: [] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      // Only create proposal.md
+      fs.writeFileSync(path.join(tempDir, 'proposal.md'), 'content');
+
+      const completed = detectCompleted(graph, tempDir);
+
+      expect(completed.has('proposal')).toBe(true);
+      expect(completed.has('design')).toBe(false);
+    });
+
+    it('should handle nested paths', () => {
+      const schema = createSchema([
+        { id: 'nested', generates: 'docs/design.md', description: 'Nested', template: 't.md', requires: [] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      // Create nested directory and file
+      fs.mkdirSync(path.join(tempDir, 'docs'), { recursive: true });
+      fs.writeFileSync(path.join(tempDir, 'docs', 'design.md'), 'content');
+
+      const completed = detectCompleted(graph, tempDir);
+
+      expect(completed.has('nested')).toBe(true);
+    });
+
+    it('should detect glob pattern as complete when files exist', () => {
+      const schema = createSchema([
+        { id: 'specs', generates: 'specs/*.md', description: 'Specs', template: 't.md', requires: [] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      // Create specs directory with files
+      fs.mkdirSync(path.join(tempDir, 'specs'), { recursive: true });
+      fs.writeFileSync(path.join(tempDir, 'specs', 'feature-a.md'), 'content');
+      fs.writeFileSync(path.join(tempDir, 'specs', 'feature-b.md'), 'content');
+
+      const completed = detectCompleted(graph, tempDir);
+
+      expect(completed.has('specs')).toBe(true);
+    });
+
+    it('should not mark glob pattern complete when directory is empty', () => {
+      const schema = createSchema([
+        { id: 'specs', generates: 'specs/*.md', description: 'Specs', template: 't.md', requires: [] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      // Create empty specs directory
+      fs.mkdirSync(path.join(tempDir, 'specs'), { recursive: true });
+
+      const completed = detectCompleted(graph, tempDir);
+
+      expect(completed.has('specs')).toBe(false);
+    });
+
+    it('should not mark glob pattern complete when directory does not exist', () => {
+      const schema = createSchema([
+        { id: 'specs', generates: 'specs/*.md', description: 'Specs', template: 't.md', requires: [] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      const completed = detectCompleted(graph, tempDir);
+
+      expect(completed.has('specs')).toBe(false);
+    });
+
+    it('should not mark glob pattern complete when only non-matching files exist', () => {
+      const schema = createSchema([
+        { id: 'specs', generates: 'specs/*.md', description: 'Specs', template: 't.md', requires: [] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      // Create specs directory with non-matching files
+      fs.mkdirSync(path.join(tempDir, 'specs'), { recursive: true });
+      fs.writeFileSync(path.join(tempDir, 'specs', 'readme.txt'), 'content');
+
+      const completed = detectCompleted(graph, tempDir);
+
+      expect(completed.has('specs')).toBe(false);
+    });
+
+    it('should handle multiple artifacts with mixed completion', () => {
+      const schema = createSchema([
+        { id: 'proposal', generates: 'proposal.md', description: 'Proposal', template: 't.md', requires: [] },
+        { id: 'specs', generates: 'specs/*.md', description: 'Specs', template: 't.md', requires: ['proposal'] },
+        { id: 'design', generates: 'design.md', description: 'Design', template: 't.md', requires: ['proposal'] },
+        { id: 'tasks', generates: 'tasks.md', description: 'Tasks', template: 't.md', requires: ['specs', 'design'] },
+      ]);
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      // Create some files
+      fs.writeFileSync(path.join(tempDir, 'proposal.md'), 'content');
+      fs.mkdirSync(path.join(tempDir, 'specs'), { recursive: true });
+      fs.writeFileSync(path.join(tempDir, 'specs', 'auth.md'), 'content');
+      // design.md and tasks.md do not exist
+
+      const completed = detectCompleted(graph, tempDir);
+
+      expect(completed.has('proposal')).toBe(true);
+      expect(completed.has('specs')).toBe(true);
+      expect(completed.has('design')).toBe(false);
+      expect(completed.has('tasks')).toBe(false);
+    });
+  });
+});
diff --git a/test/core/artifact-graph/workflow.integration.test.ts b/test/core/artifact-graph/workflow.integration.test.ts
new file mode 100644
index 0000000..337c76a
--- /dev/null
+++ b/test/core/artifact-graph/workflow.integration.test.ts
@@ -0,0 +1,222 @@
+import { describe, it, expect, beforeEach, afterEach } from 'vitest';
+import * as fs from 'node:fs';
+import * as path from 'node:path';
+import * as os from 'node:os';
+import { resolveSchema } from '../../../src/core/artifact-graph/resolver.js';
+import { ArtifactGraph } from '../../../src/core/artifact-graph/graph.js';
+import { detectCompleted } from '../../../src/core/artifact-graph/state.js';
+import type { BlockedArtifacts } from '../../../src/core/artifact-graph/types.js';
+
+/**
+ * Normalize BlockedArtifacts for comparison by sorting dependency arrays.
+ * The order of unmet dependencies is not guaranteed, so we sort for stable assertions.
+ */
+function normalizeBlocked(blocked: BlockedArtifacts): BlockedArtifacts {
+  const normalized: BlockedArtifacts = {};
+  for (const [key, deps] of Object.entries(blocked)) {
+    normalized[key] = [...deps].sort();
+  }
+  return normalized;
+}
+
+describe('artifact-graph workflow integration', () => {
+  let tempDir: string;
+
+  beforeEach(() => {
+    // Use a unique temp directory for each test
+    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'openspec-workflow-test-'));
+  });
+
+  afterEach(() => {
+    // Clean up temp directory after each test
+    if (tempDir && fs.existsSync(tempDir)) {
+      fs.rmSync(tempDir, { recursive: true, force: true });
+    }
+  });
+
+  describe('spec-driven workflow', () => {
+    it('should progress through complete workflow', () => {
+      // 1. Resolve the real built-in schema
+      const schema = resolveSchema('spec-driven');
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      // Verify schema structure
+      expect(graph.getName()).toBe('spec-driven');
+      expect(graph.getAllArtifacts()).toHaveLength(4);
+
+      // 2. Initial state - nothing complete, only proposal is ready
+      let completed = detectCompleted(graph, tempDir);
+      expect(completed.size).toBe(0);
+      expect(graph.getNextArtifacts(completed)).toEqual(['proposal']);
+      expect(graph.isComplete(completed)).toBe(false);
+      expect(normalizeBlocked(graph.getBlocked(completed))).toEqual({
+        specs: ['proposal'],
+        design: ['proposal'],
+        tasks: ['design', 'specs'],
+      });
+
+      // 3. Create proposal.md - now specs and design become ready
+      fs.writeFileSync(path.join(tempDir, 'proposal.md'), '# Proposal\n\nInitial proposal content.');
+      completed = detectCompleted(graph, tempDir);
+      expect(completed).toEqual(new Set(['proposal']));
+      expect(graph.getNextArtifacts(completed).sort()).toEqual(['design', 'specs']);
+      expect(normalizeBlocked(graph.getBlocked(completed))).toEqual({
+        tasks: ['design', 'specs'],
+      });
+
+      // 4. Create design.md - specs still needed for tasks
+      fs.writeFileSync(path.join(tempDir, 'design.md'), '# Design\n\nTechnical design content.');
+      completed = detectCompleted(graph, tempDir);
+      expect(completed).toEqual(new Set(['proposal', 'design']));
+      expect(graph.getNextArtifacts(completed)).toEqual(['specs']);
+      expect(graph.getBlocked(completed)).toEqual({
+        tasks: ['specs'],
+      });
+
+      // 5. Create specs directory with a spec file - tasks becomes ready
+      const specsDir = path.join(tempDir, 'specs');
+      fs.mkdirSync(specsDir, { recursive: true });
+      fs.writeFileSync(path.join(specsDir, 'feature-auth.md'), '# Auth Spec\n\nAuthentication specification.');
+      completed = detectCompleted(graph, tempDir);
+      expect(completed).toEqual(new Set(['proposal', 'design', 'specs']));
+      expect(graph.getNextArtifacts(completed)).toEqual(['tasks']);
+      expect(graph.getBlocked(completed)).toEqual({});
+
+      // 6. Create tasks.md - workflow complete
+      fs.writeFileSync(path.join(tempDir, 'tasks.md'), '# Tasks\n\n- [ ] Implement feature');
+      completed = detectCompleted(graph, tempDir);
+      expect(completed).toEqual(new Set(['proposal', 'design', 'specs', 'tasks']));
+      expect(graph.getNextArtifacts(completed)).toEqual([]);
+      expect(graph.isComplete(completed)).toBe(true);
+      expect(graph.getBlocked(completed)).toEqual({});
+    });
+
+    it('should handle out-of-order file creation', () => {
+      const schema = resolveSchema('spec-driven');
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      // Create files in wrong order - design before proposal
+      fs.writeFileSync(path.join(tempDir, 'design.md'), '# Design');
+
+      let completed = detectCompleted(graph, tempDir);
+      // design file exists but it's still marked complete (filesystem-based)
+      expect(completed).toEqual(new Set(['design']));
+      // proposal is still the only "ready" artifact since it has no deps
+      expect(graph.getNextArtifacts(completed)).toEqual(['proposal']);
+
+      // Now create proposal
+      fs.writeFileSync(path.join(tempDir, 'proposal.md'), '# Proposal');
+      completed = detectCompleted(graph, tempDir);
+      expect(completed).toEqual(new Set(['proposal', 'design']));
+      // specs is the only thing ready now (design already done)
+      expect(graph.getNextArtifacts(completed)).toEqual(['specs']);
+    });
+
+    it('should handle multiple spec files in glob pattern', () => {
+      const schema = resolveSchema('spec-driven');
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      // Complete prerequisites
+      fs.writeFileSync(path.join(tempDir, 'proposal.md'), '# Proposal');
+
+      // Create specs directory with multiple files
+      const specsDir = path.join(tempDir, 'specs');
+      fs.mkdirSync(specsDir, { recursive: true });
+      fs.writeFileSync(path.join(specsDir, 'auth.md'), '# Auth');
+      fs.writeFileSync(path.join(specsDir, 'api.md'), '# API');
+      fs.writeFileSync(path.join(specsDir, 'database.md'), '# Database');
+
+      const completed = detectCompleted(graph, tempDir);
+      expect(completed.has('specs')).toBe(true);
+    });
+  });
+
+  describe('tdd workflow', () => {
+    it('should progress through complete workflow', () => {
+      const schema = resolveSchema('tdd');
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      expect(graph.getName()).toBe('tdd');
+      expect(graph.getBuildOrder()).toEqual(['spec', 'tests', 'implementation', 'docs']);
+
+      // Initial state
+      let completed = detectCompleted(graph, tempDir);
+      expect(graph.getNextArtifacts(completed)).toEqual(['spec']);
+
+      // Create spec
+      fs.writeFileSync(path.join(tempDir, 'spec.md'), '# Feature Spec');
+      completed = detectCompleted(graph, tempDir);
+      expect(graph.getNextArtifacts(completed)).toEqual(['tests']);
+
+      // Create tests directory with test file
+      const testsDir = path.join(tempDir, 'tests');
+      fs.mkdirSync(testsDir, { recursive: true });
+      fs.writeFileSync(path.join(testsDir, 'feature.test.ts'), 'describe("feature", () => {});');
+      completed = detectCompleted(graph, tempDir);
+      expect(graph.getNextArtifacts(completed)).toEqual(['implementation']);
+
+      // Create src directory with implementation
+      const srcDir = path.join(tempDir, 'src');
+      fs.mkdirSync(srcDir, { recursive: true });
+      fs.writeFileSync(path.join(srcDir, 'feature.ts'), 'export function feature() {}');
+      completed = detectCompleted(graph, tempDir);
+      expect(graph.getNextArtifacts(completed)).toEqual(['docs']);
+
+      // Create docs
+      const docsDir = path.join(tempDir, 'docs');
+      fs.mkdirSync(docsDir, { recursive: true });
+      fs.writeFileSync(path.join(docsDir, 'feature.md'), '# Feature Documentation');
+      completed = detectCompleted(graph, tempDir);
+      expect(graph.isComplete(completed)).toBe(true);
+    });
+  });
+
+  describe('build order consistency', () => {
+    it('should return consistent build order across multiple calls', () => {
+      const schema = resolveSchema('spec-driven');
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      const order1 = graph.getBuildOrder();
+      const order2 = graph.getBuildOrder();
+      const order3 = graph.getBuildOrder();
+
+      expect(order1).toEqual(order2);
+      expect(order2).toEqual(order3);
+    });
+  });
+
+  describe('empty and edge cases', () => {
+    it('should handle empty change directory gracefully', () => {
+      const schema = resolveSchema('spec-driven');
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      // Directory exists but is empty
+      const completed = detectCompleted(graph, tempDir);
+      expect(completed.size).toBe(0);
+      expect(graph.getNextArtifacts(completed)).toEqual(['proposal']);
+    });
+
+    it('should handle non-existent change directory', () => {
+      const schema = resolveSchema('spec-driven');
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      const nonExistentDir = path.join(tempDir, 'does-not-exist');
+      const completed = detectCompleted(graph, nonExistentDir);
+      expect(completed.size).toBe(0);
+    });
+
+    it('should not count non-matching files in glob directories', () => {
+      const schema = resolveSchema('spec-driven');
+      const graph = ArtifactGraph.fromSchema(schema);
+
+      // Create specs directory with wrong file types
+      const specsDir = path.join(tempDir, 'specs');
+      fs.mkdirSync(specsDir, { recursive: true });
+      fs.writeFileSync(path.join(specsDir, 'notes.txt'), 'not a markdown file');
+      fs.writeFileSync(path.join(specsDir, 'data.json'), '{}');
+
+      const completed = detectCompleted(graph, tempDir);
+      expect(completed.has('specs')).toBe(false);
+    });
+  });
+});
diff --git a/test/core/list.test.ts b/test/core/list.test.ts
index edc5300..5a67891 100644
--- a/test/core/list.test.ts
+++ b/test/core/list.test.ts
@@ -115,19 +115,19 @@ Regular text that should be ignored
       expect(logOutput.some(line => line.includes('no-tasks') && line.includes('No tasks'))).toBe(true);
     });
 
-    it('should sort changes alphabetically', async () => {
+    it('should sort changes alphabetically when sort=name', async () => {
       const changesDir = path.join(tempDir, 'openspec', 'changes');
       await fs.mkdir(path.join(changesDir, 'zebra'), { recursive: true });
       await fs.mkdir(path.join(changesDir, 'alpha'), { recursive: true });
       await fs.mkdir(path.join(changesDir, 'middle'), { recursive: true });
 
       const listCommand = new ListCommand();
-      await listCommand.execute(tempDir);
+      await listCommand.execute(tempDir, 'changes', { sort: 'name' });
 
-      const changeLines = logOutput.filter(line => 
+      const changeLines = logOutput.filter(line =>
         line.includes('alpha') || line.includes('middle') || line.includes('zebra')
       );
-      
+
       expect(changeLines[0]).toContain('alpha');
       expect(changeLines[1]).toContain('middle');
       expect(changeLines[2]).toContain('zebra');
diff --git a/test/core/view.test.ts b/test/core/view.test.ts
index 7b68f2e..b8b56df 100644
--- a/test/core/view.test.ts
+++ b/test/core/view.test.ts
@@ -28,6 +28,56 @@ describe('ViewCommand', () => {
     await fs.rm(tempDir, { recursive: true, force: true });
   });
 
+  it('shows changes with no tasks in Draft section, not Completed', async () => {
+    const changesDir = path.join(tempDir, 'openspec', 'changes');
+    await fs.mkdir(changesDir, { recursive: true });
+
+    // Empty change (no tasks.md) - should show in Draft
+    await fs.mkdir(path.join(changesDir, 'empty-change'), { recursive: true });
+
+    // Change with tasks.md but no tasks - should show in Draft
+    await fs.mkdir(path.join(changesDir, 'no-tasks-change'), { recursive: true });
+    await fs.writeFile(path.join(changesDir, 'no-tasks-change', 'tasks.md'), '# Tasks\n\nNo tasks yet.');
+
+    // Change with all tasks complete - should show in Completed
+    await fs.mkdir(path.join(changesDir, 'completed-change'), { recursive: true });
+    await fs.writeFile(
+      path.join(changesDir, 'completed-change', 'tasks.md'),
+      '- [x] Done task\n'
+    );
+
+    const viewCommand = new ViewCommand();
+    await viewCommand.execute(tempDir);
+
+    const output = logOutput.map(stripAnsi).join('\n');
+
+    // Draft section should contain empty and no-tasks changes
+    expect(output).toContain('Draft Changes');
+    expect(output).toContain('empty-change');
+    expect(output).toContain('no-tasks-change');
+
+    // Completed section should only contain changes with all tasks done
+    expect(output).toContain('Completed Changes');
+    expect(output).toContain('completed-change');
+
+    // Verify empty-change and no-tasks-change are in Draft section (marked with â—‹)
+    const draftLines = logOutput
+      .map(stripAnsi)
+      .filter((line) => line.includes('â—‹'));
+    const draftNames = draftLines.map((line) => line.trim().replace('â—‹ ', ''));
+    expect(draftNames).toContain('empty-change');
+    expect(draftNames).toContain('no-tasks-change');
+
+    // Verify completed-change is in Completed section (marked with âœ“)
+    const completedLines = logOutput
+      .map(stripAnsi)
+      .filter((line) => line.includes('âœ“'));
+    const completedNames = completedLines.map((line) => line.trim().replace('âœ“ ', ''));
+    expect(completedNames).toContain('completed-change');
+    expect(completedNames).not.toContain('empty-change');
+    expect(completedNames).not.toContain('no-tasks-change');
+  });
+
   it('sorts active changes by completion percentage ascending with deterministic tie-breakers', async () => {
     const changesDir = path.join(tempDir, 'openspec', 'changes');
     await fs.mkdir(changesDir, { recursive: true });
diff --git a/test/helpers/run-cli.ts b/test/helpers/run-cli.ts
index c33f2ff..69d67df 100644
--- a/test/helpers/run-cli.ts
+++ b/test/helpers/run-cli.ts
@@ -90,6 +90,9 @@ export async function runCLI(args: string[] = [], options: RunCLIOptions = {}):
       windowsHide: true,
     });
 
+    // Prevent child process from keeping the event loop alive
+    child.unref();
+
     let stdout = '';
     let stderr = '';
     let timedOut = false;
@@ -113,11 +116,19 @@ export async function runCLI(args: string[] = [], options: RunCLIOptions = {}):
 
     child.on('error', (error) => {
       if (timeout) clearTimeout(timeout);
+      // Explicitly destroy streams to prevent hanging handles
+      child.stdout?.destroy();
+      child.stderr?.destroy();
+      child.stdin?.destroy();
       reject(error);
     });
 
     child.on('close', (code, signal) => {
       if (timeout) clearTimeout(timeout);
+      // Explicitly destroy streams to prevent hanging handles
+      child.stdout?.destroy();
+      child.stderr?.destroy();
+      child.stdin?.destroy();
       resolve({
         exitCode: code,
         signal,
diff --git a/test/utils/change-metadata.test.ts b/test/utils/change-metadata.test.ts
new file mode 100644
index 0000000..fdbb942
--- /dev/null
+++ b/test/utils/change-metadata.test.ts
@@ -0,0 +1,224 @@
+import { describe, it, expect, beforeEach, afterEach } from 'vitest';
+import { promises as fs } from 'fs';
+import path from 'path';
+import os from 'os';
+import { randomUUID } from 'crypto';
+import {
+  writeChangeMetadata,
+  readChangeMetadata,
+  resolveSchemaForChange,
+  validateSchemaName,
+  ChangeMetadataError,
+} from '../../src/utils/change-metadata.js';
+import { ChangeMetadataSchema } from '../../src/core/artifact-graph/types.js';
+
+describe('ChangeMetadataSchema', () => {
+  describe('valid metadata', () => {
+    it('should accept valid schema with created date', () => {
+      const result = ChangeMetadataSchema.safeParse({
+        schema: 'spec-driven',
+        created: '2025-01-05',
+      });
+      expect(result.success).toBe(true);
+      if (result.success) {
+        expect(result.data.schema).toBe('spec-driven');
+        expect(result.data.created).toBe('2025-01-05');
+      }
+    });
+
+    it('should accept valid schema without created date', () => {
+      const result = ChangeMetadataSchema.safeParse({
+        schema: 'tdd',
+      });
+      expect(result.success).toBe(true);
+      if (result.success) {
+        expect(result.data.schema).toBe('tdd');
+        expect(result.data.created).toBeUndefined();
+      }
+    });
+  });
+
+  describe('invalid metadata', () => {
+    it('should reject empty schema', () => {
+      const result = ChangeMetadataSchema.safeParse({
+        schema: '',
+      });
+      expect(result.success).toBe(false);
+    });
+
+    it('should reject missing schema', () => {
+      const result = ChangeMetadataSchema.safeParse({
+        created: '2025-01-05',
+      });
+      expect(result.success).toBe(false);
+    });
+
+    it('should reject invalid date format', () => {
+      const result = ChangeMetadataSchema.safeParse({
+        schema: 'spec-driven',
+        created: '01/05/2025', // Wrong format
+      });
+      expect(result.success).toBe(false);
+    });
+
+    it('should reject non-ISO date format', () => {
+      const result = ChangeMetadataSchema.safeParse({
+        schema: 'spec-driven',
+        created: '2025-1-5', // Missing leading zeros
+      });
+      expect(result.success).toBe(false);
+    });
+  });
+});
+
+describe('writeChangeMetadata', () => {
+  let testDir: string;
+  let changeDir: string;
+
+  beforeEach(async () => {
+    testDir = path.join(os.tmpdir(), `openspec-test-${randomUUID()}`);
+    changeDir = path.join(testDir, 'openspec', 'changes', 'test-change');
+    await fs.mkdir(changeDir, { recursive: true });
+  });
+
+  afterEach(async () => {
+    await fs.rm(testDir, { recursive: true, force: true });
+  });
+
+  it('should write valid YAML metadata file', async () => {
+    writeChangeMetadata(changeDir, {
+      schema: 'spec-driven',
+      created: '2025-01-05',
+    });
+
+    const metaPath = path.join(changeDir, '.openspec.yaml');
+    const content = await fs.readFile(metaPath, 'utf-8');
+
+    expect(content).toContain('schema: spec-driven');
+    expect(content).toContain('created: 2025-01-05');
+  });
+
+  it('should throw error for unknown schema', () => {
+    expect(() =>
+      writeChangeMetadata(changeDir, {
+        schema: 'unknown-schema',
+        created: '2025-01-05',
+      })
+    ).toThrow(/Unknown schema 'unknown-schema'/);
+  });
+});
+
+describe('readChangeMetadata', () => {
+  let testDir: string;
+  let changeDir: string;
+
+  beforeEach(async () => {
+    testDir = path.join(os.tmpdir(), `openspec-test-${randomUUID()}`);
+    changeDir = path.join(testDir, 'openspec', 'changes', 'test-change');
+    await fs.mkdir(changeDir, { recursive: true });
+  });
+
+  afterEach(async () => {
+    await fs.rm(testDir, { recursive: true, force: true });
+  });
+
+  it('should return null when no metadata file exists', () => {
+    const result = readChangeMetadata(changeDir);
+    expect(result).toBeNull();
+  });
+
+  it('should read valid metadata', async () => {
+    const metaPath = path.join(changeDir, '.openspec.yaml');
+    await fs.writeFile(
+      metaPath,
+      'schema: spec-driven\ncreated: "2025-01-05"\n',
+      'utf-8'
+    );
+
+    const result = readChangeMetadata(changeDir);
+    expect(result).toEqual({
+      schema: 'spec-driven',
+      created: '2025-01-05',
+    });
+  });
+
+  it('should throw ChangeMetadataError for invalid YAML', async () => {
+    const metaPath = path.join(changeDir, '.openspec.yaml');
+    await fs.writeFile(metaPath, '{ invalid yaml', 'utf-8');
+
+    expect(() => readChangeMetadata(changeDir)).toThrow(ChangeMetadataError);
+  });
+
+  it('should throw ChangeMetadataError for missing schema field', async () => {
+    const metaPath = path.join(changeDir, '.openspec.yaml');
+    await fs.writeFile(metaPath, 'created: "2025-01-05"\n', 'utf-8');
+
+    expect(() => readChangeMetadata(changeDir)).toThrow(ChangeMetadataError);
+  });
+
+  it('should throw ChangeMetadataError for unknown schema', async () => {
+    const metaPath = path.join(changeDir, '.openspec.yaml');
+    await fs.writeFile(metaPath, 'schema: unknown-schema\n', 'utf-8');
+
+    expect(() => readChangeMetadata(changeDir)).toThrow(/Unknown schema/);
+  });
+});
+
+describe('resolveSchemaForChange', () => {
+  let testDir: string;
+  let changeDir: string;
+
+  beforeEach(async () => {
+    testDir = path.join(os.tmpdir(), `openspec-test-${randomUUID()}`);
+    changeDir = path.join(testDir, 'openspec', 'changes', 'test-change');
+    await fs.mkdir(changeDir, { recursive: true });
+  });
+
+  afterEach(async () => {
+    await fs.rm(testDir, { recursive: true, force: true });
+  });
+
+  it('should return explicit schema when provided', async () => {
+    // Even with metadata file, explicit schema wins
+    const metaPath = path.join(changeDir, '.openspec.yaml');
+    await fs.writeFile(metaPath, 'schema: spec-driven\n', 'utf-8');
+
+    const result = resolveSchemaForChange(changeDir, 'tdd');
+    expect(result).toBe('tdd');
+  });
+
+  it('should return schema from metadata when no explicit schema', async () => {
+    const metaPath = path.join(changeDir, '.openspec.yaml');
+    await fs.writeFile(metaPath, 'schema: spec-driven\n', 'utf-8');
+
+    const result = resolveSchemaForChange(changeDir);
+    expect(result).toBe('spec-driven');
+  });
+
+  it('should return default when no metadata and no explicit schema', () => {
+    const result = resolveSchemaForChange(changeDir);
+    expect(result).toBe('spec-driven');
+  });
+
+  it('should return default when metadata read fails', async () => {
+    // Create an invalid metadata file
+    const metaPath = path.join(changeDir, '.openspec.yaml');
+    await fs.writeFile(metaPath, '{ invalid yaml', 'utf-8');
+
+    // Should fall back to default, not throw
+    const result = resolveSchemaForChange(changeDir);
+    expect(result).toBe('spec-driven');
+  });
+});
+
+describe('validateSchemaName', () => {
+  it('should accept valid schema name', () => {
+    expect(() => validateSchemaName('spec-driven')).not.toThrow();
+  });
+
+  it('should throw for unknown schema', () => {
+    expect(() => validateSchemaName('unknown-schema')).toThrow(
+      /Unknown schema 'unknown-schema'/
+    );
+  });
+});
diff --git a/test/utils/change-utils.test.ts b/test/utils/change-utils.test.ts
new file mode 100644
index 0000000..8e94260
--- /dev/null
+++ b/test/utils/change-utils.test.ts
@@ -0,0 +1,201 @@
+import { describe, it, expect, beforeEach, afterEach } from 'vitest';
+import { promises as fs } from 'fs';
+import path from 'path';
+import os from 'os';
+import { randomUUID } from 'crypto';
+import { validateChangeName, createChange } from '../../src/utils/change-utils.js';
+
+describe('validateChangeName', () => {
+  describe('valid names', () => {
+    it('should accept simple kebab-case name', () => {
+      const result = validateChangeName('add-auth');
+      expect(result).toEqual({ valid: true });
+    });
+
+    it('should accept name with multiple segments', () => {
+      const result = validateChangeName('add-user-auth');
+      expect(result).toEqual({ valid: true });
+    });
+
+    it('should accept name with numeric suffix', () => {
+      const result = validateChangeName('add-feature-2');
+      expect(result).toEqual({ valid: true });
+    });
+
+    it('should accept single word name', () => {
+      const result = validateChangeName('refactor');
+      expect(result).toEqual({ valid: true });
+    });
+
+    it('should accept name with numbers in segments', () => {
+      const result = validateChangeName('upgrade-to-v2');
+      expect(result).toEqual({ valid: true });
+    });
+  });
+
+  describe('invalid names - uppercase rejected', () => {
+    it('should reject name with uppercase letters', () => {
+      const result = validateChangeName('Add-Auth');
+      expect(result.valid).toBe(false);
+      expect(result.error).toContain('lowercase');
+    });
+
+    it('should reject fully uppercase name', () => {
+      const result = validateChangeName('ADD-AUTH');
+      expect(result.valid).toBe(false);
+      expect(result.error).toContain('lowercase');
+    });
+  });
+
+  describe('invalid names - spaces rejected', () => {
+    it('should reject name with spaces', () => {
+      const result = validateChangeName('add auth');
+      expect(result.valid).toBe(false);
+      expect(result.error).toContain('spaces');
+    });
+  });
+
+  describe('invalid names - underscores rejected', () => {
+    it('should reject name with underscores', () => {
+      const result = validateChangeName('add_auth');
+      expect(result.valid).toBe(false);
+      expect(result.error).toContain('underscores');
+    });
+  });
+
+  describe('invalid names - special characters rejected', () => {
+    it('should reject name with exclamation mark', () => {
+      const result = validateChangeName('add-auth!');
+      expect(result.valid).toBe(false);
+      expect(result.error).toBeDefined();
+    });
+
+    it('should reject name with @ symbol', () => {
+      const result = validateChangeName('add@auth');
+      expect(result.valid).toBe(false);
+      expect(result.error).toBeDefined();
+    });
+  });
+
+  describe('invalid names - leading/trailing hyphens rejected', () => {
+    it('should reject name with leading hyphen', () => {
+      const result = validateChangeName('-add-auth');
+      expect(result.valid).toBe(false);
+      expect(result.error).toContain('start with a hyphen');
+    });
+
+    it('should reject name with trailing hyphen', () => {
+      const result = validateChangeName('add-auth-');
+      expect(result.valid).toBe(false);
+      expect(result.error).toContain('end with a hyphen');
+    });
+  });
+
+  describe('invalid names - consecutive hyphens rejected', () => {
+    it('should reject name with double hyphens', () => {
+      const result = validateChangeName('add--auth');
+      expect(result.valid).toBe(false);
+      expect(result.error).toContain('consecutive hyphens');
+    });
+  });
+
+  describe('invalid names - empty name rejected', () => {
+    it('should reject empty string', () => {
+      const result = validateChangeName('');
+      expect(result.valid).toBe(false);
+      expect(result.error).toContain('empty');
+    });
+  });
+});
+
+describe('createChange', () => {
+  let testDir: string;
+
+  beforeEach(async () => {
+    testDir = path.join(os.tmpdir(), `openspec-test-${randomUUID()}`);
+    await fs.mkdir(testDir, { recursive: true });
+  });
+
+  afterEach(async () => {
+    await fs.rm(testDir, { recursive: true, force: true });
+  });
+
+  describe('creates directory', () => {
+    it('should create change directory', async () => {
+      await createChange(testDir, 'add-auth');
+
+      const changeDir = path.join(testDir, 'openspec', 'changes', 'add-auth');
+      const stats = await fs.stat(changeDir);
+      expect(stats.isDirectory()).toBe(true);
+    });
+
+    it('should create .openspec.yaml metadata file with default schema', async () => {
+      await createChange(testDir, 'add-auth');
+
+      const metaPath = path.join(testDir, 'openspec', 'changes', 'add-auth', '.openspec.yaml');
+      const content = await fs.readFile(metaPath, 'utf-8');
+      expect(content).toContain('schema: spec-driven');
+      expect(content).toMatch(/created: \d{4}-\d{2}-\d{2}/);
+    });
+
+    it('should create .openspec.yaml with custom schema', async () => {
+      await createChange(testDir, 'add-auth', { schema: 'tdd' });
+
+      const metaPath = path.join(testDir, 'openspec', 'changes', 'add-auth', '.openspec.yaml');
+      const content = await fs.readFile(metaPath, 'utf-8');
+      expect(content).toContain('schema: tdd');
+    });
+  });
+
+  describe('schema validation', () => {
+    it('should throw error for unknown schema', async () => {
+      await expect(createChange(testDir, 'add-auth', { schema: 'unknown-schema' })).rejects.toThrow(
+        /Unknown schema/
+      );
+    });
+  });
+
+  describe('duplicate change throws error', () => {
+    it('should throw error if change already exists', async () => {
+      await createChange(testDir, 'add-auth');
+
+      await expect(createChange(testDir, 'add-auth')).rejects.toThrow(
+        /already exists/
+      );
+    });
+  });
+
+  describe('invalid name throws validation error', () => {
+    it('should throw error for uppercase name', async () => {
+      await expect(createChange(testDir, 'Add-Auth')).rejects.toThrow(
+        /lowercase/
+      );
+    });
+
+    it('should throw error for name with spaces', async () => {
+      await expect(createChange(testDir, 'add auth')).rejects.toThrow(
+        /spaces/
+      );
+    });
+
+    it('should throw error for empty name', async () => {
+      await expect(createChange(testDir, '')).rejects.toThrow(
+        /empty/
+      );
+    });
+  });
+
+  describe('creates parent directories if needed', () => {
+    it('should create openspec/changes/ directories if they do not exist', async () => {
+      const newProjectDir = path.join(testDir, 'new-project');
+      await fs.mkdir(newProjectDir);
+
+      // openspec/changes/ does not exist yet
+      await createChange(newProjectDir, 'add-auth');
+
+      const changeDir = path.join(newProjectDir, 'openspec', 'changes', 'add-auth');
+      const stats = await fs.stat(changeDir);
+      expect(stats.isDirectory()).toBe(true);
+    });
+  });
+});
diff --git a/vitest.config.ts b/vitest.config.ts
index 2d6f658..88c06dd 100644
--- a/vitest.config.ts
+++ b/vitest.config.ts
@@ -20,6 +20,7 @@ export default defineConfig({
       ]
     },
     testTimeout: 10000,
-    hookTimeout: 10000
+    hookTimeout: 10000,
+    teardownTimeout: 3000
   }
 });
diff --git a/vitest.setup.ts b/vitest.setup.ts
index 1547dbf..3ffc2c6 100644
--- a/vitest.setup.ts
+++ b/vitest.setup.ts
@@ -4,3 +4,9 @@ import { ensureCliBuilt } from './test/helpers/run-cli.js';
 export async function setup() {
   await ensureCliBuilt();
 }
+
+// Global teardown to ensure clean exit
+export async function teardown() {
+  // Clear any remaining timers
+  // This helps prevent hanging handles from keeping the process alive
+}

# OpenSpec 並行デルタ是正計画

> この文書は、並行開発で同じ要件を編集した際にアーカイブ順によってシナリオが失われる問題を解決するための計画です。置換ベースのマージを、指紋保存→検出→`change sync`（リベース）→シナリオ粒度拡張という段階的対策で改善します。

## 問題の概要
- アーカイブ時に要件単位で置換しているため、同じ要件を別の変更が編集すると後からアーカイブした方が先行シナリオを上書きし、気づかずに消える。
- アーカイブ処理（`src/core/archive.ts`）は変更デルタの要件ブロックで丸ごと置換するだけで、ベースバージョンやシナリオ単位の操作を持たない。
- 変更がどの仕様をベースに書かれたかを記録していないため、並行更新の検出ができない。

## 具体的な故障モード
- 変更Aが「Slash Command Configuration」に Windsurf シナリオを追加。
- 変更Bが同じ要件に Kilo Code シナリオを追加（A 反映前の仕様をベース）。
- A をアーカイブすると両シナリオが入る。
- B をアーカイブすると、B に含まれない Windsurf シナリオが丸ごと消えるが警告は出ない。

## 根本原因
1) 置換のみのセマンティクス。シナリオ粒度のマージがない。  
2) ベース指紋が無い。仕様との差分を検知できない。  
3) 粒度が要件レベルだけ。シナリオ同士の併合手段がない。  
4) 衝突 UX 不在。`git merge` のような強制再調整がない。  

## 設計目標
- 承認済みシナリオをアーカイブ順序に関わらず保持する。
- 著者のベースとライブ仕様の乖離を検出してブロックする。
- Git に近い決定的でレビュー可能なコンフリクト解消フロー。
- 人手編集可能な Markdown のまま保つ。
- 既存リポジトリが段階的に移行できる。

## 段階的な是正策

### フェーズ0: 被害の即時停止（検出とガード）
1. **ベース指紋を保存**: `MODIFIED/REMOVED/RENAMED` の各要件について、執筆時の本文とハッシュを `changes/<id>/meta.json` に記録。  
2. **アーカイブ時に検証**: ライブ仕様から再計算したハッシュと比較し、ずれたらアーカイブを中止しリベースを促す。  
3. **CLI で意図を可視化**: どの要件がいつから古いか、誰の変更かを表示。  
4. **暫定ドキュメント整備**: `openspec/AGENTS.md` などに「並行時は sync を走らせる」旨を記載。  

_結果_: データロス経路を即座に封じる。

### フェーズ1: リベースワークフローの導入（著者側マージ）
1. **`openspec change sync <id>` を追加**: ベーススナップショット、現行仕様、デルタを3-way マージ。クリーンならデルタを書き換え指紋を更新。競合時は Markdown 内にコンフリクトマーカーを出す。  
2. **バリデータ強化**: `openspec validate` で指紋不一致や競合マーカーを検出。  
3. **オプション**: シナリオ箇条書きの自動マージヘルパー `--rewrite-scenarios` を検討。  

_結果_: アーカイブ前に著者が安全に最新仕様へ追随できる。

### フェーズ2: デルタの粒度をシナリオまで拡張
1. **シナリオレベルのディレクティブ追加**: `## ADDED/MODIFIED/REMOVED Scenarios` を要件配下に許可し、安定IDを `meta.json` に保持。  
2. **パーサとビルダー拡張**: シナリオ操作を IR に載せ、順序を保ちつつ決定的に挿入・マージ。  
3. **自動マイグレーション**: 既存仕様にシナリオ ID を付与し、進行中のデルタを新フォーマットへ変換するコマンドを提供。  
4. **同一シナリオ本文の競合は引き続きフェーズ1のフローで解決。**  

_結果_: ほとんどの並行更新が可換になり、上書き喪失が大幅減少。

### フェーズ3: 構造化された仕様グラフ（長期）
1. **安定した Requirement ID を導入**（`Requirement ID: <uuid>`）。  
2. **AST ベースの編集モデル**: 要件/シナリオ/メタの IR を作り、OT/CRDT 的にマージ性を担保。  
3. **Git 連携の強化**: `openspec branch` などで Git のコンフリクトエディタを活用できるオプション。  

_結果_: 置換型から意図保持型の仕様管理プラットフォームへ。

## マイグレーションと影響
- **メタデータの後付け**: ロールアウト時に既存 change と spec に指紋を埋める。  
- **CLI UX**: `change sync` や強化された `archive` のヘルプ・ドキュメント更新が必要。  
- **ドキュメント/AGENTS**: リベース手順と競合解消をアシスタントに周知。  
- **テスト**: 指紋不一致やマージロジックのフィクスチャ追加。  
- **（任意）テレメトリ**: 競合発生率を計測。  

## 未解決の論点 / リスク
- 複数の挿入位置指定が競合した場合のシナリオ順序（位置メタ or アルファベット順のフォールバック？）。  
- `meta.json` が欠損した場合の復旧策（再生成手順を CLI で提供）。  
- オフライン著者がアーカイブ前に sync を走らせられないケース（緊急用 `--accept-outdated` の是非）。  
- 過去のアーカイブ済み変更への指紋付与をどう扱うか。  

## 直近のアクション
1. `openspec change validate` で指紋を記録し、アーカイブ時に不一致をブロックするプロトタイプを作る。  
2. 行単位 diff3 による `openspec change sync` を実装し、競合マーカーを出力。  
3. コントリビューター向けドキュメントと AI 指示を更新し、アーカイブ前に sync を必須化。  
4. シナリオ粒度拡張（フェーズ2）の設計と移行手順を RFC としてまとめる。  

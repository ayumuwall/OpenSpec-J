# OpenSpec 実験的リリース計画

このドキュメントは、実験的なアーティファクトワークフローシステムをユーザーテスト向けにリリースする計画をまとめたものです。

## 概要

既存の OpenSpec コマンドと並行して、新しいアーティファクト駆動ワークフローをテストできるようにすることが目的です。この実験的システム（`opsx`）は、変更アーティファクトをより細かいステップで作成できるようにします。

## 3 つのワークフローモード

### 1. 旧ワークフロー（現行本番）
- **コマンド**: `/openspec:proposal`, `/openspec:apply`, `/openspec:archive`
- **挙動**: 1 回のコマンドで全アーティファクトを生成するハードコードのスラッシュコマンド
- **状態**: 本番運用中、変更なし

### 2. 新アーティファクトシステム - バッチモード（将来）
- **コマンド**: スキーマを使って `/openspec:proposal` を再実装
- **挙動**: スキーマ駆動だが、従来どおり一括生成
- **状態**: 今回の実験的リリースでは対象外
- **注記**: 旧システムをスキーマへ統合する将来リファクタ

### 3. 新アーティファクトシステム - 段階モード（実験）
- **コマンド**: `/opsx:new`, `/opsx:continue`
- **挙動**: 依存関係に基づき、アーティファクトを 1 つずつ作成
- **状態**: 今回の実験的リリースの対象

---

## 作業項目

### 1. AWF を OPSX にリネーム

**現状:**
- コマンド: `/awf:start`, `/awf:continue`
- ファイル: `.claude/commands/awf/start.md`, `.claude/commands/awf/continue.md`

**目標:**
- コマンド: `/opsx:new`, `/opsx:continue`
- ファイル: `.claude/commands/opsx/new.md`, `.claude/commands/opsx/continue.md`

**タスク:**
- [x] `.claude/commands/opsx/` ディレクトリを作成
- [x] `start.md` → `new.md` にリネームして内容を更新
- [x] `continue.md` を更新してコピー
- [x] コマンド内容内の "awf" を "opsx" に置換
- [x] frontmatter（name, description）を "opsx" に更新
- [x] `.claude/commands/awf/` ディレクトリを削除

**CLI コマンド:**
基盤となる CLI コマンド（`openspec status`, `openspec instructions` など）は変更なし。スラッシュコマンド名のみ変更します。

---

### 2. WF スキルファイルを削除

**現状:**
- `.claude/commands/wf/start.md` - 存在しない `openspec wf` コマンドを参照
- `.claude/commands/wf/continue.md` - 存在しない `openspec wf` コマンドを参照

**目標:**
- ディレクトリとファイルを削除

**タスク:**
- [x] `.claude/commands/wf/start.md` を削除
- [x] `.claude/commands/wf/continue.md` を削除
- [x] `.claude/commands/wf/` ディレクトリを削除

---

### 3. 実験的ワークフローの Agent Skills を追加

**目的:**
[Agent Skills](https://agentskills.io/specification) のオープン標準を使って、実験的ワークフロー用スキルを生成します。

**スラッシュコマンドではなくスキルを使う理由:**
- **クロスエディタ互換**: Claude Code / Cursor / Windsurf などで自動的に使える
- **実装がシンプル**: 18+ エディタ別設定ではなく、単一ディレクトリ（`.claude/skills/`）
- **標準フォーマット**: YAML frontmatter + markdown のシンプルな仕様
- **ユーザー主導**: ユーザーが必要なときにスキルを呼び出せる

**挙動:**
1. `.claude/skills/` がなければ作成する
2. Agent Skills 仕様に従って 2 つのスキルを生成する
   - `openspec-new-change/SKILL.md` - アーティファクトワークフローで新しい変更を開始
   - `openspec-continue-change/SKILL.md` - 変更を継続し次のアーティファクトを作成
3. 既存の `/openspec:*` コマンドと**並行**して追加する（置き換えではない）

**対応エディタ:**
- Claude Code（ネイティブ対応）
- Cursor（Settings → Rules → Import Settings）
- Windsurf（`.claude` 設定を自動取り込み）
- Cline / Codex など、Agent Skills 対応エディタ

**タスク:**
- [x] `openspec-new-change` 用スキルテンプレートを作成（opsx:new ベース）
- [x] `openspec-continue-change` 用スキルテンプレートを作成（opsx:continue ベース）
- [x] 一時的な `artifact-experimental-setup` コマンドを CLI に追加
- [x] スキルファイル生成（YAML frontmatter + markdown 本文）を実装
- [x] 使い方を案内する成功メッセージを追加

**注記:** `artifact-experimental-setup` コマンドは一時的なものです。実験的ワークフローが安定版へ昇格した時点で `openspec init` に統合します。

**スキル形式:**
各スキルは `SKILL.md` を持つディレクトリです。
```
.claude/skills/
├── openspec-new-change/
│   └── SKILL.md          # 必須フィールド: name, description, instructions
├── openspec-continue-change/
│   └── SKILL.md          # 必須フィールド: name, description, instructions
└── openspec-apply-change/
    └── SKILL.md          # 必須フィールド: name, description, instructions
```

**CLI インターフェース:**
```bash
openspec artifact-experimental-setup

# 出力:
# 🧪 実験的アーティファクトワークフロースキルを作成しました
#
#   ✓ .claude/skills/openspec-new-change/SKILL.md
#   ✓ .claude/skills/openspec-continue-change/SKILL.md
#   ✓ .claude/skills/openspec-apply-change/SKILL.md
#
# 📖 使い方:
#
#   対応エディタではスキルが自動的に動作します:
#   • Claude Code - 自動検出され、すぐに利用可能
#   • Cursor - Settings → Rules → Import Settings を有効化
#   • Windsurf - .claude ディレクトリから自動取り込み
#
#   Claude への自然な依頼例:
#   • "OpenSpec の新しい変更を作って <feature> を追加したい"
#   • "この変更を続けて"
#
#   Claude が適切なスキルを自動的に使います。
#
# 💡 これは実験的機能です。
#    フィードバックはこちら: https://github.com/Fission-AI/OpenSpec/issues
```

**実装メモ:**
- シンプルなファイル書き込み: `SKILL.md` をテンプレートで生成
- スラッシュコマンド生成と同じ `FileSystemUtils.writeFile()` を使う
- テンプレート構造は YAML frontmatter + markdown 本文
- 既存の `/opsx:*` スラッシュコマンドは当面維持（後で手動クリーンアップ）
- スキルは「ユーザーが明示的に使う」モデル
- `description` がスキル提案のトリガーになる
- 各 `SKILL.md` には `name` と `description` が必須

---

### 4. `/opsx:new` コマンド内容を更新

**現状の挙動（awf:start）:**
1. 何を作るか質問（入力がなければ）
2. 変更ディレクトリを作成
3. アーティファクト状況を表示
4. 作成可能なものを表示
5. STOP して待機

**新しい挙動（opsx:new）:**
名称だけ更新し、フローは同じ:
- "awf" → "opsx" 参照に更新
- `/awf:continue` → `/opsx:continue` に更新
- frontmatter の name/description を更新

**タスク:**
- [x] "awf" 参照を "opsx" に更新
- [x] プロンプト内のコマンド参照を更新
- [x] CLI コマンドは `openspec` のまま動作することを確認

---

### 5. `/opsx:continue` コマンド内容を更新

**現状の挙動（awf:continue）:**
1. 変更を選択（指定がなければ）
2. 現在のステータスを確認
3. 準備ができたアーティファクトを 1 つ作成
4. 進捗と開放されたアーティファクトを表示
5. STOP

**新しい挙動（opsx:continue）:**
名称だけ更新し、フローは同じです。

**タスク:**
- [x] "awf" 参照を "opsx" に更新
- [x] プロンプト内のコマンド参照を更新

---

### 6. エンドツーエンドテスト

**目的:**
新しいスキルを使って Claude と完全なワークフローを実行し、全体が正しく動くことを検証します。

**テストシナリオ:**
実際の OpenSpec 機能をテストケースに使います（ドッグフーディング）。

**テストフロー:**
1. `openspec artifact-experimental-setup` を実行してスキルを作成
2. `.claude/skills/openspec-new-change/SKILL.md` が作成されたことを確認
3. `.claude/skills/openspec-continue-change/SKILL.md` が作成されたことを確認
4. `.claude/skills/openspec-apply-change/SKILL.md` が作成されたことを確認
5. Claude に「OpenSpec の新しい変更を作って feature X を追加したい」と依頼
6. Claude が `openspec-new-change` スキルを呼ぶことを確認
7. `openspec/changes/add-feature-x/` が作成されたことを確認
8. 提案テンプレートが表示されたことを確認
9. Claude に「この変更を続けて」と依頼
10. Claude が `openspec-continue-change` スキルを呼ぶことを確認
11. `proposal.md` が作成され、内容が入っていることを確認
12. Claude に「続けて」（仕様を作成）
13. `specs/*.md` が作成されたことを確認
14. Claude に「続けて」（設計を作成）
15. `design.md` が作成されたことを確認
16. Claude に「続けて」（タスクを作成）
17. `tasks.md` が作成されたことを確認
18. ステータスが 4/4 完了を示すことを確認
19. タスクに従って機能を実装
20. `/openspec:archive` を実行してアーカイブ

**検証チェックリスト:**
- [ ] `openspec artifact-experimental-setup` が正しいディレクトリ構成を作る
- [ ] Claude Code でスキルが自動検出される
- [ ] スキルの description が適切に起動トリガーになる
- [ ] スキルが変更ディレクトリを作成し、提案テンプレートを表示する
- [ ] スキルが次に作れるアーティファクトを正しく判定する
- [ ] スキルが意味のある内容でアーティファクトを作成する
- [ ] 依存関係検出が正しく動く（specs は proposal が必要 など）
- [ ] 進捗トラッキングが正確
- [ ] テンプレート内容が有用で構造化されている
- [ ] エラーハンドリングが機能する（不正な名前、存在しない変更 など）
- [ ] 異なるスキーマで動作する（spec-driven, tdd）
- [ ] Cursor でも検証する（Settings → Rules → Import Settings）

**結果の記録:**
- 何がうまくいき、何がうまくいかなかったかをテストログに記録
- 摩擦点やわかりにくい UX を記録
- リリース前に必要な修正点や改善点を洗い出す

---

### 7. ユーザー向けドキュメント

**ユーザー向けに以下を説明するドキュメントを作成:**

1. **実験的ワークフローとは何か？**
   - Agent Skills を使って OpenSpec の変更を段階的に作る新しい方法
   - 依存関係を追跡しながら 1 つずつ作成
   - バッチ方式よりも対話的で反復的
   - Claude Code / Cursor / Windsurf など対応エディタで動作

2. **実験的ワークフローのセットアップ方法**
   ```bash
   openspec artifact-experimental-setup
   ```

   注記: これは一時的なコマンドで、安定版に昇格後は `openspec init` に統合します。

3. **利用可能なスキル**
   - `openspec-new-change` - アーティファクトワークフローで新しい変更を開始
   - `openspec-continue-change` - 変更を継続（次のアーティファクトを作成）

4. **使い方**
   - **Claude Code**: スキルは自動検出されるので自然に依頼
     - 「OpenSpec の新しい変更を作って X を追加したい」
     - 「この変更を続けて」
   - **Cursor**: Settings → Rules → Import Settings を有効化
   - **Windsurf**: `.claude` ディレクトリを自動取り込み

5. **ワークフロー例**
   - 自然言語での対話を含むステップバイステップ例
   - ユーザーの依頼に応じてスキルが呼ばれる様子を示す

6. **フィードバック方法**
   - GitHub issue テンプレートでフィードバックを受付
   - 何を報告してほしいか（バグ、UX の問題、提案）

**タスク:**
- [ ] `docs/experimental-workflow.md` のユーザーガイドを作成
- [ ] 実験的機能向けの GitHub issue テンプレートを追加
- [ ] README に実験的機能への言及を追加

---

## 依存関係グラフ

```
1. WF スキルファイルを削除
   └── （依存なし）

2. AWF を OPSX にリネーム
   └── （依存なし）

3. Agent Skills を追加
   └── 依存: AWF を OPSX にリネーム（opsx の内容をテンプレートに使う）

4. opsx:new の内容更新
   └── 依存: AWF を OPSX にリネーム

5. opsx:continue の内容更新
   └── 依存: AWF を OPSX にリネーム

6. E2E テスト
   └── 依存: Agent Skills を追加（スキルワークフローをテスト）

7. ユーザー向けドキュメント
   └── 依存: E2E テスト（最終挙動が必要）
```

---

## 対象外

今回の実験的リリースでは、次の項目は明確に対象外です。

1. **バッチモードのリファクタ** - 旧 `/openspec:proposal` をスキーマ化する
2. **新しいスキーマ** - 既存の `spec-driven` と `tdd` のみ提供
3. **スキーマカスタマイズ UI** - `openspec schema list` などは未提供
4. **CLI 側でのマルチエディタ対応** - スキルは `.claude/skills/` 経由で自動対応
5. **既存コマンドの置き換え** - スキルは追加であり、`/openspec:*` / `/opsx:*` は残す

---

## 成功条件

実験的リリースは次を満たしたときに準備完了とする:

1. `openspec-new-change`, `openspec-continue-change`, `openspec-apply-change` が E2E で動作
2. `openspec artifact-experimental-setup` が `.claude/skills/` にスキルを作成
3. Claude Code で動作し、Cursor/Windsurf と互換
4. 少なくとも 1 回の完全なワークフローを手動テスト済み
5. スキル生成と使用方法のドキュメントがある
6. フィードバック手段が用意されている
7. WF スキルファイルが削除されている
8. ユーザー向け内容から "awf" 参照が消えている

---

## 未決事項

1. **スキーマ選択** - `opsx:new` でスキーマを選択できるべきか？
   - 現状: デフォルトで `spec-driven` を使う
   - 検討: `--schema tdd` オプション追加またはプロンプト

2. **CLI の名前空間** - 実験的 CLI を名前空間化するか？
   - 現状: `openspec status`, `openspec instructions`（名前空間なし）
   - 代替案: `openspec opsx status`（実験的であることを明示）
   - 推奨: 現状維持（ユーザーの打鍵が少ない）

3. **デプリケーションの道筋** - opsx をデフォルトにする場合の移行方法
   - 実験的リリースでは不要
   - 将来コマンド名が変わる可能性を明記する

---

## 見積り内訳

| 項目 | 複雑度 | 注記 |
|------|------------|-------|
| WF ファイル削除 | 極小 | 2 ファイル + ディレクトリ削除のみ |
| AWF → OPSX | 低 | ファイルリネーム + 内容更新 |
| Agent Skills 追加 | **低** | **シンプル: 3〜4 ファイル、単一出力ディレクトリ、標準形式** |
| opsx:new 内容更新 | 低 | テキスト置換 |
| opsx:continue 内容更新 | 低 | テキスト置換 |
| E2E テスト | 中 | 手動テスト + 記録 |
| ユーザー向けドキュメント | 中 | 新規ドキュメント、issue テンプレート |

**主要な改善点:** Agent Skills により大幅に簡素化される。
- **従来:** 20+ ファイル（型定義、18+ エディタ別設定、エディタ選択 UI）
- **改善後:** 3〜4 ファイル（スキルテンプレート、シンプルな CLI コマンド）
- **クロスエディタ:** Claude Code / Cursor / Windsurf で追加作業なしに動作

---

## E2E テストからのユーザーフィードバック

### うまくいった点

1. **明確な依存グラフ** ⭐ 高優先度 - 維持
   - status コマンドがブロック/未ブロックを示して直感的だった:
     ```
     [x] proposal
     [ ] design
     [-] tasks (blocked by: design, specs)
     ```
   - 次に何をすべきかが常に分かった
   - **意義**: 中核的な UX の強み

2. **構造化された指示出力** ⭐ 高優先度 - 維持
   - `openspec instructions <artifact>` がテンプレート、出力パス、文脈を一度に示す
   - 何を作るべきかが理解しやすい
   - **意義**: エージェント駆動ワークフローに不可欠

3. **シンプルなひな形作成** ✅ 良好
   - `openspec new change "name"` が素直に動く
   - **意義**: 良いベースライン（改善余地はあり）

---

### 課題と混乱点

1. **CLI 呼び出しの冗長さ** ⚠️ 中優先度
   - `status` と `next` を毎回呼ぶユーザーが多いが、内容が重複
   - `status` だけでブロック状況は分かる
   - **提案**: `next` を統合するか、より実用的なガイダンスにする
   - **意義**: 反復ワークフローの摩擦軽減

2. **specs ディレクトリ構成が曖昧** 🔥 高優先度 - 修正
   - 指示が `Write to: .../specs/**/*.md` となり、書き先が分からない
   - `specs/spec.md`? `specs/game/spec.md`? `specs/tic-tac-toe/spec.md`?
   - 実際は `mkdir -p .../specs/tic-tac-toe` を作って `spec.md` を書くケースが多い
   - **提案**: CLI がディレクトリ構成を自動生成する
   - **意義**: エージェント UX の核心。曖昧なパスは摩擦になる

3. **`--change` フラグの繰り返し** ⚠️ 中優先度
   - すべてのコマンドに `--change "tic-tac-toe-game"` が必要
   - 10 回以上呼ぶと冗長に感じる
   - **提案**: `openspec use "tic-tac-toe-game"` で文脈を固定
   - **意義**: 反復セッションの品質向上

4. **検証フィードバックがない** 🔥 高優先度 - 追加
   - 各アーティファクト作成後、`status` が `[x]` になることを願うだけ
   - 疑問点:
     - どのように「完了」を判定しているのか？ファイル存在？
     - 仕様フォーマットが不正な場合は？
   - **提案**: `openspec validate --change "name"` で品質を確認
   - **意義**: ユーザーの信頼と早期検出に不可欠

5. **問い合わせが多く、アクションが少ない CLI** 🔥 高優先度 - 改善
   - 多くのコマンドが情報取得で、実際の作成は手作業
   - **提案**: `openspec create proposal --change "name"` のように雛形生成
   - **意義**: エージェント生産性に直結。手作業を減らす

6. **指示出力が冗長** ⚠️ 低優先度
   - XML 風の出力は解析しやすいが長い
   - 出力パスやテンプレートが 50 行の中に埋もれる
   - **提案**: コンパクトモードや構造化 JSON 出力を追加
   - **意義**: 解析効率の向上

---

### ワークフロー上の摩擦

1. **提案テンプレート表示後の「STOP and wait（停止して待機）」** ⚠️ 中優先度
   - スキルが提案テンプレートを表示した後に必ず STOP する
   - ユーザーが十分な文脈を渡している場合は過剰
   - **提案**: 文脈が十分なら停止を省略する
   - **意義**: 不要な往復を減らす

2. **実装フェーズへの接続がない** 🔥 高優先度 - ロードマップ項目
   - 4/4 完了後に次がない。計画で止まる
   - `openspec apply` がなく、実行フェーズに繋がらない
   - **提案**: 実装フェーズへの橋渡しを追加
     - `openspec apply` コマンドで実行フェーズを開始
     - 既存 `/openspec:apply` への明確なハンドオフ
     - 計画完了後の次の手順をドキュメント化
   - **意義**: エンドツーエンド体験の欠落

---

### 優先度まとめ

**必須（高優先度）:**
1. specs ディレクトリの曖昧さ解消（#2）
2. 検証フィードバック追加（#4）
3. CLI をアクション指向に（#5）
4. 実装フェーズへの橋渡し（摩擦 #2）
5. 明確な依存グラフを維持（うまくいった点 #1）
6. 構造化された指示出力を維持（うまくいった点 #2）

**推奨（中優先度）:**
1. 冗長な CLI 呼び出し削減（#1）
2. `--change` の繰り返し削減（#3）
3. 必須 STOP の緩和（摩擦 #1）

**あると良い（低優先度）:**
1. 指示出力のコンパクトモード（#6）

---

## 設計判断（E2E フィードバックより）

開発テストとエージェントワークフローの摩擦分析から、実験的リリースを妨げる 3 つのブロッカーを特定し、以下の判断を行いました。

### ブロッカー

E2E テストの課題から、次の 3 つがブロッカーです。

1. **specs ディレクトリの曖昧さ** - どこに書くべきか、機能名をどう決めるか分からない
2. **CLI が問い合わせ中心** - 情報取得が多く、作成は手作業
3. **apply 連携がない** - 4/4 完了後の実装ガイドがない

### 決定 1: 提案での機能抽出（解決済み）

**問題:** specs の指示が「`specs/<name>/spec.md` に 1 つずつ」と言うが:
- `<name>` が分からない
- 機能の特定には調査が必要（既存仕様、コードベース）
- 提案テンプレートの「影響する仕様」が曖昧
- 調査内容が明文化されない

**決定:** 提案テンプレートを拡張し、機能抽出を明示的に行う。

**現在の提案テンプレート:**
```markdown
## Why
## What Changes
## Impact
- 影響する仕様: 機能を列挙...  ← 曖昧で飛ばしやすい
- 影響するコード: ...
```

**新しい提案テンプレート:**
```markdown
## Why
## What Changes
## Capabilities

### New Capabilities
<!-- 追加する機能（specs/<name>/spec.md を作成） -->
- `<name>`: <この機能が扱う範囲の簡潔な説明>

### Modified Capabilities
<!-- 変更する既存機能（既存の仕様を更新） -->
- `<existing-name>`: <変更内容>

## Impact
<!-- 影響するコード、API、依存関係、システム -->
```

**理由:**
- 提案は元々機能を尋ねていた（ただ曖昧だった）
- 明文化されることでレビュー可能になる
- 提案と仕様フェーズの契約が明確になる
- 新規と変更を先に分けられる（仕様フェーズで重要）
- エージェントの調査が省略されない

**実装:**
- `schemas/spec-driven/templates/proposal.md` を更新
- `schemas/spec-driven/schema.yaml` の提案指示を更新
- スキル指示に機能抽出ガイドを追加

### 決定 2: CLI アクションコマンド（進行中）

**問題:** CLI は問い合わせ中心。`openspec status`, `openspec next`, `openspec instructions` を使うが、ファイル作成は手作業。

#### 決定 2a: `openspec next` を削除（解決済み）

**問題:** `next` は冗長です。準備済みアーティファクトの一覧は `status` に含まれています。

**現状:**
```bash
openspec status --change "X"  # proposal（完了）、specs（準備完了）、design（ブロック）、tasks（ブロック）を表示
openspec next --change "X"    # ["specs"] を表示  ← 冗長
```

**決定:** `next` コマンドを削除する。`status` が同等以上の情報を提供します。

**実装:**
- CLI から `next` を削除
- スキル指示で `status` を使用
- AGENTS.md の参照を更新

#### 決定 2b: CLI ひな形生成（解決済み - しない）

**問題:** 指示を得た後、エージェントが手作業でファイルを書き込む。CLI が生成すべきか？

**検討した選択肢:**
- `openspec create <artifact>` を追加しテンプレートで雛形生成
- 現状どおり、指示を見てエージェントが直接作成
- ハイブリッド: CLI でも生成、エージェントでも直接書ける

**決定:** 現状を維持。ひな形生成コマンドは追加しない。

**理由（エージェント作業の観点）:**
- 1 回の書き込みで完結するほうが良い
- `instructions` がテンプレートを提供済み
- ツール呼び出しが増える（`instructions` + Write で済む）
- 本質的な問題は「何を書くか」であり、雛形生成では解決しない
- 仕様名が未確定の `specs` は CLI で生成できない

**補足:** 機能抽出を提案テンプレートに組み込むことで、未確定問題を解消する。

### 決定 3: apply 連携（解決済み）

**元の問題:** 計画が完了すると実験的ワークフローが終わる。実装へのガイドがない。

**重要な洞察: フェーズではなくアクション**

議論の結果、フェーズ（計画 → 実装 → アーカイブ）は人工的な制約だと分かりました。作業は流動的です:
- 実装中に設計が違うと気づけば design.md を更新
- タスク途中に新要件が見つかれば specs を更新
- 計画と実装を行き来する

**より良いモデル: 変更に対するアクション**

変更は「もの」。アクションは「動詞」です。フェーズではなく、いつでも実行できる操作として扱います。

| アクション | 役割 | スキル | CLI コマンド |
|--------|--------------|-------|-------------|
| `new` | 変更を作成（ディレクトリ作成） | `opsx:new` | `openspec new change` |
| `continue` | 次のアーティファクトを作成 | `opsx:continue` | `openspec instructions` |
| `apply` | タスク実装 | `opsx:apply`（新規） | 未定 |
| `update` | 学びに合わせてアーティファクトを更新 | `opsx:update`（新規） | 未定 |
| `explore` | 調査・理解・質問 | `opsx:explore`（新規） | 未定 |
| `validate` | アーティファクト検証 | 未定 | `openspec validate` |
| `archive` | 完了後にアーカイブ | 既存 | `openspec archive` |

**重要原則:**
- アクションはスキルとしてモデル化（エージェントの主要インターフェース）
- いくつかは CLI コマンドも持つ（利便性のため）
- スキルと CLI は分離。両方必要とは限らない
- どの順序でも実行可能（ソフトな前提条件）
- フェーズによるゲートは設けない

**スキーマが定義するもの:**
- アーティファクト（何か、どこに置くか）
- 依存関係（先に必要なもの）
- 必須 / 任意
- テンプレートと指示

**スキーマが定義しないもの:**
- フェーズ
- 変更可能なタイミング
- 直線的なワークフロー

**進捗トラッキング:**
- tasks.md のチェックボックス = 実装進捗
- アーティファクトの存在 = 計画進捗
- アーカイブのタイミング = ユーザー判断

**実験的リリースでは:**
- `opsx:apply` スキルを追加（タスク実装のガイダンス）
- 「変更に対するアクション」モデルをドキュメント化
- 他のアクション（update, explore）は後回し

---

### デザイン: `openspec-apply-change` スキル

#### 概要

この apply スキルは、完了済みまたは進行中の変更からタスクを実装する際にガイドします。旧 `/openspec:apply` と異なり:
- **流動的** - すべて完了後でなくても使える
- **アーティファクト更新を許容** - 実装で問題が出たら設計や仕様を更新
- **完了まで継続** - 完了またはブロックされるまでタスクを進める
- **チェックボックスで進捗管理** - tasks.md が真実のソース

#### スキルメタデータ

```yaml
name: openspec-apply-change
description: OpenSpec の変更に含まれるタスクを実装する。実装を開始するとき、継続するとき、タスクを進めるときに使用する。
```

#### 起動タイミング

次の場合にスキルを起動します。
- ユーザーが「この変更を実装して」「実装を始めて」と言ったとき
- ユーザーが「タスクを進めて」「次のタスクをやって」と言ったとき
- ユーザーが「apply して」と言ったとき
- アーティファクトが揃い、実装に進みたいとき
- 休憩後に実装を再開するとき

#### 入力

- 任意: 変更名
- 任意: 特定のタスク番号
- 未指定なら変更選択を促す（continue-change と同じパターン）

#### 手順

1. **変更名が指定されていない場合は選択を促す**

   `openspec list --json` を実行して利用可能な変更を取得し、**AskUserQuestion** で選択させる。

   tasks.md を持つ変更（実装可能）を表示し、未完了の変更には「(In Progress)」を付ける。

2. **apply 指示を取得する**

   ```bash
   openspec instructions apply --change "<name>" --json
   ```

   返ってくる内容:
   - 文脈ファイルのパス（proposal, specs, design, tasks）
   - 進捗（合計 / 完了 / 残り）
   - ステータス付きのタスクリスト
   - 現在の状態に応じた動的な指示

   **状態ごとの扱い:**
   - 依存が足りずブロックされている場合: メッセージを表示し `openspec-continue-change` を提案
   - すべて完了している場合: 祝辞を出し、アーカイブを提案
   - それ以外: 実装へ進む

3. **文脈ファイルを読む**

   指示に列挙されたファイルを読む:
   - `proposal.md` - なぜ・何をするか
   - `specs/*.md` - 要件とシナリオ
   - `design.md` - 技術的な方針（存在する場合）
   - `tasks.md` - 実装チェックリスト

4. **現在の進捗を表示する**

   表示内容:
   - 進捗: "N/M タスク完了"
   - 残タスクの概要
   - CLI からの動的指示

5. **タスクを実装する（完了またはブロックまでループ）**

   未完了タスクごとに:
   - 取り組むタスクを明示する
   - 必要なコード変更を行う
   - 変更は最小限かつ集中させる
   - tasks.md の完了チェックを付ける: `- [ ]` → `- [x]`
   - 次のタスクへ進む

   **一時停止する条件:**
   - タスクが曖昧 → 確認する
   - 実装で設計問題が判明 → アーティファクト更新を提案
   - エラーやブロッカーに遭遇 → 報告して指示待ち
   - ユーザーが中断

6. **完了または一時停止時に状態を表示する**

   表示内容:
   - このセッションで完了したタスク
   - 全体進捗: "N/M タスク完了"
   - 完了していればアーカイブを提案
   - 一時停止なら理由を説明して指示待ち

#### 出力形式

**実装中:**
```
## 実装中: add-user-auth

タスク 3/7 を実行中: UserAuth サービスクラスを作成
[...実装中...]
✓ タスク完了

タスク 4/7 を実行中: AuthController にログインエンドポイントを追加
[...実装中...]
✓ タスク完了

タスク 5/7 を実行中: JWT トークン生成を追加
[...実装中...]
```

**完了時:**
```
## 実装完了

**変更:** add-user-auth
**進捗:** 7/7 タスク完了 ✓

### このセッションで完了した内容
- [x] UserAuth サービスクラスを作成
- [x] AuthController にログインエンドポイントを追加
- [x] JWT トークン生成を追加
- [x] ログアウトエンドポイントを追加
- [x] 認証ミドルウェアを追加
- [x] ユニットテストを追加
- [x] API ドキュメントを更新

すべてのタスクが完了しました。この変更をアーカイブできます。
```

**一時停止時（問題発生）:**
```
## 実装を一時停止

**変更:** add-user-auth
**進捗:** 4/7 タスク完了

### 発生した問題
タスク 5「JWT トークン生成を追加」: 設計では RS256 を指定しているが、
既存の認証ライブラリは HS256 のみ対応。

**選択肢:**
1. design.md を更新して HS256 を使う
2. RS256 をサポートする新しい JWT ライブラリを追加
3. その他の方法

どう進めますか？
```

#### ガードレール

- 完了またはブロックまでタスクを進める
- 開始前に必ず文脈を読む（specs, design）
- タスクが曖昧なら実装前に確認
- 実装で問題が見つかれば一時停止し、アーティファクト更新を提案
- 変更は最小限かつタスク単位で行う
- タスク完了後はすぐにチェックを入れる
- エラー/ブロッカー/不明点では停止して指示を待つ

#### 流動的ワークフローへの統合

apply スキルは「変更に対するアクション」モデルを支えます。

**いつでも起動できる:**
- アーティファクトが揃っていない段階でも（tasks.md があれば）
- 部分的な実装後
- 他のアクション（update, continue）と交互に使える

**アーティファクト更新を許容:**
- 実装で設計問題が判明 → `opsx:update` を提案（将来）
- 要件が曖昧 → specs の更新を提案
- フェーズに縛られない

**流動的ワークフロー例:**
```
ユーザー: "add-user-auth を実装して"
→ openspec-apply-change: タスク 1, 2, 3, 4 を実行...
→ タスク 5 で一時停止: "設計は RS256 だがライブラリは HS256 のみ対応"

ユーザー: "HS256 で進めよう、設計を更新して"
→ ユーザーが design.md を編集（または将来的に opsx:update を使用）

ユーザー: "実装を続けて"
→ openspec-apply-change: タスク 5, 6, 7 を実行
→ "すべてのタスクが完了しました。アーカイブできます。"
```

#### 使用する CLI コマンド

```bash
openspec list --json                        # 選択用の変更一覧を取得
openspec status --change "<name>"           # アーティファクトの完了状況を確認
openspec instructions apply --change "<name>" # apply 指示を取得（新規）
# proposal/specs/design/tasks は Read ツールで読む
# タスクのチェックは Edit ツールで更新
```

#### 新 CLI コマンド: `openspec instructions apply`

アーティファクト指示と同じパターンで使います。

**使い方:**
```bash
openspec instructions apply --change "<name>" [--json]
```

**出力（Markdown 形式）:**
```markdown
## 適用: add-user-auth

### 文脈ファイル
- proposal: openspec/changes/add-user-auth/proposal.md
- specs: openspec/changes/add-user-auth/specs/**/*.md
- design: openspec/changes/add-user-auth/design.md
- tasks: openspec/changes/add-user-auth/tasks.md

### 進捗
2/7 完了

### タスク
- [x] UserAuth サービスクラスを作成
- [x] ログインエンドポイントを追加
- [ ] JWT トークン生成を追加
- [ ] ログアウトエンドポイントを追加
- [ ] 認証ミドルウェアを追加
- [ ] ユニットテストを追加
- [ ] API ドキュメントを更新

### 指示
文脈ファイルを読み、未完了のタスクを進めながら完了マークを付けてください。
ブロッカーや確認事項があれば一時停止します。
```

**CLI コマンドのメリット:**
- **一貫性** - `openspec instructions <artifact>` と同じパターン
- **構造化出力** - 進捗、タスク、文脈パスを一度に取得
- **見やすい形式** - 冗長な XML ではなく読みやすい Markdown
- **拡張性** - セクション追加が容易
- **JSON 対応** - `--json` で機械利用可能

#### 旧 `/openspec:apply` との違い

| 項目 | 旧 `/openspec:apply` | 新 `openspec-apply-change` |
|--------|----------------------|----------------------------|
| 起動タイミング | 全アーティファクト完了後 | tasks.md があればいつでも |
| 粒度 | すべてのタスクを一括 | 問題があれば一時停止 |
| アーティファクト更新 | 言及なし | 必要に応じて推奨 |
| 進捗管理 | 最後にまとめて更新 | タスクごとに更新 |
| フロー制御 | すべて押し通す | ブロッカーで停止、再開可 |
| 文脈ロード | 最初に一度読む | 必要に応じて参照 |
| 問題対応 | 不明 | 停止して選択肢提示 |

#### 実装メモ

1. **CLI コマンドを追加**: `openspec instructions apply` を `artifact-workflow.ts` に追加
   - tasks.md を解析し進捗を取得
   - 文脈パス、進捗、タスク一覧、簡潔な指示を返す
2. **skill-templates.ts に追加**: `getApplyChangeSkillTemplate()` を作る
3. **artifact-experimental-setup を更新**: new/continue と同様に apply スキルを生成
4. **スキル一覧を更新**: `.claude/skills/` に追加
5. **フローをテスト**: tasks.md のある既存変更で動作確認

---

## 次のステップ

1. ~~計画をレビューしてスコープ確定~~（完了 - ブロッカー特定）
2. ~~設計判断~~（完了 - 3 ブロッカーすべて解決）
3. ~~apply スキル設計~~（完了 - 上記に記載）
4. ~~提案テンプレート変更（決定 1: 機能抽出）~~（完了）
5. ~~`openspec next` 削除（決定 2a）~~（完了）
6. ~~`openspec instructions apply` 追加~~（完了）
7. ~~`openspec-apply-change` スキル作成~~（完了）
8. 更新後のフローで E2E テストを実施
9. ユーザー向けドキュメントを作成（「変更に対するアクション」モデル）
10. テストユーザーへリリース
